"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/google-auth-library";
exports.ids = ["vendor-chunks/google-auth-library"];
exports.modules = {

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/authclient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2012 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AuthClient = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = exports.DEFAULT_UNIVERSE = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/google-auth-library/build/src/util.js\");\n/**\n * The default cloud universe\n *\n * @see {@link AuthJSONOptions.universe_domain}\n */ exports.DEFAULT_UNIVERSE = \"googleapis.com\";\n/**\n * The default {@link AuthClientOptions.eagerRefreshThresholdMillis}\n */ exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1000;\nclass AuthClient extends events_1.EventEmitter {\n    constructor(opts = {}){\n        var _a, _b, _c, _d, _e;\n        super();\n        this.credentials = {};\n        this.eagerRefreshThresholdMillis = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS;\n        this.forceRefreshOnFailure = false;\n        this.universeDomain = exports.DEFAULT_UNIVERSE;\n        const options = (0, util_1.originalOrCamelOptions)(opts);\n        // Shared auth options\n        this.apiKey = opts.apiKey;\n        this.projectId = (_a = options.get(\"project_id\")) !== null && _a !== void 0 ? _a : null;\n        this.quotaProjectId = options.get(\"quota_project_id\");\n        this.credentials = (_b = options.get(\"credentials\")) !== null && _b !== void 0 ? _b : {};\n        this.universeDomain = (_c = options.get(\"universe_domain\")) !== null && _c !== void 0 ? _c : exports.DEFAULT_UNIVERSE;\n        // Shared client options\n        this.transporter = (_d = opts.transporter) !== null && _d !== void 0 ? _d : new transporters_1.DefaultTransporter();\n        if (opts.transporterOptions) {\n            this.transporter.defaults = opts.transporterOptions;\n        }\n        if (opts.eagerRefreshThresholdMillis) {\n            this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = (_e = opts.forceRefreshOnFailure) !== null && _e !== void 0 ? _e : false;\n    }\n    /**\n     * Return the {@link Gaxios `Gaxios`} instance from the {@link AuthClient.transporter}.\n     *\n     * @expiremental\n     */ get gaxios() {\n        if (this.transporter instanceof gaxios_1.Gaxios) {\n            return this.transporter;\n        } else if (this.transporter instanceof transporters_1.DefaultTransporter) {\n            return this.transporter.instance;\n        } else if (\"instance\" in this.transporter && this.transporter.instance instanceof gaxios_1.Gaxios) {\n            return this.transporter.instance;\n        }\n        return null;\n    }\n    /**\n     * Sets the auth credentials.\n     */ setCredentials(credentials) {\n        this.credentials = credentials;\n    }\n    /**\n     * Append additional headers, e.g., x-goog-user-project, shared across the\n     * classes inheriting AuthClient. This method should be used by any method\n     * that overrides getRequestMetadataAsync(), which is a shared helper for\n     * setting request information in both gRPC and HTTP API calls.\n     *\n     * @param headers object to append additional headers to.\n     */ addSharedMetadataHeaders(headers) {\n        // quota_project_id, stored in application_default_credentials.json, is set in\n        // the x-goog-user-project header, to indicate an alternate account for\n        // billing and quota:\n        if (!headers[\"x-goog-user-project\"] && // don't override a value the user sets.\n        this.quotaProjectId) {\n            headers[\"x-goog-user-project\"] = this.quotaProjectId;\n        }\n        return headers;\n    }\n    /**\n     * Retry config for Auth-related requests.\n     *\n     * @remarks\n     *\n     * This is not a part of the default {@link AuthClient.transporter transporter/gaxios}\n     * config as some downstream APIs would prefer if customers explicitly enable retries,\n     * such as GCS.\n     */ static get RETRY_CONFIG() {\n        return {\n            retry: true,\n            retryConfig: {\n                httpMethodsToRetry: [\n                    \"GET\",\n                    \"PUT\",\n                    \"POST\",\n                    \"HEAD\",\n                    \"OPTIONS\",\n                    \"DELETE\"\n                ]\n            }\n        };\n    }\n}\nexports.AuthClient = AuthClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hdXRoY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUdBLDhDQUE4QyxHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQ3RHLE1BQU1LLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLDhEQUFRO0FBQ2pDLE1BQU1FLGlCQUFpQkYsbUJBQU9BLENBQUMsMkZBQWlCO0FBQ2hELE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDLDJFQUFTO0FBQ2hDOzs7O0NBSUMsR0FDRE4sd0JBQXdCLEdBQUc7QUFDM0I7O0NBRUMsR0FDREEsOENBQThDLEdBQUcsSUFBSSxLQUFLO0FBQzFELE1BQU1FLG1CQUFtQkcsU0FBU0ssWUFBWTtJQUMxQ0MsWUFBWUMsT0FBTyxDQUFDLENBQUMsQ0FBRTtRQUNuQixJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUNwQixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxXQUFXLEdBQUcsQ0FBQztRQUNwQixJQUFJLENBQUNDLDJCQUEyQixHQUFHbkIsUUFBUUcsc0NBQXNDO1FBQ2pGLElBQUksQ0FBQ2lCLHFCQUFxQixHQUFHO1FBQzdCLElBQUksQ0FBQ0MsY0FBYyxHQUFHckIsUUFBUUksZ0JBQWdCO1FBQzlDLE1BQU1rQixVQUFVLENBQUMsR0FBR2IsT0FBT2Msc0JBQXNCLEVBQUVYO1FBQ25ELHNCQUFzQjtRQUN0QixJQUFJLENBQUNZLE1BQU0sR0FBR1osS0FBS1ksTUFBTTtRQUN6QixJQUFJLENBQUNDLFNBQVMsR0FBRyxDQUFDWixLQUFLUyxRQUFRSSxHQUFHLENBQUMsYUFBWSxNQUFPLFFBQVFiLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ25GLElBQUksQ0FBQ2MsY0FBYyxHQUFHTCxRQUFRSSxHQUFHLENBQUM7UUFDbEMsSUFBSSxDQUFDUixXQUFXLEdBQUcsQ0FBQ0osS0FBS1EsUUFBUUksR0FBRyxDQUFDLGNBQWEsTUFBTyxRQUFRWixPQUFPLEtBQUssSUFBSUEsS0FBSyxDQUFDO1FBQ3ZGLElBQUksQ0FBQ08sY0FBYyxHQUFHLENBQUNOLEtBQUtPLFFBQVFJLEdBQUcsQ0FBQyxrQkFBaUIsTUFBTyxRQUFRWCxPQUFPLEtBQUssSUFBSUEsS0FBS2YsUUFBUUksZ0JBQWdCO1FBQ3JILHdCQUF3QjtRQUN4QixJQUFJLENBQUN3QixXQUFXLEdBQUcsQ0FBQ1osS0FBS0osS0FBS2dCLFdBQVcsTUFBTSxRQUFRWixPQUFPLEtBQUssSUFBSUEsS0FBSyxJQUFJUixlQUFlcUIsa0JBQWtCO1FBQ2pILElBQUlqQixLQUFLa0Isa0JBQWtCLEVBQUU7WUFDekIsSUFBSSxDQUFDRixXQUFXLENBQUNHLFFBQVEsR0FBR25CLEtBQUtrQixrQkFBa0I7UUFDdkQ7UUFDQSxJQUFJbEIsS0FBS08sMkJBQTJCLEVBQUU7WUFDbEMsSUFBSSxDQUFDQSwyQkFBMkIsR0FBR1AsS0FBS08sMkJBQTJCO1FBQ3ZFO1FBQ0EsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRyxDQUFDSCxLQUFLTCxLQUFLUSxxQkFBcUIsTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSUEsS0FBSztJQUNwRztJQUNBOzs7O0tBSUMsR0FDRCxJQUFJZSxTQUFTO1FBQ1QsSUFBSSxJQUFJLENBQUNKLFdBQVcsWUFBWXJCLFNBQVMwQixNQUFNLEVBQUU7WUFDN0MsT0FBTyxJQUFJLENBQUNMLFdBQVc7UUFDM0IsT0FDSyxJQUFJLElBQUksQ0FBQ0EsV0FBVyxZQUFZcEIsZUFBZXFCLGtCQUFrQixFQUFFO1lBQ3BFLE9BQU8sSUFBSSxDQUFDRCxXQUFXLENBQUNNLFFBQVE7UUFDcEMsT0FDSyxJQUFJLGNBQWMsSUFBSSxDQUFDTixXQUFXLElBQ25DLElBQUksQ0FBQ0EsV0FBVyxDQUFDTSxRQUFRLFlBQVkzQixTQUFTMEIsTUFBTSxFQUFFO1lBQ3RELE9BQU8sSUFBSSxDQUFDTCxXQUFXLENBQUNNLFFBQVE7UUFDcEM7UUFDQSxPQUFPO0lBQ1g7SUFDQTs7S0FFQyxHQUNEQyxlQUFlakIsV0FBVyxFQUFFO1FBQ3hCLElBQUksQ0FBQ0EsV0FBVyxHQUFHQTtJQUN2QjtJQUNBOzs7Ozs7O0tBT0MsR0FDRGtCLHlCQUF5QkMsT0FBTyxFQUFFO1FBQzlCLDhFQUE4RTtRQUM5RSx1RUFBdUU7UUFDdkUscUJBQXFCO1FBQ3JCLElBQUksQ0FBQ0EsT0FBTyxDQUFDLHNCQUFzQixJQUFJLHdDQUF3QztRQUMzRSxJQUFJLENBQUNWLGNBQWMsRUFBRTtZQUNyQlUsT0FBTyxDQUFDLHNCQUFzQixHQUFHLElBQUksQ0FBQ1YsY0FBYztRQUN4RDtRQUNBLE9BQU9VO0lBQ1g7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNELFdBQVdDLGVBQWU7UUFDdEIsT0FBTztZQUNIQyxPQUFPO1lBQ1BDLGFBQWE7Z0JBQ1RDLG9CQUFvQjtvQkFBQztvQkFBTztvQkFBTztvQkFBUTtvQkFBUTtvQkFBVztpQkFBUztZQUMzRTtRQUNKO0lBQ0o7QUFDSjtBQUNBekMsa0JBQWtCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hdXRoY2xpZW50LmpzPzNjZTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxMiBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXV0aENsaWVudCA9IGV4cG9ydHMuREVGQVVMVF9FQUdFUl9SRUZSRVNIX1RIUkVTSE9MRF9NSUxMSVMgPSBleHBvcnRzLkRFRkFVTFRfVU5JVkVSU0UgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCB0cmFuc3BvcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRlcnNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogVGhlIGRlZmF1bHQgY2xvdWQgdW5pdmVyc2VcbiAqXG4gKiBAc2VlIHtAbGluayBBdXRoSlNPTk9wdGlvbnMudW5pdmVyc2VfZG9tYWlufVxuICovXG5leHBvcnRzLkRFRkFVTFRfVU5JVkVSU0UgPSAnZ29vZ2xlYXBpcy5jb20nO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCB7QGxpbmsgQXV0aENsaWVudE9wdGlvbnMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzfVxuICovXG5leHBvcnRzLkRFRkFVTFRfRUFHRVJfUkVGUkVTSF9USFJFU0hPTERfTUlMTElTID0gNSAqIDYwICogMTAwMDtcbmNsYXNzIEF1dGhDbGllbnQgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0ge307XG4gICAgICAgIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzID0gZXhwb3J0cy5ERUZBVUxUX0VBR0VSX1JFRlJFU0hfVEhSRVNIT0xEX01JTExJUztcbiAgICAgICAgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bml2ZXJzZURvbWFpbiA9IGV4cG9ydHMuREVGQVVMVF9VTklWRVJTRTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9ICgwLCB1dGlsXzEub3JpZ2luYWxPckNhbWVsT3B0aW9ucykob3B0cyk7XG4gICAgICAgIC8vIFNoYXJlZCBhdXRoIG9wdGlvbnNcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBvcHRzLmFwaUtleTtcbiAgICAgICAgdGhpcy5wcm9qZWN0SWQgPSAoX2EgPSBvcHRpb25zLmdldCgncHJvamVjdF9pZCcpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICB0aGlzLnF1b3RhUHJvamVjdElkID0gb3B0aW9ucy5nZXQoJ3F1b3RhX3Byb2plY3RfaWQnKTtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IChfYiA9IG9wdGlvbnMuZ2V0KCdjcmVkZW50aWFscycpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgICAgICAgdGhpcy51bml2ZXJzZURvbWFpbiA9IChfYyA9IG9wdGlvbnMuZ2V0KCd1bml2ZXJzZV9kb21haW4nKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZXhwb3J0cy5ERUZBVUxUX1VOSVZFUlNFO1xuICAgICAgICAvLyBTaGFyZWQgY2xpZW50IG9wdGlvbnNcbiAgICAgICAgdGhpcy50cmFuc3BvcnRlciA9IChfZCA9IG9wdHMudHJhbnNwb3J0ZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG5ldyB0cmFuc3BvcnRlcnNfMS5EZWZhdWx0VHJhbnNwb3J0ZXIoKTtcbiAgICAgICAgaWYgKG9wdHMudHJhbnNwb3J0ZXJPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydGVyLmRlZmF1bHRzID0gb3B0cy50cmFuc3BvcnRlck9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKSB7XG4gICAgICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9IG9wdHMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlID0gKF9lID0gb3B0cy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHtAbGluayBHYXhpb3MgYEdheGlvc2B9IGluc3RhbmNlIGZyb20gdGhlIHtAbGluayBBdXRoQ2xpZW50LnRyYW5zcG9ydGVyfS5cbiAgICAgKlxuICAgICAqIEBleHBpcmVtZW50YWxcbiAgICAgKi9cbiAgICBnZXQgZ2F4aW9zKCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRlciBpbnN0YW5jZW9mIGdheGlvc18xLkdheGlvcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50cmFuc3BvcnRlciBpbnN0YW5jZW9mIHRyYW5zcG9ydGVyc18xLkRlZmF1bHRUcmFuc3BvcnRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0ZXIuaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2luc3RhbmNlJyBpbiB0aGlzLnRyYW5zcG9ydGVyICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydGVyLmluc3RhbmNlIGluc3RhbmNlb2YgZ2F4aW9zXzEuR2F4aW9zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRlci5pbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYXV0aCBjcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBzZXRDcmVkZW50aWFscyhjcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhZGRpdGlvbmFsIGhlYWRlcnMsIGUuZy4sIHgtZ29vZy11c2VyLXByb2plY3QsIHNoYXJlZCBhY3Jvc3MgdGhlXG4gICAgICogY2xhc3NlcyBpbmhlcml0aW5nIEF1dGhDbGllbnQuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIGJ5IGFueSBtZXRob2RcbiAgICAgKiB0aGF0IG92ZXJyaWRlcyBnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYygpLCB3aGljaCBpcyBhIHNoYXJlZCBoZWxwZXIgZm9yXG4gICAgICogc2V0dGluZyByZXF1ZXN0IGluZm9ybWF0aW9uIGluIGJvdGggZ1JQQyBhbmQgSFRUUCBBUEkgY2FsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGVhZGVycyBvYmplY3QgdG8gYXBwZW5kIGFkZGl0aW9uYWwgaGVhZGVycyB0by5cbiAgICAgKi9cbiAgICBhZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICAvLyBxdW90YV9wcm9qZWN0X2lkLCBzdG9yZWQgaW4gYXBwbGljYXRpb25fZGVmYXVsdF9jcmVkZW50aWFscy5qc29uLCBpcyBzZXQgaW5cbiAgICAgICAgLy8gdGhlIHgtZ29vZy11c2VyLXByb2plY3QgaGVhZGVyLCB0byBpbmRpY2F0ZSBhbiBhbHRlcm5hdGUgYWNjb3VudCBmb3JcbiAgICAgICAgLy8gYmlsbGluZyBhbmQgcXVvdGE6XG4gICAgICAgIGlmICghaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddICYmIC8vIGRvbid0IG92ZXJyaWRlIGEgdmFsdWUgdGhlIHVzZXIgc2V0cy5cbiAgICAgICAgICAgIHRoaXMucXVvdGFQcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSA9IHRoaXMucXVvdGFQcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJ5IGNvbmZpZyBmb3IgQXV0aC1yZWxhdGVkIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbm90IGEgcGFydCBvZiB0aGUgZGVmYXVsdCB7QGxpbmsgQXV0aENsaWVudC50cmFuc3BvcnRlciB0cmFuc3BvcnRlci9nYXhpb3N9XG4gICAgICogY29uZmlnIGFzIHNvbWUgZG93bnN0cmVhbSBBUElzIHdvdWxkIHByZWZlciBpZiBjdXN0b21lcnMgZXhwbGljaXRseSBlbmFibGUgcmV0cmllcyxcbiAgICAgKiBzdWNoIGFzIEdDUy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFJFVFJZX0NPTkZJRygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJldHJ5OiB0cnVlLFxuICAgICAgICAgICAgcmV0cnlDb25maWc6IHtcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kc1RvUmV0cnk6IFsnR0VUJywgJ1BVVCcsICdQT1NUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdERUxFVEUnXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5BdXRoQ2xpZW50ID0gQXV0aENsaWVudDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkF1dGhDbGllbnQiLCJERUZBVUxUX0VBR0VSX1JFRlJFU0hfVEhSRVNIT0xEX01JTExJUyIsIkRFRkFVTFRfVU5JVkVSU0UiLCJldmVudHNfMSIsInJlcXVpcmUiLCJnYXhpb3NfMSIsInRyYW5zcG9ydGVyc18xIiwidXRpbF8xIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJvcHRzIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsImNyZWRlbnRpYWxzIiwiZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIiwiZm9yY2VSZWZyZXNoT25GYWlsdXJlIiwidW5pdmVyc2VEb21haW4iLCJvcHRpb25zIiwib3JpZ2luYWxPckNhbWVsT3B0aW9ucyIsImFwaUtleSIsInByb2plY3RJZCIsImdldCIsInF1b3RhUHJvamVjdElkIiwidHJhbnNwb3J0ZXIiLCJEZWZhdWx0VHJhbnNwb3J0ZXIiLCJ0cmFuc3BvcnRlck9wdGlvbnMiLCJkZWZhdWx0cyIsImdheGlvcyIsIkdheGlvcyIsImluc3RhbmNlIiwic2V0Q3JlZGVudGlhbHMiLCJhZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMiLCJoZWFkZXJzIiwiUkVUUllfQ09ORklHIiwicmV0cnkiLCJyZXRyeUNvbmZpZyIsImh0dHBNZXRob2RzVG9SZXRyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/awsclient.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _a, _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AwsClient = void 0;\nconst awsrequestsigner_1 = __webpack_require__(/*! ./awsrequestsigner */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst defaultawssecuritycredentialssupplier_1 = __webpack_require__(/*! ./defaultawssecuritycredentialssupplier */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/google-auth-library/build/src/util.js\");\n/**\n * AWS external account client. This is used for AWS workloads, where\n * AWS STS GetCallerIdentity serialized signed requests are exchanged for\n * GCP access token.\n */ class AwsClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiates an AwsClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid AWS credential.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        super(options, additionalOptions);\n        const opts = (0, util_1.originalOrCamelOptions)(options);\n        const credentialSource = opts.get(\"credential_source\");\n        const awsSecurityCredentialsSupplier = opts.get(\"aws_security_credentials_supplier\");\n        // Validate credential sourcing configuration.\n        if (!credentialSource && !awsSecurityCredentialsSupplier) {\n            throw new Error(\"A credential source or AWS security credentials supplier must be specified.\");\n        }\n        if (credentialSource && awsSecurityCredentialsSupplier) {\n            throw new Error(\"Only one of credential source or AWS security credentials supplier can be specified.\");\n        }\n        if (awsSecurityCredentialsSupplier) {\n            this.awsSecurityCredentialsSupplier = awsSecurityCredentialsSupplier;\n            this.regionalCredVerificationUrl = __classPrivateFieldGet(_a, _a, \"f\", _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL);\n            this.credentialSourceType = \"programmatic\";\n        } else {\n            const credentialSourceOpts = (0, util_1.originalOrCamelOptions)(credentialSource);\n            this.environmentId = credentialSourceOpts.get(\"environment_id\");\n            // This is only required if the AWS region is not available in the\n            // AWS_REGION or AWS_DEFAULT_REGION environment variables.\n            const regionUrl = credentialSourceOpts.get(\"region_url\");\n            // This is only required if AWS security credentials are not available in\n            // environment variables.\n            const securityCredentialsUrl = credentialSourceOpts.get(\"url\");\n            const imdsV2SessionTokenUrl = credentialSourceOpts.get(\"imdsv2_session_token_url\");\n            this.awsSecurityCredentialsSupplier = new defaultawssecuritycredentialssupplier_1.DefaultAwsSecurityCredentialsSupplier({\n                regionUrl: regionUrl,\n                securityCredentialsUrl: securityCredentialsUrl,\n                imdsV2SessionTokenUrl: imdsV2SessionTokenUrl\n            });\n            this.regionalCredVerificationUrl = credentialSourceOpts.get(\"regional_cred_verification_url\");\n            this.credentialSourceType = \"aws\";\n            // Data validators.\n            this.validateEnvironmentId();\n        }\n        this.awsRequestSigner = null;\n        this.region = \"\";\n    }\n    validateEnvironmentId() {\n        var _b;\n        const match = (_b = this.environmentId) === null || _b === void 0 ? void 0 : _b.match(/^(aws)(\\d+)$/);\n        if (!match || !this.regionalCredVerificationUrl) {\n            throw new Error('No valid AWS \"credential_source\" provided');\n        } else if (parseInt(match[2], 10) !== 1) {\n            throw new Error(`aws version \"${match[2]}\" is not supported in the current build.`);\n        }\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint. This will call the\n     * {@link AwsSecurityCredentialsSupplier} to retrieve an AWS region and AWS\n     * Security Credentials, then use them to create a signed AWS STS request that\n     * can be exchanged for a GCP access token.\n     * @return A promise that resolves with the external subject token.\n     */ async retrieveSubjectToken() {\n        // Initialize AWS request signer if not already initialized.\n        if (!this.awsRequestSigner) {\n            this.region = await this.awsSecurityCredentialsSupplier.getAwsRegion(this.supplierContext);\n            this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async ()=>{\n                return this.awsSecurityCredentialsSupplier.getAwsSecurityCredentials(this.supplierContext);\n            }, this.region);\n        }\n        // Generate signed request to AWS STS GetCallerIdentity API.\n        // Use the required regional endpoint. Otherwise, the request will fail.\n        const options = await this.awsRequestSigner.getRequestOptions({\n            ..._a.RETRY_CONFIG,\n            url: this.regionalCredVerificationUrl.replace(\"{region}\", this.region),\n            method: \"POST\"\n        });\n        // The GCP STS endpoint expects the headers to be formatted as:\n        // [\n        //   {key: 'x-amz-date', value: '...'},\n        //   {key: 'Authorization', value: '...'},\n        //   ...\n        // ]\n        // And then serialized as:\n        // encodeURIComponent(JSON.stringify({\n        //   url: '...',\n        //   method: 'POST',\n        //   headers: [{key: 'x-amz-date', value: '...'}, ...]\n        // }))\n        const reformattedHeader = [];\n        const extendedHeaders = Object.assign({\n            // The full, canonical resource name of the workload identity pool\n            // provider, with or without the HTTPS prefix.\n            // Including this header as part of the signature is recommended to\n            // ensure data integrity.\n            \"x-goog-cloud-target-resource\": this.audience\n        }, options.headers);\n        // Reformat header to GCP STS expected format.\n        for(const key in extendedHeaders){\n            reformattedHeader.push({\n                key,\n                value: extendedHeaders[key]\n            });\n        }\n        // Serialize the reformatted signed request.\n        return encodeURIComponent(JSON.stringify({\n            url: options.url,\n            method: options.method,\n            headers: reformattedHeader\n        }));\n    }\n}\nexports.AwsClient = AwsClient;\n_a = AwsClient;\n_AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL = {\n    value: \"https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\"\n};\n/**\n * @deprecated AWS client no validates the EC2 metadata address.\n **/ AwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = \"169.254.169.254\";\n/**\n * @deprecated AWS client no validates the EC2 metadata address.\n **/ AwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = \"fd00:ec2::254\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hd3NjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsSUFBSUEseUJBQXlCLElBQUssSUFBSSxJQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0gsVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNFLElBQUksQ0FBQ0YsTUFBTUksR0FBRyxDQUFDTCxXQUFXLE1BQU0sSUFBSUksVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDTixZQUFZRyxJQUFJQSxFQUFFSSxLQUFLLEdBQUdOLE1BQU1PLEdBQUcsQ0FBQ1I7QUFDeEY7QUFDQSxJQUFJUyxJQUFJQztBQUNSQyw4Q0FBNkM7SUFBRUosT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RE0saUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRSxxQkFBcUJDLG1CQUFPQSxDQUFDLHVHQUFvQjtBQUN2RCxNQUFNQyx1QkFBdUJELG1CQUFPQSxDQUFDLDJHQUFzQjtBQUMzRCxNQUFNRSwwQ0FBMENGLG1CQUFPQSxDQUFDLGlKQUF5QztBQUNqRyxNQUFNRyxTQUFTSCxtQkFBT0EsQ0FBQywyRUFBUztBQUNoQzs7OztDQUlDLEdBQ0QsTUFBTUYsa0JBQWtCRyxxQkFBcUJHLHlCQUF5QjtJQUNs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QUFLLElBQUksQ0FBQ3JCLDJCQUEyQixDQUFDc0IsT0FBTyxDQUFDLFlBQVksSUFBSSxDQUFDWixNQUFNO1lBQ3JFYSxRQUFRO1FBQ1o7UUFDQSwrREFBK0Q7UUFDL0QsSUFBSTtRQUNKLHVDQUF1QztRQUN2QywwQ0FBMEM7UUFDMUMsUUFBUTtRQUNSLElBQUk7UUFDSiwwQkFBMEI7UUFDMUIsc0NBQXNDO1FBQ3RDLGdCQUFnQjtRQUNoQixvQkFBb0I7UUFDcEIsc0RBQXNEO1FBQ3RELE1BQU07UUFDTixNQUFNQyxvQkFBb0IsRUFBRTtRQUM1QixNQUFNQyxrQkFBa0IzQyxPQUFPNEMsTUFBTSxDQUFDO1lBQ2xDLGtFQUFrRTtZQUNsRSw4Q0FBOEM7WUFDOUMsbUVBQW1FO1lBQ25FLHlCQUF5QjtZQUN6QixnQ0FBZ0MsSUFBSSxDQUFDQyxRQUFRO1FBQ2pELEdBQUdsQyxRQUFRbUMsT0FBTztRQUNsQiw4Q0FBOEM7UUFDOUMsSUFBSyxNQUFNQyxPQUFPSixnQkFBaUI7WUFDL0JELGtCQUFrQk0sSUFBSSxDQUFDO2dCQUNuQkQ7Z0JBQ0FuRCxPQUFPK0MsZUFBZSxDQUFDSSxJQUFJO1lBQy9CO1FBQ0o7UUFDQSw0Q0FBNEM7UUFDNUMsT0FBT0UsbUJBQW1CQyxLQUFLQyxTQUFTLENBQUM7WUFDckNaLEtBQUs1QixRQUFRNEIsR0FBRztZQUNoQkUsUUFBUTlCLFFBQVE4QixNQUFNO1lBQ3RCSyxTQUFTSjtRQUNiO0lBQ0o7QUFDSjtBQUNBeEMsaUJBQWlCLEdBQUdDO0FBQ3BCTCxLQUFLSztBQUNMSiw4REFBOEQ7SUFBRUgsT0FBTztBQUFpRjtBQUN4Sjs7RUFFRSxHQUNGTyxVQUFVaUQsNkJBQTZCLEdBQUc7QUFDMUM7O0VBRUUsR0FDRmpELFVBQVVrRCw2QkFBNkIsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvYXdzY2xpZW50LmpzPzQ4YjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9hLCBfQXdzQ2xpZW50X0RFRkFVTFRfQVdTX1JFR0lPTkFMX0NSRURFTlRJQUxfVkVSSUZJQ0FUSU9OX1VSTDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXdzQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgYXdzcmVxdWVzdHNpZ25lcl8xID0gcmVxdWlyZShcIi4vYXdzcmVxdWVzdHNpZ25lclwiKTtcbmNvbnN0IGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuY29uc3QgZGVmYXVsdGF3c3NlY3VyaXR5Y3JlZGVudGlhbHNzdXBwbGllcl8xID0gcmVxdWlyZShcIi4vZGVmYXVsdGF3c3NlY3VyaXR5Y3JlZGVudGlhbHNzdXBwbGllclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBBV1MgZXh0ZXJuYWwgYWNjb3VudCBjbGllbnQuIFRoaXMgaXMgdXNlZCBmb3IgQVdTIHdvcmtsb2Fkcywgd2hlcmVcbiAqIEFXUyBTVFMgR2V0Q2FsbGVySWRlbnRpdHkgc2VyaWFsaXplZCBzaWduZWQgcmVxdWVzdHMgYXJlIGV4Y2hhbmdlZCBmb3JcbiAqIEdDUCBhY2Nlc3MgdG9rZW4uXG4gKi9cbmNsYXNzIEF3c0NsaWVudCBleHRlbmRzIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBBd3NDbGllbnQgaW5zdGFuY2UgdXNpbmcgdGhlIHByb3ZpZGVkIEpTT05cbiAgICAgKiBvYmplY3QgbG9hZGVkIGZyb20gYW4gZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFscyBmaWxlLlxuICAgICAqIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgY3JlZGVudGlhbCBpcyBub3QgYSB2YWxpZCBBV1MgY3JlZGVudGlhbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZXh0ZXJuYWwgYWNjb3VudCBvcHRpb25zIG9iamVjdCB0eXBpY2FsbHkgbG9hZGVkXG4gICAgICogICBmcm9tIHRoZSBleHRlcm5hbCBhY2NvdW50IEpTT04gY3JlZGVudGlhbCBmaWxlLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsT3B0aW9ucyAqKkRFUFJFQ0FURUQsIGFsbCBvcHRpb25zIGFyZSBhdmFpbGFibGUgaW4gdGhlXG4gICAgICogICBgb3B0aW9uc2AgcGFyYW1ldGVyLioqIE9wdGlvbmFsIGFkZGl0aW9uYWwgYmVoYXZpb3IgY3VzdG9taXphdGlvbiBvcHRpb25zLlxuICAgICAqICAgVGhlc2UgY3VycmVudGx5IGN1c3RvbWl6ZSBleHBpcmF0aW9uIHRocmVzaG9sZCB0aW1lIGFuZCB3aGV0aGVyIHRvIHJldHJ5XG4gICAgICogICBvbiA0MDEvNDAzIEFQSSByZXF1ZXN0IGVycm9ycy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSAoMCwgdXRpbF8xLm9yaWdpbmFsT3JDYW1lbE9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjcmVkZW50aWFsU291cmNlID0gb3B0cy5nZXQoJ2NyZWRlbnRpYWxfc291cmNlJyk7XG4gICAgICAgIGNvbnN0IGF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllciA9IG9wdHMuZ2V0KCdhd3Nfc2VjdXJpdHlfY3JlZGVudGlhbHNfc3VwcGxpZXInKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgY3JlZGVudGlhbCBzb3VyY2luZyBjb25maWd1cmF0aW9uLlxuICAgICAgICBpZiAoIWNyZWRlbnRpYWxTb3VyY2UgJiYgIWF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGNyZWRlbnRpYWwgc291cmNlIG9yIEFXUyBzZWN1cml0eSBjcmVkZW50aWFscyBzdXBwbGllciBtdXN0IGJlIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3JlZGVudGlhbFNvdXJjZSAmJiBhd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgb2YgY3JlZGVudGlhbCBzb3VyY2Ugb3IgQVdTIHNlY3VyaXR5IGNyZWRlbnRpYWxzIHN1cHBsaWVyIGNhbiBiZSBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcikge1xuICAgICAgICAgICAgdGhpcy5hd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXIgPSBhd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXI7XG4gICAgICAgICAgICB0aGlzLnJlZ2lvbmFsQ3JlZFZlcmlmaWNhdGlvblVybCA9XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldChfYSwgX2EsIFwiZlwiLCBfQXdzQ2xpZW50X0RFRkFVTFRfQVdTX1JFR0lPTkFMX0NSRURFTlRJQUxfVkVSSUZJQ0FUSU9OX1VSTCk7XG4gICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxTb3VyY2VUeXBlID0gJ3Byb2dyYW1tYXRpYyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjcmVkZW50aWFsU291cmNlT3B0cyA9ICgwLCB1dGlsXzEub3JpZ2luYWxPckNhbWVsT3B0aW9ucykoY3JlZGVudGlhbFNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLmVudmlyb25tZW50SWQgPSBjcmVkZW50aWFsU291cmNlT3B0cy5nZXQoJ2Vudmlyb25tZW50X2lkJyk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIG9ubHkgcmVxdWlyZWQgaWYgdGhlIEFXUyByZWdpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGVcbiAgICAgICAgICAgIC8vIEFXU19SRUdJT04gb3IgQVdTX0RFRkFVTFRfUkVHSU9OIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvblVybCA9IGNyZWRlbnRpYWxTb3VyY2VPcHRzLmdldCgncmVnaW9uX3VybCcpO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHJlcXVpcmVkIGlmIEFXUyBzZWN1cml0eSBjcmVkZW50aWFscyBhcmUgbm90IGF2YWlsYWJsZSBpblxuICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICAgICAgICAgICAgY29uc3Qgc2VjdXJpdHlDcmVkZW50aWFsc1VybCA9IGNyZWRlbnRpYWxTb3VyY2VPcHRzLmdldCgndXJsJyk7XG4gICAgICAgICAgICBjb25zdCBpbWRzVjJTZXNzaW9uVG9rZW5VcmwgPSBjcmVkZW50aWFsU291cmNlT3B0cy5nZXQoJ2ltZHN2Ml9zZXNzaW9uX3Rva2VuX3VybCcpO1xuICAgICAgICAgICAgdGhpcy5hd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXIgPVxuICAgICAgICAgICAgICAgIG5ldyBkZWZhdWx0YXdzc2VjdXJpdHljcmVkZW50aWFsc3N1cHBsaWVyXzEuRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcih7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvblVybDogcmVnaW9uVXJsLFxuICAgICAgICAgICAgICAgICAgICBzZWN1cml0eUNyZWRlbnRpYWxzVXJsOiBzZWN1cml0eUNyZWRlbnRpYWxzVXJsLFxuICAgICAgICAgICAgICAgICAgICBpbWRzVjJTZXNzaW9uVG9rZW5Vcmw6IGltZHNWMlNlc3Npb25Ub2tlblVybCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVnaW9uYWxDcmVkVmVyaWZpY2F0aW9uVXJsID0gY3JlZGVudGlhbFNvdXJjZU9wdHMuZ2V0KCdyZWdpb25hbF9jcmVkX3ZlcmlmaWNhdGlvbl91cmwnKTtcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbFNvdXJjZVR5cGUgPSAnYXdzJztcbiAgICAgICAgICAgIC8vIERhdGEgdmFsaWRhdG9ycy5cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVFbnZpcm9ubWVudElkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hd3NSZXF1ZXN0U2lnbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWdpb24gPSAnJztcbiAgICB9XG4gICAgdmFsaWRhdGVFbnZpcm9ubWVudElkKCkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gKF9iID0gdGhpcy5lbnZpcm9ubWVudElkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF0Y2goL14oYXdzKShcXGQrKSQvKTtcbiAgICAgICAgaWYgKCFtYXRjaCB8fCAhdGhpcy5yZWdpb25hbENyZWRWZXJpZmljYXRpb25VcmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgQVdTIFwiY3JlZGVudGlhbF9zb3VyY2VcIiBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnNlSW50KG1hdGNoWzJdLCAxMCkgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXdzIHZlcnNpb24gXCIke21hdGNoWzJdfVwiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgYnVpbGQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYW4gZXh0ZXJuYWwgc3ViamVjdCB0b2tlbiBpcyBuZWVkZWQgdG8gYmUgZXhjaGFuZ2VkIGZvciBhXG4gICAgICogR0NQIGFjY2VzcyB0b2tlbiB2aWEgR0NQIFNUUyBlbmRwb2ludC4gVGhpcyB3aWxsIGNhbGwgdGhlXG4gICAgICoge0BsaW5rIEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcn0gdG8gcmV0cmlldmUgYW4gQVdTIHJlZ2lvbiBhbmQgQVdTXG4gICAgICogU2VjdXJpdHkgQ3JlZGVudGlhbHMsIHRoZW4gdXNlIHRoZW0gdG8gY3JlYXRlIGEgc2lnbmVkIEFXUyBTVFMgcmVxdWVzdCB0aGF0XG4gICAgICogY2FuIGJlIGV4Y2hhbmdlZCBmb3IgYSBHQ1AgYWNjZXNzIHRva2VuLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZVN1YmplY3RUb2tlbigpIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBBV1MgcmVxdWVzdCBzaWduZXIgaWYgbm90IGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAgICAgIGlmICghdGhpcy5hd3NSZXF1ZXN0U2lnbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lvbiA9IGF3YWl0IHRoaXMuYXdzU2VjdXJpdHlDcmVkZW50aWFsc1N1cHBsaWVyLmdldEF3c1JlZ2lvbih0aGlzLnN1cHBsaWVyQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLmF3c1JlcXVlc3RTaWduZXIgPSBuZXcgYXdzcmVxdWVzdHNpZ25lcl8xLkF3c1JlcXVlc3RTaWduZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllci5nZXRBd3NTZWN1cml0eUNyZWRlbnRpYWxzKHRoaXMuc3VwcGxpZXJDb250ZXh0KTtcbiAgICAgICAgICAgIH0sIHRoaXMucmVnaW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZW5lcmF0ZSBzaWduZWQgcmVxdWVzdCB0byBBV1MgU1RTIEdldENhbGxlcklkZW50aXR5IEFQSS5cbiAgICAgICAgLy8gVXNlIHRoZSByZXF1aXJlZCByZWdpb25hbCBlbmRwb2ludC4gT3RoZXJ3aXNlLCB0aGUgcmVxdWVzdCB3aWxsIGZhaWwuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCB0aGlzLmF3c1JlcXVlc3RTaWduZXIuZ2V0UmVxdWVzdE9wdGlvbnMoe1xuICAgICAgICAgICAgLi4uX2EuUkVUUllfQ09ORklHLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnJlZ2lvbmFsQ3JlZFZlcmlmaWNhdGlvblVybC5yZXBsYWNlKCd7cmVnaW9ufScsIHRoaXMucmVnaW9uKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIEdDUCBTVFMgZW5kcG9pbnQgZXhwZWN0cyB0aGUgaGVhZGVycyB0byBiZSBmb3JtYXR0ZWQgYXM6XG4gICAgICAgIC8vIFtcbiAgICAgICAgLy8gICB7a2V5OiAneC1hbXotZGF0ZScsIHZhbHVlOiAnLi4uJ30sXG4gICAgICAgIC8vICAge2tleTogJ0F1dGhvcml6YXRpb24nLCB2YWx1ZTogJy4uLid9LFxuICAgICAgICAvLyAgIC4uLlxuICAgICAgICAvLyBdXG4gICAgICAgIC8vIEFuZCB0aGVuIHNlcmlhbGl6ZWQgYXM6XG4gICAgICAgIC8vIGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIC8vICAgdXJsOiAnLi4uJyxcbiAgICAgICAgLy8gICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgLy8gICBoZWFkZXJzOiBbe2tleTogJ3gtYW16LWRhdGUnLCB2YWx1ZTogJy4uLid9LCAuLi5dXG4gICAgICAgIC8vIH0pKVxuICAgICAgICBjb25zdCByZWZvcm1hdHRlZEhlYWRlciA9IFtdO1xuICAgICAgICBjb25zdCBleHRlbmRlZEhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIC8vIFRoZSBmdWxsLCBjYW5vbmljYWwgcmVzb3VyY2UgbmFtZSBvZiB0aGUgd29ya2xvYWQgaWRlbnRpdHkgcG9vbFxuICAgICAgICAgICAgLy8gcHJvdmlkZXIsIHdpdGggb3Igd2l0aG91dCB0aGUgSFRUUFMgcHJlZml4LlxuICAgICAgICAgICAgLy8gSW5jbHVkaW5nIHRoaXMgaGVhZGVyIGFzIHBhcnQgb2YgdGhlIHNpZ25hdHVyZSBpcyByZWNvbW1lbmRlZCB0b1xuICAgICAgICAgICAgLy8gZW5zdXJlIGRhdGEgaW50ZWdyaXR5LlxuICAgICAgICAgICAgJ3gtZ29vZy1jbG91ZC10YXJnZXQtcmVzb3VyY2UnOiB0aGlzLmF1ZGllbmNlLFxuICAgICAgICB9LCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAvLyBSZWZvcm1hdCBoZWFkZXIgdG8gR0NQIFNUUyBleHBlY3RlZCBmb3JtYXQuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGV4dGVuZGVkSGVhZGVycykge1xuICAgICAgICAgICAgcmVmb3JtYXR0ZWRIZWFkZXIucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRlbmRlZEhlYWRlcnNba2V5XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgcmVmb3JtYXR0ZWQgc2lnbmVkIHJlcXVlc3QuXG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzOiByZWZvcm1hdHRlZEhlYWRlcixcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXdzQ2xpZW50ID0gQXdzQ2xpZW50O1xuX2EgPSBBd3NDbGllbnQ7XG5fQXdzQ2xpZW50X0RFRkFVTFRfQVdTX1JFR0lPTkFMX0NSRURFTlRJQUxfVkVSSUZJQ0FUSU9OX1VSTCA9IHsgdmFsdWU6ICdodHRwczovL3N0cy57cmVnaW9ufS5hbWF6b25hd3MuY29tP0FjdGlvbj1HZXRDYWxsZXJJZGVudGl0eSZWZXJzaW9uPTIwMTEtMDYtMTUnIH07XG4vKipcbiAqIEBkZXByZWNhdGVkIEFXUyBjbGllbnQgbm8gdmFsaWRhdGVzIHRoZSBFQzIgbWV0YWRhdGEgYWRkcmVzcy5cbiAqKi9cbkF3c0NsaWVudC5BV1NfRUMyX01FVEFEQVRBX0lQVjRfQUREUkVTUyA9ICcxNjkuMjU0LjE2OS4yNTQnO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBBV1MgY2xpZW50IG5vIHZhbGlkYXRlcyB0aGUgRUMyIG1ldGFkYXRhIGFkZHJlc3MuXG4gKiovXG5Bd3NDbGllbnQuQVdTX0VDMl9NRVRBREFUQV9JUFY2X0FERFJFU1MgPSAnZmQwMDplYzI6OjI1NCc7XG4iXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsInJlY2VpdmVyIiwic3RhdGUiLCJraW5kIiwiZiIsIlR5cGVFcnJvciIsImhhcyIsImNhbGwiLCJ2YWx1ZSIsImdldCIsIl9hIiwiX0F3c0NsaWVudF9ERUZBVUxUX0FXU19SRUdJT05BTF9DUkVERU5USUFMX1ZFUklGSUNBVElPTl9VUkwiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJBd3NDbGllbnQiLCJhd3NyZXF1ZXN0c2lnbmVyXzEiLCJyZXF1aXJlIiwiYmFzZWV4dGVybmFsY2xpZW50XzEiLCJkZWZhdWx0YXdzc2VjdXJpdHljcmVkZW50aWFsc3N1cHBsaWVyXzEiLCJ1dGlsXzEiLCJCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJvcHRzIiwib3JpZ2luYWxPckNhbWVsT3B0aW9ucyIsImNyZWRlbnRpYWxTb3VyY2UiLCJhd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXIiLCJFcnJvciIsInJlZ2lvbmFsQ3JlZFZlcmlmaWNhdGlvblVybCIsImNyZWRlbnRpYWxTb3VyY2VUeXBlIiwiY3JlZGVudGlhbFNvdXJjZU9wdHMiLCJlbnZpcm9ubWVudElkIiwicmVnaW9uVXJsIiwic2VjdXJpdHlDcmVkZW50aWFsc1VybCIsImltZHNWMlNlc3Npb25Ub2tlblVybCIsIkRlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXIiLCJ2YWxpZGF0ZUVudmlyb25tZW50SWQiLCJhd3NSZXF1ZXN0U2lnbmVyIiwicmVnaW9uIiwiX2IiLCJtYXRjaCIsInBhcnNlSW50IiwicmV0cmlldmVTdWJqZWN0VG9rZW4iLCJnZXRBd3NSZWdpb24iLCJzdXBwbGllckNvbnRleHQiLCJBd3NSZXF1ZXN0U2lnbmVyIiwiZ2V0QXdzU2VjdXJpdHlDcmVkZW50aWFscyIsImdldFJlcXVlc3RPcHRpb25zIiwiUkVUUllfQ09ORklHIiwidXJsIiwicmVwbGFjZSIsIm1ldGhvZCIsInJlZm9ybWF0dGVkSGVhZGVyIiwiZXh0ZW5kZWRIZWFkZXJzIiwiYXNzaWduIiwiYXVkaWVuY2UiLCJoZWFkZXJzIiwia2V5IiwicHVzaCIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJBV1NfRUMyX01FVEFEQVRBX0lQVjRfQUREUkVTUyIsIkFXU19FQzJfTUVUQURBVEFfSVBWNl9BRERSRVNTIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AwsRequestSigner = void 0;\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\n/** AWS Signature Version 4 signing algorithm identifier.  */ const AWS_ALGORITHM = \"AWS4-HMAC-SHA256\";\n/**\n * The termination string for the AWS credential scope value as defined in\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n */ const AWS_REQUEST_TYPE = \"aws4_request\";\n/**\n * Implements an AWS API request signer based on the AWS Signature Version 4\n * signing process.\n * https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */ class AwsRequestSigner {\n    /**\n     * Instantiates an AWS API request signer used to send authenticated signed\n     * requests to AWS APIs based on the AWS Signature Version 4 signing process.\n     * This also provides a mechanism to generate the signed request without\n     * sending it.\n     * @param getCredentials A mechanism to retrieve AWS security credentials\n     *   when needed.\n     * @param region The AWS region to use.\n     */ constructor(getCredentials, region){\n        this.getCredentials = getCredentials;\n        this.region = region;\n        this.crypto = (0, crypto_1.createCrypto)();\n    }\n    /**\n     * Generates the signed request for the provided HTTP request for calling\n     * an AWS API. This follows the steps described at:\n     * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html\n     * @param amzOptions The AWS request options that need to be signed.\n     * @return A promise that resolves with the GaxiosOptions containing the\n     *   signed HTTP request parameters.\n     */ async getRequestOptions(amzOptions) {\n        if (!amzOptions.url) {\n            throw new Error('\"url\" is required in \"amzOptions\"');\n        }\n        // Stringify JSON requests. This will be set in the request body of the\n        // generated signed request.\n        const requestPayloadData = typeof amzOptions.data === \"object\" ? JSON.stringify(amzOptions.data) : amzOptions.data;\n        const url = amzOptions.url;\n        const method = amzOptions.method || \"GET\";\n        const requestPayload = amzOptions.body || requestPayloadData;\n        const additionalAmzHeaders = amzOptions.headers;\n        const awsSecurityCredentials = await this.getCredentials();\n        const uri = new URL(url);\n        const headerMap = await generateAuthenticationHeaderMap({\n            crypto: this.crypto,\n            host: uri.host,\n            canonicalUri: uri.pathname,\n            canonicalQuerystring: uri.search.substr(1),\n            method,\n            region: this.region,\n            securityCredentials: awsSecurityCredentials,\n            requestPayload,\n            additionalAmzHeaders\n        });\n        // Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.\n        const headers = Object.assign(// Add x-amz-date if available.\n        headerMap.amzDate ? {\n            \"x-amz-date\": headerMap.amzDate\n        } : {}, {\n            Authorization: headerMap.authorizationHeader,\n            host: uri.host\n        }, additionalAmzHeaders || {});\n        if (awsSecurityCredentials.token) {\n            Object.assign(headers, {\n                \"x-amz-security-token\": awsSecurityCredentials.token\n            });\n        }\n        const awsSignedReq = {\n            url,\n            method: method,\n            headers\n        };\n        if (typeof requestPayload !== \"undefined\") {\n            awsSignedReq.body = requestPayload;\n        }\n        return awsSignedReq;\n    }\n}\nexports.AwsRequestSigner = AwsRequestSigner;\n/**\n * Creates the HMAC-SHA256 hash of the provided message using the\n * provided key.\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The HMAC-SHA256 key to use.\n * @param msg The message to hash.\n * @return The computed hash bytes.\n */ async function sign(crypto, key, msg) {\n    return await crypto.signWithHmacSha256(key, msg);\n}\n/**\n * Calculates the signing key used to calculate the signature for\n * AWS Signature Version 4 based on:\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The AWS secret access key.\n * @param dateStamp The '%Y%m%d' date format.\n * @param region The AWS region.\n * @param serviceName The AWS service name, eg. sts.\n * @return The signing key bytes.\n */ async function getSigningKey(crypto, key, dateStamp, region, serviceName) {\n    const kDate = await sign(crypto, `AWS4${key}`, dateStamp);\n    const kRegion = await sign(crypto, kDate, region);\n    const kService = await sign(crypto, kRegion, serviceName);\n    const kSigning = await sign(crypto, kService, \"aws4_request\");\n    return kSigning;\n}\n/**\n * Generates the authentication header map needed for generating the AWS\n * Signature Version 4 signed request.\n *\n * @param option The options needed to compute the authentication header map.\n * @return The AWS authentication header map which constitutes of the following\n *   components: amz-date, authorization header and canonical query string.\n */ async function generateAuthenticationHeaderMap(options) {\n    const additionalAmzHeaders = options.additionalAmzHeaders || {};\n    const requestPayload = options.requestPayload || \"\";\n    // iam.amazonaws.com host => iam service.\n    // sts.us-east-2.amazonaws.com => sts service.\n    const serviceName = options.host.split(\".\")[0];\n    const now = new Date();\n    // Format: '%Y%m%dT%H%M%SZ'.\n    const amzDate = now.toISOString().replace(/[-:]/g, \"\").replace(/\\.[0-9]+/, \"\");\n    // Format: '%Y%m%d'.\n    const dateStamp = now.toISOString().replace(/[-]/g, \"\").replace(/T.*/, \"\");\n    // Change all additional headers to be lower case.\n    const reformattedAdditionalAmzHeaders = {};\n    Object.keys(additionalAmzHeaders).forEach((key)=>{\n        reformattedAdditionalAmzHeaders[key.toLowerCase()] = additionalAmzHeaders[key];\n    });\n    // Add AWS token if available.\n    if (options.securityCredentials.token) {\n        reformattedAdditionalAmzHeaders[\"x-amz-security-token\"] = options.securityCredentials.token;\n    }\n    // Header keys need to be sorted alphabetically.\n    const amzHeaders = Object.assign({\n        host: options.host\n    }, // Previously the date was not fixed with x-amz- and could be provided manually.\n    // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\n    reformattedAdditionalAmzHeaders.date ? {} : {\n        \"x-amz-date\": amzDate\n    }, reformattedAdditionalAmzHeaders);\n    let canonicalHeaders = \"\";\n    const signedHeadersList = Object.keys(amzHeaders).sort();\n    signedHeadersList.forEach((key)=>{\n        canonicalHeaders += `${key}:${amzHeaders[key]}\\n`;\n    });\n    const signedHeaders = signedHeadersList.join(\";\");\n    const payloadHash = await options.crypto.sha256DigestHex(requestPayload);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n    const canonicalRequest = `${options.method}\\n` + `${options.canonicalUri}\\n` + `${options.canonicalQuerystring}\\n` + `${canonicalHeaders}\\n` + `${signedHeaders}\\n` + `${payloadHash}`;\n    const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n    const stringToSign = `${AWS_ALGORITHM}\\n` + `${amzDate}\\n` + `${credentialScope}\\n` + await options.crypto.sha256DigestHex(canonicalRequest);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n    const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);\n    const signature = await sign(options.crypto, signingKey, stringToSign);\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n    const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/` + `${credentialScope}, SignedHeaders=${signedHeaders}, ` + `Signature=${(0, crypto_1.fromArrayBufferToHex)(signature)}`;\n    return {\n        // Do not return x-amz-date if date is available.\n        amzDate: reformattedAdditionalAmzHeaders.date ? undefined : amzDate,\n        authorizationHeader,\n        canonicalQuerystring: options.canonicalQuerystring\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hd3NyZXF1ZXN0c2lnbmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUcsS0FBSztBQUNoQyxNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyw2RkFBa0I7QUFDM0MsMkRBQTJELEdBQzNELE1BQU1DLGdCQUFnQjtBQUN0Qjs7O0NBR0MsR0FDRCxNQUFNQyxtQkFBbUI7QUFDekI7Ozs7Q0FJQyxHQUNELE1BQU1KO0lBQ0Y7Ozs7Ozs7O0tBUUMsR0FDREssWUFBWUMsY0FBYyxFQUFFQyxNQUFNLENBQUU7UUFDaEMsSUFBSSxDQUFDRCxjQUFjLEdBQUdBO1FBQ3RCLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUMsR0FBR1AsU0FBU1EsWUFBWTtJQUMzQztJQUNBOzs7Ozs7O0tBT0MsR0FDRCxNQUFNQyxrQkFBa0JDLFVBQVUsRUFBRTtRQUNoQyxJQUFJLENBQUNBLFdBQVdDLEdBQUcsRUFBRTtZQUNqQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSx1RUFBdUU7UUFDdkUsNEJBQTRCO1FBQzVCLE1BQU1DLHFCQUFxQixPQUFPSCxXQUFXSSxJQUFJLEtBQUssV0FDaERDLEtBQUtDLFNBQVMsQ0FBQ04sV0FBV0ksSUFBSSxJQUM5QkosV0FBV0ksSUFBSTtRQUNyQixNQUFNSCxNQUFNRCxXQUFXQyxHQUFHO1FBQzFCLE1BQU1NLFNBQVNQLFdBQVdP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d0MsWUFBWSxDQUFDLEVBQUUzQyxpQkFBaUIsQ0FBQztJQUMzRixpRkFBaUY7SUFDakYsTUFBTXFFLGVBQWUsQ0FBQyxFQUFFdEUsY0FBYyxFQUFFLENBQUMsR0FDckMsQ0FBQyxFQUFFaUMsUUFBUSxFQUFFLENBQUMsR0FDZCxDQUFDLEVBQUVvQyxnQkFBZ0IsRUFBRSxDQUFDLEdBQ3JCLE1BQU1wQixRQUFRNUMsTUFBTSxDQUFDOEQsZUFBZSxDQUFDQztJQUMxQywrRUFBK0U7SUFDL0UsTUFBTUcsYUFBYSxNQUFNN0IsY0FBY08sUUFBUTVDLE1BQU0sRUFBRTRDLFFBQVFsQixtQkFBbUIsQ0FBQ3lDLGVBQWUsRUFBRTdCLFdBQVdNLFFBQVE3QyxNQUFNLEVBQUV3QztJQUMvSCxNQUFNNkIsWUFBWSxNQUFNbkMsS0FBS1csUUFBUTVDLE1BQU0sRUFBRWtFLFlBQVlEO0lBQ3pELG9GQUFvRjtJQUNwRixNQUFNbkMsc0JBQXNCLENBQUMsRUFBRW5DLGNBQWMsWUFBWSxFQUFFaUQsUUFBUWxCLG1CQUFtQixDQUFDMkMsV0FBVyxDQUFDLENBQUMsQ0FBQyxHQUNqRyxDQUFDLEVBQUVMLGdCQUFnQixnQkFBZ0IsRUFBRUwsY0FBYyxFQUFFLENBQUMsR0FDdEQsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxHQUFHbEUsU0FBUzZFLG9CQUFvQixFQUFFRixXQUFXLENBQUM7SUFDaEUsT0FBTztRQUNILGlEQUFpRDtRQUNqRHhDLFNBQVNzQixnQ0FBZ0NLLElBQUksR0FBR2dCLFlBQVkzQztRQUM1REU7UUFDQVAsc0JBQXNCcUIsUUFBUXJCLG9CQUFvQjtJQUN0RDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9hd3NyZXF1ZXN0c2lnbmVyLmpzPzk1ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXdzUmVxdWVzdFNpZ25lciA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9jcnlwdG9cIik7XG4vKiogQVdTIFNpZ25hdHVyZSBWZXJzaW9uIDQgc2lnbmluZyBhbGdvcml0aG0gaWRlbnRpZmllci4gICovXG5jb25zdCBBV1NfQUxHT1JJVEhNID0gJ0FXUzQtSE1BQy1TSEEyNTYnO1xuLyoqXG4gKiBUaGUgdGVybWluYXRpb24gc3RyaW5nIGZvciB0aGUgQVdTIGNyZWRlbnRpYWwgc2NvcGUgdmFsdWUgYXMgZGVmaW5lZCBpblxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNyZWF0ZS1zdHJpbmctdG8tc2lnbi5odG1sXG4gKi9cbmNvbnN0IEFXU19SRVFVRVNUX1RZUEUgPSAnYXdzNF9yZXF1ZXN0Jztcbi8qKlxuICogSW1wbGVtZW50cyBhbiBBV1MgQVBJIHJlcXVlc3Qgc2lnbmVyIGJhc2VkIG9uIHRoZSBBV1MgU2lnbmF0dXJlIFZlcnNpb24gNFxuICogc2lnbmluZyBwcm9jZXNzLlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ25hdHVyZS12ZXJzaW9uLTQuaHRtbFxuICovXG5jbGFzcyBBd3NSZXF1ZXN0U2lnbmVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gQVdTIEFQSSByZXF1ZXN0IHNpZ25lciB1c2VkIHRvIHNlbmQgYXV0aGVudGljYXRlZCBzaWduZWRcbiAgICAgKiByZXF1ZXN0cyB0byBBV1MgQVBJcyBiYXNlZCBvbiB0aGUgQVdTIFNpZ25hdHVyZSBWZXJzaW9uIDQgc2lnbmluZyBwcm9jZXNzLlxuICAgICAqIFRoaXMgYWxzbyBwcm92aWRlcyBhIG1lY2hhbmlzbSB0byBnZW5lcmF0ZSB0aGUgc2lnbmVkIHJlcXVlc3Qgd2l0aG91dFxuICAgICAqIHNlbmRpbmcgaXQuXG4gICAgICogQHBhcmFtIGdldENyZWRlbnRpYWxzIEEgbWVjaGFuaXNtIHRvIHJldHJpZXZlIEFXUyBzZWN1cml0eSBjcmVkZW50aWFsc1xuICAgICAqICAgd2hlbiBuZWVkZWQuXG4gICAgICogQHBhcmFtIHJlZ2lvbiBUaGUgQVdTIHJlZ2lvbiB0byB1c2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZ2V0Q3JlZGVudGlhbHMsIHJlZ2lvbikge1xuICAgICAgICB0aGlzLmdldENyZWRlbnRpYWxzID0gZ2V0Q3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgICAgICB0aGlzLmNyeXB0byA9ICgwLCBjcnlwdG9fMS5jcmVhdGVDcnlwdG8pKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgc2lnbmVkIHJlcXVlc3QgZm9yIHRoZSBwcm92aWRlZCBIVFRQIHJlcXVlc3QgZm9yIGNhbGxpbmdcbiAgICAgKiBhbiBBV1MgQVBJLiBUaGlzIGZvbGxvd3MgdGhlIHN0ZXBzIGRlc2NyaWJlZCBhdDpcbiAgICAgKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2VuZXJhbC9sYXRlc3QvZ3Ivc2lndjRfc2lnbmluZy5odG1sXG4gICAgICogQHBhcmFtIGFtek9wdGlvbnMgVGhlIEFXUyByZXF1ZXN0IG9wdGlvbnMgdGhhdCBuZWVkIHRvIGJlIHNpZ25lZC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEdheGlvc09wdGlvbnMgY29udGFpbmluZyB0aGVcbiAgICAgKiAgIHNpZ25lZCBIVFRQIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0T3B0aW9ucyhhbXpPcHRpb25zKSB7XG4gICAgICAgIGlmICghYW16T3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJ1cmxcIiBpcyByZXF1aXJlZCBpbiBcImFtek9wdGlvbnNcIicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cmluZ2lmeSBKU09OIHJlcXVlc3RzLiBUaGlzIHdpbGwgYmUgc2V0IGluIHRoZSByZXF1ZXN0IGJvZHkgb2YgdGhlXG4gICAgICAgIC8vIGdlbmVyYXRlZCBzaWduZWQgcmVxdWVzdC5cbiAgICAgICAgY29uc3QgcmVxdWVzdFBheWxvYWREYXRhID0gdHlwZW9mIGFtek9wdGlvbnMuZGF0YSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYW16T3B0aW9ucy5kYXRhKVxuICAgICAgICAgICAgOiBhbXpPcHRpb25zLmRhdGE7XG4gICAgICAgIGNvbnN0IHVybCA9IGFtek9wdGlvbnMudXJsO1xuICAgICAgICBjb25zdCBtZXRob2QgPSBhbXpPcHRpb25zLm1ldGhvZCB8fCAnR0VUJztcbiAgICAgICAgY29uc3QgcmVxdWVzdFBheWxvYWQgPSBhbXpPcHRpb25zLmJvZHkgfHwgcmVxdWVzdFBheWxvYWREYXRhO1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsQW16SGVhZGVycyA9IGFtek9wdGlvbnMuaGVhZGVycztcbiAgICAgICAgY29uc3QgYXdzU2VjdXJpdHlDcmVkZW50aWFscyA9IGF3YWl0IHRoaXMuZ2V0Q3JlZGVudGlhbHMoKTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICBjb25zdCBoZWFkZXJNYXAgPSBhd2FpdCBnZW5lcmF0ZUF1dGhlbnRpY2F0aW9uSGVhZGVyTWFwKHtcbiAgICAgICAgICAgIGNyeXB0bzogdGhpcy5jcnlwdG8sXG4gICAgICAgICAgICBob3N0OiB1cmkuaG9zdCxcbiAgICAgICAgICAgIGNhbm9uaWNhbFVyaTogdXJpLnBhdGhuYW1lLFxuICAgICAgICAgICAgY2Fub25pY2FsUXVlcnlzdHJpbmc6IHVyaS5zZWFyY2guc3Vic3RyKDEpLFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVnaW9uOiB0aGlzLnJlZ2lvbixcbiAgICAgICAgICAgIHNlY3VyaXR5Q3JlZGVudGlhbHM6IGF3c1NlY3VyaXR5Q3JlZGVudGlhbHMsXG4gICAgICAgICAgICByZXF1ZXN0UGF5bG9hZCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxBbXpIZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXBwZW5kIGFkZGl0aW9uYWwgb3B0aW9uYWwgaGVhZGVycywgZWcuIFgtQW16LVRhcmdldCwgQ29udGVudC1UeXBlLCBldGMuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAvLyBBZGQgeC1hbXotZGF0ZSBpZiBhdmFpbGFibGUuXG4gICAgICAgIGhlYWRlck1hcC5hbXpEYXRlID8geyAneC1hbXotZGF0ZSc6IGhlYWRlck1hcC5hbXpEYXRlIH0gOiB7fSwge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogaGVhZGVyTWFwLmF1dGhvcml6YXRpb25IZWFkZXIsXG4gICAgICAgICAgICBob3N0OiB1cmkuaG9zdCxcbiAgICAgICAgfSwgYWRkaXRpb25hbEFtekhlYWRlcnMgfHwge30pO1xuICAgICAgICBpZiAoYXdzU2VjdXJpdHlDcmVkZW50aWFscy50b2tlbikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgJ3gtYW16LXNlY3VyaXR5LXRva2VuJzogYXdzU2VjdXJpdHlDcmVkZW50aWFscy50b2tlbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF3c1NpZ25lZFJlcSA9IHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0UGF5bG9hZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGF3c1NpZ25lZFJlcS5ib2R5ID0gcmVxdWVzdFBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3c1NpZ25lZFJlcTtcbiAgICB9XG59XG5leHBvcnRzLkF3c1JlcXVlc3RTaWduZXIgPSBBd3NSZXF1ZXN0U2lnbmVyO1xuLyoqXG4gKiBDcmVhdGVzIHRoZSBITUFDLVNIQTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZCBtZXNzYWdlIHVzaW5nIHRoZVxuICogcHJvdmlkZWQga2V5LlxuICpcbiAqIEBwYXJhbSBjcnlwdG8gVGhlIGNyeXB0byBpbnN0YW5jZSB1c2VkIHRvIGZhY2lsaXRhdGUgY3J5cHRvZ3JhcGhpY1xuICogICBvcGVyYXRpb25zLlxuICogQHBhcmFtIGtleSBUaGUgSE1BQy1TSEEyNTYga2V5IHRvIHVzZS5cbiAqIEBwYXJhbSBtc2cgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEByZXR1cm4gVGhlIGNvbXB1dGVkIGhhc2ggYnl0ZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ24oY3J5cHRvLCBrZXksIG1zZykge1xuICAgIHJldHVybiBhd2FpdCBjcnlwdG8uc2lnbldpdGhIbWFjU2hhMjU2KGtleSwgbXNnKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc2lnbmluZyBrZXkgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIEFXUyBTaWduYXR1cmUgVmVyc2lvbiA0IGJhc2VkIG9uOlxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNhbGN1bGF0ZS1zaWduYXR1cmUuaHRtbFxuICpcbiAqIEBwYXJhbSBjcnlwdG8gVGhlIGNyeXB0byBpbnN0YW5jZSB1c2VkIHRvIGZhY2lsaXRhdGUgY3J5cHRvZ3JhcGhpY1xuICogICBvcGVyYXRpb25zLlxuICogQHBhcmFtIGtleSBUaGUgQVdTIHNlY3JldCBhY2Nlc3Mga2V5LlxuICogQHBhcmFtIGRhdGVTdGFtcCBUaGUgJyVZJW0lZCcgZGF0ZSBmb3JtYXQuXG4gKiBAcGFyYW0gcmVnaW9uIFRoZSBBV1MgcmVnaW9uLlxuICogQHBhcmFtIHNlcnZpY2VOYW1lIFRoZSBBV1Mgc2VydmljZSBuYW1lLCBlZy4gc3RzLlxuICogQHJldHVybiBUaGUgc2lnbmluZyBrZXkgYnl0ZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFNpZ25pbmdLZXkoY3J5cHRvLCBrZXksIGRhdGVTdGFtcCwgcmVnaW9uLCBzZXJ2aWNlTmFtZSkge1xuICAgIGNvbnN0IGtEYXRlID0gYXdhaXQgc2lnbihjcnlwdG8sIGBBV1M0JHtrZXl9YCwgZGF0ZVN0YW1wKTtcbiAgICBjb25zdCBrUmVnaW9uID0gYXdhaXQgc2lnbihjcnlwdG8sIGtEYXRlLCByZWdpb24pO1xuICAgIGNvbnN0IGtTZXJ2aWNlID0gYXdhaXQgc2lnbihjcnlwdG8sIGtSZWdpb24sIHNlcnZpY2VOYW1lKTtcbiAgICBjb25zdCBrU2lnbmluZyA9IGF3YWl0IHNpZ24oY3J5cHRvLCBrU2VydmljZSwgJ2F3czRfcmVxdWVzdCcpO1xuICAgIHJldHVybiBrU2lnbmluZztcbn1cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBhdXRoZW50aWNhdGlvbiBoZWFkZXIgbWFwIG5lZWRlZCBmb3IgZ2VuZXJhdGluZyB0aGUgQVdTXG4gKiBTaWduYXR1cmUgVmVyc2lvbiA0IHNpZ25lZCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBvcHRpb24gVGhlIG9wdGlvbnMgbmVlZGVkIHRvIGNvbXB1dGUgdGhlIGF1dGhlbnRpY2F0aW9uIGhlYWRlciBtYXAuXG4gKiBAcmV0dXJuIFRoZSBBV1MgYXV0aGVudGljYXRpb24gaGVhZGVyIG1hcCB3aGljaCBjb25zdGl0dXRlcyBvZiB0aGUgZm9sbG93aW5nXG4gKiAgIGNvbXBvbmVudHM6IGFtei1kYXRlLCBhdXRob3JpemF0aW9uIGhlYWRlciBhbmQgY2Fub25pY2FsIHF1ZXJ5IHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVBdXRoZW50aWNhdGlvbkhlYWRlck1hcChvcHRpb25zKSB7XG4gICAgY29uc3QgYWRkaXRpb25hbEFtekhlYWRlcnMgPSBvcHRpb25zLmFkZGl0aW9uYWxBbXpIZWFkZXJzIHx8IHt9O1xuICAgIGNvbnN0IHJlcXVlc3RQYXlsb2FkID0gb3B0aW9ucy5yZXF1ZXN0UGF5bG9hZCB8fCAnJztcbiAgICAvLyBpYW0uYW1hem9uYXdzLmNvbSBob3N0ID0+IGlhbSBzZXJ2aWNlLlxuICAgIC8vIHN0cy51cy1lYXN0LTIuYW1hem9uYXdzLmNvbSA9PiBzdHMgc2VydmljZS5cbiAgICBjb25zdCBzZXJ2aWNlTmFtZSA9IG9wdGlvbnMuaG9zdC5zcGxpdCgnLicpWzBdO1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgLy8gRm9ybWF0OiAnJVklbSVkVCVIJU0lU1onLlxuICAgIGNvbnN0IGFtekRhdGUgPSBub3dcbiAgICAgICAgLnRvSVNPU3RyaW5nKClcbiAgICAgICAgLnJlcGxhY2UoL1stOl0vZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9cXC5bMC05XSsvLCAnJyk7XG4gICAgLy8gRm9ybWF0OiAnJVklbSVkJy5cbiAgICBjb25zdCBkYXRlU3RhbXAgPSBub3cudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bLV0vZywgJycpLnJlcGxhY2UoL1QuKi8sICcnKTtcbiAgICAvLyBDaGFuZ2UgYWxsIGFkZGl0aW9uYWwgaGVhZGVycyB0byBiZSBsb3dlciBjYXNlLlxuICAgIGNvbnN0IHJlZm9ybWF0dGVkQWRkaXRpb25hbEFtekhlYWRlcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsQW16SGVhZGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICByZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9XG4gICAgICAgICAgICBhZGRpdGlvbmFsQW16SGVhZGVyc1trZXldO1xuICAgIH0pO1xuICAgIC8vIEFkZCBBV1MgdG9rZW4gaWYgYXZhaWxhYmxlLlxuICAgIGlmIChvcHRpb25zLnNlY3VyaXR5Q3JlZGVudGlhbHMudG9rZW4pIHtcbiAgICAgICAgcmVmb3JtYXR0ZWRBZGRpdGlvbmFsQW16SGVhZGVyc1sneC1hbXotc2VjdXJpdHktdG9rZW4nXSA9XG4gICAgICAgICAgICBvcHRpb25zLnNlY3VyaXR5Q3JlZGVudGlhbHMudG9rZW47XG4gICAgfVxuICAgIC8vIEhlYWRlciBrZXlzIG5lZWQgdG8gYmUgc29ydGVkIGFscGhhYmV0aWNhbGx5LlxuICAgIGNvbnN0IGFtekhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgaG9zdDogb3B0aW9ucy5ob3N0LFxuICAgIH0sIFxuICAgIC8vIFByZXZpb3VzbHkgdGhlIGRhdGUgd2FzIG5vdCBmaXhlZCB3aXRoIHgtYW16LSBhbmQgY291bGQgYmUgcHJvdmlkZWQgbWFudWFsbHkuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JvdG8vYm90b2NvcmUvYmxvYi84NzlmODQ0MGE0ZTlhY2U1ZDNjZjE0NWNlOGIzZDVlNWZmYjg5MmVmL3Rlc3RzL3VuaXQvYXV0aC9hd3M0X3Rlc3RzdWl0ZS9nZXQtaGVhZGVyLXZhbHVlLXRyaW0ucmVxXG4gICAgcmVmb3JtYXR0ZWRBZGRpdGlvbmFsQW16SGVhZGVycy5kYXRlID8ge30gOiB7ICd4LWFtei1kYXRlJzogYW16RGF0ZSB9LCByZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzKTtcbiAgICBsZXQgY2Fub25pY2FsSGVhZGVycyA9ICcnO1xuICAgIGNvbnN0IHNpZ25lZEhlYWRlcnNMaXN0ID0gT2JqZWN0LmtleXMoYW16SGVhZGVycykuc29ydCgpO1xuICAgIHNpZ25lZEhlYWRlcnNMaXN0LmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY2Fub25pY2FsSGVhZGVycyArPSBgJHtrZXl9OiR7YW16SGVhZGVyc1trZXldfVxcbmA7XG4gICAgfSk7XG4gICAgY29uc3Qgc2lnbmVkSGVhZGVycyA9IHNpZ25lZEhlYWRlcnNMaXN0LmpvaW4oJzsnKTtcbiAgICBjb25zdCBwYXlsb2FkSGFzaCA9IGF3YWl0IG9wdGlvbnMuY3J5cHRvLnNoYTI1NkRpZ2VzdEhleChyZXF1ZXN0UGF5bG9hZCk7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNyZWF0ZS1jYW5vbmljYWwtcmVxdWVzdC5odG1sXG4gICAgY29uc3QgY2Fub25pY2FsUmVxdWVzdCA9IGAke29wdGlvbnMubWV0aG9kfVxcbmAgK1xuICAgICAgICBgJHtvcHRpb25zLmNhbm9uaWNhbFVyaX1cXG5gICtcbiAgICAgICAgYCR7b3B0aW9ucy5jYW5vbmljYWxRdWVyeXN0cmluZ31cXG5gICtcbiAgICAgICAgYCR7Y2Fub25pY2FsSGVhZGVyc31cXG5gICtcbiAgICAgICAgYCR7c2lnbmVkSGVhZGVyc31cXG5gICtcbiAgICAgICAgYCR7cGF5bG9hZEhhc2h9YDtcbiAgICBjb25zdCBjcmVkZW50aWFsU2NvcGUgPSBgJHtkYXRlU3RhbXB9LyR7b3B0aW9ucy5yZWdpb259LyR7c2VydmljZU5hbWV9LyR7QVdTX1JFUVVFU1RfVFlQRX1gO1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nZW5lcmFsL2xhdGVzdC9nci9zaWd2NC1jcmVhdGUtc3RyaW5nLXRvLXNpZ24uaHRtbFxuICAgIGNvbnN0IHN0cmluZ1RvU2lnbiA9IGAke0FXU19BTEdPUklUSE19XFxuYCArXG4gICAgICAgIGAke2FtekRhdGV9XFxuYCArXG4gICAgICAgIGAke2NyZWRlbnRpYWxTY29wZX1cXG5gICtcbiAgICAgICAgKGF3YWl0IG9wdGlvbnMuY3J5cHRvLnNoYTI1NkRpZ2VzdEhleChjYW5vbmljYWxSZXF1ZXN0KSk7XG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dlbmVyYWwvbGF0ZXN0L2dyL3NpZ3Y0LWNhbGN1bGF0ZS1zaWduYXR1cmUuaHRtbFxuICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBhd2FpdCBnZXRTaWduaW5nS2V5KG9wdGlvbnMuY3J5cHRvLCBvcHRpb25zLnNlY3VyaXR5Q3JlZGVudGlhbHMuc2VjcmV0QWNjZXNzS2V5LCBkYXRlU3RhbXAsIG9wdGlvbnMucmVnaW9uLCBzZXJ2aWNlTmFtZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbihvcHRpb25zLmNyeXB0bywgc2lnbmluZ0tleSwgc3RyaW5nVG9TaWduKTtcbiAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2VuZXJhbC9sYXRlc3QvZ3Ivc2lndjQtYWRkLXNpZ25hdHVyZS10by1yZXF1ZXN0Lmh0bWxcbiAgICBjb25zdCBhdXRob3JpemF0aW9uSGVhZGVyID0gYCR7QVdTX0FMR09SSVRITX0gQ3JlZGVudGlhbD0ke29wdGlvbnMuc2VjdXJpdHlDcmVkZW50aWFscy5hY2Nlc3NLZXlJZH0vYCArXG4gICAgICAgIGAke2NyZWRlbnRpYWxTY29wZX0sIFNpZ25lZEhlYWRlcnM9JHtzaWduZWRIZWFkZXJzfSwgYCArXG4gICAgICAgIGBTaWduYXR1cmU9JHsoMCwgY3J5cHRvXzEuZnJvbUFycmF5QnVmZmVyVG9IZXgpKHNpZ25hdHVyZSl9YDtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBEbyBub3QgcmV0dXJuIHgtYW16LWRhdGUgaWYgZGF0ZSBpcyBhdmFpbGFibGUuXG4gICAgICAgIGFtekRhdGU6IHJlZm9ybWF0dGVkQWRkaXRpb25hbEFtekhlYWRlcnMuZGF0ZSA/IHVuZGVmaW5lZCA6IGFtekRhdGUsXG4gICAgICAgIGF1dGhvcml6YXRpb25IZWFkZXIsXG4gICAgICAgIGNhbm9uaWNhbFF1ZXJ5c3RyaW5nOiBvcHRpb25zLmNhbm9uaWNhbFF1ZXJ5c3RyaW5nLFxuICAgIH07XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBd3NSZXF1ZXN0U2lnbmVyIiwiY3J5cHRvXzEiLCJyZXF1aXJlIiwiQVdTX0FMR09SSVRITSIsIkFXU19SRVFVRVNUX1RZUEUiLCJjb25zdHJ1Y3RvciIsImdldENyZWRlbnRpYWxzIiwicmVnaW9uIiwiY3J5cHRvIiwiY3JlYXRlQ3J5cHRvIiwiZ2V0UmVxdWVzdE9wdGlvbnMiLCJhbXpPcHRpb25zIiwidXJsIiwiRXJyb3IiLCJyZXF1ZXN0UGF5bG9hZERhdGEiLCJkYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1ldGhvZCIsInJlcXVlc3RQYXlsb2FkIiwiYm9keSIsImFkZGl0aW9uYWxBbXpIZWFkZXJzIiwiaGVhZGVycyIsImF3c1NlY3VyaXR5Q3JlZGVudGlhbHMiLCJ1cmkiLCJVUkwiLCJoZWFkZXJNYXAiLCJnZW5lcmF0ZUF1dGhlbnRpY2F0aW9uSGVhZGVyTWFwIiwiaG9zdCIsImNhbm9uaWNhbFVyaSIsInBhdGhuYW1lIiwiY2Fub25pY2FsUXVlcnlzdHJpbmciLCJzZWFyY2giLCJzdWJzdHIiLCJzZWN1cml0eUNyZWRlbnRpYWxzIiwiYXNzaWduIiwiYW16RGF0ZSIsIkF1dGhvcml6YXRpb24iLCJhdXRob3JpemF0aW9uSGVhZGVyIiwidG9rZW4iLCJhd3NTaWduZWRSZXEiLCJzaWduIiwia2V5IiwibXNnIiwic2lnbldpdGhIbWFjU2hhMjU2IiwiZ2V0U2lnbmluZ0tleSIsImRhdGVTdGFtcCIsInNlcnZpY2VOYW1lIiwia0RhdGUiLCJrUmVnaW9uIiwia1NlcnZpY2UiLCJrU2lnbmluZyIsIm9wdGlvbnMiLCJzcGxpdCIsIm5vdyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJyZWZvcm1hdHRlZEFkZGl0aW9uYWxBbXpIZWFkZXJzIiwia2V5cyIsImZvckVhY2giLCJ0b0xvd2VyQ2FzZSIsImFtekhlYWRlcnMiLCJkYXRlIiwiY2Fub25pY2FsSGVhZGVycyIsInNpZ25lZEhlYWRlcnNMaXN0Iiwic29ydCIsInNpZ25lZEhlYWRlcnMiLCJqb2luIiwicGF5bG9hZEhhc2giLCJzaGEyNTZEaWdlc3RIZXgiLCJjYW5vbmljYWxSZXF1ZXN0IiwiY3JlZGVudGlhbFNjb3BlIiwic3RyaW5nVG9TaWduIiwic2lnbmluZ0tleSIsInNlY3JldEFjY2Vzc0tleSIsInNpZ25hdHVyZSIsImFjY2Vzc0tleUlkIiwiZnJvbUFycmF5QnVmZmVyVG9IZXgiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/baseexternalclient.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _BaseExternalAccountClient_instances, _BaseExternalAccountClient_pendingAccessToken, _BaseExternalAccountClient_internalRefreshAccessTokenAsync;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseExternalAccountClient = exports.DEFAULT_UNIVERSE = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst sts = __webpack_require__(/*! ./stscredentials */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/google-auth-library/build/src/util.js\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */ const STS_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\";\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */ const STS_REQUEST_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\";\n/** The default OAuth scope to request when none is provided. */ const DEFAULT_OAUTH_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\n/** Default impersonated token lifespan in seconds.*/ const DEFAULT_TOKEN_LIFESPAN = 3600;\n/**\n * Offset to take into account network delays and server clock skews.\n */ exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */ exports.EXTERNAL_ACCOUNT_TYPE = \"external_account\";\n/**\n * Cloud resource manager URL used to retrieve project information.\n *\n * @deprecated use {@link BaseExternalAccountClient.cloudResourceManagerURL} instead\n **/ exports.CLOUD_RESOURCE_MANAGER = \"https://cloudresourcemanager.googleapis.com/v1/projects/\";\n/** The workforce audience pattern. */ const WORKFORCE_AUDIENCE_PATTERN = \"//iam\\\\.googleapis\\\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+\";\nconst DEFAULT_TOKEN_URL = \"https://sts.{universeDomain}/v1/token\";\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst pkg = __webpack_require__(/*! ../../../package.json */ \"(rsc)/./node_modules/google-auth-library/package.json\");\n/**\n * For backwards compatibility.\n */ var authclient_2 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nObject.defineProperty(exports, \"DEFAULT_UNIVERSE\", ({\n    enumerable: true,\n    get: function() {\n        return authclient_2.DEFAULT_UNIVERSE;\n    }\n}));\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */ class BaseExternalAccountClient extends authclient_1.AuthClient {\n    /**\n     * Instantiate a BaseExternalAccountClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file. The camelCased options\n     *   are aliases for the snake_cased options.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        var _a;\n        super({\n            ...options,\n            ...additionalOptions\n        });\n        _BaseExternalAccountClient_instances.add(this);\n        /**\n         * A pending access token request. Used for concurrent calls.\n         */ _BaseExternalAccountClient_pendingAccessToken.set(this, null);\n        const opts = (0, util_1.originalOrCamelOptions)(options);\n        const type = opts.get(\"type\");\n        if (type && type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n            throw new Error(`Expected \"${exports.EXTERNAL_ACCOUNT_TYPE}\" type but ` + `received \"${options.type}\"`);\n        }\n        const clientId = opts.get(\"client_id\");\n        const clientSecret = opts.get(\"client_secret\");\n        const tokenUrl = (_a = opts.get(\"token_url\")) !== null && _a !== void 0 ? _a : DEFAULT_TOKEN_URL.replace(\"{universeDomain}\", this.universeDomain);\n        const subjectTokenType = opts.get(\"subject_token_type\");\n        const workforcePoolUserProject = opts.get(\"workforce_pool_user_project\");\n        const serviceAccountImpersonationUrl = opts.get(\"service_account_impersonation_url\");\n        const serviceAccountImpersonation = opts.get(\"service_account_impersonation\");\n        const serviceAccountImpersonationLifetime = (0, util_1.originalOrCamelOptions)(serviceAccountImpersonation).get(\"token_lifetime_seconds\");\n        this.cloudResourceManagerURL = new URL(opts.get(\"cloud_resource_manager_url\") || `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`);\n        if (clientId) {\n            this.clientAuth = {\n                confidentialClientType: \"basic\",\n                clientId,\n                clientSecret\n            };\n        }\n        this.stsCredential = new sts.StsCredentials(tokenUrl, this.clientAuth);\n        this.scopes = opts.get(\"scopes\") || [\n            DEFAULT_OAUTH_SCOPE\n        ];\n        this.cachedAccessToken = null;\n        this.audience = opts.get(\"audience\");\n        this.subjectTokenType = subjectTokenType;\n        this.workforcePoolUserProject = workforcePoolUserProject;\n        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n        if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {\n            throw new Error(\"workforcePoolUserProject should not be set for non-workforce pool \" + \"credentials.\");\n        }\n        this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;\n        this.serviceAccountImpersonationLifetime = serviceAccountImpersonationLifetime;\n        if (this.serviceAccountImpersonationLifetime) {\n            this.configLifetimeRequested = true;\n        } else {\n            this.configLifetimeRequested = false;\n            this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;\n        }\n        this.projectNumber = this.getProjectNumber(this.audience);\n        this.supplierContext = {\n            audience: this.audience,\n            subjectTokenType: this.subjectTokenType,\n            transporter: this.transporter\n        };\n    }\n    /** The service account email to be impersonated, if available. */ getServiceAccountEmail() {\n        var _a;\n        if (this.serviceAccountImpersonationUrl) {\n            if (this.serviceAccountImpersonationUrl.length > 256) {\n                /**\n                 * Prevents DOS attacks.\n                 * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/84}\n                 **/ throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);\n            }\n            // Parse email from URL. The formal looks as follows:\n            // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n            const re = /serviceAccounts\\/(?<email>[^:]+):generateAccessToken$/;\n            const result = re.exec(this.serviceAccountImpersonationUrl);\n            return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\n        }\n        return null;\n    }\n    /**\n     * Provides a mechanism to inject GCP access tokens directly.\n     * When the provided credential expires, a new credential, using the\n     * external account options, is retrieved.\n     * @param credentials The Credentials object to set on the current client.\n     */ setCredentials(credentials) {\n        super.setCredentials(credentials);\n        this.cachedAccessToken = credentials;\n    }\n    /**\n     * @return A promise that resolves with the current GCP access token\n     *   response. If the current credential is expired, a new one is retrieved.\n     */ async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */ async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * @return A promise that resolves with the project ID corresponding to the\n     *   current workload identity pool or current workforce pool if\n     *   determinable. For workforce pool credential, it returns the project ID\n     *   corresponding to the workforcePoolUserProject.\n     *   This is introduced to match the current pattern of using the Auth\n     *   library:\n     *   const projectId = await auth.getProjectId();\n     *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n     *   const res = await client.request({ url });\n     *   The resource may not have permission\n     *   (resourcemanager.projects.get) to call this API or the required\n     *   scopes may not be selected:\n     *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n     */ async getProjectId() {\n        const projectNumber = this.projectNumber || this.workforcePoolUserProject;\n        if (this.projectId) {\n            // Return previously determined project ID.\n            return this.projectId;\n        } else if (projectNumber) {\n            // Preferable not to use request() to avoid retrial policies.\n            const headers = await this.getRequestHeaders();\n            const response = await this.transporter.request({\n                ...BaseExternalAccountClient.RETRY_CONFIG,\n                headers,\n                url: `${this.cloudResourceManagerURL.toString()}${projectNumber}`,\n                responseType: \"json\"\n            });\n            this.projectId = response.data.projectId;\n            return this.projectId;\n        }\n        return null;\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.\n     * @return A promise that resolves with the successful response.\n     */ async requestAsync(opts, reAuthRetried = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = requestHeaders[\"x-goog-user-project\"];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * External credentials are exchanged for GCP access tokens via the token\n     * exchange endpoint and other settings provided in the client options\n     * object.\n     * If the service_account_impersonation_url is provided, an additional\n     * step to exchange the external account GCP access token for a service\n     * account impersonated token is performed.\n     * @return A promise that resolves with the fresh GCP access tokens.\n     */ async refreshAccessTokenAsync() {\n        // Use an existing access token request, or cache a new one\n        __classPrivateFieldSet(this, _BaseExternalAccountClient_pendingAccessToken, __classPrivateFieldGet(this, _BaseExternalAccountClient_pendingAccessToken, \"f\") || __classPrivateFieldGet(this, _BaseExternalAccountClient_instances, \"m\", _BaseExternalAccountClient_internalRefreshAccessTokenAsync).call(this), \"f\");\n        try {\n            return await __classPrivateFieldGet(this, _BaseExternalAccountClient_pendingAccessToken, \"f\");\n        } finally{\n            // clear pending access token for future requests\n            __classPrivateFieldSet(this, _BaseExternalAccountClient_pendingAccessToken, null, \"f\");\n        }\n    }\n    /**\n     * Returns the workload identity pool project number if it is determinable\n     * from the audience resource name.\n     * @param audience The STS audience used to determine the project number.\n     * @return The project number associated with the workload identity pool, if\n     *   this can be determined from the STS audience field. Otherwise, null is\n     *   returned.\n     */ getProjectNumber(audience) {\n        // STS audience pattern:\n        // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n        const match = audience.match(/\\/projects\\/([^/]+)/);\n        if (!match) {\n            return null;\n        }\n        return match[1];\n    }\n    /**\n     * Exchanges an external account GCP access token for a service\n     * account impersonated access token using iamcredentials\n     * GenerateAccessToken API.\n     * @param token The access token to exchange for a service account access\n     *   token.\n     * @return A promise that resolves with the service account impersonated\n     *   credentials response.\n     */ async getImpersonatedAccessToken(token) {\n        const opts = {\n            ...BaseExternalAccountClient.RETRY_CONFIG,\n            url: this.serviceAccountImpersonationUrl,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${token}`\n            },\n            data: {\n                scope: this.getScopesArray(),\n                lifetime: this.serviceAccountImpersonationLifetime + \"s\"\n            },\n            responseType: \"json\"\n        };\n        const response = await this.transporter.request(opts);\n        const successResponse = response.data;\n        return {\n            access_token: successResponse.accessToken,\n            // Convert from ISO format to timestamp.\n            expiry_date: new Date(successResponse.expireTime).getTime(),\n            res: response\n        };\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param accessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */ isExpired(accessToken) {\n        const now = new Date().getTime();\n        return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n    /**\n     * @return The list of scopes for the requested GCP access token.\n     */ getScopesArray() {\n        // Since scopes can be provided as string or array, the type should\n        // be normalized.\n        if (typeof this.scopes === \"string\") {\n            return [\n                this.scopes\n            ];\n        }\n        return this.scopes || [\n            DEFAULT_OAUTH_SCOPE\n        ];\n    }\n    getMetricsHeaderValue() {\n        const nodeVersion = process.version.replace(/^v/, \"\");\n        const saImpersonation = this.serviceAccountImpersonationUrl !== undefined;\n        const credentialSourceType = this.credentialSourceType ? this.credentialSourceType : \"unknown\";\n        return `gl-node/${nodeVersion} auth/${pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;\n    }\n}\nexports.BaseExternalAccountClient = BaseExternalAccountClient;\n_BaseExternalAccountClient_pendingAccessToken = new WeakMap(), _BaseExternalAccountClient_instances = new WeakSet(), _BaseExternalAccountClient_internalRefreshAccessTokenAsync = async function _BaseExternalAccountClient_internalRefreshAccessTokenAsync() {\n    // Retrieve the external credential.\n    const subjectToken = await this.retrieveSubjectToken();\n    // Construct the STS credentials options.\n    const stsCredentialsOptions = {\n        grantType: STS_GRANT_TYPE,\n        audience: this.audience,\n        requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n        subjectToken,\n        subjectTokenType: this.subjectTokenType,\n        // generateAccessToken requires the provided access token to have\n        // scopes:\n        // https://www.googleapis.com/auth/iam or\n        // https://www.googleapis.com/auth/cloud-platform\n        // The new service account access token scopes will match the user\n        // provided ones.\n        scope: this.serviceAccountImpersonationUrl ? [\n            DEFAULT_OAUTH_SCOPE\n        ] : this.getScopesArray()\n    };\n    // Exchange the external credentials for a GCP access token.\n    // Client auth is prioritized over passing the workforcePoolUserProject\n    // parameter for STS token exchange.\n    const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? {\n        userProject: this.workforcePoolUserProject\n    } : undefined;\n    const additionalHeaders = {\n        \"x-goog-api-client\": this.getMetricsHeaderValue()\n    };\n    const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);\n    if (this.serviceAccountImpersonationUrl) {\n        this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n    } else if (stsResponse.expires_in) {\n        // Save response in cached access token.\n        this.cachedAccessToken = {\n            access_token: stsResponse.access_token,\n            expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n            res: stsResponse.res\n        };\n    } else {\n        // Save response in cached access token.\n        this.cachedAccessToken = {\n            access_token: stsResponse.access_token,\n            res: stsResponse.res\n        };\n    }\n    // Save credentials.\n    this.credentials = {};\n    Object.assign(this.credentials, this.cachedAccessToken);\n    delete this.credentials.res;\n    // Trigger tokens event to notify external listeners.\n    this.emit(\"tokens\", {\n        refresh_token: null,\n        expiry_date: this.cachedAccessToken.expiry_date,\n        access_token: this.cachedAccessToken.access_token,\n        token_type: \"Bearer\",\n        id_token: null\n    });\n    // Return the cached access token.\n    return this.cachedAccessToken;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9iYXNlZXh0ZXJuYWxjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsSUFBSUEseUJBQXlCLElBQUssSUFBSSxJQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLENBQUM7SUFDcEcsSUFBSUQsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0gsVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNFLElBQUksQ0FBQ0YsTUFBTUksR0FBRyxDQUFDTCxXQUFXLE1BQU0sSUFBSUksVUFBVTtJQUN2RyxPQUFPRixTQUFTLE1BQU1DLElBQUlELFNBQVMsTUFBTUMsRUFBRUcsSUFBSSxDQUFDTixZQUFZRyxJQUFJQSxFQUFFSSxLQUFLLEdBQUdOLE1BQU1PLEdBQUcsQ0FBQ1I7QUFDeEY7QUFDQSxJQUFJUyx5QkFBeUIsSUFBSyxJQUFJLElBQUksQ0FBQ0Esc0JBQXNCLElBQUssU0FBVVQsUUFBUSxFQUFFQyxLQUFLLEVBQUVNLEtBQUssRUFBRUwsSUFBSSxFQUFFQyxDQUFDO0lBQzNHLElBQUlELFNBQVMsS0FBSyxNQUFNLElBQUlFLFVBQVU7SUFDdEMsSUFBSUYsU0FBUyxPQUFPLENBQUNDLEdBQUcsTUFBTSxJQUFJQyxVQUFVO0lBQzVDLElBQUksT0FBT0gsVUFBVSxhQUFhRCxhQUFhQyxTQUFTLENBQUNFLElBQUksQ0FBQ0YsTUFBTUksR0FBRyxDQUFDTCxXQUFXLE1BQU0s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QUFLMEQsWUFBWTFELEdBQUc7UUFDeEI7SUFDSixPQUNLO1FBQ0Qsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQ3pCLGlCQUFpQixHQUFHO1lBQ3JCd0IsY0FBYzJELFlBQVkzRCxZQUFZO1lBQ3RDQyxLQUFLMEQsWUFBWTFELEdBQUc7UUFDeEI7SUFDSjtJQUNBLG9CQUFvQjtJQUNwQixJQUFJLENBQUNOLFdBQVcsR0FBRyxDQUFDO0lBQ3BCcEUsT0FBT3VJLE1BQU0sQ0FBQyxJQUFJLENBQUNuRSxXQUFXLEVBQUUsSUFBSSxDQUFDbkIsaUJBQWlCO0lBQ3RELE9BQU8sSUFBSSxDQUFDbUIsV0FBVyxDQUFDTSxHQUFHO0lBQzNCLHFEQUFxRDtJQUNyRCxJQUFJLENBQUM4RCxJQUFJLENBQUMsVUFBVTtRQUNoQkMsZUFBZTtRQUNmM0IsYUFBYSxJQUFJLENBQUM3RCxpQkFBaUIsQ0FBQzZELFdBQVc7UUFDL0NyQyxjQUFjLElBQUksQ0FBQ3hCLGlCQUFpQixDQUFDd0IsWUFBWTtRQUNqRGlFLFlBQVk7UUFDWkMsVUFBVTtJQUNkO0lBQ0Esa0NBQWtDO0lBQ2xDLE9BQU8sSUFBSSxDQUFDMUYsaUJBQWlCO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9iYXNlZXh0ZXJuYWxjbGllbnQuanM/NjA3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50X2luc3RhbmNlcywgX0Jhc2VFeHRlcm5hbEFjY291bnRDbGllbnRfcGVuZGluZ0FjY2Vzc1Rva2VuLCBfQmFzZUV4dGVybmFsQWNjb3VudENsaWVudF9pbnRlcm5hbFJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50ID0gZXhwb3J0cy5ERUZBVUxUX1VOSVZFUlNFID0gZXhwb3J0cy5DTE9VRF9SRVNPVVJDRV9NQU5BR0VSID0gZXhwb3J0cy5FWFRFUk5BTF9BQ0NPVU5UX1RZUEUgPSBleHBvcnRzLkVYUElSQVRJT05fVElNRV9PRkZTRVQgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aGNsaWVudFwiKTtcbmNvbnN0IHN0cyA9IHJlcXVpcmUoXCIuL3N0c2NyZWRlbnRpYWxzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIFRoZSByZXF1aXJlZCB0b2tlbiBleGNoYW5nZSBncmFudF90eXBlOiByZmM4NjkzI3NlY3Rpb24tMi4xXG4gKi9cbmNvbnN0IFNUU19HUkFOVF9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOnRva2VuLWV4Y2hhbmdlJztcbi8qKlxuICogVGhlIHJlcXVlc3RlZCB0b2tlbiBleGNoYW5nZSByZXF1ZXN0ZWRfdG9rZW5fdHlwZTogcmZjODY5MyNzZWN0aW9uLTIuMVxuICovXG5jb25zdCBTVFNfUkVRVUVTVF9UT0tFTl9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOmFjY2Vzc190b2tlbic7XG4vKiogVGhlIGRlZmF1bHQgT0F1dGggc2NvcGUgdG8gcmVxdWVzdCB3aGVuIG5vbmUgaXMgcHJvdmlkZWQuICovXG5jb25zdCBERUZBVUxUX09BVVRIX1NDT1BFID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0nO1xuLyoqIERlZmF1bHQgaW1wZXJzb25hdGVkIHRva2VuIGxpZmVzcGFuIGluIHNlY29uZHMuKi9cbmNvbnN0IERFRkFVTFRfVE9LRU5fTElGRVNQQU4gPSAzNjAwO1xuLyoqXG4gKiBPZmZzZXQgdG8gdGFrZSBpbnRvIGFjY291bnQgbmV0d29yayBkZWxheXMgYW5kIHNlcnZlciBjbG9jayBza2V3cy5cbiAqL1xuZXhwb3J0cy5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUID0gNSAqIDYwICogMTAwMDtcbi8qKlxuICogVGhlIGNyZWRlbnRpYWxzIEpTT04gZmlsZSB0eXBlIGZvciBleHRlcm5hbCBhY2NvdW50IGNsaWVudHMuXG4gKiBUaGVyZSBhcmUgMyB0eXBlcyBvZiBKU09OIGNvbmZpZ3M6XG4gKiAxLiBhdXRob3JpemVkX3VzZXIgPT4gR29vZ2xlIGVuZCB1c2VyIGNyZWRlbnRpYWxcbiAqIDIuIHNlcnZpY2VfYWNjb3VudCA9PiBHb29nbGUgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxcbiAqIDMuIGV4dGVybmFsX0FjY291bnQgPT4gbm9uLUdDUCBzZXJ2aWNlIChlZy4gQVdTLCBBenVyZSwgSzhzKVxuICovXG5leHBvcnRzLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSA9ICdleHRlcm5hbF9hY2NvdW50Jztcbi8qKlxuICogQ2xvdWQgcmVzb3VyY2UgbWFuYWdlciBVUkwgdXNlZCB0byByZXRyaWV2ZSBwcm9qZWN0IGluZm9ybWF0aW9uLlxuICpcbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgQmFzZUV4dGVybmFsQWNjb3VudENsaWVudC5jbG91ZFJlc291cmNlTWFuYWdlclVSTH0gaW5zdGVhZFxuICoqL1xuZXhwb3J0cy5DTE9VRF9SRVNPVVJDRV9NQU5BR0VSID0gJ2h0dHBzOi8vY2xvdWRyZXNvdXJjZW1hbmFnZXIuZ29vZ2xlYXBpcy5jb20vdjEvcHJvamVjdHMvJztcbi8qKiBUaGUgd29ya2ZvcmNlIGF1ZGllbmNlIHBhdHRlcm4uICovXG5jb25zdCBXT1JLRk9SQ0VfQVVESUVOQ0VfUEFUVEVSTiA9ICcvL2lhbVxcXFwuZ29vZ2xlYXBpc1xcXFwuY29tL2xvY2F0aW9ucy9bXi9dKy93b3JrZm9yY2VQb29scy9bXi9dKy9wcm92aWRlcnMvLisnO1xuY29uc3QgREVGQVVMVF9UT0tFTl9VUkwgPSAnaHR0cHM6Ly9zdHMue3VuaXZlcnNlRG9tYWlufS92MS90b2tlbic7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuY29uc3QgcGtnID0gcmVxdWlyZSgnLi4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG4vKipcbiAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqL1xudmFyIGF1dGhjbGllbnRfMiA9IHJlcXVpcmUoXCIuL2F1dGhjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJERUZBVUxUX1VOSVZFUlNFXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhdXRoY2xpZW50XzIuREVGQVVMVF9VTklWRVJTRTsgfSB9KTtcbi8qKlxuICogQmFzZSBleHRlcm5hbCBhY2NvdW50IGNsaWVudC4gVGhpcyBpcyB1c2VkIHRvIGluc3RhbnRpYXRlIEF1dGhDbGllbnRzIGZvclxuICogZXhjaGFuZ2luZyBleHRlcm5hbCBhY2NvdW50IGNyZWRlbnRpYWxzIGZvciBHQ1AgYWNjZXNzIHRva2VuIGFuZCBhdXRob3JpemluZ1xuICogcmVxdWVzdHMgdG8gR0NQIEFQSXMuXG4gKiBUaGUgYmFzZSBjbGFzcyBpbXBsZW1lbnRzIGNvbW1vbiBsb2dpYyBmb3IgZXhjaGFuZ2luZyB2YXJpb3VzIHR5cGUgb2ZcbiAqIGV4dGVybmFsIGNyZWRlbnRpYWxzIGZvciBHQ1AgYWNjZXNzIHRva2VuLiBUaGUgbG9naWMgb2YgZGV0ZXJtaW5pbmcgYW5kXG4gKiByZXRyaWV2aW5nIHRoZSBleHRlcm5hbCBjcmVkZW50aWFsIGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudCBhbmRcbiAqIGNyZWRlbnRpYWxfc291cmNlIHdpbGwgYmUgbGVmdCBmb3IgdGhlIHN1YmNsYXNzZXMuXG4gKi9cbmNsYXNzIEJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgZXh0ZW5kcyBhdXRoY2xpZW50XzEuQXV0aENsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYSBCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OXG4gICAgICogb2JqZWN0IGxvYWRlZCBmcm9tIGFuIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbHMgZmlsZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgZXh0ZXJuYWwgYWNjb3VudCBvcHRpb25zIG9iamVjdCB0eXBpY2FsbHkgbG9hZGVkXG4gICAgICogICBmcm9tIHRoZSBleHRlcm5hbCBhY2NvdW50IEpTT04gY3JlZGVudGlhbCBmaWxlLiBUaGUgY2FtZWxDYXNlZCBvcHRpb25zXG4gICAgICogICBhcmUgYWxpYXNlcyBmb3IgdGhlIHNuYWtlX2Nhc2VkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zICoqREVQUkVDQVRFRCwgYWxsIG9wdGlvbnMgYXJlIGF2YWlsYWJsZSBpbiB0aGVcbiAgICAgKiAgIGBvcHRpb25zYCBwYXJhbWV0ZXIuKiogT3B0aW9uYWwgYWRkaXRpb25hbCBiZWhhdmlvciBjdXN0b21pemF0aW9uIG9wdGlvbnMuXG4gICAgICogICBUaGVzZSBjdXJyZW50bHkgY3VzdG9taXplIGV4cGlyYXRpb24gdGhyZXNob2xkIHRpbWUgYW5kIHdoZXRoZXIgdG8gcmV0cnlcbiAgICAgKiAgIG9uIDQwMS80MDMgQVBJIHJlcXVlc3QgZXJyb3JzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoeyAuLi5vcHRpb25zLCAuLi5hZGRpdGlvbmFsT3B0aW9ucyB9KTtcbiAgICAgICAgX0Jhc2VFeHRlcm5hbEFjY291bnRDbGllbnRfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcGVuZGluZyBhY2Nlc3MgdG9rZW4gcmVxdWVzdC4gVXNlZCBmb3IgY29uY3VycmVudCBjYWxscy5cbiAgICAgICAgICovXG4gICAgICAgIF9CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50X3BlbmRpbmdBY2Nlc3NUb2tlbi5zZXQodGhpcywgbnVsbCk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSAoMCwgdXRpbF8xLm9yaWdpbmFsT3JDYW1lbE9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB0eXBlID0gb3B0cy5nZXQoJ3R5cGUnKTtcbiAgICAgICAgaWYgKHR5cGUgJiYgdHlwZSAhPT0gZXhwb3J0cy5FWFRFUk5BTF9BQ0NPVU5UX1RZUEUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgXCIke2V4cG9ydHMuRVhURVJOQUxfQUNDT1VOVF9UWVBFfVwiIHR5cGUgYnV0IGAgK1xuICAgICAgICAgICAgICAgIGByZWNlaXZlZCBcIiR7b3B0aW9ucy50eXBlfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50SWQgPSBvcHRzLmdldCgnY2xpZW50X2lkJyk7XG4gICAgICAgIGNvbnN0IGNsaWVudFNlY3JldCA9IG9wdHMuZ2V0KCdjbGllbnRfc2VjcmV0Jyk7XG4gICAgICAgIGNvbnN0IHRva2VuVXJsID0gKF9hID0gb3B0cy5nZXQoJ3Rva2VuX3VybCcpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1RPS0VOX1VSTC5yZXBsYWNlKCd7dW5pdmVyc2VEb21haW59JywgdGhpcy51bml2ZXJzZURvbWFpbik7XG4gICAgICAgIGNvbnN0IHN1YmplY3RUb2tlblR5cGUgPSBvcHRzLmdldCgnc3ViamVjdF90b2tlbl90eXBlJyk7XG4gICAgICAgIGNvbnN0IHdvcmtmb3JjZVBvb2xVc2VyUHJvamVjdCA9IG9wdHMuZ2V0KCd3b3JrZm9yY2VfcG9vbF91c2VyX3Byb2plY3QnKTtcbiAgICAgICAgY29uc3Qgc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsID0gb3B0cy5nZXQoJ3NlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybCcpO1xuICAgICAgICBjb25zdCBzZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb24gPSBvcHRzLmdldCgnc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb24nKTtcbiAgICAgICAgY29uc3Qgc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uTGlmZXRpbWUgPSAoMCwgdXRpbF8xLm9yaWdpbmFsT3JDYW1lbE9wdGlvbnMpKHNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvbikuZ2V0KCd0b2tlbl9saWZldGltZV9zZWNvbmRzJyk7XG4gICAgICAgIHRoaXMuY2xvdWRSZXNvdXJjZU1hbmFnZXJVUkwgPSBuZXcgVVJMKG9wdHMuZ2V0KCdjbG91ZF9yZXNvdXJjZV9tYW5hZ2VyX3VybCcpIHx8XG4gICAgICAgICAgICBgaHR0cHM6Ly9jbG91ZHJlc291cmNlbWFuYWdlci4ke3RoaXMudW5pdmVyc2VEb21haW59L3YxL3Byb2plY3RzL2ApO1xuICAgICAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50QXV0aCA9IHtcbiAgICAgICAgICAgICAgICBjb25maWRlbnRpYWxDbGllbnRUeXBlOiAnYmFzaWMnLFxuICAgICAgICAgICAgICAgIGNsaWVudElkLFxuICAgICAgICAgICAgICAgIGNsaWVudFNlY3JldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHNDcmVkZW50aWFsID0gbmV3IHN0cy5TdHNDcmVkZW50aWFscyh0b2tlblVybCwgdGhpcy5jbGllbnRBdXRoKTtcbiAgICAgICAgdGhpcy5zY29wZXMgPSBvcHRzLmdldCgnc2NvcGVzJykgfHwgW0RFRkFVTFRfT0FVVEhfU0NPUEVdO1xuICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdWRpZW5jZSA9IG9wdHMuZ2V0KCdhdWRpZW5jZScpO1xuICAgICAgICB0aGlzLnN1YmplY3RUb2tlblR5cGUgPSBzdWJqZWN0VG9rZW5UeXBlO1xuICAgICAgICB0aGlzLndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdCA9IHdvcmtmb3JjZVBvb2xVc2VyUHJvamVjdDtcbiAgICAgICAgY29uc3Qgd29ya2ZvcmNlQXVkaWVuY2VQYXR0ZXJuID0gbmV3IFJlZ0V4cChXT1JLRk9SQ0VfQVVESUVOQ0VfUEFUVEVSTik7XG4gICAgICAgIGlmICh0aGlzLndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdCAmJlxuICAgICAgICAgICAgIXRoaXMuYXVkaWVuY2UubWF0Y2god29ya2ZvcmNlQXVkaWVuY2VQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b3JrZm9yY2VQb29sVXNlclByb2plY3Qgc2hvdWxkIG5vdCBiZSBzZXQgZm9yIG5vbi13b3JrZm9yY2UgcG9vbCAnICtcbiAgICAgICAgICAgICAgICAnY3JlZGVudGlhbHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwgPSBzZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25Vcmw7XG4gICAgICAgIHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uTGlmZXRpbWUgPVxuICAgICAgICAgICAgc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uTGlmZXRpbWU7XG4gICAgICAgIGlmICh0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvbkxpZmV0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ0xpZmV0aW1lUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnTGlmZXRpbWVSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uTGlmZXRpbWUgPSBERUZBVUxUX1RPS0VOX0xJRkVTUEFOO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvamVjdE51bWJlciA9IHRoaXMuZ2V0UHJvamVjdE51bWJlcih0aGlzLmF1ZGllbmNlKTtcbiAgICAgICAgdGhpcy5zdXBwbGllckNvbnRleHQgPSB7XG4gICAgICAgICAgICBhdWRpZW5jZTogdGhpcy5hdWRpZW5jZSxcbiAgICAgICAgICAgIHN1YmplY3RUb2tlblR5cGU6IHRoaXMuc3ViamVjdFRva2VuVHlwZSxcbiAgICAgICAgICAgIHRyYW5zcG9ydGVyOiB0aGlzLnRyYW5zcG9ydGVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogVGhlIHNlcnZpY2UgYWNjb3VudCBlbWFpbCB0byBiZSBpbXBlcnNvbmF0ZWQsIGlmIGF2YWlsYWJsZS4gKi9cbiAgICBnZXRTZXJ2aWNlQWNjb3VudEVtYWlsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uVXJsLmxlbmd0aCA+IDI1Nikge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFByZXZlbnRzIERPUyBhdHRhY2tzLlxuICAgICAgICAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL2dvb2dsZS1hdXRoLWxpYnJhcnktbm9kZWpzL3NlY3VyaXR5L2NvZGUtc2Nhbm5pbmcvODR9XG4gICAgICAgICAgICAgICAgICoqL1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVUkwgaXMgdG9vIGxvbmc6ICR7dGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25Vcmx9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBlbWFpbCBmcm9tIFVSTC4gVGhlIGZvcm1hbCBsb29rcyBhcyBmb2xsb3dzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9pYW1jcmVkZW50aWFscy5nb29nbGVhcGlzLmNvbS92MS9wcm9qZWN0cy8tL3NlcnZpY2VBY2NvdW50cy9uYW1lQHByb2plY3QtaWQuaWFtLmdzZXJ2aWNlYWNjb3VudC5jb206Z2VuZXJhdGVBY2Nlc3NUb2tlblxuICAgICAgICAgICAgY29uc3QgcmUgPSAvc2VydmljZUFjY291bnRzXFwvKD88ZW1haWw+W146XSspOmdlbmVyYXRlQWNjZXNzVG9rZW4kLztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlLmV4ZWModGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwpO1xuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZ3JvdXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1haWwpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIGluamVjdCBHQ1AgYWNjZXNzIHRva2VucyBkaXJlY3RseS5cbiAgICAgKiBXaGVuIHRoZSBwcm92aWRlZCBjcmVkZW50aWFsIGV4cGlyZXMsIGEgbmV3IGNyZWRlbnRpYWwsIHVzaW5nIHRoZVxuICAgICAqIGV4dGVybmFsIGFjY291bnQgb3B0aW9ucywgaXMgcmV0cmlldmVkLlxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgQ3JlZGVudGlhbHMgb2JqZWN0IHRvIHNldCBvbiB0aGUgY3VycmVudCBjbGllbnQuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgc3VwZXIuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0gY3JlZGVudGlhbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY3VycmVudCBHQ1AgYWNjZXNzIHRva2VuXG4gICAgICogICByZXNwb25zZS4gSWYgdGhlIGN1cnJlbnQgY3JlZGVudGlhbCBpcyBleHBpcmVkLCBhIG5ldyBvbmUgaXMgcmV0cmlldmVkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICAvLyBJZiBjYWNoZWQgYWNjZXNzIHRva2VuIGlzIHVuYXZhaWxhYmxlIG9yIGV4cGlyZWQsIGZvcmNlIHJlZnJlc2guXG4gICAgICAgIGlmICghdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiB8fCB0aGlzLmlzRXhwaXJlZCh0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBHQ1AgYWNjZXNzIHRva2VuIGluIEdldEFjY2Vzc1Rva2VuUmVzcG9uc2UgZm9ybWF0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW46IHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgcmVzOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLnJlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1haW4gYXV0aGVudGljYXRpb24gaW50ZXJmYWNlLiBJdCB0YWtlcyBhbiBvcHRpb25hbCB1cmwgd2hpY2ggd2hlblxuICAgICAqIHByZXNlbnQgaXMgdGhlIGVuZHBvaW50IGJlaW5nIGFjY2Vzc2VkLCBhbmQgcmV0dXJucyBhIFByb21pc2Ugd2hpY2hcbiAgICAgKiByZXNvbHZlcyB3aXRoIGF1dGhvcml6YXRpb24gaGVhZGVyIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIFRoZSByZXN1bHQgaGFzIHRoZSBmb3JtOlxuICAgICAqIHsgQXV0aG9yaXphdGlvbjogJ0JlYXJlciA8YWNjZXNzX3Rva2VuX3ZhbHVlPicgfVxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlcXVlc3RIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VuUmVzcG9uc2UudG9rZW59YCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH1cbiAgICByZXF1ZXN0KG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSwgZS5yZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHByb2plY3QgSUQgY29ycmVzcG9uZGluZyB0byB0aGVcbiAgICAgKiAgIGN1cnJlbnQgd29ya2xvYWQgaWRlbnRpdHkgcG9vbCBvciBjdXJyZW50IHdvcmtmb3JjZSBwb29sIGlmXG4gICAgICogICBkZXRlcm1pbmFibGUuIEZvciB3b3JrZm9yY2UgcG9vbCBjcmVkZW50aWFsLCBpdCByZXR1cm5zIHRoZSBwcm9qZWN0IElEXG4gICAgICogICBjb3JyZXNwb25kaW5nIHRvIHRoZSB3b3JrZm9yY2VQb29sVXNlclByb2plY3QuXG4gICAgICogICBUaGlzIGlzIGludHJvZHVjZWQgdG8gbWF0Y2ggdGhlIGN1cnJlbnQgcGF0dGVybiBvZiB1c2luZyB0aGUgQXV0aFxuICAgICAqICAgbGlicmFyeTpcbiAgICAgKiAgIGNvbnN0IHByb2plY3RJZCA9IGF3YWl0IGF1dGguZ2V0UHJvamVjdElkKCk7XG4gICAgICogICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9kbnMuZ29vZ2xlYXBpcy5jb20vZG5zL3YxL3Byb2plY3RzLyR7cHJvamVjdElkfWA7XG4gICAgICogICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7IHVybCB9KTtcbiAgICAgKiAgIFRoZSByZXNvdXJjZSBtYXkgbm90IGhhdmUgcGVybWlzc2lvblxuICAgICAqICAgKHJlc291cmNlbWFuYWdlci5wcm9qZWN0cy5nZXQpIHRvIGNhbGwgdGhpcyBBUEkgb3IgdGhlIHJlcXVpcmVkXG4gICAgICogICBzY29wZXMgbWF5IG5vdCBiZSBzZWxlY3RlZDpcbiAgICAgKiAgIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9yZXNvdXJjZS1tYW5hZ2VyL3JlZmVyZW5jZS9yZXN0L3YxL3Byb2plY3RzL2dldCNhdXRob3JpemF0aW9uLXNjb3Blc1xuICAgICAqL1xuICAgIGFzeW5jIGdldFByb2plY3RJZCgpIHtcbiAgICAgICAgY29uc3QgcHJvamVjdE51bWJlciA9IHRoaXMucHJvamVjdE51bWJlciB8fCB0aGlzLndvcmtmb3JjZVBvb2xVc2VyUHJvamVjdDtcbiAgICAgICAgaWYgKHRoaXMucHJvamVjdElkKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gcHJldmlvdXNseSBkZXRlcm1pbmVkIHByb2plY3QgSUQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdE51bWJlcikge1xuICAgICAgICAgICAgLy8gUHJlZmVyYWJsZSBub3QgdG8gdXNlIHJlcXVlc3QoKSB0byBhdm9pZCByZXRyaWFsIHBvbGljaWVzLlxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAuLi5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50LlJFVFJZX0NPTkZJRyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHVybDogYCR7dGhpcy5jbG91ZFJlc291cmNlTWFuYWdlclVSTC50b1N0cmluZygpfSR7cHJvamVjdE51bWJlcn1gLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnByb2plY3RJZCA9IHJlc3BvbnNlLmRhdGEucHJvamVjdElkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdXRoZW50aWNhdGVzIHRoZSBwcm92aWRlZCBIVFRQIHJlcXVlc3QsIHByb2Nlc3NlcyBpdCBhbmQgcmVzb2x2ZXMgd2l0aCB0aGVcbiAgICAgKiByZXR1cm5lZCByZXNwb25zZS5cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgSFRUUCByZXF1ZXN0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHJlQXV0aFJldHJpZWQgV2hldGhlciB0aGUgY3VycmVudCBhdHRlbXB0IGlzIGEgcmV0cnkgYWZ0ZXIgYSBmYWlsZWQgYXR0ZW1wdCBkdWUgdG8gYW4gYXV0aCBmYWlsdXJlLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0QXN5bmMob3B0cywgcmVBdXRoUmV0cmllZCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSA9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdEhlYWRlcnMgJiYgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbikge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBlLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIFJldHJ5IHRoZSByZXF1ZXN0IGZvciBtZXRhZGF0YSBpZiB0aGUgZm9sbG93aW5nIGNyaXRlcmlhIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgIC8vIC0gV2UgaGF2ZW4ndCBhbHJlYWR5IHJldHJpZWQuICBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVzcG9uc2Ugd2FzIGEgNDAxIG9yIGEgNDAzXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVxdWVzdCBkaWRuJ3Qgc2VuZCBhIHJlYWRhYmxlU3RyZWFtXG4gICAgICAgICAgICAgICAgLy8gLSBmb3JjZVJlZnJlc2hPbkZhaWx1cmUgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSByZXMuY29uZmlnLmRhdGEgaW5zdGFuY2VvZiBzdHJlYW0uUmVhZGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdXRoRXJyID0gc3RhdHVzQ29kZSA9PT0gNDAxIHx8IHN0YXR1c0NvZGUgPT09IDQwMztcbiAgICAgICAgICAgICAgICBpZiAoIXJlQXV0aFJldHJpZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRoRXJyICYmXG4gICAgICAgICAgICAgICAgICAgICFpc1JlYWRhYmxlU3RyZWFtICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdEFzeW5jKG9wdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdG9rZW4gcmVmcmVzaCwgZXZlbiBpZiB1bmV4cGlyZWQgdG9rZW5zIGFyZSBjdXJyZW50bHkgY2FjaGVkLlxuICAgICAqIEV4dGVybmFsIGNyZWRlbnRpYWxzIGFyZSBleGNoYW5nZWQgZm9yIEdDUCBhY2Nlc3MgdG9rZW5zIHZpYSB0aGUgdG9rZW5cbiAgICAgKiBleGNoYW5nZSBlbmRwb2ludCBhbmQgb3RoZXIgc2V0dGluZ3MgcHJvdmlkZWQgaW4gdGhlIGNsaWVudCBvcHRpb25zXG4gICAgICogb2JqZWN0LlxuICAgICAqIElmIHRoZSBzZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmwgaXMgcHJvdmlkZWQsIGFuIGFkZGl0aW9uYWxcbiAgICAgKiBzdGVwIHRvIGV4Y2hhbmdlIHRoZSBleHRlcm5hbCBhY2NvdW50IEdDUCBhY2Nlc3MgdG9rZW4gZm9yIGEgc2VydmljZVxuICAgICAqIGFjY291bnQgaW1wZXJzb25hdGVkIHRva2VuIGlzIHBlcmZvcm1lZC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGZyZXNoIEdDUCBhY2Nlc3MgdG9rZW5zLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCkge1xuICAgICAgICAvLyBVc2UgYW4gZXhpc3RpbmcgYWNjZXNzIHRva2VuIHJlcXVlc3QsIG9yIGNhY2hlIGEgbmV3IG9uZVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50X3BlbmRpbmdBY2Nlc3NUb2tlbiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmFzZUV4dGVybmFsQWNjb3VudENsaWVudF9wZW5kaW5nQWNjZXNzVG9rZW4sIFwiZlwiKSB8fCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50X2luc3RhbmNlcywgXCJtXCIsIF9CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50X2ludGVybmFsUmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMpLmNhbGwodGhpcyksIFwiZlwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50X3BlbmRpbmdBY2Nlc3NUb2tlbiwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gY2xlYXIgcGVuZGluZyBhY2Nlc3MgdG9rZW4gZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmFzZUV4dGVybmFsQWNjb3VudENsaWVudF9wZW5kaW5nQWNjZXNzVG9rZW4sIG51bGwsIFwiZlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3b3JrbG9hZCBpZGVudGl0eSBwb29sIHByb2plY3QgbnVtYmVyIGlmIGl0IGlzIGRldGVybWluYWJsZVxuICAgICAqIGZyb20gdGhlIGF1ZGllbmNlIHJlc291cmNlIG5hbWUuXG4gICAgICogQHBhcmFtIGF1ZGllbmNlIFRoZSBTVFMgYXVkaWVuY2UgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHByb2plY3QgbnVtYmVyLlxuICAgICAqIEByZXR1cm4gVGhlIHByb2plY3QgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgd29ya2xvYWQgaWRlbnRpdHkgcG9vbCwgaWZcbiAgICAgKiAgIHRoaXMgY2FuIGJlIGRldGVybWluZWQgZnJvbSB0aGUgU1RTIGF1ZGllbmNlIGZpZWxkLiBPdGhlcndpc2UsIG51bGwgaXNcbiAgICAgKiAgIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldFByb2plY3ROdW1iZXIoYXVkaWVuY2UpIHtcbiAgICAgICAgLy8gU1RTIGF1ZGllbmNlIHBhdHRlcm46XG4gICAgICAgIC8vIC8vaWFtLmdvb2dsZWFwaXMuY29tL3Byb2plY3RzLyRQUk9KRUNUX05VTUJFUi9sb2NhdGlvbnMvLi4uXG4gICAgICAgIGNvbnN0IG1hdGNoID0gYXVkaWVuY2UubWF0Y2goL1xcL3Byb2plY3RzXFwvKFteL10rKS8pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2hhbmdlcyBhbiBleHRlcm5hbCBhY2NvdW50IEdDUCBhY2Nlc3MgdG9rZW4gZm9yIGEgc2VydmljZVxuICAgICAqIGFjY291bnQgaW1wZXJzb25hdGVkIGFjY2VzcyB0b2tlbiB1c2luZyBpYW1jcmVkZW50aWFsc1xuICAgICAqIEdlbmVyYXRlQWNjZXNzVG9rZW4gQVBJLlxuICAgICAqIEBwYXJhbSB0b2tlbiBUaGUgYWNjZXNzIHRva2VuIHRvIGV4Y2hhbmdlIGZvciBhIHNlcnZpY2UgYWNjb3VudCBhY2Nlc3NcbiAgICAgKiAgIHRva2VuLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc2VydmljZSBhY2NvdW50IGltcGVyc29uYXRlZFxuICAgICAqICAgY3JlZGVudGlhbHMgcmVzcG9uc2UuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SW1wZXJzb25hdGVkQWNjZXNzVG9rZW4odG9rZW4pIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIC4uLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQuUkVUUllfQ09ORklHLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybCxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHNjb3BlOiB0aGlzLmdldFNjb3Blc0FycmF5KCksXG4gICAgICAgICAgICAgICAgbGlmZXRpbWU6IHRoaXMuc2VydmljZUFjY291bnRJbXBlcnNvbmF0aW9uTGlmZXRpbWUgKyAncycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICBjb25zdCBzdWNjZXNzUmVzcG9uc2UgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBzdWNjZXNzUmVzcG9uc2UuYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gSVNPIGZvcm1hdCB0byB0aW1lc3RhbXAuXG4gICAgICAgICAgICBleHBpcnlfZGF0ZTogbmV3IERhdGUoc3VjY2Vzc1Jlc3BvbnNlLmV4cGlyZVRpbWUpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIHJlczogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgY3JlZGVudGlhbHMgYXJlIGV4cGlyZWQgb3Igbm90LlxuICAgICAqIElmIHRoZXJlIGlzIG5vIGV4cGlyeSB0aW1lLCBhc3N1bWVzIHRoZSB0b2tlbiBpcyBub3QgZXhwaXJlZCBvciBleHBpcmluZy5cbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gVGhlIGNyZWRlbnRpYWxzIHRvIGNoZWNrIGZvciBleHBpcmF0aW9uLlxuICAgICAqIEByZXR1cm4gV2hldGhlciB0aGUgY3JlZGVudGlhbHMgYXJlIGV4cGlyZWQgb3Igbm90LlxuICAgICAqL1xuICAgIGlzRXhwaXJlZChhY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlXG4gICAgICAgICAgICA/IG5vdyA+PSBhY2Nlc3NUb2tlbi5leHBpcnlfZGF0ZSAtIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIFRoZSBsaXN0IG9mIHNjb3BlcyBmb3IgdGhlIHJlcXVlc3RlZCBHQ1AgYWNjZXNzIHRva2VuLlxuICAgICAqL1xuICAgIGdldFNjb3Blc0FycmF5KCkge1xuICAgICAgICAvLyBTaW5jZSBzY29wZXMgY2FuIGJlIHByb3ZpZGVkIGFzIHN0cmluZyBvciBhcnJheSwgdGhlIHR5cGUgc2hvdWxkXG4gICAgICAgIC8vIGJlIG5vcm1hbGl6ZWQuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zY29wZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuc2NvcGVzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY29wZXMgfHwgW0RFRkFVTFRfT0FVVEhfU0NPUEVdO1xuICAgIH1cbiAgICBnZXRNZXRyaWNzSGVhZGVyVmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IG5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9uLnJlcGxhY2UoL152LywgJycpO1xuICAgICAgICBjb25zdCBzYUltcGVyc29uYXRpb24gPSB0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBjcmVkZW50aWFsU291cmNlVHlwZSA9IHRoaXMuY3JlZGVudGlhbFNvdXJjZVR5cGVcbiAgICAgICAgICAgID8gdGhpcy5jcmVkZW50aWFsU291cmNlVHlwZVxuICAgICAgICAgICAgOiAndW5rbm93bic7XG4gICAgICAgIHJldHVybiBgZ2wtbm9kZS8ke25vZGVWZXJzaW9ufSBhdXRoLyR7cGtnLnZlcnNpb259IGdvb2dsZS1ieW9pZC1zZGsgc291cmNlLyR7Y3JlZGVudGlhbFNvdXJjZVR5cGV9IHNhLWltcGVyc29uYXRpb24vJHtzYUltcGVyc29uYXRpb259IGNvbmZpZy1saWZldGltZS8ke3RoaXMuY29uZmlnTGlmZXRpbWVSZXF1ZXN0ZWR9YDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgPSBCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50O1xuX0Jhc2VFeHRlcm5hbEFjY291bnRDbGllbnRfcGVuZGluZ0FjY2Vzc1Rva2VuID0gbmV3IFdlYWtNYXAoKSwgX0Jhc2VFeHRlcm5hbEFjY291bnRDbGllbnRfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX0Jhc2VFeHRlcm5hbEFjY291bnRDbGllbnRfaW50ZXJuYWxSZWZyZXNoQWNjZXNzVG9rZW5Bc3luYyA9IGFzeW5jIGZ1bmN0aW9uIF9CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50X2ludGVybmFsUmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKSB7XG4gICAgLy8gUmV0cmlldmUgdGhlIGV4dGVybmFsIGNyZWRlbnRpYWwuXG4gICAgY29uc3Qgc3ViamVjdFRva2VuID0gYXdhaXQgdGhpcy5yZXRyaWV2ZVN1YmplY3RUb2tlbigpO1xuICAgIC8vIENvbnN0cnVjdCB0aGUgU1RTIGNyZWRlbnRpYWxzIG9wdGlvbnMuXG4gICAgY29uc3Qgc3RzQ3JlZGVudGlhbHNPcHRpb25zID0ge1xuICAgICAgICBncmFudFR5cGU6IFNUU19HUkFOVF9UWVBFLFxuICAgICAgICBhdWRpZW5jZTogdGhpcy5hdWRpZW5jZSxcbiAgICAgICAgcmVxdWVzdGVkVG9rZW5UeXBlOiBTVFNfUkVRVUVTVF9UT0tFTl9UWVBFLFxuICAgICAgICBzdWJqZWN0VG9rZW4sXG4gICAgICAgIHN1YmplY3RUb2tlblR5cGU6IHRoaXMuc3ViamVjdFRva2VuVHlwZSxcbiAgICAgICAgLy8gZ2VuZXJhdGVBY2Nlc3NUb2tlbiByZXF1aXJlcyB0aGUgcHJvdmlkZWQgYWNjZXNzIHRva2VuIHRvIGhhdmVcbiAgICAgICAgLy8gc2NvcGVzOlxuICAgICAgICAvLyBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2lhbSBvclxuICAgICAgICAvLyBodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtXG4gICAgICAgIC8vIFRoZSBuZXcgc2VydmljZSBhY2NvdW50IGFjY2VzcyB0b2tlbiBzY29wZXMgd2lsbCBtYXRjaCB0aGUgdXNlclxuICAgICAgICAvLyBwcm92aWRlZCBvbmVzLlxuICAgICAgICBzY29wZTogdGhpcy5zZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmxcbiAgICAgICAgICAgID8gW0RFRkFVTFRfT0FVVEhfU0NPUEVdXG4gICAgICAgICAgICA6IHRoaXMuZ2V0U2NvcGVzQXJyYXkoKSxcbiAgICB9O1xuICAgIC8vIEV4Y2hhbmdlIHRoZSBleHRlcm5hbCBjcmVkZW50aWFscyBmb3IgYSBHQ1AgYWNjZXNzIHRva2VuLlxuICAgIC8vIENsaWVudCBhdXRoIGlzIHByaW9yaXRpemVkIG92ZXIgcGFzc2luZyB0aGUgd29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0XG4gICAgLy8gcGFyYW1ldGVyIGZvciBTVFMgdG9rZW4gZXhjaGFuZ2UuXG4gICAgY29uc3QgYWRkaXRpb25hbE9wdGlvbnMgPSAhdGhpcy5jbGllbnRBdXRoICYmIHRoaXMud29ya2ZvcmNlUG9vbFVzZXJQcm9qZWN0XG4gICAgICAgID8geyB1c2VyUHJvamVjdDogdGhpcy53b3JrZm9yY2VQb29sVXNlclByb2plY3QgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBhZGRpdGlvbmFsSGVhZGVycyA9IHtcbiAgICAgICAgJ3gtZ29vZy1hcGktY2xpZW50JzogdGhpcy5nZXRNZXRyaWNzSGVhZGVyVmFsdWUoKSxcbiAgICB9O1xuICAgIGNvbnN0IHN0c1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5zdHNDcmVkZW50aWFsLmV4Y2hhbmdlVG9rZW4oc3RzQ3JlZGVudGlhbHNPcHRpb25zLCBhZGRpdGlvbmFsSGVhZGVycywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgIGlmICh0aGlzLnNlcnZpY2VBY2NvdW50SW1wZXJzb25hdGlvblVybCkge1xuICAgICAgICB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5nZXRJbXBlcnNvbmF0ZWRBY2Nlc3NUb2tlbihzdHNSZXNwb25zZS5hY2Nlc3NfdG9rZW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHNSZXNwb25zZS5leHBpcmVzX2luKSB7XG4gICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgaW4gY2FjaGVkIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiA9IHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogc3RzUmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgc3RzUmVzcG9uc2UuZXhwaXJlc19pbiAqIDEwMDAsXG4gICAgICAgICAgICByZXM6IHN0c1Jlc3BvbnNlLnJlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgaW4gY2FjaGVkIGFjY2VzcyB0b2tlbi5cbiAgICAgICAgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiA9IHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogc3RzUmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgcmVzOiBzdHNSZXNwb25zZS5yZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNhdmUgY3JlZGVudGlhbHMuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IHt9O1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jcmVkZW50aWFscywgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbik7XG4gICAgZGVsZXRlIHRoaXMuY3JlZGVudGlhbHMucmVzO1xuICAgIC8vIFRyaWdnZXIgdG9rZW5zIGV2ZW50IHRvIG5vdGlmeSBleHRlcm5hbCBsaXN0ZW5lcnMuXG4gICAgdGhpcy5lbWl0KCd0b2tlbnMnLCB7XG4gICAgICAgIHJlZnJlc2hfdG9rZW46IG51bGwsXG4gICAgICAgIGV4cGlyeV9kYXRlOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlLFxuICAgICAgICBhY2Nlc3NfdG9rZW46IHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICB0b2tlbl90eXBlOiAnQmVhcmVyJyxcbiAgICAgICAgaWRfdG9rZW46IG51bGwsXG4gICAgfSk7XG4gICAgLy8gUmV0dXJuIHRoZSBjYWNoZWQgYWNjZXNzIHRva2VuLlxuICAgIHJldHVybiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuO1xufTtcbiJdLCJuYW1lcyI6WyJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwicmVjZWl2ZXIiLCJzdGF0ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInZhbHVlIiwiZ2V0IiwiX19jbGFzc1ByaXZhdGVGaWVsZFNldCIsInNldCIsIl9CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50X2luc3RhbmNlcyIsIl9CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50X3BlbmRpbmdBY2Nlc3NUb2tlbiIsIl9CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50X2ludGVybmFsUmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IiwiREVGQVVMVF9VTklWRVJTRSIsIkNMT1VEX1JFU09VUkNFX01BTkFHRVIiLCJFWFRFUk5BTF9BQ0NPVU5UX1RZUEUiLCJFWFBJUkFUSU9OX1RJTUVfT0ZGU0VUIiwic3RyZWFtIiwicmVxdWlyZSIsImF1dGhjbGllbnRfMSIsInN0cyIsInV0aWxfMSIsIlNUU19HUkFOVF9UWVBFIiwiU1RTX1JFUVVFU1RfVE9LRU5fVFlQRSIsIkRFRkFVTFRfT0FVVEhfU0NPUEUiLCJERUZBVUxUX1RPS0VOX0xJRkVTUEFOIiwiV09SS0ZPUkNFX0FVRElFTkNFX1BBVFRFUk4iLCJERUZBVUxUX1RPS0VOX1VSTCIsInBrZyIsImF1dGhjbGllbnRfMiIsImVudW1lcmFibGUiLCJBdXRoQ2xpZW50IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJfYSIsImFkZCIsIm9wdHMiLCJvcmlnaW5hbE9yQ2FtZWxPcHRpb25zIiwidHlwZSIsIkVycm9yIiwiY2xpZW50SWQiLCJjbGllbnRTZWNyZXQiLCJ0b2tlblVybCIsInJlcGxhY2UiLCJ1bml2ZXJzZURvbWFpbiIsInN1YmplY3RUb2tlblR5cGUiLCJ3b3JrZm9yY2VQb29sVXNlclByb2plY3QiLCJzZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25VcmwiLCJzZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb24iLCJzZXJ2aWNlQWNjb3VudEltcGVyc29uYXRpb25MaWZldGltZSIsImNsb3VkUmVzb3VyY2VNYW5hZ2VyVVJMIiwiVVJMIiwiY2xpZW50QXV0aCIsImNvbmZpZGVudGlhbENsaWVudFR5cGUiLCJzdHNDcmVkZW50aWFsIiwiU3RzQ3JlZGVudGlhbHMiLCJzY29wZXMiLCJjYWNoZWRBY2Nlc3NUb2tlbiIsImF1ZGllbmNlIiwid29ya2ZvcmNlQXVkaWVuY2VQYXR0ZXJuIiwiUmVnRXhwIiwibWF0Y2giLCJjb25maWdMaWZldGltZVJlcXVlc3RlZCIsInByb2plY3ROdW1iZXIiLCJnZXRQcm9qZWN0TnVtYmVyIiwic3VwcGxpZXJDb250ZXh0IiwidHJhbnNwb3J0ZXIiLCJnZXRTZXJ2aWNlQWNjb3VudEVtYWlsIiwibGVuZ3RoIiwiUmFuZ2VFcnJvciIsInJlIiwicmVzdWx0IiwiZXhlYyIsImdyb3VwcyIsImVtYWlsIiwic2V0Q3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsImdldEFjY2Vzc1Rva2VuIiwiaXNFeHBpcmVkIiwicmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMiLCJ0b2tlbiIsImFjY2Vzc190b2tlbiIsInJlcyIsImdldFJlcXVlc3RIZWFkZXJzIiwiYWNjZXNzVG9rZW5SZXNwb25zZSIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwiYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzIiwicmVxdWVzdCIsImNhbGxiYWNrIiwicmVxdWVzdEFzeW5jIiwidGhlbiIsInIiLCJlIiwicmVzcG9uc2UiLCJnZXRQcm9qZWN0SWQiLCJwcm9qZWN0SWQiLCJSRVRSWV9DT05GSUciLCJ1cmwiLCJ0b1N0cmluZyIsInJlc3BvbnNlVHlwZSIsImRhdGEiLCJyZUF1dGhSZXRyaWVkIiwicmVxdWVzdEhlYWRlcnMiLCJzdGF0dXNDb2RlIiwic3RhdHVzIiwiaXNSZWFkYWJsZVN0cmVhbSIsImNvbmZpZyIsIlJlYWRhYmxlIiwiaXNBdXRoRXJyIiwiZm9yY2VSZWZyZXNoT25GYWlsdXJlIiwiZ2V0SW1wZXJzb25hdGVkQWNjZXNzVG9rZW4iLCJtZXRob2QiLCJzY29wZSIsImdldFNjb3Blc0FycmF5IiwibGlmZXRpbWUiLCJzdWNjZXNzUmVzcG9uc2UiLCJhY2Nlc3NUb2tlbiIsImV4cGlyeV9kYXRlIiwiRGF0ZSIsImV4cGlyZVRpbWUiLCJnZXRUaW1lIiwibm93IiwiZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIiwiZ2V0TWV0cmljc0hlYWRlclZhbHVlIiwibm9kZVZlcnNpb24iLCJwcm9jZXNzIiwidmVyc2lvbiIsInNhSW1wZXJzb25hdGlvbiIsInVuZGVmaW5lZCIsImNyZWRlbnRpYWxTb3VyY2VUeXBlIiwiV2Vha01hcCIsIldlYWtTZXQiLCJzdWJqZWN0VG9rZW4iLCJyZXRyaWV2ZVN1YmplY3RUb2tlbiIsInN0c0NyZWRlbnRpYWxzT3B0aW9ucyIsImdyYW50VHlwZSIsInJlcXVlc3RlZFRva2VuVHlwZSIsInVzZXJQcm9qZWN0IiwiYWRkaXRpb25hbEhlYWRlcnMiLCJzdHNSZXNwb25zZSIsImV4Y2hhbmdlVG9rZW4iLCJleHBpcmVzX2luIiwiYXNzaWduIiwiZW1pdCIsInJlZnJlc2hfdG9rZW4iLCJ0b2tlbl90eXBlIiwiaWRfdG9rZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/computeclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Compute = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(rsc)/./node_modules/gcp-metadata/build/src/index.js\");\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass Compute extends oauth2client_1.OAuth2Client {\n    /**\n     * Google Compute Engine service account credentials.\n     *\n     * Retrieve access token from the metadata server.\n     * See: https://cloud.google.com/compute/docs/access/authenticate-workloads#applications\n     */ constructor(options = {}){\n        super(options);\n        // Start with an expired refresh token, which will automatically be\n        // refreshed before the first API call is made.\n        this.credentials = {\n            expiry_date: 1,\n            refresh_token: \"compute-placeholder\"\n        };\n        this.serviceAccountEmail = options.serviceAccountEmail || \"default\";\n        this.scopes = Array.isArray(options.scopes) ? options.scopes : options.scopes ? [\n            options.scopes\n        ] : [];\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken Unused parameter\n     */ async refreshTokenNoCache(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;\n        let data;\n        try {\n            const instanceOptions = {\n                property: tokenPath\n            };\n            if (this.scopes.length > 0) {\n                instanceOptions.params = {\n                    scopes: this.scopes.join(\",\")\n                };\n            }\n            data = await gcpMetadata.instance(instanceOptions);\n        } catch (e) {\n            if (e instanceof gaxios_1.GaxiosError) {\n                e.message = `Could not refresh access token: ${e.message}`;\n                this.wrapError(e);\n            }\n            throw e;\n        }\n        const tokens = data;\n        if (data && data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit(\"tokens\", tokens);\n        return {\n            tokens,\n            res: null\n        };\n    }\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */ async fetchIdToken(targetAudience) {\n        const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity` + `?format=full&audience=${targetAudience}`;\n        let idToken;\n        try {\n            const instanceOptions = {\n                property: idTokenPath\n            };\n            idToken = await gcpMetadata.instance(instanceOptions);\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Could not fetch ID token: ${e.message}`;\n            }\n            throw e;\n        }\n        return idToken;\n    }\n    wrapError(e) {\n        const res = e.response;\n        if (res && res.status) {\n            e.status = res.status;\n            if (res.status === 403) {\n                e.message = \"A Forbidden error was returned while attempting to retrieve an access \" + \"token for the Compute Engine built-in service account. This may be because the Compute \" + \"Engine instance does not have the correct permission scopes specified: \" + e.message;\n            } else if (res.status === 404) {\n                e.message = \"A Not Found error was returned while attempting to retrieve an access\" + \"token for the Compute Engine built-in service account. This may be because the Compute \" + \"Engine instance does not have any permission scopes specified: \" + e.message;\n            }\n        }\n    }\n}\nexports.Compute = Compute;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9jb21wdXRlY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZUFBZSxHQUFHLEtBQUs7QUFDdkIsTUFBTUcsV0FBV0MsbUJBQU9BLENBQUMsOERBQVE7QUFDakMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMEVBQWM7QUFDMUMsTUFBTUUsaUJBQWlCRixtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDL0MsTUFBTUYsZ0JBQWdCSSxlQUFlQyxZQUFZO0lBQzdDOzs7OztLQUtDLEdBQ0RDLFlBQVlDLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDdEIsS0FBSyxDQUFDQTtRQUNOLG1FQUFtRTtRQUNuRSwrQ0FBK0M7UUFDL0MsSUFBSSxDQUFDQyxXQUFXLEdBQUc7WUFBRUMsYUFBYTtZQUFHQyxlQUFlO1FBQXNCO1FBQzFFLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUdKLFFBQVFJLG1CQUFtQixJQUFJO1FBQzFELElBQUksQ0FBQ0MsTUFBTSxHQUFHQyxNQUFNQyxPQUFPLENBQUNQLFFBQVFLLE1BQU0sSUFDcENMLFFBQVFLLE1BQU0sR0FDZEwsUUFBUUssTUFBTSxHQUNWO1lBQUNMLFFBQVFLLE1BQU07U0FBQyxHQUNoQixFQUFFO0lBQ2hCO0lBQ0E7OztLQUdDLEdBQ0QsTUFBTUcsb0JBQ04sNkRBQTZEO0lBQzdEQyxZQUFZLEVBQUU7UUFDVixNQUFNQyxZQUFZLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDTixtQkFBbUIsQ0FBQyxNQUFNLENBQUM7UUFDdEUsSUFBSU87UUFDSixJQUFJO1lBQ0EsTUFBTUMsa0JBQWtCO2dCQUNwQkMsVUFBVUg7WUFDZDtZQUNBLElBQUksSUFBSSxDQUFDTCxNQUFNLENBQUNTLE1BQU0sR0FBRyxHQUFHO2dCQUN4QkYsZ0JBQWdCRyxNQUFNLEdBQUc7b0JBQ3JCVixRQUFRLElBQUksQ0FBQ0EsTUFBTSxDQUFDVyxJQUFJLENBQUM7Z0JBQzdCO1lBQ0o7WUFDQUwsT0FBTyxNQUFNZixZQUFZcUIsUUFBUSxDQUFDTDtRQUN0QyxFQUNBLE9BQU9NLEdBQUc7WUFDTixJQUFJQSxhQUFheEIsU0FBU3lCLFdBQVcsRUFBRTtnQkFDbkNELEVBQUVFLE9BQU8sR0FBRyxDQUFDLGdDQUFnQyxFQUFFRixFQUFFRSxPQUFPLENBQUMsQ0FBQztnQkFDMUQsSUFBSSxDQUFDQyxTQUFTLENBQUNIO1lBQ25CO1lBQ0EsTUFBTUE7UUFDVjtRQUNBLE1BQU1JLFNBQVNYO1FBQ2YsSUFBSUEsUUFBUUEsS0FBS1ksVUFBVSxFQUFFO1lBQ3pCRCxPQUFPcEIsV0FBVyxHQUFHLElBQUlzQixPQUFPQyxPQUFPLEtBQUtkLEtBQUtZLFVBQVUsR0FBRztZQUM5RCxPQUFPRCxPQUFPQyxVQUFVO1FBQzVCO1FBQ0EsSUFBSSxDQUFDRyxJQUFJLENBQUMsVUFBVUo7UUFDcEIsT0FBTztZQUFFQTtZQUFRSyxLQUFLO1FBQUs7SUFDL0I7SUFDQTs7O0tBR0MsR0FDRCxNQUFNQyxhQUFhQyxjQUFjLEVBQUU7UUFDL0IsTUFBTUMsY0FBYyxDQUFDLGlCQUFpQixFQUFFLElBQUksQ0FBQzFCLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxHQUN2RSxDQUFDLHNCQUFzQixFQUFFeUIsZUFBZSxDQUFDO1FBQzdDLElBQUlFO1FBQ0osSUFBSTtZQUNBLE1BQU1uQixrQkFBa0I7Z0JBQ3BCQyxVQUFVaUI7WUFDZDtZQUNBQyxVQUFVLE1BQU1uQyxZQUFZcUIsUUFBUSxDQUFDTDtRQUN6QyxFQUNBLE9BQU9NLEdBQUc7WUFDTixJQUFJQSxhQUFhYyxPQUFPO2dCQUNwQmQsRUFBRUUsT0FBTyxHQUFHLENBQUMsMEJBQTBCLEVBQUVGLEVBQUVFLE9BQU8sQ0FBQyxDQUFDO1lBQ3hEO1lBQ0EsTUFBTUY7UUFDVjtRQUNBLE9BQU9hO0lBQ1g7SUFDQVYsVUFBVUgsQ0FBQyxFQUFFO1FBQ1QsTUFBTVMsTUFBTVQsRUFBRWUsUUFBUTtRQUN0QixJQUFJTixPQUFPQSxJQUFJTyxNQUFNLEVBQUU7WUFDbkJoQixFQUFFZ0IsTUFBTSxHQUFHUCxJQUFJTyxNQUFNO1lBQ3JCLElBQUlQLElBQUlPLE1BQU0sS0FBSyxLQUFLO2dCQUNwQmhCLEVBQUVFLE9BQU8sR0FDTCwyRUFDSSw0RkFDQSw0RUFDQUYsRUFBRUUsT0FBTztZQUNyQixPQUNLLElBQUlPLElBQUlPLE1BQU0sS0FBSyxLQUFLO2dCQUN6QmhCLEVBQUVFLE9BQU8sR0FDTCwwRUFDSSw0RkFDQSxvRUFDQUYsRUFBRUUsT0FBTztZQUNyQjtRQUNKO0lBQ0o7QUFDSjtBQUNBN0IsZUFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvY29tcHV0ZWNsaWVudC5qcz82M2YyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTMgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXB1dGUgPSB2b2lkIDA7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBnY3BNZXRhZGF0YSA9IHJlcXVpcmUoXCJnY3AtbWV0YWRhdGFcIik7XG5jb25zdCBvYXV0aDJjbGllbnRfMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNsaWVudFwiKTtcbmNsYXNzIENvbXB1dGUgZXh0ZW5kcyBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEdvb2dsZSBDb21wdXRlIEVuZ2luZSBzZXJ2aWNlIGFjY291bnQgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZSBhY2Nlc3MgdG9rZW4gZnJvbSB0aGUgbWV0YWRhdGEgc2VydmVyLlxuICAgICAqIFNlZTogaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2NvbXB1dGUvZG9jcy9hY2Nlc3MvYXV0aGVudGljYXRlLXdvcmtsb2FkcyNhcHBsaWNhdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYW4gZXhwaXJlZCByZWZyZXNoIHRva2VuLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICAgICAgLy8gcmVmcmVzaGVkIGJlZm9yZSB0aGUgZmlyc3QgQVBJIGNhbGwgaXMgbWFkZS5cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHsgZXhwaXJ5X2RhdGU6IDEsIHJlZnJlc2hfdG9rZW46ICdjb21wdXRlLXBsYWNlaG9sZGVyJyB9O1xuICAgICAgICB0aGlzLnNlcnZpY2VBY2NvdW50RW1haWwgPSBvcHRpb25zLnNlcnZpY2VBY2NvdW50RW1haWwgfHwgJ2RlZmF1bHQnO1xuICAgICAgICB0aGlzLnNjb3BlcyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5zY29wZXMpXG4gICAgICAgICAgICA/IG9wdGlvbnMuc2NvcGVzXG4gICAgICAgICAgICA6IG9wdGlvbnMuc2NvcGVzXG4gICAgICAgICAgICAgICAgPyBbb3B0aW9ucy5zY29wZXNdXG4gICAgICAgICAgICAgICAgOiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBVbnVzZWQgcGFyYW1ldGVyXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFRva2VuTm9DYWNoZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHRva2VuUGF0aCA9IGBzZXJ2aWNlLWFjY291bnRzLyR7dGhpcy5zZXJ2aWNlQWNjb3VudEVtYWlsfS90b2tlbmA7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5OiB0b2tlblBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc2NvcGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZU9wdGlvbnMucGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBzY29wZXM6IHRoaXMuc2NvcGVzLmpvaW4oJywnKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IGF3YWl0IGdjcE1ldGFkYXRhLmluc3RhbmNlKGluc3RhbmNlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgZ2F4aW9zXzEuR2F4aW9zRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBgQ291bGQgbm90IHJlZnJlc2ggYWNjZXNzIHRva2VuOiAke2UubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcEVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbnMgPSBkYXRhO1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmV4cGlyZXNfaW4pIHtcbiAgICAgICAgICAgIHRva2Vucy5leHBpcnlfZGF0ZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgZGF0YS5leHBpcmVzX2luICogMTAwMDtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbnMuZXhwaXJlc19pbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB7IHRva2VucywgcmVzOiBudWxsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYW4gSUQgdG9rZW4uXG4gICAgICogQHBhcmFtIHRhcmdldEF1ZGllbmNlIHRoZSBhdWRpZW5jZSBmb3IgdGhlIGZldGNoZWQgSUQgdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgZmV0Y2hJZFRva2VuKHRhcmdldEF1ZGllbmNlKSB7XG4gICAgICAgIGNvbnN0IGlkVG9rZW5QYXRoID0gYHNlcnZpY2UtYWNjb3VudHMvJHt0aGlzLnNlcnZpY2VBY2NvdW50RW1haWx9L2lkZW50aXR5YCArXG4gICAgICAgICAgICBgP2Zvcm1hdD1mdWxsJmF1ZGllbmNlPSR7dGFyZ2V0QXVkaWVuY2V9YDtcbiAgICAgICAgbGV0IGlkVG9rZW47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHk6IGlkVG9rZW5QYXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlkVG9rZW4gPSBhd2FpdCBnY3BNZXRhZGF0YS5pbnN0YW5jZShpbnN0YW5jZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYENvdWxkIG5vdCBmZXRjaCBJRCB0b2tlbjogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkVG9rZW47XG4gICAgfVxuICAgIHdyYXBFcnJvcihlKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGUucmVzcG9uc2U7XG4gICAgICAgIGlmIChyZXMgJiYgcmVzLnN0YXR1cykge1xuICAgICAgICAgICAgZS5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICdBIEZvcmJpZGRlbiBlcnJvciB3YXMgcmV0dXJuZWQgd2hpbGUgYXR0ZW1wdGluZyB0byByZXRyaWV2ZSBhbiBhY2Nlc3MgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAndG9rZW4gZm9yIHRoZSBDb21wdXRlIEVuZ2luZSBidWlsdC1pbiBzZXJ2aWNlIGFjY291bnQuIFRoaXMgbWF5IGJlIGJlY2F1c2UgdGhlIENvbXB1dGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnRW5naW5lIGluc3RhbmNlIGRvZXMgbm90IGhhdmUgdGhlIGNvcnJlY3QgcGVybWlzc2lvbiBzY29wZXMgc3BlY2lmaWVkOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICdBIE5vdCBGb3VuZCBlcnJvciB3YXMgcmV0dXJuZWQgd2hpbGUgYXR0ZW1wdGluZyB0byByZXRyaWV2ZSBhbiBhY2Nlc3MnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd0b2tlbiBmb3IgdGhlIENvbXB1dGUgRW5naW5lIGJ1aWx0LWluIHNlcnZpY2UgYWNjb3VudC4gVGhpcyBtYXkgYmUgYmVjYXVzZSB0aGUgQ29tcHV0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdFbmdpbmUgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBhbnkgcGVybWlzc2lvbiBzY29wZXMgc3BlY2lmaWVkOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29tcHV0ZSA9IENvbXB1dGU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDb21wdXRlIiwiZ2F4aW9zXzEiLCJyZXF1aXJlIiwiZ2NwTWV0YWRhdGEiLCJvYXV0aDJjbGllbnRfMSIsIk9BdXRoMkNsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNyZWRlbnRpYWxzIiwiZXhwaXJ5X2RhdGUiLCJyZWZyZXNoX3Rva2VuIiwic2VydmljZUFjY291bnRFbWFpbCIsInNjb3BlcyIsIkFycmF5IiwiaXNBcnJheSIsInJlZnJlc2hUb2tlbk5vQ2FjaGUiLCJyZWZyZXNoVG9rZW4iLCJ0b2tlblBhdGgiLCJkYXRhIiwiaW5zdGFuY2VPcHRpb25zIiwicHJvcGVydHkiLCJsZW5ndGgiLCJwYXJhbXMiLCJqb2luIiwiaW5zdGFuY2UiLCJlIiwiR2F4aW9zRXJyb3IiLCJtZXNzYWdlIiwid3JhcEVycm9yIiwidG9rZW5zIiwiZXhwaXJlc19pbiIsIkRhdGUiLCJnZXRUaW1lIiwiZW1pdCIsInJlcyIsImZldGNoSWRUb2tlbiIsInRhcmdldEF1ZGllbmNlIiwiaWRUb2tlblBhdGgiLCJpZFRva2VuIiwiRXJyb3IiLCJyZXNwb25zZSIsInN0YXR1cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n// Copyright 2024 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _DefaultAwsSecurityCredentialsSupplier_instances, _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken, _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName, _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials, _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get, _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DefaultAwsSecurityCredentialsSupplier = void 0;\n/**\n * Internal AWS security credentials supplier implementation used by {@link AwsClient}\n * when a credential source is provided instead of a user defined supplier.\n * The logic is summarized as:\n * 1. If imdsv2_session_token_url is provided in the credential source, then\n *    fetch the aws session token and include it in the headers of the\n *    metadata requests. This is a requirement for IDMSv2 but optional\n *    for IDMSv1.\n * 2. Retrieve AWS region from availability-zone.\n * 3a. Check AWS credentials in environment variables. If not found, get\n *     from security-credentials endpoint.\n * 3b. Get AWS credentials from security-credentials endpoint. In order\n *     to retrieve this, the AWS role needs to be determined by calling\n *     security-credentials endpoint without any argument. Then the\n *     credentials can be retrieved via: security-credentials/role_name\n * 4. Generate the signed request to AWS STS GetCallerIdentity action.\n * 5. Inject x-goog-cloud-target-resource into header and serialize the\n *    signed request. This will be the subject-token to pass to GCP STS.\n */ class DefaultAwsSecurityCredentialsSupplier {\n    /**\n     * Instantiates a new DefaultAwsSecurityCredentialsSupplier using information\n     * from the credential_source stored in the ADC file.\n     * @param opts The default aws security credentials supplier options object to\n     *   build the supplier with.\n     */ constructor(opts){\n        _DefaultAwsSecurityCredentialsSupplier_instances.add(this);\n        this.regionUrl = opts.regionUrl;\n        this.securityCredentialsUrl = opts.securityCredentialsUrl;\n        this.imdsV2SessionTokenUrl = opts.imdsV2SessionTokenUrl;\n        this.additionalGaxiosOptions = opts.additionalGaxiosOptions;\n    }\n    /**\n     * Returns the active AWS region. This first checks to see if the region\n     * is available as an environment variable. If it is not, then the supplier\n     * will call the region URL.\n     * @param context {@link ExternalAccountSupplierContext} from the calling\n     *   {@link AwsClient}, contains the requested audience and subject token type\n     *   for the external account identity.\n     * @return A promise that resolves with the AWS region string.\n     */ async getAwsRegion(context) {\n        // Priority order for region determination:\n        // AWS_REGION > AWS_DEFAULT_REGION > metadata server.\n        if (__classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, \"a\", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get)) {\n            return __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, \"a\", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get);\n        }\n        const metadataHeaders = {};\n        if (!__classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, \"a\", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get) && this.imdsV2SessionTokenUrl) {\n            metadataHeaders[\"x-aws-ec2-metadata-token\"] = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, \"m\", _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken).call(this, context.transporter);\n        }\n        if (!this.regionUrl) {\n            throw new Error(\"Unable to determine AWS region due to missing \" + '\"options.credential_source.region_url\"');\n        }\n        const opts = {\n            ...this.additionalGaxiosOptions,\n            url: this.regionUrl,\n            method: \"GET\",\n            responseType: \"text\",\n            headers: metadataHeaders\n        };\n        const response = await context.transporter.request(opts);\n        // Remove last character. For example, if us-east-2b is returned,\n        // the region would be us-east-2.\n        return response.data.substr(0, response.data.length - 1);\n    }\n    /**\n     * Returns AWS security credentials. This first checks to see if the credentials\n     * is available as environment variables. If it is not, then the supplier\n     * will call the security credentials URL.\n     * @param context {@link ExternalAccountSupplierContext} from the calling\n     *   {@link AwsClient}, contains the requested audience and subject token type\n     *   for the external account identity.\n     * @return A promise that resolves with the AWS security credentials.\n     */ async getAwsSecurityCredentials(context) {\n        // Check environment variables for permanent credentials first.\n        // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n        if (__classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, \"a\", _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get)) {\n            return __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, \"a\", _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get);\n        }\n        const metadataHeaders = {};\n        if (this.imdsV2SessionTokenUrl) {\n            metadataHeaders[\"x-aws-ec2-metadata-token\"] = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, \"m\", _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken).call(this, context.transporter);\n        }\n        // Since the role on a VM can change, we don't need to cache it.\n        const roleName = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, \"m\", _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName).call(this, metadataHeaders, context.transporter);\n        // Temporary credentials typically last for several hours.\n        // Expiration is returned in response.\n        // Consider future optimization of this logic to cache AWS tokens\n        // until their natural expiration.\n        const awsCreds = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, \"m\", _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials).call(this, roleName, metadataHeaders, context.transporter);\n        return {\n            accessKeyId: awsCreds.AccessKeyId,\n            secretAccessKey: awsCreds.SecretAccessKey,\n            token: awsCreds.Token\n        };\n    }\n}\nexports.DefaultAwsSecurityCredentialsSupplier = DefaultAwsSecurityCredentialsSupplier;\n_DefaultAwsSecurityCredentialsSupplier_instances = new WeakSet(), _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken = /**\n * @param transporter The transporter to use for requests.\n * @return A promise that resolves with the IMDSv2 Session Token.\n */ async function _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken(transporter) {\n    const opts = {\n        ...this.additionalGaxiosOptions,\n        url: this.imdsV2SessionTokenUrl,\n        method: \"PUT\",\n        responseType: \"text\",\n        headers: {\n            \"x-aws-ec2-metadata-token-ttl-seconds\": \"300\"\n        }\n    };\n    const response = await transporter.request(opts);\n    return response.data;\n}, _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName = /**\n * @param headers The headers to be used in the metadata request.\n * @param transporter The transporter to use for requests.\n * @return A promise that resolves with the assigned role to the current\n *   AWS VM. This is needed for calling the security-credentials endpoint.\n */ async function _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName(headers, transporter) {\n    if (!this.securityCredentialsUrl) {\n        throw new Error(\"Unable to determine AWS role name due to missing \" + '\"options.credential_source.url\"');\n    }\n    const opts = {\n        ...this.additionalGaxiosOptions,\n        url: this.securityCredentialsUrl,\n        method: \"GET\",\n        responseType: \"text\",\n        headers: headers\n    };\n    const response = await transporter.request(opts);\n    return response.data;\n}, _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials = /**\n * Retrieves the temporary AWS credentials by calling the security-credentials\n * endpoint as specified in the `credential_source` object.\n * @param roleName The role attached to the current VM.\n * @param headers The headers to be used in the metadata request.\n * @param transporter The transporter to use for requests.\n * @return A promise that resolves with the temporary AWS credentials\n *   needed for creating the GetCallerIdentity signed request.\n */ async function _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials(roleName, headers, transporter) {\n    const response = await transporter.request({\n        ...this.additionalGaxiosOptions,\n        url: `${this.securityCredentialsUrl}/${roleName}`,\n        responseType: \"json\",\n        headers: headers\n    });\n    return response.data;\n}, _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get = function _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get() {\n    // The AWS region can be provided through AWS_REGION or AWS_DEFAULT_REGION.\n    // Only one is required.\n    return process.env[\"AWS_REGION\"] || process.env[\"AWS_DEFAULT_REGION\"] || null;\n}, _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get = function _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get() {\n    // Both AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are required.\n    if (process.env[\"AWS_ACCESS_KEY_ID\"] && process.env[\"AWS_SECRET_ACCESS_KEY\"]) {\n        return {\n            accessKeyId: process.env[\"AWS_ACCESS_KEY_ID\"],\n            secretAccessKey: process.env[\"AWS_SECRET_ACCESS_KEY\"],\n            token: process.env[\"AWS_SESSION_TOKEN\"]\n        };\n    }\n    return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9kZWZhdWx0YXdzc2VjdXJpdHljcmVkZW50aWFsc3N1cHBsaWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLElBQUlBLHlCQUF5QixJQUFLLElBQUksSUFBSSxDQUFDQSxzQkFBc0IsSUFBSyxTQUFVQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxDQUFDO0lBQ3BHLElBQUlELFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9ILFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRSxJQUFJLENBQUNGLE1BQU1JLEdBQUcsQ0FBQ0wsV0FBVyxNQUFNLElBQUlJLFVBQVU7SUFDdkcsT0FBT0YsU0FBUyxNQUFNQyxJQUFJRCxTQUFTLE1BQU1DLEVBQUVHLElBQUksQ0FBQ04sWUFBWUcsSUFBSUEsRUFBRUksS0FBSyxHQUFHTixNQUFNTyxHQUFHLENBQUNSO0FBQ3hGO0FBQ0EsSUFBSVMsa0RBQWtEQyw4REFBOERDLHVEQUF1REMsdUVBQXVFQywwREFBMERDO0FBQzVTQyw4Q0FBNkM7SUFBRVIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RFUsNkNBQTZDLEdBQUcsS0FBSztBQUNyRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDLEdBQ0QsTUFBTUM7SUFDRjs7Ozs7S0FLQyxHQUNEQyxZQUFZQyxJQUFJLENBQUU7UUFDZFgsaURBQWlEWSxHQUFHLENBQUMsSUFBSTtRQUN6RCxJQUFJLENBQUNDLFNBQVMsR0FBR0YsS0FBS0UsU0FBUztRQUMvQixJQUFJLENBQUNDLHNCQUFzQixHQUFHSCxLQUFLRyxzQkFBc0I7UUFDekQsSUFBSSxDQUFDQyxxQkFBcUIsR0FBR0osS0FBS0kscUJBQXFCO1FBQ3ZELElBQUksQ0FBQ0MsdUJBQXVCLEdBQUdMLEtBQUtLLHVCQUF1QjtJQUMvRDtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTUMsYUFBYUMsT0FBTyxFQUFFO1FBQ3hCLDJDQUEyQztRQUMzQyxxREFBcUQ7UUFDckQsSUFBSTVCLHVCQUF1QixJQUFJLEVBQUVVLGtEQUFrRCxLQUFLSSwyREFBMkQ7WUFDL0ksT0FBT2QsdUJBQXVCLElBQUksRUFBRVUsa0RBQWtELEtBQUtJO1FBQy9GO1FBQ0EsTUFBTWUsa0JBQWtCLENBQUM7UUFDekIsSUFBSSxDQUFDN0IsdUJBQXVCLElBQUksRUFBRVUsa0RBQWtELEtBQUtJLDZEQUE2RCxJQUFJLENBQUNXLHFCQUFxQixFQUFFO1lBQzlLSSxlQUFlLENBQUMsMkJBQTJCLEdBQ3ZDLE1BQU03Qix1QkFBdUIsSUFBSSxFQUFFVSxrREFBa0QsS0FBS0MsOERBQThESixJQUFJLENBQUMsSUFBSSxFQUFFcUIsUUFBUUUsV0FBVztRQUM5TDtRQUNBLElBQUksQ0FBQyxJQUFJLENBQUNQLFNBQVMsRUFBRTtZQUNqQixNQUFNLElBQUlRLE1BQU0sbURBQ1o7UUFDUjtRQUNBLE1BQU1WLE9BQU87WUFDVCxHQUFHLElBQUksQ0FBQ0ssdUJBQXVCO1lBQy9CTSxLQUFLLElBQUksQ0FBQ1QsU0FBUztZQUNuQlUsUUFBUTtZQUNSQyxjQUFjO1lBQ2RDLFNBQVNOO1FBQ2I7UUFDQSxNQUFNTyxXQUFXLE1BQU1SLFFBQVFFLFdBQVcsQ0FBQ08sT0FBTyxDQUFDaEI7UUFDbkQsaUVBQWlFO1FBQ2pFLGlDQUFpQztRQUNqQyxPQUFPZSxTQUFTRSxJQUFJLENBQUNDLE1BQU0sQ0FBQyxHQUFHSCxTQUFTRSxJQUFJLENBQUNFLE1BQU0sR0FBRztJQUMxRDtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsTUFBTUMsMEJBQTBCYixPQUFPLEVBQUU7UUFDckMsK0RBQStEO1FBQy9ELHdFQUF3RTtRQUN4RSxJQUFJNUIsdUJBQXVCLElBQUksRUFBRVUsa0RBQWtELEtBQUtLLHdFQUF3RTtZQUM1SixPQUFPZix1QkFBdUIsSUFBSSxFQUFFVSxrREFBa0QsS0FBS0s7UUFDL0Y7UUFDQSxNQUFNYyxrQkFBa0IsQ0FBQztRQUN6QixJQUFJLElBQUksQ0FBQ0oscUJBQXFCLEVBQUU7WUFDNUJJLGVBQWUsQ0FBQywyQkFBMkIsR0FDdkMsTUFBTTdCLHVCQUF1QixJQUFJLEVBQUVVLGtEQUFrRCxLQUFLQyw4REFBOERKLElBQUksQ0FBQyxJQUFJLEVBQUVxQixRQUFRRSxXQUFXO1FBQzlMO1FBQ0EsZ0VBQWdFO1FBQ2hFLE1BQU1ZLFdBQVcsTUFBTTFDLHVCQUF1QixJQUFJLEVBQUVVLGtEQUFrRCxLQUFLRSx1REFBdURMLElBQUksQ0FBQyxJQUFJLEVBQUVzQixpQkFBaUJELFFBQVFFLFdBQVc7UUFDak4sMERBQTBEO1FBQzFELHNDQUFzQztRQUN0QyxpRUFBaUU7UUFDakUsa0NBQWtDO1FBQ2xDLE1BQU1hLFdBQVcsTUFBTTNDLHVCQUF1QixJQUFJLEVBQUVVLGtEQUFrRCxLQUFLRyx1RUFBdUVOLElBQUksQ0FBQyxJQUFJLEVBQUVtQyxVQUFVYixpQkFBaUJELFFBQVFFLFdBQVc7UUFDM08sT0FBTztZQUNIYyxhQUFhRCxTQUFTRSxXQUFXO1lBQ2pDQyxpQkFBaUJILFNBQVNJLGVBQWU7WUFDekNDLE9BQU9MLFNBQVNNLEtBQUs7UUFDekI7SUFDSjtBQUNKO0FBQ0EvQiw2Q0FBNkMsR0FBR0M7QUFDaERULG1EQUFtRCxJQUFJd0MsV0FBV3ZDLCtEQUNsRTs7O0NBR0MsR0FDRCxlQUFlQSw2REFBNkRtQixXQUFXO0lBQ25GLE1BQU1ULE9BQU87UUFDVCxHQUFHLElBQUksQ0FBQ0ssdUJBQXVCO1FBQy9CTSxLQUFLLElBQUksQ0FBQ1AscUJBQXFCO1FBQy9CUSxRQUFRO1FBQ1JDLGNBQWM7UUFDZEMsU0FBUztZQUFFLHdDQUF3QztRQUFNO0lBQzdEO0lBQ0EsTUFBTUMsV0FBVyxNQUFNTixZQUFZTyxPQUFPLENBQUNoQjtJQUMzQyxPQUFPZSxTQUFTRSxJQUFJO0FBQ3hCLEdBQUcxQix3REFDSDs7Ozs7Q0FLQyxHQUNELGVBQWVBLHNEQUFzRHVCLE9BQU8sRUFBRUwsV0FBVztJQUNyRixJQUFJLENBQUMsSUFBSSxDQUFDTixzQkFBc0IsRUFBRTtRQUM5QixNQUFNLElBQUlPLE1BQU0sc0RBQ1o7SUFDUjtJQUNBLE1BQU1WLE9BQU87UUFDVCxHQUFHLElBQUksQ0FBQ0ssdUJBQXVCO1FBQy9CTSxLQUFLLElBQUksQ0FBQ1Isc0JBQXNCO1FBQ2hDUyxRQUFRO1FBQ1JDLGNBQWM7UUFDZEMsU0FBU0E7SUFDYjtJQUNBLE1BQU1DLFdBQVcsTUFBTU4sWUFBWU8sT0FBTyxDQUFDaEI7SUFDM0MsT0FBT2UsU0FBU0UsSUFBSTtBQUN4QixHQUFHekIsd0VBQ0g7Ozs7Ozs7O0NBUUMsR0FDRCxlQUFlQSxzRUFBc0U2QixRQUFRLEVBQUVQLE9BQU8sRUFBRUwsV0FBVztJQUMvRyxNQUFNTSxXQUFXLE1BQU1OLFlBQVlPLE9BQU8sQ0FBQztRQUN2QyxHQUFHLElBQUksQ0FBQ1gsdUJBQXVCO1FBQy9CTSxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUNSLHNCQUFzQixDQUFDLENBQUMsRUFBRWtCLFNBQVMsQ0FBQztRQUNqRFIsY0FBYztRQUNkQyxTQUFTQTtJQUNiO0lBQ0EsT0FBT0MsU0FBU0UsSUFBSTtBQUN4QixHQUFHeEIsMkRBQTJELFNBQVNBO0lBQ25FLDJFQUEyRTtJQUMzRSx3QkFBd0I7SUFDeEIsT0FBUXFDLFFBQVFDLEdBQUcsQ0FBQyxhQUFhLElBQUlELFFBQVFDLEdBQUcsQ0FBQyxxQkFBcUIsSUFBSTtBQUM5RSxHQUFHckMsd0VBQXdFLFNBQVNBO0lBQ2hGLGlFQUFpRTtJQUNqRSxJQUFJb0MsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQixJQUNoQ0QsUUFBUUMsR0FBRyxDQUFDLHdCQUF3QixFQUFFO1FBQ3RDLE9BQU87WUFDSFIsYUFBYU8sUUFBUUMsR0FBRyxDQUFDLG9CQUFvQjtZQUM3Q04saUJBQWlCSyxRQUFRQyxHQUFHLENBQUMsd0JBQXdCO1lBQ3JESixPQUFPRyxRQUFRQyxHQUFHLENBQUMsb0JBQW9CO1FBQzNDO0lBQ0o7SUFDQSxPQUFPO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWNvbW1lbnRlci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2RlZmF1bHRhd3NzZWN1cml0eWNyZWRlbnRpYWxzc3VwcGxpZXIuanM/M2ViOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfaW5zdGFuY2VzLCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9nZXRJbWRzVjJTZXNzaW9uVG9rZW4sIF9EZWZhdWx0QXdzU2VjdXJpdHlDcmVkZW50aWFsc1N1cHBsaWVyX2dldEF3c1JvbGVOYW1lLCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9yZXRyaWV2ZUF3c1NlY3VyaXR5Q3JlZGVudGlhbHMsIF9EZWZhdWx0QXdzU2VjdXJpdHlDcmVkZW50aWFsc1N1cHBsaWVyX3JlZ2lvbkZyb21FbnZfZ2V0LCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9zZWN1cml0eUNyZWRlbnRpYWxzRnJvbUVudl9nZXQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXIgPSB2b2lkIDA7XG4vKipcbiAqIEludGVybmFsIEFXUyBzZWN1cml0eSBjcmVkZW50aWFscyBzdXBwbGllciBpbXBsZW1lbnRhdGlvbiB1c2VkIGJ5IHtAbGluayBBd3NDbGllbnR9XG4gKiB3aGVuIGEgY3JlZGVudGlhbCBzb3VyY2UgaXMgcHJvdmlkZWQgaW5zdGVhZCBvZiBhIHVzZXIgZGVmaW5lZCBzdXBwbGllci5cbiAqIFRoZSBsb2dpYyBpcyBzdW1tYXJpemVkIGFzOlxuICogMS4gSWYgaW1kc3YyX3Nlc3Npb25fdG9rZW5fdXJsIGlzIHByb3ZpZGVkIGluIHRoZSBjcmVkZW50aWFsIHNvdXJjZSwgdGhlblxuICogICAgZmV0Y2ggdGhlIGF3cyBzZXNzaW9uIHRva2VuIGFuZCBpbmNsdWRlIGl0IGluIHRoZSBoZWFkZXJzIG9mIHRoZVxuICogICAgbWV0YWRhdGEgcmVxdWVzdHMuIFRoaXMgaXMgYSByZXF1aXJlbWVudCBmb3IgSURNU3YyIGJ1dCBvcHRpb25hbFxuICogICAgZm9yIElETVN2MS5cbiAqIDIuIFJldHJpZXZlIEFXUyByZWdpb24gZnJvbSBhdmFpbGFiaWxpdHktem9uZS5cbiAqIDNhLiBDaGVjayBBV1MgY3JlZGVudGlhbHMgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLiBJZiBub3QgZm91bmQsIGdldFxuICogICAgIGZyb20gc2VjdXJpdHktY3JlZGVudGlhbHMgZW5kcG9pbnQuXG4gKiAzYi4gR2V0IEFXUyBjcmVkZW50aWFscyBmcm9tIHNlY3VyaXR5LWNyZWRlbnRpYWxzIGVuZHBvaW50LiBJbiBvcmRlclxuICogICAgIHRvIHJldHJpZXZlIHRoaXMsIHRoZSBBV1Mgcm9sZSBuZWVkcyB0byBiZSBkZXRlcm1pbmVkIGJ5IGNhbGxpbmdcbiAqICAgICBzZWN1cml0eS1jcmVkZW50aWFscyBlbmRwb2ludCB3aXRob3V0IGFueSBhcmd1bWVudC4gVGhlbiB0aGVcbiAqICAgICBjcmVkZW50aWFscyBjYW4gYmUgcmV0cmlldmVkIHZpYTogc2VjdXJpdHktY3JlZGVudGlhbHMvcm9sZV9uYW1lXG4gKiA0LiBHZW5lcmF0ZSB0aGUgc2lnbmVkIHJlcXVlc3QgdG8gQVdTIFNUUyBHZXRDYWxsZXJJZGVudGl0eSBhY3Rpb24uXG4gKiA1LiBJbmplY3QgeC1nb29nLWNsb3VkLXRhcmdldC1yZXNvdXJjZSBpbnRvIGhlYWRlciBhbmQgc2VyaWFsaXplIHRoZVxuICogICAgc2lnbmVkIHJlcXVlc3QuIFRoaXMgd2lsbCBiZSB0aGUgc3ViamVjdC10b2tlbiB0byBwYXNzIHRvIEdDUCBTVFMuXG4gKi9cbmNsYXNzIERlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXIge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIG5ldyBEZWZhdWx0QXdzU2VjdXJpdHlDcmVkZW50aWFsc1N1cHBsaWVyIHVzaW5nIGluZm9ybWF0aW9uXG4gICAgICogZnJvbSB0aGUgY3JlZGVudGlhbF9zb3VyY2Ugc3RvcmVkIGluIHRoZSBBREMgZmlsZS5cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgZGVmYXVsdCBhd3Mgc2VjdXJpdHkgY3JlZGVudGlhbHMgc3VwcGxpZXIgb3B0aW9ucyBvYmplY3QgdG9cbiAgICAgKiAgIGJ1aWxkIHRoZSBzdXBwbGllciB3aXRoLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWdpb25VcmwgPSBvcHRzLnJlZ2lvblVybDtcbiAgICAgICAgdGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzVXJsID0gb3B0cy5zZWN1cml0eUNyZWRlbnRpYWxzVXJsO1xuICAgICAgICB0aGlzLmltZHNWMlNlc3Npb25Ub2tlblVybCA9IG9wdHMuaW1kc1YyU2Vzc2lvblRva2VuVXJsO1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxHYXhpb3NPcHRpb25zID0gb3B0cy5hZGRpdGlvbmFsR2F4aW9zT3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWN0aXZlIEFXUyByZWdpb24uIFRoaXMgZmlyc3QgY2hlY2tzIHRvIHNlZSBpZiB0aGUgcmVnaW9uXG4gICAgICogaXMgYXZhaWxhYmxlIGFzIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLiBJZiBpdCBpcyBub3QsIHRoZW4gdGhlIHN1cHBsaWVyXG4gICAgICogd2lsbCBjYWxsIHRoZSByZWdpb24gVVJMLlxuICAgICAqIEBwYXJhbSBjb250ZXh0IHtAbGluayBFeHRlcm5hbEFjY291bnRTdXBwbGllckNvbnRleHR9IGZyb20gdGhlIGNhbGxpbmdcbiAgICAgKiAgIHtAbGluayBBd3NDbGllbnR9LCBjb250YWlucyB0aGUgcmVxdWVzdGVkIGF1ZGllbmNlIGFuZCBzdWJqZWN0IHRva2VuIHR5cGVcbiAgICAgKiAgIGZvciB0aGUgZXh0ZXJuYWwgYWNjb3VudCBpZGVudGl0eS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEFXUyByZWdpb24gc3RyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEF3c1JlZ2lvbihjb250ZXh0KSB7XG4gICAgICAgIC8vIFByaW9yaXR5IG9yZGVyIGZvciByZWdpb24gZGV0ZXJtaW5hdGlvbjpcbiAgICAgICAgLy8gQVdTX1JFR0lPTiA+IEFXU19ERUZBVUxUX1JFR0lPTiA+IG1ldGFkYXRhIHNlcnZlci5cbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfaW5zdGFuY2VzLCBcImFcIiwgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfcmVnaW9uRnJvbUVudl9nZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9pbnN0YW5jZXMsIFwiYVwiLCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9yZWdpb25Gcm9tRW52X2dldCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YWRhdGFIZWFkZXJzID0ge307XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9pbnN0YW5jZXMsIFwiYVwiLCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9yZWdpb25Gcm9tRW52X2dldCkgJiYgdGhpcy5pbWRzVjJTZXNzaW9uVG9rZW5VcmwpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhSGVhZGVyc1sneC1hd3MtZWMyLW1ldGFkYXRhLXRva2VuJ10gPVxuICAgICAgICAgICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfZ2V0SW1kc1YyU2Vzc2lvblRva2VuKS5jYWxsKHRoaXMsIGNvbnRleHQudHJhbnNwb3J0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yZWdpb25VcmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRldGVybWluZSBBV1MgcmVnaW9uIGR1ZSB0byBtaXNzaW5nICcgK1xuICAgICAgICAgICAgICAgICdcIm9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UucmVnaW9uX3VybFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuYWRkaXRpb25hbEdheGlvc09wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IHRoaXMucmVnaW9uVXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgaGVhZGVyczogbWV0YWRhdGFIZWFkZXJzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvbnRleHQudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgLy8gUmVtb3ZlIGxhc3QgY2hhcmFjdGVyLiBGb3IgZXhhbXBsZSwgaWYgdXMtZWFzdC0yYiBpcyByZXR1cm5lZCxcbiAgICAgICAgLy8gdGhlIHJlZ2lvbiB3b3VsZCBiZSB1cy1lYXN0LTIuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLnN1YnN0cigwLCByZXNwb25zZS5kYXRhLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEFXUyBzZWN1cml0eSBjcmVkZW50aWFscy4gVGhpcyBmaXJzdCBjaGVja3MgdG8gc2VlIGlmIHRoZSBjcmVkZW50aWFsc1xuICAgICAqIGlzIGF2YWlsYWJsZSBhcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuIElmIGl0IGlzIG5vdCwgdGhlbiB0aGUgc3VwcGxpZXJcbiAgICAgKiB3aWxsIGNhbGwgdGhlIHNlY3VyaXR5IGNyZWRlbnRpYWxzIFVSTC5cbiAgICAgKiBAcGFyYW0gY29udGV4dCB7QGxpbmsgRXh0ZXJuYWxBY2NvdW50U3VwcGxpZXJDb250ZXh0fSBmcm9tIHRoZSBjYWxsaW5nXG4gICAgICogICB7QGxpbmsgQXdzQ2xpZW50fSwgY29udGFpbnMgdGhlIHJlcXVlc3RlZCBhdWRpZW5jZSBhbmQgc3ViamVjdCB0b2tlbiB0eXBlXG4gICAgICogICBmb3IgdGhlIGV4dGVybmFsIGFjY291bnQgaWRlbnRpdHkuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBBV1Mgc2VjdXJpdHkgY3JlZGVudGlhbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXdzU2VjdXJpdHlDcmVkZW50aWFscyhjb250ZXh0KSB7XG4gICAgICAgIC8vIENoZWNrIGVudmlyb25tZW50IHZhcmlhYmxlcyBmb3IgcGVybWFuZW50IGNyZWRlbnRpYWxzIGZpcnN0LlxuICAgICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2VuZXJhbC9sYXRlc3QvZ3IvYXdzLXNlYy1jcmVkLXR5cGVzLmh0bWxcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfaW5zdGFuY2VzLCBcImFcIiwgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfc2VjdXJpdHlDcmVkZW50aWFsc0Zyb21FbnZfZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfaW5zdGFuY2VzLCBcImFcIiwgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfc2VjdXJpdHlDcmVkZW50aWFsc0Zyb21FbnZfZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhZGF0YUhlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuaW1kc1YyU2Vzc2lvblRva2VuVXJsKSB7XG4gICAgICAgICAgICBtZXRhZGF0YUhlYWRlcnNbJ3gtYXdzLWVjMi1tZXRhZGF0YS10b2tlbiddID1cbiAgICAgICAgICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9EZWZhdWx0QXdzU2VjdXJpdHlDcmVkZW50aWFsc1N1cHBsaWVyX2luc3RhbmNlcywgXCJtXCIsIF9EZWZhdWx0QXdzU2VjdXJpdHlDcmVkZW50aWFsc1N1cHBsaWVyX2dldEltZHNWMlNlc3Npb25Ub2tlbikuY2FsbCh0aGlzLCBjb250ZXh0LnRyYW5zcG9ydGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSB0aGUgcm9sZSBvbiBhIFZNIGNhbiBjaGFuZ2UsIHdlIGRvbid0IG5lZWQgdG8gY2FjaGUgaXQuXG4gICAgICAgIGNvbnN0IHJvbGVOYW1lID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9pbnN0YW5jZXMsIFwibVwiLCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9nZXRBd3NSb2xlTmFtZSkuY2FsbCh0aGlzLCBtZXRhZGF0YUhlYWRlcnMsIGNvbnRleHQudHJhbnNwb3J0ZXIpO1xuICAgICAgICAvLyBUZW1wb3JhcnkgY3JlZGVudGlhbHMgdHlwaWNhbGx5IGxhc3QgZm9yIHNldmVyYWwgaG91cnMuXG4gICAgICAgIC8vIEV4cGlyYXRpb24gaXMgcmV0dXJuZWQgaW4gcmVzcG9uc2UuXG4gICAgICAgIC8vIENvbnNpZGVyIGZ1dHVyZSBvcHRpbWl6YXRpb24gb2YgdGhpcyBsb2dpYyB0byBjYWNoZSBBV1MgdG9rZW5zXG4gICAgICAgIC8vIHVudGlsIHRoZWlyIG5hdHVyYWwgZXhwaXJhdGlvbi5cbiAgICAgICAgY29uc3QgYXdzQ3JlZHMgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9EZWZhdWx0QXdzU2VjdXJpdHlDcmVkZW50aWFsc1N1cHBsaWVyX2luc3RhbmNlcywgXCJtXCIsIF9EZWZhdWx0QXdzU2VjdXJpdHlDcmVkZW50aWFsc1N1cHBsaWVyX3JldHJpZXZlQXdzU2VjdXJpdHlDcmVkZW50aWFscykuY2FsbCh0aGlzLCByb2xlTmFtZSwgbWV0YWRhdGFIZWFkZXJzLCBjb250ZXh0LnRyYW5zcG9ydGVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY2Vzc0tleUlkOiBhd3NDcmVkcy5BY2Nlc3NLZXlJZCxcbiAgICAgICAgICAgIHNlY3JldEFjY2Vzc0tleTogYXdzQ3JlZHMuU2VjcmV0QWNjZXNzS2V5LFxuICAgICAgICAgICAgdG9rZW46IGF3c0NyZWRzLlRva2VuLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllciA9IERlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXI7XG5fRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9nZXRJbWRzVjJTZXNzaW9uVG9rZW4gPSBcbi8qKlxuICogQHBhcmFtIHRyYW5zcG9ydGVyIFRoZSB0cmFuc3BvcnRlciB0byB1c2UgZm9yIHJlcXVlc3RzLlxuICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBJTURTdjIgU2Vzc2lvbiBUb2tlbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfZ2V0SW1kc1YyU2Vzc2lvblRva2VuKHRyYW5zcG9ydGVyKSB7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgLi4udGhpcy5hZGRpdGlvbmFsR2F4aW9zT3B0aW9ucyxcbiAgICAgICAgdXJsOiB0aGlzLmltZHNWMlNlc3Npb25Ub2tlblVybCxcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ3gtYXdzLWVjMi1tZXRhZGF0YS10b2tlbi10dGwtc2Vjb25kcyc6ICczMDAnIH0sXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59LCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9nZXRBd3NSb2xlTmFtZSA9IFxuLyoqXG4gKiBAcGFyYW0gaGVhZGVycyBUaGUgaGVhZGVycyB0byBiZSB1c2VkIGluIHRoZSBtZXRhZGF0YSByZXF1ZXN0LlxuICogQHBhcmFtIHRyYW5zcG9ydGVyIFRoZSB0cmFuc3BvcnRlciB0byB1c2UgZm9yIHJlcXVlc3RzLlxuICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBhc3NpZ25lZCByb2xlIHRvIHRoZSBjdXJyZW50XG4gKiAgIEFXUyBWTS4gVGhpcyBpcyBuZWVkZWQgZm9yIGNhbGxpbmcgdGhlIHNlY3VyaXR5LWNyZWRlbnRpYWxzIGVuZHBvaW50LlxuICovXG5hc3luYyBmdW5jdGlvbiBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9nZXRBd3NSb2xlTmFtZShoZWFkZXJzLCB0cmFuc3BvcnRlcikge1xuICAgIGlmICghdGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzVXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRldGVybWluZSBBV1Mgcm9sZSBuYW1lIGR1ZSB0byBtaXNzaW5nICcgK1xuICAgICAgICAgICAgJ1wib3B0aW9ucy5jcmVkZW50aWFsX3NvdXJjZS51cmxcIicpO1xuICAgIH1cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAuLi50aGlzLmFkZGl0aW9uYWxHYXhpb3NPcHRpb25zLFxuICAgICAgICB1cmw6IHRoaXMuc2VjdXJpdHlDcmVkZW50aWFsc1VybCxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59LCBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9yZXRyaWV2ZUF3c1NlY3VyaXR5Q3JlZGVudGlhbHMgPSBcbi8qKlxuICogUmV0cmlldmVzIHRoZSB0ZW1wb3JhcnkgQVdTIGNyZWRlbnRpYWxzIGJ5IGNhbGxpbmcgdGhlIHNlY3VyaXR5LWNyZWRlbnRpYWxzXG4gKiBlbmRwb2ludCBhcyBzcGVjaWZpZWQgaW4gdGhlIGBjcmVkZW50aWFsX3NvdXJjZWAgb2JqZWN0LlxuICogQHBhcmFtIHJvbGVOYW1lIFRoZSByb2xlIGF0dGFjaGVkIHRvIHRoZSBjdXJyZW50IFZNLlxuICogQHBhcmFtIGhlYWRlcnMgVGhlIGhlYWRlcnMgdG8gYmUgdXNlZCBpbiB0aGUgbWV0YWRhdGEgcmVxdWVzdC5cbiAqIEBwYXJhbSB0cmFuc3BvcnRlciBUaGUgdHJhbnNwb3J0ZXIgdG8gdXNlIGZvciByZXF1ZXN0cy5cbiAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdGVtcG9yYXJ5IEFXUyBjcmVkZW50aWFsc1xuICogICBuZWVkZWQgZm9yIGNyZWF0aW5nIHRoZSBHZXRDYWxsZXJJZGVudGl0eSBzaWduZWQgcmVxdWVzdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfcmV0cmlldmVBd3NTZWN1cml0eUNyZWRlbnRpYWxzKHJvbGVOYW1lLCBoZWFkZXJzLCB0cmFuc3BvcnRlcikge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdHJhbnNwb3J0ZXIucmVxdWVzdCh7XG4gICAgICAgIC4uLnRoaXMuYWRkaXRpb25hbEdheGlvc09wdGlvbnMsXG4gICAgICAgIHVybDogYCR7dGhpcy5zZWN1cml0eUNyZWRlbnRpYWxzVXJsfS8ke3JvbGVOYW1lfWAsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xufSwgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfcmVnaW9uRnJvbUVudl9nZXQgPSBmdW5jdGlvbiBfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9yZWdpb25Gcm9tRW52X2dldCgpIHtcbiAgICAvLyBUaGUgQVdTIHJlZ2lvbiBjYW4gYmUgcHJvdmlkZWQgdGhyb3VnaCBBV1NfUkVHSU9OIG9yIEFXU19ERUZBVUxUX1JFR0lPTi5cbiAgICAvLyBPbmx5IG9uZSBpcyByZXF1aXJlZC5cbiAgICByZXR1cm4gKHByb2Nlc3MuZW52WydBV1NfUkVHSU9OJ10gfHwgcHJvY2Vzcy5lbnZbJ0FXU19ERUZBVUxUX1JFR0lPTiddIHx8IG51bGwpO1xufSwgX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfc2VjdXJpdHlDcmVkZW50aWFsc0Zyb21FbnZfZ2V0ID0gZnVuY3Rpb24gX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfc2VjdXJpdHlDcmVkZW50aWFsc0Zyb21FbnZfZ2V0KCkge1xuICAgIC8vIEJvdGggQVdTX0FDQ0VTU19LRVlfSUQgYW5kIEFXU19TRUNSRVRfQUNDRVNTX0tFWSBhcmUgcmVxdWlyZWQuXG4gICAgaWYgKHByb2Nlc3MuZW52WydBV1NfQUNDRVNTX0tFWV9JRCddICYmXG4gICAgICAgIHByb2Nlc3MuZW52WydBV1NfU0VDUkVUX0FDQ0VTU19LRVknXSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWNjZXNzS2V5SWQ6IHByb2Nlc3MuZW52WydBV1NfQUNDRVNTX0tFWV9JRCddLFxuICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiBwcm9jZXNzLmVudlsnQVdTX1NFQ1JFVF9BQ0NFU1NfS0VZJ10sXG4gICAgICAgICAgICB0b2tlbjogcHJvY2Vzcy5lbnZbJ0FXU19TRVNTSU9OX1RPS0VOJ10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbiJdLCJuYW1lcyI6WyJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwicmVjZWl2ZXIiLCJzdGF0ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInZhbHVlIiwiZ2V0IiwiX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfaW5zdGFuY2VzIiwiX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfZ2V0SW1kc1YyU2Vzc2lvblRva2VuIiwiX0RlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXJfZ2V0QXdzUm9sZU5hbWUiLCJfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9yZXRyaWV2ZUF3c1NlY3VyaXR5Q3JlZGVudGlhbHMiLCJfRGVmYXVsdEF3c1NlY3VyaXR5Q3JlZGVudGlhbHNTdXBwbGllcl9yZWdpb25Gcm9tRW52X2dldCIsIl9EZWZhdWx0QXdzU2VjdXJpdHlDcmVkZW50aWFsc1N1cHBsaWVyX3NlY3VyaXR5Q3JlZGVudGlhbHNGcm9tRW52X2dldCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsIkRlZmF1bHRBd3NTZWN1cml0eUNyZWRlbnRpYWxzU3VwcGxpZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJhZGQiLCJyZWdpb25VcmwiLCJzZWN1cml0eUNyZWRlbnRpYWxzVXJsIiwiaW1kc1YyU2Vzc2lvblRva2VuVXJsIiwiYWRkaXRpb25hbEdheGlvc09wdGlvbnMiLCJnZXRBd3NSZWdpb24iLCJjb250ZXh0IiwibWV0YWRhdGFIZWFkZXJzIiwidHJhbnNwb3J0ZXIiLCJFcnJvciIsInVybCIsIm1ldGhvZCIsInJlc3BvbnNlVHlwZSIsImhlYWRlcnMiLCJyZXNwb25zZSIsInJlcXVlc3QiLCJkYXRhIiwic3Vic3RyIiwibGVuZ3RoIiwiZ2V0QXdzU2VjdXJpdHlDcmVkZW50aWFscyIsInJvbGVOYW1lIiwiYXdzQ3JlZHMiLCJhY2Nlc3NLZXlJZCIsIkFjY2Vzc0tleUlkIiwic2VjcmV0QWNjZXNzS2V5IiwiU2VjcmV0QWNjZXNzS2V5IiwidG9rZW4iLCJUb2tlbiIsIldlYWtTZXQiLCJwcm9jZXNzIiwiZW52Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/downscopedclient.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst sts = __webpack_require__(/*! ./stscredentials */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */ const STS_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\";\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */ const STS_REQUEST_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\";\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */ const STS_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\";\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */ exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */ exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */ class DownscopedClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates a downscoped client object using the provided source\n     * AuthClient and credential access boundary rules.\n     * To downscope permissions of a source AuthClient, a Credential Access\n     * Boundary that specifies which resources the new credential can access, as\n     * well as an upper bound on the permissions that are available on each\n     * resource, has to be defined. A downscoped client can then be instantiated\n     * using the source AuthClient and the Credential Access Boundary.\n     * @param authClient The source AuthClient to be downscoped based on the\n     *   provided Credential Access Boundary rules.\n     * @param credentialAccessBoundary The Credential Access Boundary which\n     *   contains a list of access boundary rules. Each rule contains information\n     *   on the resource that the rule applies to, the upper bound of the\n     *   permissions that are available on that resource and an optional\n     *   condition to further restrict permissions.\n     * @param additionalOptions **DEPRECATED, set this in the provided `authClient`.**\n     *   Optional additional behavior customization options.\n     * @param quotaProjectId **DEPRECATED, set this in the provided `authClient`.**\n     *   Optional quota project id for setting up in the x-goog-user-project header.\n     */ constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId){\n        super({\n            ...additionalOptions,\n            quotaProjectId\n        });\n        this.authClient = authClient;\n        this.credentialAccessBoundary = credentialAccessBoundary;\n        // Check 1-10 Access Boundary Rules are defined within Credential Access\n        // Boundary.\n        if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n            throw new Error(\"At least one access boundary rule needs to be defined.\");\n        } else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n            throw new Error(\"The provided access boundary has more than \" + `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\n        }\n        // Check at least one permission should be defined in each Access Boundary\n        // Rule.\n        for (const rule of credentialAccessBoundary.accessBoundary.accessBoundaryRules){\n            if (rule.availablePermissions.length === 0) {\n                throw new Error(\"At least one permission should be defined in access boundary rules.\");\n            }\n        }\n        this.stsCredential = new sts.StsCredentials(`https://sts.${this.universeDomain}/v1/token`);\n        this.cachedDownscopedAccessToken = null;\n    }\n    /**\n     * Provides a mechanism to inject Downscoped access tokens directly.\n     * The expiry_date field is required to facilitate determination of the token\n     * expiration which would make it easier for the token consumer to handle.\n     * @param credentials The Credentials object to set on the current client.\n     */ setCredentials(credentials) {\n        if (!credentials.expiry_date) {\n            throw new Error(\"The access token expiry_date field is missing in the provided \" + \"credentials.\");\n        }\n        super.setCredentials(credentials);\n        this.cachedDownscopedAccessToken = credentials;\n    }\n    async getAccessToken() {\n        // If the cached access token is unavailable or expired, force refresh.\n        // The Downscoped access token will be returned in\n        // DownscopedAccessTokenResponse format.\n        if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return Downscoped access token in DownscopedAccessTokenResponse format.\n        return {\n            token: this.cachedDownscopedAccessToken.access_token,\n            expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n            res: this.cachedDownscopedAccessToken.res\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */ async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure\n     * @return A promise that resolves with the successful response.\n     */ async requestAsync(opts, reAuthRetried = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = requestHeaders[\"x-goog-user-project\"];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Then GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */ async refreshAccessTokenAsync() {\n        var _a;\n        // Retrieve GCP access token from source credential.\n        const subjectToken = (await this.authClient.getAccessToken()).token;\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken: subjectToken,\n            subjectTokenType: STS_SUBJECT_TOKEN_TYPE\n        };\n        // Exchange the source AuthClient access token for a Downscoped access\n        // token.\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n        /**\n         * The STS endpoint will only return the expiration time for the downscoped\n         * access token if the original access token represents a service account.\n         * The downscoped token's expiration time will always match the source\n         * credential expiration. When no expires_in is returned, we can copy the\n         * source credential's expiration time.\n         */ const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n        const expiryDate = stsResponse.expires_in ? new Date().getTime() + stsResponse.expires_in * 1000 : sourceCredExpireDate;\n        // Save response in cached access token.\n        this.cachedDownscopedAccessToken = {\n            access_token: stsResponse.access_token,\n            expiry_date: expiryDate,\n            res: stsResponse.res\n        };\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit(\"tokens\", {\n            refresh_token: null,\n            expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n            access_token: this.cachedDownscopedAccessToken.access_token,\n            token_type: \"Bearer\",\n            id_token: null\n        });\n        // Return the cached access token.\n        return this.cachedDownscopedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */ isExpired(downscopedAccessToken) {\n        const now = new Date().getTime();\n        return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n}\nexports.DownscopedClient = DownscopedClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9kb3duc2NvcGVkY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUdBLDhCQUE4QixHQUFHQSx1Q0FBdUMsR0FBRyxLQUFLO0FBQzNHLE1BQU1LLFNBQVNDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQy9CLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLDJGQUFjO0FBQzNDLE1BQU1FLE1BQU1GLG1CQUFPQSxDQUFDLG1HQUFrQjtBQUN0Qzs7Q0FFQyxHQUNELE1BQU1HLGlCQUFpQjtBQUN2Qjs7Q0FFQyxHQUNELE1BQU1DLHlCQUF5QjtBQUMvQjs7Q0FFQyxHQUNELE1BQU1DLHlCQUF5QjtBQUMvQjs7O0NBR0MsR0FDRFgsdUNBQXVDLEdBQUc7QUFDMUM7O0NBRUMsR0FDREEsOEJBQThCLEdBQUcsSUFBSSxLQUFLO0FBQzFDOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU1FLHlCQUF5QkssYUFBYUssVUFBVTtJQUNsRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQW1CQyxHQUNEQyxZQUFZQyxVQUFVLEVBQUVDLHdCQUF3QixFQUFFQyxpQkFBaUIsRUFBRUMsY0FBYyxDQUFFO1FBQ2pGLEtBQUssQ0FBQztZQUFFLEdBQUdELGlCQUFpQjtZQUFFQztRQUFlO1FBQzdDLElBQUksQ0FBQ0gsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLHdCQUF3QixHQUFHQTtRQUNoQyx3RUFBd0U7UUFDeEUsWUFBWTtR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QUFDZSxXQUFXLE1BQU0sUUFBUWlDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2hDLFdBQVcsS0FBSztRQUN6SCxNQUFNMEMsYUFBYUosWUFBWUssVUFBVSxHQUNuQyxJQUFJQyxPQUFPQyxPQUFPLEtBQUtQLFlBQVlLLFVBQVUsR0FBRyxPQUNoREY7UUFDTix3Q0FBd0M7UUFDeEMsSUFBSSxDQUFDNUMsMkJBQTJCLEdBQUc7WUFDL0JRLGNBQWNpQyxZQUFZakMsWUFBWTtZQUN0Q0wsYUFBYTBDO1lBQ2JuQyxLQUFLK0IsWUFBWS9CLEdBQUc7UUFDeEI7UUFDQSxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDUixXQUFXLEdBQUcsQ0FBQztRQUNwQi9CLE9BQU84RSxNQUFNLENBQUMsSUFBSSxDQUFDL0MsV0FBVyxFQUFFLElBQUksQ0FBQ0YsMkJBQTJCO1FBQ2hFLE9BQU8sSUFBSSxDQUFDRSxXQUFXLENBQUNRLEdBQUc7UUFDM0IscURBQXFEO1FBQ3JELElBQUksQ0FBQ3dDLElBQUksQ0FBQyxVQUFVO1lBQ2hCQyxlQUFlO1lBQ2ZoRCxhQUFhLElBQUksQ0FBQ0gsMkJBQTJCLENBQUNHLFdBQVc7WUFDekRLLGNBQWMsSUFBSSxDQUFDUiwyQkFBMkIsQ0FBQ1EsWUFBWTtZQUMzRDRDLFlBQVk7WUFDWkMsVUFBVTtRQUNkO1FBQ0Esa0NBQWtDO1FBQ2xDLE9BQU8sSUFBSSxDQUFDckQsMkJBQTJCO0lBQzNDO0lBQ0E7Ozs7O0tBS0MsR0FDREssVUFBVWlELHFCQUFxQixFQUFFO1FBQzdCLE1BQU1DLE1BQU0sSUFBSVIsT0FBT0MsT0FBTztRQUM5QixPQUFPTSxzQkFBc0JuRCxXQUFXLEdBQ2xDb0QsT0FDRUQsc0JBQXNCbkQsV0FBVyxHQUFHLElBQUksQ0FBQ3FELDJCQUEyQixHQUN0RTtJQUNWO0FBQ0o7QUFDQW5GLHdCQUF3QixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZG93bnNjb3BlZGNsaWVudC5qcz84Yjk4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRvd25zY29wZWRDbGllbnQgPSBleHBvcnRzLkVYUElSQVRJT05fVElNRV9PRkZTRVQgPSBleHBvcnRzLk1BWF9BQ0NFU1NfQk9VTkRBUllfUlVMRVNfQ09VTlQgPSB2b2lkIDA7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aGNsaWVudFwiKTtcbmNvbnN0IHN0cyA9IHJlcXVpcmUoXCIuL3N0c2NyZWRlbnRpYWxzXCIpO1xuLyoqXG4gKiBUaGUgcmVxdWlyZWQgdG9rZW4gZXhjaGFuZ2UgZ3JhbnRfdHlwZTogcmZjODY5MyNzZWN0aW9uLTIuMVxuICovXG5jb25zdCBTVFNfR1JBTlRfVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6Z3JhbnQtdHlwZTp0b2tlbi1leGNoYW5nZSc7XG4vKipcbiAqIFRoZSByZXF1ZXN0ZWQgdG9rZW4gZXhjaGFuZ2UgcmVxdWVzdGVkX3Rva2VuX3R5cGU6IHJmYzg2OTMjc2VjdGlvbi0yLjFcbiAqL1xuY29uc3QgU1RTX1JFUVVFU1RfVE9LRU5fVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTphY2Nlc3NfdG9rZW4nO1xuLyoqXG4gKiBUaGUgcmVxdWVzdGVkIHRva2VuIGV4Y2hhbmdlIHN1YmplY3RfdG9rZW5fdHlwZTogcmZjODY5MyNzZWN0aW9uLTIuMVxuICovXG5jb25zdCBTVFNfU1VCSkVDVF9UT0tFTl9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOmFjY2Vzc190b2tlbic7XG4vKipcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhY2Nlc3MgYm91bmRhcnkgcnVsZXMgYSBDcmVkZW50aWFsIEFjY2VzcyBCb3VuZGFyeVxuICogY2FuIGNvbnRhaW4uXG4gKi9cbmV4cG9ydHMuTUFYX0FDQ0VTU19CT1VOREFSWV9SVUxFU19DT1VOVCA9IDEwO1xuLyoqXG4gKiBPZmZzZXQgdG8gdGFrZSBpbnRvIGFjY291bnQgbmV0d29yayBkZWxheXMgYW5kIHNlcnZlciBjbG9jayBza2V3cy5cbiAqL1xuZXhwb3J0cy5FWFBJUkFUSU9OX1RJTUVfT0ZGU0VUID0gNSAqIDYwICogMTAwMDtcbi8qKlxuICogRGVmaW5lcyBhIHNldCBvZiBHb29nbGUgY3JlZGVudGlhbHMgdGhhdCBhcmUgZG93bnNjb3BlZCBmcm9tIGFuIGV4aXN0aW5nIHNldFxuICogb2YgR29vZ2xlIE9BdXRoMiBjcmVkZW50aWFscy4gVGhpcyBpcyB1c2VmdWwgdG8gcmVzdHJpY3QgdGhlIElkZW50aXR5IGFuZFxuICogQWNjZXNzIE1hbmFnZW1lbnQgKElBTSkgcGVybWlzc2lvbnMgdGhhdCBhIHNob3J0LWxpdmVkIGNyZWRlbnRpYWwgY2FuIHVzZS5cbiAqIFRoZSBjb21tb24gcGF0dGVybiBvZiB1c2FnZSBpcyB0byBoYXZlIGEgdG9rZW4gYnJva2VyIHdpdGggZWxldmF0ZWQgYWNjZXNzXG4gKiBnZW5lcmF0ZSB0aGVzZSBkb3duc2NvcGVkIGNyZWRlbnRpYWxzIGZyb20gaGlnaGVyIGFjY2VzcyBzb3VyY2UgY3JlZGVudGlhbHNcbiAqIGFuZCBwYXNzIHRoZSBkb3duc2NvcGVkIHNob3J0LWxpdmVkIGFjY2VzcyB0b2tlbnMgdG8gYSB0b2tlbiBjb25zdW1lciB2aWFcbiAqIHNvbWUgc2VjdXJlIGF1dGhlbnRpY2F0ZWQgY2hhbm5lbCBmb3IgbGltaXRlZCBhY2Nlc3MgdG8gR29vZ2xlIENsb3VkIFN0b3JhZ2VcbiAqIHJlc291cmNlcy5cbiAqL1xuY2xhc3MgRG93bnNjb3BlZENsaWVudCBleHRlbmRzIGF1dGhjbGllbnRfMS5BdXRoQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYSBkb3duc2NvcGVkIGNsaWVudCBvYmplY3QgdXNpbmcgdGhlIHByb3ZpZGVkIHNvdXJjZVxuICAgICAqIEF1dGhDbGllbnQgYW5kIGNyZWRlbnRpYWwgYWNjZXNzIGJvdW5kYXJ5IHJ1bGVzLlxuICAgICAqIFRvIGRvd25zY29wZSBwZXJtaXNzaW9ucyBvZiBhIHNvdXJjZSBBdXRoQ2xpZW50LCBhIENyZWRlbnRpYWwgQWNjZXNzXG4gICAgICogQm91bmRhcnkgdGhhdCBzcGVjaWZpZXMgd2hpY2ggcmVzb3VyY2VzIHRoZSBuZXcgY3JlZGVudGlhbCBjYW4gYWNjZXNzLCBhc1xuICAgICAqIHdlbGwgYXMgYW4gdXBwZXIgYm91bmQgb24gdGhlIHBlcm1pc3Npb25zIHRoYXQgYXJlIGF2YWlsYWJsZSBvbiBlYWNoXG4gICAgICogcmVzb3VyY2UsIGhhcyB0byBiZSBkZWZpbmVkLiBBIGRvd25zY29wZWQgY2xpZW50IGNhbiB0aGVuIGJlIGluc3RhbnRpYXRlZFxuICAgICAqIHVzaW5nIHRoZSBzb3VyY2UgQXV0aENsaWVudCBhbmQgdGhlIENyZWRlbnRpYWwgQWNjZXNzIEJvdW5kYXJ5LlxuICAgICAqIEBwYXJhbSBhdXRoQ2xpZW50IFRoZSBzb3VyY2UgQXV0aENsaWVudCB0byBiZSBkb3duc2NvcGVkIGJhc2VkIG9uIHRoZVxuICAgICAqICAgcHJvdmlkZWQgQ3JlZGVudGlhbCBBY2Nlc3MgQm91bmRhcnkgcnVsZXMuXG4gICAgICogQHBhcmFtIGNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeSBUaGUgQ3JlZGVudGlhbCBBY2Nlc3MgQm91bmRhcnkgd2hpY2hcbiAgICAgKiAgIGNvbnRhaW5zIGEgbGlzdCBvZiBhY2Nlc3MgYm91bmRhcnkgcnVsZXMuIEVhY2ggcnVsZSBjb250YWlucyBpbmZvcm1hdGlvblxuICAgICAqICAgb24gdGhlIHJlc291cmNlIHRoYXQgdGhlIHJ1bGUgYXBwbGllcyB0bywgdGhlIHVwcGVyIGJvdW5kIG9mIHRoZVxuICAgICAqICAgcGVybWlzc2lvbnMgdGhhdCBhcmUgYXZhaWxhYmxlIG9uIHRoYXQgcmVzb3VyY2UgYW5kIGFuIG9wdGlvbmFsXG4gICAgICogICBjb25kaXRpb24gdG8gZnVydGhlciByZXN0cmljdCBwZXJtaXNzaW9ucy5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnMgKipERVBSRUNBVEVELCBzZXQgdGhpcyBpbiB0aGUgcHJvdmlkZWQgYGF1dGhDbGllbnRgLioqXG4gICAgICogICBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gcXVvdGFQcm9qZWN0SWQgKipERVBSRUNBVEVELCBzZXQgdGhpcyBpbiB0aGUgcHJvdmlkZWQgYGF1dGhDbGllbnRgLioqXG4gICAgICogICBPcHRpb25hbCBxdW90YSBwcm9qZWN0IGlkIGZvciBzZXR0aW5nIHVwIGluIHRoZSB4LWdvb2ctdXNlci1wcm9qZWN0IGhlYWRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhdXRoQ2xpZW50LCBjcmVkZW50aWFsQWNjZXNzQm91bmRhcnksIGFkZGl0aW9uYWxPcHRpb25zLCBxdW90YVByb2plY3RJZCkge1xuICAgICAgICBzdXBlcih7IC4uLmFkZGl0aW9uYWxPcHRpb25zLCBxdW90YVByb2plY3RJZCB9KTtcbiAgICAgICAgdGhpcy5hdXRoQ2xpZW50ID0gYXV0aENsaWVudDtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFsQWNjZXNzQm91bmRhcnkgPSBjcmVkZW50aWFsQWNjZXNzQm91bmRhcnk7XG4gICAgICAgIC8vIENoZWNrIDEtMTAgQWNjZXNzIEJvdW5kYXJ5IFJ1bGVzIGFyZSBkZWZpbmVkIHdpdGhpbiBDcmVkZW50aWFsIEFjY2Vzc1xuICAgICAgICAvLyBCb3VuZGFyeS5cbiAgICAgICAgaWYgKGNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeS5hY2Nlc3NCb3VuZGFyeS5hY2Nlc3NCb3VuZGFyeVJ1bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgYWNjZXNzIGJvdW5kYXJ5IHJ1bGUgbmVlZHMgdG8gYmUgZGVmaW5lZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjcmVkZW50aWFsQWNjZXNzQm91bmRhcnkuYWNjZXNzQm91bmRhcnkuYWNjZXNzQm91bmRhcnlSdWxlcy5sZW5ndGggPlxuICAgICAgICAgICAgZXhwb3J0cy5NQVhfQUNDRVNTX0JPVU5EQVJZX1JVTEVTX0NPVU5UKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm92aWRlZCBhY2Nlc3MgYm91bmRhcnkgaGFzIG1vcmUgdGhhbiAnICtcbiAgICAgICAgICAgICAgICBgJHtleHBvcnRzLk1BWF9BQ0NFU1NfQk9VTkRBUllfUlVMRVNfQ09VTlR9IGFjY2VzcyBib3VuZGFyeSBydWxlcy5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBhdCBsZWFzdCBvbmUgcGVybWlzc2lvbiBzaG91bGQgYmUgZGVmaW5lZCBpbiBlYWNoIEFjY2VzcyBCb3VuZGFyeVxuICAgICAgICAvLyBSdWxlLlxuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5LmFjY2Vzc0JvdW5kYXJ5XG4gICAgICAgICAgICAuYWNjZXNzQm91bmRhcnlSdWxlcykge1xuICAgICAgICAgICAgaWYgKHJ1bGUuYXZhaWxhYmxlUGVybWlzc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgcGVybWlzc2lvbiBzaG91bGQgYmUgZGVmaW5lZCBpbiBhY2Nlc3MgYm91bmRhcnkgcnVsZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHNDcmVkZW50aWFsID0gbmV3IHN0cy5TdHNDcmVkZW50aWFscyhgaHR0cHM6Ly9zdHMuJHt0aGlzLnVuaXZlcnNlRG9tYWlufS92MS90b2tlbmApO1xuICAgICAgICB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIGluamVjdCBEb3duc2NvcGVkIGFjY2VzcyB0b2tlbnMgZGlyZWN0bHkuXG4gICAgICogVGhlIGV4cGlyeV9kYXRlIGZpZWxkIGlzIHJlcXVpcmVkIHRvIGZhY2lsaXRhdGUgZGV0ZXJtaW5hdGlvbiBvZiB0aGUgdG9rZW5cbiAgICAgKiBleHBpcmF0aW9uIHdoaWNoIHdvdWxkIG1ha2UgaXQgZWFzaWVyIGZvciB0aGUgdG9rZW4gY29uc3VtZXIgdG8gaGFuZGxlLlxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgQ3JlZGVudGlhbHMgb2JqZWN0IHRvIHNldCBvbiB0aGUgY3VycmVudCBjbGllbnQuXG4gICAgICovXG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgaWYgKCFjcmVkZW50aWFscy5leHBpcnlfZGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYWNjZXNzIHRva2VuIGV4cGlyeV9kYXRlIGZpZWxkIGlzIG1pc3NpbmcgaW4gdGhlIHByb3ZpZGVkICcgK1xuICAgICAgICAgICAgICAgICdjcmVkZW50aWFscy4nKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5zZXRDcmVkZW50aWFscyhjcmVkZW50aWFscyk7XG4gICAgICAgIHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuID0gY3JlZGVudGlhbHM7XG4gICAgfVxuICAgIGFzeW5jIGdldEFjY2Vzc1Rva2VuKCkge1xuICAgICAgICAvLyBJZiB0aGUgY2FjaGVkIGFjY2VzcyB0b2tlbiBpcyB1bmF2YWlsYWJsZSBvciBleHBpcmVkLCBmb3JjZSByZWZyZXNoLlxuICAgICAgICAvLyBUaGUgRG93bnNjb3BlZCBhY2Nlc3MgdG9rZW4gd2lsbCBiZSByZXR1cm5lZCBpblxuICAgICAgICAvLyBEb3duc2NvcGVkQWNjZXNzVG9rZW5SZXNwb25zZSBmb3JtYXQuXG4gICAgICAgIGlmICghdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4gfHxcbiAgICAgICAgICAgIHRoaXMuaXNFeHBpcmVkKHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuKSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBEb3duc2NvcGVkIGFjY2VzcyB0b2tlbiBpbiBEb3duc2NvcGVkQWNjZXNzVG9rZW5SZXNwb25zZSBmb3JtYXQuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbjogdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgZXhwaXJhdGlvblRpbWU6IHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlLFxuICAgICAgICAgICAgcmVzOiB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbi5yZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIGF1dGhlbnRpY2F0aW9uIGludGVyZmFjZS4gSXQgdGFrZXMgYW4gb3B0aW9uYWwgdXJsIHdoaWNoIHdoZW5cbiAgICAgKiBwcmVzZW50IGlzIHRoZSBlbmRwb2ludCBiZWluZyBhY2Nlc3NlZCwgYW5kIHJldHVybnMgYSBQcm9taXNlIHdoaWNoXG4gICAgICogcmVzb2x2ZXMgd2l0aCBhdXRob3JpemF0aW9uIGhlYWRlciBmaWVsZHMuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzdWx0IGhhcyB0aGUgZm9ybTpcbiAgICAgKiB7IEF1dGhvcml6YXRpb246ICdCZWFyZXIgPGFjY2Vzc190b2tlbl92YWx1ZT4nIH1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5SZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlblJlc3BvbnNlLnRva2VufWAsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG4gICAgcmVxdWVzdChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIGUucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXV0aGVudGljYXRlcyB0aGUgcHJvdmlkZWQgSFRUUCByZXF1ZXN0LCBwcm9jZXNzZXMgaXQgYW5kIHJlc29sdmVzIHdpdGggdGhlXG4gICAgICogcmV0dXJuZWQgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIEhUVFAgcmVxdWVzdCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSByZUF1dGhSZXRyaWVkIFdoZXRoZXIgdGhlIGN1cnJlbnQgYXR0ZW1wdCBpcyBhIHJldHJ5IGFmdGVyIGEgZmFpbGVkIGF0dGVtcHQgZHVlIHRvIGFuIGF1dGggZmFpbHVyZVxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0QXN5bmMob3B0cywgcmVBdXRoUmV0cmllZCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSA9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdEhlYWRlcnMgJiYgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbikge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBlLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIFJldHJ5IHRoZSByZXF1ZXN0IGZvciBtZXRhZGF0YSBpZiB0aGUgZm9sbG93aW5nIGNyaXRlcmlhIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgIC8vIC0gV2UgaGF2ZW4ndCBhbHJlYWR5IHJldHJpZWQuICBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVzcG9uc2Ugd2FzIGEgNDAxIG9yIGEgNDAzXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVxdWVzdCBkaWRuJ3Qgc2VuZCBhIHJlYWRhYmxlU3RyZWFtXG4gICAgICAgICAgICAgICAgLy8gLSBmb3JjZVJlZnJlc2hPbkZhaWx1cmUgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSByZXMuY29uZmlnLmRhdGEgaW5zdGFuY2VvZiBzdHJlYW0uUmVhZGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdXRoRXJyID0gc3RhdHVzQ29kZSA9PT0gNDAxIHx8IHN0YXR1c0NvZGUgPT09IDQwMztcbiAgICAgICAgICAgICAgICBpZiAoIXJlQXV0aFJldHJpZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRoRXJyICYmXG4gICAgICAgICAgICAgICAgICAgICFpc1JlYWRhYmxlU3RyZWFtICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdEFzeW5jKG9wdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdG9rZW4gcmVmcmVzaCwgZXZlbiBpZiB1bmV4cGlyZWQgdG9rZW5zIGFyZSBjdXJyZW50bHkgY2FjaGVkLlxuICAgICAqIEdDUCBhY2Nlc3MgdG9rZW5zIGFyZSByZXRyaWV2ZWQgZnJvbSBhdXRoY2xpZW50IG9iamVjdC9zb3VyY2UgY3JlZGVudGlhbC5cbiAgICAgKiBUaGVuIEdDUCBhY2Nlc3MgdG9rZW5zIGFyZSBleGNoYW5nZWQgZm9yIGRvd25zY29wZWQgYWNjZXNzIHRva2VucyB2aWEgdGhlXG4gICAgICogdG9rZW4gZXhjaGFuZ2UgZW5kcG9pbnQuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBmcmVzaCBkb3duc2NvcGVkIGFjY2VzcyB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBSZXRyaWV2ZSBHQ1AgYWNjZXNzIHRva2VuIGZyb20gc291cmNlIGNyZWRlbnRpYWwuXG4gICAgICAgIGNvbnN0IHN1YmplY3RUb2tlbiA9IChhd2FpdCB0aGlzLmF1dGhDbGllbnQuZ2V0QWNjZXNzVG9rZW4oKSkudG9rZW47XG4gICAgICAgIC8vIENvbnN0cnVjdCB0aGUgU1RTIGNyZWRlbnRpYWxzIG9wdGlvbnMuXG4gICAgICAgIGNvbnN0IHN0c0NyZWRlbnRpYWxzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGdyYW50VHlwZTogU1RTX0dSQU5UX1RZUEUsXG4gICAgICAgICAgICByZXF1ZXN0ZWRUb2tlblR5cGU6IFNUU19SRVFVRVNUX1RPS0VOX1RZUEUsXG4gICAgICAgICAgICBzdWJqZWN0VG9rZW46IHN1YmplY3RUb2tlbixcbiAgICAgICAgICAgIHN1YmplY3RUb2tlblR5cGU6IFNUU19TVUJKRUNUX1RPS0VOX1RZUEUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEV4Y2hhbmdlIHRoZSBzb3VyY2UgQXV0aENsaWVudCBhY2Nlc3MgdG9rZW4gZm9yIGEgRG93bnNjb3BlZCBhY2Nlc3NcbiAgICAgICAgLy8gdG9rZW4uXG4gICAgICAgIGNvbnN0IHN0c1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5zdHNDcmVkZW50aWFsLmV4Y2hhbmdlVG9rZW4oc3RzQ3JlZGVudGlhbHNPcHRpb25zLCB1bmRlZmluZWQsIHRoaXMuY3JlZGVudGlhbEFjY2Vzc0JvdW5kYXJ5KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBTVFMgZW5kcG9pbnQgd2lsbCBvbmx5IHJldHVybiB0aGUgZXhwaXJhdGlvbiB0aW1lIGZvciB0aGUgZG93bnNjb3BlZFxuICAgICAgICAgKiBhY2Nlc3MgdG9rZW4gaWYgdGhlIG9yaWdpbmFsIGFjY2VzcyB0b2tlbiByZXByZXNlbnRzIGEgc2VydmljZSBhY2NvdW50LlxuICAgICAgICAgKiBUaGUgZG93bnNjb3BlZCB0b2tlbidzIGV4cGlyYXRpb24gdGltZSB3aWxsIGFsd2F5cyBtYXRjaCB0aGUgc291cmNlXG4gICAgICAgICAqIGNyZWRlbnRpYWwgZXhwaXJhdGlvbi4gV2hlbiBubyBleHBpcmVzX2luIGlzIHJldHVybmVkLCB3ZSBjYW4gY29weSB0aGVcbiAgICAgICAgICogc291cmNlIGNyZWRlbnRpYWwncyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzb3VyY2VDcmVkRXhwaXJlRGF0ZSA9ICgoX2EgPSB0aGlzLmF1dGhDbGllbnQuY3JlZGVudGlhbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leHBpcnlfZGF0ZSkgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgZXhwaXJ5RGF0ZSA9IHN0c1Jlc3BvbnNlLmV4cGlyZXNfaW5cbiAgICAgICAgICAgID8gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBzdHNSZXNwb25zZS5leHBpcmVzX2luICogMTAwMFxuICAgICAgICAgICAgOiBzb3VyY2VDcmVkRXhwaXJlRGF0ZTtcbiAgICAgICAgLy8gU2F2ZSByZXNwb25zZSBpbiBjYWNoZWQgYWNjZXNzIHRva2VuLlxuICAgICAgICB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbiA9IHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogc3RzUmVzcG9uc2UuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IGV4cGlyeURhdGUsXG4gICAgICAgICAgICByZXM6IHN0c1Jlc3BvbnNlLnJlcyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2F2ZSBjcmVkZW50aWFscy5cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY3JlZGVudGlhbHMucmVzO1xuICAgICAgICAvLyBUcmlnZ2VyIHRva2VucyBldmVudCB0byBub3RpZnkgZXh0ZXJuYWwgbGlzdGVuZXJzLlxuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHtcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IG51bGwsXG4gICAgICAgICAgICBleHBpcnlfZGF0ZTogdGhpcy5jYWNoZWREb3duc2NvcGVkQWNjZXNzVG9rZW4uZXhwaXJ5X2RhdGUsXG4gICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRoaXMuY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIHRva2VuX3R5cGU6ICdCZWFyZXInLFxuICAgICAgICAgICAgaWRfdG9rZW46IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGNhY2hlZCBhY2Nlc3MgdG9rZW4uXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlZERvd25zY29wZWRBY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBjcmVkZW50aWFscyBhcmUgZXhwaXJlZCBvciBub3QuXG4gICAgICogSWYgdGhlcmUgaXMgbm8gZXhwaXJ5IHRpbWUsIGFzc3VtZXMgdGhlIHRva2VuIGlzIG5vdCBleHBpcmVkIG9yIGV4cGlyaW5nLlxuICAgICAqIEBwYXJhbSBkb3duc2NvcGVkQWNjZXNzVG9rZW4gVGhlIGNyZWRlbnRpYWxzIHRvIGNoZWNrIGZvciBleHBpcmF0aW9uLlxuICAgICAqIEByZXR1cm4gV2hldGhlciB0aGUgY3JlZGVudGlhbHMgYXJlIGV4cGlyZWQgb3Igbm90LlxuICAgICAqL1xuICAgIGlzRXhwaXJlZChkb3duc2NvcGVkQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHJldHVybiBkb3duc2NvcGVkQWNjZXNzVG9rZW4uZXhwaXJ5X2RhdGVcbiAgICAgICAgICAgID8gbm93ID49XG4gICAgICAgICAgICAgICAgZG93bnNjb3BlZEFjY2Vzc1Rva2VuLmV4cGlyeV9kYXRlIC0gdGhpcy5lYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXNcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5Eb3duc2NvcGVkQ2xpZW50ID0gRG93bnNjb3BlZENsaWVudDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRvd25zY29wZWRDbGllbnQiLCJFWFBJUkFUSU9OX1RJTUVfT0ZGU0VUIiwiTUFYX0FDQ0VTU19CT1VOREFSWV9SVUxFU19DT1VOVCIsInN0cmVhbSIsInJlcXVpcmUiLCJhdXRoY2xpZW50XzEiLCJzdHMiLCJTVFNfR1JBTlRfVFlQRSIsIlNUU19SRVFVRVNUX1RPS0VOX1RZUEUiLCJTVFNfU1VCSkVDVF9UT0tFTl9UWVBFIiwiQXV0aENsaWVudCIsImNvbnN0cnVjdG9yIiwiYXV0aENsaWVudCIsImNyZWRlbnRpYWxBY2Nlc3NCb3VuZGFyeSIsImFkZGl0aW9uYWxPcHRpb25zIiwicXVvdGFQcm9qZWN0SWQiLCJhY2Nlc3NCb3VuZGFyeSIsImFjY2Vzc0JvdW5kYXJ5UnVsZXMiLCJsZW5ndGgiLCJFcnJvciIsInJ1bGUiLCJhdmFpbGFibGVQZXJtaXNzaW9ucyIsInN0c0NyZWRlbnRpYWwiLCJTdHNDcmVkZW50aWFscyIsInVuaXZlcnNlRG9tYWluIiwiY2FjaGVkRG93bnNjb3BlZEFjY2Vzc1Rva2VuIiwic2V0Q3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsImV4cGlyeV9kYXRlIiwiZ2V0QWNjZXNzVG9rZW4iLCJpc0V4cGlyZWQiLCJyZWZyZXNoQWNjZXNzVG9rZW5Bc3luYyIsInRva2VuIiwiYWNjZXNzX3Rva2VuIiwiZXhwaXJhdGlvblRpbWUiLCJyZXMiLCJnZXRSZXF1ZXN0SGVhZGVycyIsImFjY2Vzc1Rva2VuUmVzcG9uc2UiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyIsInJlcXVlc3QiLCJvcHRzIiwiY2FsbGJhY2siLCJyZXF1ZXN0QXN5bmMiLCJ0aGVuIiwiciIsImUiLCJyZXNwb25zZSIsInJlQXV0aFJldHJpZWQiLCJyZXF1ZXN0SGVhZGVycyIsInRyYW5zcG9ydGVyIiwic3RhdHVzQ29kZSIsInN0YXR1cyIsImlzUmVhZGFibGVTdHJlYW0iLCJjb25maWciLCJkYXRhIiwiUmVhZGFibGUiLCJpc0F1dGhFcnIiLCJmb3JjZVJlZnJlc2hPbkZhaWx1cmUiLCJfYSIsInN1YmplY3RUb2tlbiIsInN0c0NyZWRlbnRpYWxzT3B0aW9ucyIsImdyYW50VHlwZSIsInJlcXVlc3RlZFRva2VuVHlwZSIsInN1YmplY3RUb2tlblR5cGUiLCJzdHNSZXNwb25zZSIsImV4Y2hhbmdlVG9rZW4iLCJ1bmRlZmluZWQiLCJzb3VyY2VDcmVkRXhwaXJlRGF0ZSIsImV4cGlyeURhdGUiLCJleHBpcmVzX2luIiwiRGF0ZSIsImdldFRpbWUiLCJhc3NpZ24iLCJlbWl0IiwicmVmcmVzaF90b2tlbiIsInRva2VuX3R5cGUiLCJpZF90b2tlbiIsImRvd25zY29wZWRBY2Nlc3NUb2tlbiIsIm5vdyIsImVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/envDetect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2018 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GCPEnv = void 0;\nexports.clear = clear;\nexports.getEnv = getEnv;\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(rsc)/./node_modules/gcp-metadata/build/src/index.js\");\nvar GCPEnv;\n(function(GCPEnv) {\n    GCPEnv[\"APP_ENGINE\"] = \"APP_ENGINE\";\n    GCPEnv[\"KUBERNETES_ENGINE\"] = \"KUBERNETES_ENGINE\";\n    GCPEnv[\"CLOUD_FUNCTIONS\"] = \"CLOUD_FUNCTIONS\";\n    GCPEnv[\"COMPUTE_ENGINE\"] = \"COMPUTE_ENGINE\";\n    GCPEnv[\"CLOUD_RUN\"] = \"CLOUD_RUN\";\n    GCPEnv[\"NONE\"] = \"NONE\";\n})(GCPEnv || (exports.GCPEnv = GCPEnv = {}));\nlet envPromise;\nfunction clear() {\n    envPromise = undefined;\n}\nasync function getEnv() {\n    if (envPromise) {\n        return envPromise;\n    }\n    envPromise = getEnvMemoized();\n    return envPromise;\n}\nasync function getEnvMemoized() {\n    let env = GCPEnv.NONE;\n    if (isAppEngine()) {\n        env = GCPEnv.APP_ENGINE;\n    } else if (isCloudFunction()) {\n        env = GCPEnv.CLOUD_FUNCTIONS;\n    } else if (await isComputeEngine()) {\n        if (await isKubernetesEngine()) {\n            env = GCPEnv.KUBERNETES_ENGINE;\n        } else if (isCloudRun()) {\n            env = GCPEnv.CLOUD_RUN;\n        } else {\n            env = GCPEnv.COMPUTE_ENGINE;\n        }\n    } else {\n        env = GCPEnv.NONE;\n    }\n    return env;\n}\nfunction isAppEngine() {\n    return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);\n}\nfunction isCloudFunction() {\n    return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);\n}\n/**\n * This check only verifies that the environment is running knative.\n * This must be run *after* checking for Kubernetes, otherwise it will\n * return a false positive.\n */ function isCloudRun() {\n    return !!process.env.K_CONFIGURATION;\n}\nasync function isKubernetesEngine() {\n    try {\n        await gcpMetadata.instance(\"attributes/cluster-name\");\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nasync function isComputeEngine() {\n    return gcpMetadata.isAvailable();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9lbnZEZXRlY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QkEsYUFBYSxHQUFHRztBQUNoQkgsY0FBYyxHQUFHSTtBQUNqQixNQUFNQyxjQUFjQyxtQkFBT0EsQ0FBQywwRUFBYztBQUMxQyxJQUFJSjtBQUNILFVBQVVBLE1BQU07SUFDYkEsTUFBTSxDQUFDLGFBQWEsR0FBRztJQUN2QkEsTUFBTSxDQUFDLG9CQUFvQixHQUFHO0lBQzlCQSxNQUFNLENBQUMsa0JBQWtCLEdBQUc7SUFDNUJBLE1BQU0sQ0FBQyxpQkFBaUIsR0FBRztJQUMzQkEsTUFBTSxDQUFDLFlBQVksR0FBRztJQUN0QkEsTUFBTSxDQUFDLE9BQU8sR0FBRztBQUNyQixHQUFHQSxVQUFXRixDQUFBQSxjQUFjLEdBQUdFLFNBQVMsQ0FBQztBQUN6QyxJQUFJSztBQUNKLFNBQVNKO0lBQ0xJLGFBQWFDO0FBQ2pCO0FBQ0EsZUFBZUo7SUFDWCxJQUFJRyxZQUFZO1FBQ1osT0FBT0E7SUFDWDtJQUNBQSxhQUFhRTtJQUNiLE9BQU9GO0FBQ1g7QUFDQSxlQUFlRTtJQUNYLElBQUlDLE1BQU1SLE9BQU9TLElBQUk7SUFDckIsSUFBSUMsZUFBZTtRQUNmRixNQUFNUixPQUFPVyxVQUFVO0lBQzNCLE9BQ0ssSUFBSUMsbUJBQW1CO1FBQ3hCSixNQUFNUixPQUFPYSxlQUFlO0lBQ2hDLE9BQ0ssSUFBSSxNQUFNQyxtQkFBbUI7UUFDOUIsSUFBSSxNQUFNQyxzQkFBc0I7WUFDNUJQLE1BQU1SLE9BQU9nQixpQkFBaUI7UUFDbEMsT0FDSyxJQUFJQyxjQUFjO1lBQ25CVCxNQUFNUixPQUFPa0IsU0FBUztRQUMxQixPQUNLO1lBQ0RWLE1BQU1SLE9BQU9tQixjQUFjO1FBQy9CO0lBQ0osT0FDSztRQUNEWCxNQUFNUixPQUFPUyxJQUFJO0lBQ3JCO0lBQ0EsT0FBT0Q7QUFDWDtBQUNBLFNBQVNFO0lBQ0wsT0FBTyxDQUFDLENBQUVVLENBQUFBLFFBQVFaLEdBQUcsQ0FBQ2EsV0FBVyxJQUFJRCxRQUFRWixHQUFHLENBQUNjLGVBQWU7QUFDcEU7QUFDQSxTQUFTVjtJQUNMLE9BQU8sQ0FBQyxDQUFFUSxDQUFBQSxRQUFRWixHQUFHLENBQUNlLGFBQWEsSUFBSUgsUUFBUVosR0FBRyxDQUFDZ0IsZUFBZTtBQUN0RTtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTUDtJQUNMLE9BQU8sQ0FBQyxDQUFDRyxRQUFRWixHQUFHLENBQUNpQixlQUFlO0FBQ3hDO0FBQ0EsZUFBZVY7SUFDWCxJQUFJO1FBQ0EsTUFBTVosWUFBWXVCLFFBQVEsQ0FBQztRQUMzQixPQUFPO0lBQ1gsRUFDQSxPQUFPQyxHQUFHO1FBQ04sT0FBTztJQUNYO0FBQ0o7QUFDQSxlQUFlYjtJQUNYLE9BQU9YLFlBQVl5QixXQUFXO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9lbnZEZXRlY3QuanM/Y2UzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HQ1BFbnYgPSB2b2lkIDA7XG5leHBvcnRzLmNsZWFyID0gY2xlYXI7XG5leHBvcnRzLmdldEVudiA9IGdldEVudjtcbmNvbnN0IGdjcE1ldGFkYXRhID0gcmVxdWlyZShcImdjcC1tZXRhZGF0YVwiKTtcbnZhciBHQ1BFbnY7XG4oZnVuY3Rpb24gKEdDUEVudikge1xuICAgIEdDUEVudltcIkFQUF9FTkdJTkVcIl0gPSBcIkFQUF9FTkdJTkVcIjtcbiAgICBHQ1BFbnZbXCJLVUJFUk5FVEVTX0VOR0lORVwiXSA9IFwiS1VCRVJORVRFU19FTkdJTkVcIjtcbiAgICBHQ1BFbnZbXCJDTE9VRF9GVU5DVElPTlNcIl0gPSBcIkNMT1VEX0ZVTkNUSU9OU1wiO1xuICAgIEdDUEVudltcIkNPTVBVVEVfRU5HSU5FXCJdID0gXCJDT01QVVRFX0VOR0lORVwiO1xuICAgIEdDUEVudltcIkNMT1VEX1JVTlwiXSA9IFwiQ0xPVURfUlVOXCI7XG4gICAgR0NQRW52W1wiTk9ORVwiXSA9IFwiTk9ORVwiO1xufSkoR0NQRW52IHx8IChleHBvcnRzLkdDUEVudiA9IEdDUEVudiA9IHt9KSk7XG5sZXQgZW52UHJvbWlzZTtcbmZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGVudlByb21pc2UgPSB1bmRlZmluZWQ7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRFbnYoKSB7XG4gICAgaWYgKGVudlByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIGVudlByb21pc2U7XG4gICAgfVxuICAgIGVudlByb21pc2UgPSBnZXRFbnZNZW1vaXplZCgpO1xuICAgIHJldHVybiBlbnZQcm9taXNlO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0RW52TWVtb2l6ZWQoKSB7XG4gICAgbGV0IGVudiA9IEdDUEVudi5OT05FO1xuICAgIGlmIChpc0FwcEVuZ2luZSgpKSB7XG4gICAgICAgIGVudiA9IEdDUEVudi5BUFBfRU5HSU5FO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Nsb3VkRnVuY3Rpb24oKSkge1xuICAgICAgICBlbnYgPSBHQ1BFbnYuQ0xPVURfRlVOQ1RJT05TO1xuICAgIH1cbiAgICBlbHNlIGlmIChhd2FpdCBpc0NvbXB1dGVFbmdpbmUoKSkge1xuICAgICAgICBpZiAoYXdhaXQgaXNLdWJlcm5ldGVzRW5naW5lKCkpIHtcbiAgICAgICAgICAgIGVudiA9IEdDUEVudi5LVUJFUk5FVEVTX0VOR0lORTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Nsb3VkUnVuKCkpIHtcbiAgICAgICAgICAgIGVudiA9IEdDUEVudi5DTE9VRF9SVU47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbnYgPSBHQ1BFbnYuQ09NUFVURV9FTkdJTkU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVudiA9IEdDUEVudi5OT05FO1xuICAgIH1cbiAgICByZXR1cm4gZW52O1xufVxuZnVuY3Rpb24gaXNBcHBFbmdpbmUoKSB7XG4gICAgcmV0dXJuICEhKHByb2Nlc3MuZW52LkdBRV9TRVJWSUNFIHx8IHByb2Nlc3MuZW52LkdBRV9NT0RVTEVfTkFNRSk7XG59XG5mdW5jdGlvbiBpc0Nsb3VkRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhKHByb2Nlc3MuZW52LkZVTkNUSU9OX05BTUUgfHwgcHJvY2Vzcy5lbnYuRlVOQ1RJT05fVEFSR0VUKTtcbn1cbi8qKlxuICogVGhpcyBjaGVjayBvbmx5IHZlcmlmaWVzIHRoYXQgdGhlIGVudmlyb25tZW50IGlzIHJ1bm5pbmcga25hdGl2ZS5cbiAqIFRoaXMgbXVzdCBiZSBydW4gKmFmdGVyKiBjaGVja2luZyBmb3IgS3ViZXJuZXRlcywgb3RoZXJ3aXNlIGl0IHdpbGxcbiAqIHJldHVybiBhIGZhbHNlIHBvc2l0aXZlLlxuICovXG5mdW5jdGlvbiBpc0Nsb3VkUnVuKCkge1xuICAgIHJldHVybiAhIXByb2Nlc3MuZW52LktfQ09ORklHVVJBVElPTjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGlzS3ViZXJuZXRlc0VuZ2luZSgpIHtcbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBnY3BNZXRhZGF0YS5pbnN0YW5jZSgnYXR0cmlidXRlcy9jbHVzdGVyLW5hbWUnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpc0NvbXB1dGVFbmdpbmUoKSB7XG4gICAgcmV0dXJuIGdjcE1ldGFkYXRhLmlzQXZhaWxhYmxlKCk7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJHQ1BFbnYiLCJjbGVhciIsImdldEVudiIsImdjcE1ldGFkYXRhIiwicmVxdWlyZSIsImVudlByb21pc2UiLCJ1bmRlZmluZWQiLCJnZXRFbnZNZW1vaXplZCIsImVudiIsIk5PTkUiLCJpc0FwcEVuZ2luZSIsIkFQUF9FTkdJTkUiLCJpc0Nsb3VkRnVuY3Rpb24iLCJDTE9VRF9GVU5DVElPTlMiLCJpc0NvbXB1dGVFbmdpbmUiLCJpc0t1YmVybmV0ZXNFbmdpbmUiLCJLVUJFUk5FVEVTX0VOR0lORSIsImlzQ2xvdWRSdW4iLCJDTE9VRF9SVU4iLCJDT01QVVRFX0VOR0lORSIsInByb2Nlc3MiLCJHQUVfU0VSVklDRSIsIkdBRV9NT0RVTEVfTkFNRSIsIkZVTkNUSU9OX05BTUUiLCJGVU5DVElPTl9UQVJHRVQiLCJLX0NPTkZJR1VSQVRJT04iLCJpbnN0YW5jZSIsImUiLCJpc0F2YWlsYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js":
/*!********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/executable-response.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.InvalidSubjectTokenError = exports.InvalidMessageFieldError = exports.InvalidCodeFieldError = exports.InvalidTokenTypeFieldError = exports.InvalidExpirationTimeFieldError = exports.InvalidSuccessFieldError = exports.InvalidVersionFieldError = exports.ExecutableResponseError = exports.ExecutableResponse = void 0;\nconst SAML_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:saml2\";\nconst OIDC_SUBJECT_TOKEN_TYPE1 = \"urn:ietf:params:oauth:token-type:id_token\";\nconst OIDC_SUBJECT_TOKEN_TYPE2 = \"urn:ietf:params:oauth:token-type:jwt\";\n/**\n * Defines the response of a 3rd party executable run by the pluggable auth client.\n */ class ExecutableResponse {\n    /**\n     * Instantiates an ExecutableResponse instance using the provided JSON object\n     * from the output of the executable.\n     * @param responseJson Response from a 3rd party executable, loaded from a\n     * run of the executable or a cached output file.\n     */ constructor(responseJson){\n        // Check that the required fields exist in the json response.\n        if (!responseJson.version) {\n            throw new InvalidVersionFieldError(\"Executable response must contain a 'version' field.\");\n        }\n        if (responseJson.success === undefined) {\n            throw new InvalidSuccessFieldError(\"Executable response must contain a 'success' field.\");\n        }\n        this.version = responseJson.version;\n        this.success = responseJson.success;\n        // Validate required fields for a successful response.\n        if (this.success) {\n            this.expirationTime = responseJson.expiration_time;\n            this.tokenType = responseJson.token_type;\n            // Validate token type field.\n            if (this.tokenType !== SAML_SUBJECT_TOKEN_TYPE && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE1 && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE2) {\n                throw new InvalidTokenTypeFieldError(\"Executable response must contain a 'token_type' field when successful \" + `and it must be one of ${OIDC_SUBJECT_TOKEN_TYPE1}, ${OIDC_SUBJECT_TOKEN_TYPE2}, or ${SAML_SUBJECT_TOKEN_TYPE}.`);\n            }\n            // Validate subject token.\n            if (this.tokenType === SAML_SUBJECT_TOKEN_TYPE) {\n                if (!responseJson.saml_response) {\n                    throw new InvalidSubjectTokenError(`Executable response must contain a 'saml_response' field when token_type=${SAML_SUBJECT_TOKEN_TYPE}.`);\n                }\n                this.subjectToken = responseJson.saml_response;\n            } else {\n                if (!responseJson.id_token) {\n                    throw new InvalidSubjectTokenError(\"Executable response must contain a 'id_token' field when \" + `token_type=${OIDC_SUBJECT_TOKEN_TYPE1} or ${OIDC_SUBJECT_TOKEN_TYPE2}.`);\n                }\n                this.subjectToken = responseJson.id_token;\n            }\n        } else {\n            // Both code and message must be provided for unsuccessful responses.\n            if (!responseJson.code) {\n                throw new InvalidCodeFieldError(\"Executable response must contain a 'code' field when unsuccessful.\");\n            }\n            if (!responseJson.message) {\n                throw new InvalidMessageFieldError(\"Executable response must contain a 'message' field when unsuccessful.\");\n            }\n            this.errorCode = responseJson.code;\n            this.errorMessage = responseJson.message;\n        }\n    }\n    /**\n     * @return A boolean representing if the response has a valid token. Returns\n     * true when the response was successful and the token is not expired.\n     */ isValid() {\n        return !this.isExpired() && this.success;\n    }\n    /**\n     * @return A boolean representing if the response is expired. Returns true if the\n     * provided timeout has passed.\n     */ isExpired() {\n        return this.expirationTime !== undefined && this.expirationTime < Math.round(Date.now() / 1000);\n    }\n}\nexports.ExecutableResponse = ExecutableResponse;\n/**\n * An error thrown by the ExecutableResponse class.\n */ class ExecutableResponseError extends Error {\n    constructor(message){\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.ExecutableResponseError = ExecutableResponseError;\n/**\n * An error thrown when the 'version' field in an executable response is missing or invalid.\n */ class InvalidVersionFieldError extends ExecutableResponseError {\n}\nexports.InvalidVersionFieldError = InvalidVersionFieldError;\n/**\n * An error thrown when the 'success' field in an executable response is missing or invalid.\n */ class InvalidSuccessFieldError extends ExecutableResponseError {\n}\nexports.InvalidSuccessFieldError = InvalidSuccessFieldError;\n/**\n * An error thrown when the 'expiration_time' field in an executable response is missing or invalid.\n */ class InvalidExpirationTimeFieldError extends ExecutableResponseError {\n}\nexports.InvalidExpirationTimeFieldError = InvalidExpirationTimeFieldError;\n/**\n * An error thrown when the 'token_type' field in an executable response is missing or invalid.\n */ class InvalidTokenTypeFieldError extends ExecutableResponseError {\n}\nexports.InvalidTokenTypeFieldError = InvalidTokenTypeFieldError;\n/**\n * An error thrown when the 'code' field in an executable response is missing or invalid.\n */ class InvalidCodeFieldError extends ExecutableResponseError {\n}\nexports.InvalidCodeFieldError = InvalidCodeFieldError;\n/**\n * An error thrown when the 'message' field in an executable response is missing or invalid.\n */ class InvalidMessageFieldError extends ExecutableResponseError {\n}\nexports.InvalidMessageFieldError = InvalidMessageFieldError;\n/**\n * An error thrown when the subject token in an executable response is missing or invalid.\n */ class InvalidSubjectTokenError extends ExecutableResponseError {\n}\nexports.InvalidSubjectTokenError = InvalidSubjectTokenError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leGVjdXRhYmxlLXJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0NBQWdDLEdBQUdBLGdDQUFnQyxHQUFHQSw2QkFBNkIsR0FBR0Esa0NBQWtDLEdBQUdBLHVDQUF1QyxHQUFHQSxnQ0FBZ0MsR0FBR0EsZ0NBQWdDLEdBQUdBLCtCQUErQixHQUFHQSwwQkFBMEIsR0FBRyxLQUFLO0FBQy9ULE1BQU1XLDBCQUEwQjtBQUNoQyxNQUFNQywyQkFBMkI7QUFDakMsTUFBTUMsMkJBQTJCO0FBQ2pDOztDQUVDLEdBQ0QsTUFBTUg7SUFDRjs7Ozs7S0FLQyxHQUNESSxZQUFZQyxZQUFZLENBQUU7UUFDdEIsNkRBQTZEO1FBQzdELElBQUksQ0FBQ0EsYUFBYUMsT0FBTyxFQUFFO1lBQ3ZCLE1BQU0sSUFBSVIseUJBQXlCO1FBQ3ZDO1FBQ0EsSUFBSU8sYUFBYUUsT0FBTyxLQUFLQyxXQUFXO1lBQ3BDLE1BQU0sSUFBSVgseUJBQXlCO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDUyxPQUFPLEdBQUdELGFBQWFDLE9BQU87UUFDbkMsSUFBSSxDQUFDQyxPQUFPLEdBQUdGLGFBQWFFLE9BQU87UUFDbkMsc0RBQXNEO1FBQ3RELElBQUksSUFBSSxDQUFDQSxPQUFPLEVBQUU7WUFDZCxJQUFJLENBQUNFLGNBQWMsR0FBR0osYUFBYUssZUFBZTtZQUNsRCxJQUFJLENBQUNDLFNBQVMsR0FBR04sYUFBYU8sVUFBVTtZQUN4Qyw2QkFBNkI7WUFDN0IsSUFBSSxJQUFJLENBQUNELFNBQVMsS0FBS1YsMkJBQ25CLElBQUksQ0FBQ1UsU0FBUyxLQUFLVCw0QkFDbkIsSUFBSSxDQUFDUyxTQUFTLEtBQUtSLDBCQUEwQjtnQkFDN0MsTUFBTSxJQUFJUiwyQkFBMkIsMkVBQ2pDLENBQUMsc0JBQXNCLEVBQUVPLHlCQUF5QixFQUFFLEVBQUVDLHlCQUF5QixLQUFLLEVBQUVGLHdCQUF3QixDQUFDLENBQUM7WUFDeEg7WUFDQSwwQkFBMEI7WUFDMUIsSUFBSSxJQUFJLENBQUNVLFNBQVMsS0FBS1YseUJBQXlCO2dCQUM1QyxJQUFJLENBQUNJLGFBQWFRLGFBQWEsRUFBRTtvQkFDN0IsTUFBTSxJQUFJckIseUJBQXlCLENBQUMseUVBQXlFLEVBQUVTLHdCQUF3QixDQUFDLENBQUM7Z0JBQzdJO2dCQUNBLElBQUksQ0FBQ2EsWUFBWSxHQUFHVCxhQUFhUSxhQUFhO1lBQ2xELE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDUixhQUFhVSxRQUFRLEVBQUU7b0JBQ3hCLE1BQU0sSUFBSXZCLHlCQUF5Qiw4REFDL0IsQ0FBQyxXQUFXLEVBQUVVLHlCQUF5QixJQUFJLEVBQUVDLHlCQUF5QixDQUFDLENBQUM7Z0JBQ2hGO2dCQUNBLElBQUksQ0FBQ1csWUFBWSxHQUFHVCxhQUFhVSxRQUFRO1lBQzdDO1FBQ0osT0FDSztZQUNELHFFQUFxRTtZQUNyRSxJQUFJLENBQUNWLGFBQWFXLElBQUksRUFBRTtnQkFDcEIsTUFBTSxJQUFJdEIsc0JBQXNCO1lBQ3BDO1lBQ0EsSUFBSSxDQUFDVyxhQUFhWSxPQUFPLEVBQUU7Z0JBQ3ZCLE1BQU0sSUFBSXhCLHlCQUF5QjtZQUN2QztZQUNBLElBQUksQ0FBQ3lCLFNBQVMsR0FBR2IsYUFBYVcsSUFBSTtZQUNsQyxJQUFJLENBQUNHLFlBQVksR0FBR2QsYUFBYVksT0FBTztRQUM1QztJQUNKO0lBQ0E7OztLQUdDLEdBQ0RHLFVBQVU7UUFDTixPQUFPLENBQUMsSUFBSSxDQUFDQyxTQUFTLE1BQU0sSUFBSSxDQUFDZCxPQUFPO0lBQzVDO0lBQ0E7OztLQUdDLEdBQ0RjLFlBQVk7UUFDUixPQUFRLElBQUksQ0FBQ1osY0FBYyxLQUFLRCxhQUM1QixJQUFJLENBQUNDLGNBQWMsR0FBR2EsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUs7SUFDdEQ7QUFDSjtBQUNBbkMsMEJBQTBCLEdBQUdVO0FBQzdCOztDQUVDLEdBQ0QsTUFBTUQsZ0NBQWdDMkI7SUFDbEN0QixZQUFZYSxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNON0IsT0FBT3VDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBV0MsU0FBUztJQUNwRDtBQUNKO0FBQ0F0QywrQkFBK0IsR0FBR1M7QUFDbEM7O0NBRUMsR0FDRCxNQUFNRCxpQ0FBaUNDO0FBQ3ZDO0FBQ0FULGdDQUFnQyxHQUFHUTtBQUNuQzs7Q0FFQyxHQUNELE1BQU1ELGlDQUFpQ0U7QUFDdkM7QUFDQVQsZ0NBQWdDLEdBQUdPO0FBQ25DOztDQUVDLEdBQ0QsTUFBTUQsd0NBQXdDRztBQUM5QztBQUNBVCx1Q0FBdUMsR0FBR007QUFDMUM7O0NBRUMsR0FDRCxNQUFNRCxtQ0FBbUNJO0FBQ3pDO0FBQ0FULGtDQUFrQyxHQUFHSztBQUNyQzs7Q0FFQyxHQUNELE1BQU1ELDhCQUE4Qks7QUFDcEM7QUFDQVQsNkJBQTZCLEdBQUdJO0FBQ2hDOztDQUVDLEdBQ0QsTUFBTUQsaUNBQWlDTTtBQUN2QztBQUNBVCxnQ0FBZ0MsR0FBR0c7QUFDbkM7O0NBRUMsR0FDRCxNQUFNRCxpQ0FBaUNPO0FBQ3ZDO0FBQ0FULGdDQUFnQyxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXhlY3V0YWJsZS1yZXNwb25zZS5qcz9kNTg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludmFsaWRTdWJqZWN0VG9rZW5FcnJvciA9IGV4cG9ydHMuSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ29kZUZpZWxkRXJyb3IgPSBleHBvcnRzLkludmFsaWRUb2tlblR5cGVGaWVsZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkU3VjY2Vzc0ZpZWxkRXJyb3IgPSBleHBvcnRzLkludmFsaWRWZXJzaW9uRmllbGRFcnJvciA9IGV4cG9ydHMuRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IgPSBleHBvcnRzLkV4ZWN1dGFibGVSZXNwb25zZSA9IHZvaWQgMDtcbmNvbnN0IFNBTUxfU1VCSkVDVF9UT0tFTl9UWVBFID0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDp0b2tlbi10eXBlOnNhbWwyJztcbmNvbnN0IE9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTppZF90b2tlbic7XG5jb25zdCBPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTIgPSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6and0Jztcbi8qKlxuICogRGVmaW5lcyB0aGUgcmVzcG9uc2Ugb2YgYSAzcmQgcGFydHkgZXhlY3V0YWJsZSBydW4gYnkgdGhlIHBsdWdnYWJsZSBhdXRoIGNsaWVudC5cbiAqL1xuY2xhc3MgRXhlY3V0YWJsZVJlc3BvbnNlIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gRXhlY3V0YWJsZVJlc3BvbnNlIGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OIG9iamVjdFxuICAgICAqIGZyb20gdGhlIG91dHB1dCBvZiB0aGUgZXhlY3V0YWJsZS5cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2VKc29uIFJlc3BvbnNlIGZyb20gYSAzcmQgcGFydHkgZXhlY3V0YWJsZSwgbG9hZGVkIGZyb20gYVxuICAgICAqIHJ1biBvZiB0aGUgZXhlY3V0YWJsZSBvciBhIGNhY2hlZCBvdXRwdXQgZmlsZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZUpzb24pIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgcmVxdWlyZWQgZmllbGRzIGV4aXN0IGluIHRoZSBqc29uIHJlc3BvbnNlLlxuICAgICAgICBpZiAoIXJlc3BvbnNlSnNvbi52ZXJzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZlcnNpb25GaWVsZEVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAndmVyc2lvbicgZmllbGQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZUpzb24uc3VjY2VzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN1Y2Nlc3NGaWVsZEVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAnc3VjY2VzcycgZmllbGQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHJlc3BvbnNlSnNvbi52ZXJzaW9uO1xuICAgICAgICB0aGlzLnN1Y2Nlc3MgPSByZXNwb25zZUpzb24uc3VjY2VzcztcbiAgICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzIGZvciBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gICAgICAgIGlmICh0aGlzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSByZXNwb25zZUpzb24uZXhwaXJhdGlvbl90aW1lO1xuICAgICAgICAgICAgdGhpcy50b2tlblR5cGUgPSByZXNwb25zZUpzb24udG9rZW5fdHlwZTtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRva2VuIHR5cGUgZmllbGQuXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlblR5cGUgIT09IFNBTUxfU1VCSkVDVF9UT0tFTl9UWVBFICYmXG4gICAgICAgICAgICAgICAgdGhpcy50b2tlblR5cGUgIT09IE9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMSAmJlxuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5UeXBlICE9PSBPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3IoXCJFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICd0b2tlbl90eXBlJyBmaWVsZCB3aGVuIHN1Y2Nlc3NmdWwgXCIgK1xuICAgICAgICAgICAgICAgICAgICBgYW5kIGl0IG11c3QgYmUgb25lIG9mICR7T0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUxfSwgJHtPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTJ9LCBvciAke1NBTUxfU1VCSkVDVF9UT0tFTl9UWVBFfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHN1YmplY3QgdG9rZW4uXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlblR5cGUgPT09IFNBTUxfU1VCSkVDVF9UT0tFTl9UWVBFKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZUpzb24uc2FtbF9yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN1YmplY3RUb2tlbkVycm9yKGBFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICdzYW1sX3Jlc3BvbnNlJyBmaWVsZCB3aGVuIHRva2VuX3R5cGU9JHtTQU1MX1NVQkpFQ1RfVE9LRU5fVFlQRX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3ViamVjdFRva2VuID0gcmVzcG9uc2VKc29uLnNhbWxfcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlSnNvbi5pZF90b2tlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN1YmplY3RUb2tlbkVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAnaWRfdG9rZW4nIGZpZWxkIHdoZW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHRva2VuX3R5cGU9JHtPSURDX1NVQkpFQ1RfVE9LRU5fVFlQRTF9IG9yICR7T0lEQ19TVUJKRUNUX1RPS0VOX1RZUEUyfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJqZWN0VG9rZW4gPSByZXNwb25zZUpzb24uaWRfdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBCb3RoIGNvZGUgYW5kIG1lc3NhZ2UgbXVzdCBiZSBwcm92aWRlZCBmb3IgdW5zdWNjZXNzZnVsIHJlc3BvbnNlcy5cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VKc29uLmNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvZGVGaWVsZEVycm9yKFwiRXhlY3V0YWJsZSByZXNwb25zZSBtdXN0IGNvbnRhaW4gYSAnY29kZScgZmllbGQgd2hlbiB1bnN1Y2Nlc3NmdWwuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUpzb24ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3IoXCJFeGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiBhICdtZXNzYWdlJyBmaWVsZCB3aGVuIHVuc3VjY2Vzc2Z1bC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yQ29kZSA9IHJlc3BvbnNlSnNvbi5jb2RlO1xuICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSByZXNwb25zZUpzb24ubWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgaWYgdGhlIHJlc3BvbnNlIGhhcyBhIHZhbGlkIHRva2VuLiBSZXR1cm5zXG4gICAgICogdHJ1ZSB3aGVuIHRoZSByZXNwb25zZSB3YXMgc3VjY2Vzc2Z1bCBhbmQgdGhlIHRva2VuIGlzIG5vdCBleHBpcmVkLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc0V4cGlyZWQoKSAmJiB0aGlzLnN1Y2Nlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gQSBib29sZWFuIHJlcHJlc2VudGluZyBpZiB0aGUgcmVzcG9uc2UgaXMgZXhwaXJlZC4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgICAqIHByb3ZpZGVkIHRpbWVvdXQgaGFzIHBhc3NlZC5cbiAgICAgKi9cbiAgICBpc0V4cGlyZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5leHBpcmF0aW9uVGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmV4cGlyYXRpb25UaW1lIDwgTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhlY3V0YWJsZVJlc3BvbnNlID0gRXhlY3V0YWJsZVJlc3BvbnNlO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gYnkgdGhlIEV4ZWN1dGFibGVSZXNwb25zZSBjbGFzcy5cbiAqL1xuY2xhc3MgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yID0gRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3I7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIHRoZSAndmVyc2lvbicgZmllbGQgaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRWZXJzaW9uRmllbGRFcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFZlcnNpb25GaWVsZEVycm9yID0gSW52YWxpZFZlcnNpb25GaWVsZEVycm9yO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgJ3N1Y2Nlc3MnIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkU3VjY2Vzc0ZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRTdWNjZXNzRmllbGRFcnJvciA9IEludmFsaWRTdWNjZXNzRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlICdleHBpcmF0aW9uX3RpbWUnIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yIGV4dGVuZHMgRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yID0gSW52YWxpZEV4cGlyYXRpb25UaW1lRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlICd0b2tlbl90eXBlJyBmaWVsZCBpbiBhbiBleGVjdXRhYmxlIHJlc3BvbnNlIGlzIG1pc3Npbmcgb3IgaW52YWxpZC5cbiAqL1xuY2xhc3MgSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRUb2tlblR5cGVGaWVsZEVycm9yID0gSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3I7XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIHRoZSAnY29kZScgZmllbGQgaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRDb2RlRmllbGRFcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZENvZGVGaWVsZEVycm9yID0gSW52YWxpZENvZGVGaWVsZEVycm9yO1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiB0aGUgJ21lc3NhZ2UnIGZpZWxkIGluIGFuIGV4ZWN1dGFibGUgcmVzcG9uc2UgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkTWVzc2FnZUZpZWxkRXJyb3IgZXh0ZW5kcyBFeGVjdXRhYmxlUmVzcG9uc2VFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRNZXNzYWdlRmllbGRFcnJvciA9IEludmFsaWRNZXNzYWdlRmllbGRFcnJvcjtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gdGhlIHN1YmplY3QgdG9rZW4gaW4gYW4gZXhlY3V0YWJsZSByZXNwb25zZSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmNsYXNzIEludmFsaWRTdWJqZWN0VG9rZW5FcnJvciBleHRlbmRzIEV4ZWN1dGFibGVSZXNwb25zZUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFN1YmplY3RUb2tlbkVycm9yID0gSW52YWxpZFN1YmplY3RUb2tlbkVycm9yO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW52YWxpZFN1YmplY3RUb2tlbkVycm9yIiwiSW52YWxpZE1lc3NhZ2VGaWVsZEVycm9yIiwiSW52YWxpZENvZGVGaWVsZEVycm9yIiwiSW52YWxpZFRva2VuVHlwZUZpZWxkRXJyb3IiLCJJbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yIiwiSW52YWxpZFN1Y2Nlc3NGaWVsZEVycm9yIiwiSW52YWxpZFZlcnNpb25GaWVsZEVycm9yIiwiRXhlY3V0YWJsZVJlc3BvbnNlRXJyb3IiLCJFeGVjdXRhYmxlUmVzcG9uc2UiLCJTQU1MX1NVQkpFQ1RfVE9LRU5fVFlQRSIsIk9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMSIsIk9JRENfU1VCSkVDVF9UT0tFTl9UWVBFMiIsImNvbnN0cnVjdG9yIiwicmVzcG9uc2VKc29uIiwidmVyc2lvbiIsInN1Y2Nlc3MiLCJ1bmRlZmluZWQiLCJleHBpcmF0aW9uVGltZSIsImV4cGlyYXRpb25fdGltZSIsInRva2VuVHlwZSIsInRva2VuX3R5cGUiLCJzYW1sX3Jlc3BvbnNlIiwic3ViamVjdFRva2VuIiwiaWRfdG9rZW4iLCJjb2RlIiwibWVzc2FnZSIsImVycm9yQ29kZSIsImVycm9yTWVzc2FnZSIsImlzVmFsaWQiLCJpc0V4cGlyZWQiLCJNYXRoIiwicm91bmQiLCJEYXRlIiwibm93IiwiRXJyb3IiLCJzZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst oauth2common_1 = __webpack_require__(/*! ./oauth2common */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\n/**\n * The credentials JSON file type for external account authorized user clients.\n */ exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = \"external_account_authorized_user\";\nconst DEFAULT_TOKEN_URL = \"https://sts.{universeDomain}/v1/oauthtoken\";\n/**\n * Handler for token refresh requests sent to the token_url endpoint for external\n * authorized user credentials.\n */ class ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {\n    /**\n     * Initializes an ExternalAccountAuthorizedUserHandler instance.\n     * @param url The URL of the token refresh endpoint.\n     * @param transporter The transporter to use for the refresh request.\n     * @param clientAuthentication The client authentication credentials to use\n     *   for the refresh request.\n     */ constructor(url, transporter, clientAuthentication){\n        super(clientAuthentication);\n        this.url = url;\n        this.transporter = transporter;\n    }\n    /**\n     * Requests a new access token from the token_url endpoint using the provided\n     *   refresh token.\n     * @param refreshToken The refresh token to use to generate a new access token.\n     * @param additionalHeaders Optional additional headers to pass along the\n     *   request.\n     * @return A promise that resolves with the token refresh response containing\n     *   the requested access token and its expiration time.\n     */ async refreshToken(refreshToken, additionalHeaders) {\n        const values = new URLSearchParams({\n            grant_type: \"refresh_token\",\n            refresh_token: refreshToken\n        });\n        const headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            ...additionalHeaders\n        };\n        const opts = {\n            ...ExternalAccountAuthorizedUserHandler.RETRY_CONFIG,\n            url: this.url,\n            method: \"POST\",\n            headers,\n            data: values.toString(),\n            responseType: \"json\"\n        };\n        // Apply OAuth client authentication.\n        this.applyClientAuthenticationOptions(opts);\n        try {\n            const response = await this.transporter.request(opts);\n            // Successful response.\n            const tokenRefreshResponse = response.data;\n            tokenRefreshResponse.res = response;\n            return tokenRefreshResponse;\n        } catch (error) {\n            // Translate error to OAuthError.\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, // Preserve other fields from the original error.\n                error);\n            }\n            // Request could fail before the server responds.\n            throw error;\n        }\n    }\n}\n/**\n * External Account Authorized User Client. This is used for OAuth2 credentials\n * sourced using external identities through Workforce Identity Federation.\n * Obtaining the initial access and refresh token can be done through the\n * Google Cloud CLI.\n */ class ExternalAccountAuthorizedUserClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates an ExternalAccountAuthorizedUserClient instances using the\n     * provided JSON object loaded from a credentials files.\n     * An error is throws if the credential is not valid.\n     * @param options The external account authorized user option object typically\n     *   from the external accoutn authorized user JSON credential file.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        var _a;\n        super({\n            ...options,\n            ...additionalOptions\n        });\n        if (options.universe_domain) {\n            this.universeDomain = options.universe_domain;\n        }\n        this.refreshToken = options.refresh_token;\n        const clientAuth = {\n            confidentialClientType: \"basic\",\n            clientId: options.client_id,\n            clientSecret: options.client_secret\n        };\n        this.externalAccountAuthorizedUserHandler = new ExternalAccountAuthorizedUserHandler((_a = options.token_url) !== null && _a !== void 0 ? _a : DEFAULT_TOKEN_URL.replace(\"{universeDomain}\", this.universeDomain), this.transporter, clientAuth);\n        this.cachedAccessToken = null;\n        this.quotaProjectId = options.quota_project_id;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== \"number\") {\n            this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;\n        } else {\n            this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    }\n    async getAccessToken() {\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return GCP access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedAccessToken.access_token,\n            res: this.cachedAccessToken.res\n        };\n    }\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.\n     * @return A promise that resolves with the successful response.\n     */ async requestAsync(opts, reAuthRetried = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = requestHeaders[\"x-goog-user-project\"];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * @return A promise that resolves with the refreshed credential.\n     */ async refreshAccessTokenAsync() {\n        // Refresh the access token using the refresh token.\n        const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);\n        this.cachedAccessToken = {\n            access_token: refreshResponse.access_token,\n            expiry_date: new Date().getTime() + refreshResponse.expires_in * 1000,\n            res: refreshResponse.res\n        };\n        if (refreshResponse.refresh_token !== undefined) {\n            this.refreshToken = refreshResponse.refresh_token;\n        }\n        return this.cachedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param credentials The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */ isExpired(credentials) {\n        const now = new Date().getTime();\n        return credentials.expiry_date ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n}\nexports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJDQUEyQyxHQUFHQSw2Q0FBNkMsR0FBRyxLQUFLO0FBQ25HLE1BQU1JLGVBQWVDLG1CQUFPQSxDQUFDLDJGQUFjO0FBQzNDLE1BQU1DLGlCQUFpQkQsbUJBQU9BLENBQUMsK0ZBQWdCO0FBQy9DLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLDhEQUFRO0FBQ2pDLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDLHNCQUFRO0FBQy9CLE1BQU1JLHVCQUF1QkosbUJBQU9BLENBQUMsMkdBQXNCO0FBQzNEOztDQUVDLEdBQ0RMLDZDQUE2QyxHQUFHO0FBQ2hELE1BQU1VLG9CQUFvQjtBQUMxQjs7O0NBR0MsR0FDRCxNQUFNQyw2Q0FBNkNMLGVBQWVNLHNCQUFzQjtJQUNwRjs7Ozs7O0tBTUMsR0FDREMsWUFBWUMsR0FBRyxFQUFFQyxXQUFXLEVBQUVDLG9CQUFvQixDQUFFO1FBQ2hELEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNGLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLFdBQVcsR0FBR0E7SUFDdkI7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNELE1BQU1FLGFBQWFBLFlBQVksRUFBRUMsaUJBQWlCLEVBQUU7UUFDaEQsTUFBTUMsU0FBUyxJQUFJQyxnQkFBZ0I7WUFDL0JDLFlBQVk7WUFDWkMsZUFBZUw7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T0QsWUFBWUwsV0FBVyxHQUFHLElBQUksQ0FBQzFCLDJCQUEyQixHQUNqRTtJQUNWO0FBQ0o7QUFDQXhELDJDQUEyQyxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQuanM/ODZkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudCA9IGV4cG9ydHMuRVhURVJOQUxfQUNDT1VOVF9BVVRIT1JJWkVEX1VTRVJfVFlQRSA9IHZvaWQgMDtcbmNvbnN0IGF1dGhjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGhjbGllbnRcIik7XG5jb25zdCBvYXV0aDJjb21tb25fMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNvbW1vblwiKTtcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2Jhc2VleHRlcm5hbGNsaWVudFwiKTtcbi8qKlxuICogVGhlIGNyZWRlbnRpYWxzIEpTT04gZmlsZSB0eXBlIGZvciBleHRlcm5hbCBhY2NvdW50IGF1dGhvcml6ZWQgdXNlciBjbGllbnRzLlxuICovXG5leHBvcnRzLkVYVEVSTkFMX0FDQ09VTlRfQVVUSE9SSVpFRF9VU0VSX1RZUEUgPSAnZXh0ZXJuYWxfYWNjb3VudF9hdXRob3JpemVkX3VzZXInO1xuY29uc3QgREVGQVVMVF9UT0tFTl9VUkwgPSAnaHR0cHM6Ly9zdHMue3VuaXZlcnNlRG9tYWlufS92MS9vYXV0aHRva2VuJztcbi8qKlxuICogSGFuZGxlciBmb3IgdG9rZW4gcmVmcmVzaCByZXF1ZXN0cyBzZW50IHRvIHRoZSB0b2tlbl91cmwgZW5kcG9pbnQgZm9yIGV4dGVybmFsXG4gKiBhdXRob3JpemVkIHVzZXIgY3JlZGVudGlhbHMuXG4gKi9cbmNsYXNzIEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciBleHRlbmRzIG9hdXRoMmNvbW1vbl8xLk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgb2YgdGhlIHRva2VuIHJlZnJlc2ggZW5kcG9pbnQuXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydGVyIFRoZSB0cmFuc3BvcnRlciB0byB1c2UgZm9yIHRoZSByZWZyZXNoIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGNsaWVudEF1dGhlbnRpY2F0aW9uIFRoZSBjbGllbnQgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgdG8gdXNlXG4gICAgICogICBmb3IgdGhlIHJlZnJlc2ggcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHRyYW5zcG9ydGVyLCBjbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICBzdXBlcihjbGllbnRBdXRoZW50aWNhdGlvbik7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydGVyID0gdHJhbnNwb3J0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGEgbmV3IGFjY2VzcyB0b2tlbiBmcm9tIHRoZSB0b2tlbl91cmwgZW5kcG9pbnQgdXNpbmcgdGhlIHByb3ZpZGVkXG4gICAgICogICByZWZyZXNoIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gVGhlIHJlZnJlc2ggdG9rZW4gdG8gdXNlIHRvIGdlbmVyYXRlIGEgbmV3IGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbEhlYWRlcnMgT3B0aW9uYWwgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHBhc3MgYWxvbmcgdGhlXG4gICAgICogICByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdG9rZW4gcmVmcmVzaCByZXNwb25zZSBjb250YWluaW5nXG4gICAgICogICB0aGUgcmVxdWVzdGVkIGFjY2VzcyB0b2tlbiBhbmQgaXRzIGV4cGlyYXRpb24gdGltZS5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuLCBhZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAuLi5hZGRpdGlvbmFsSGVhZGVycyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIC4uLkV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlci5SRVRSWV9DT05GSUcsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgZGF0YTogdmFsdWVzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXBwbHkgT0F1dGggY2xpZW50IGF1dGhlbnRpY2F0aW9uLlxuICAgICAgICB0aGlzLmFwcGx5Q2xpZW50QXV0aGVudGljYXRpb25PcHRpb25zKG9wdHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgICAgICAvLyBTdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAgICAgICAgY29uc3QgdG9rZW5SZWZyZXNoUmVzcG9uc2UgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgdG9rZW5SZWZyZXNoUmVzcG9uc2UucmVzID0gcmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5SZWZyZXNoUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgZXJyb3IgdG8gT0F1dGhFcnJvci5cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGdheGlvc18xLkdheGlvc0Vycm9yICYmIGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIG9hdXRoMmNvbW1vbl8xLmdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSkoZXJyb3IucmVzcG9uc2UuZGF0YSwgXG4gICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgb3RoZXIgZmllbGRzIGZyb20gdGhlIG9yaWdpbmFsIGVycm9yLlxuICAgICAgICAgICAgICAgIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcXVlc3QgY291bGQgZmFpbCBiZWZvcmUgdGhlIHNlcnZlciByZXNwb25kcy5cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBFeHRlcm5hbCBBY2NvdW50IEF1dGhvcml6ZWQgVXNlciBDbGllbnQuIFRoaXMgaXMgdXNlZCBmb3IgT0F1dGgyIGNyZWRlbnRpYWxzXG4gKiBzb3VyY2VkIHVzaW5nIGV4dGVybmFsIGlkZW50aXRpZXMgdGhyb3VnaCBXb3JrZm9yY2UgSWRlbnRpdHkgRmVkZXJhdGlvbi5cbiAqIE9idGFpbmluZyB0aGUgaW5pdGlhbCBhY2Nlc3MgYW5kIHJlZnJlc2ggdG9rZW4gY2FuIGJlIGRvbmUgdGhyb3VnaCB0aGVcbiAqIEdvb2dsZSBDbG91ZCBDTEkuXG4gKi9cbmNsYXNzIEV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50IGV4dGVuZHMgYXV0aGNsaWVudF8xLkF1dGhDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBFeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudCBpbnN0YW5jZXMgdXNpbmcgdGhlXG4gICAgICogcHJvdmlkZWQgSlNPTiBvYmplY3QgbG9hZGVkIGZyb20gYSBjcmVkZW50aWFscyBmaWxlcy5cbiAgICAgKiBBbiBlcnJvciBpcyB0aHJvd3MgaWYgdGhlIGNyZWRlbnRpYWwgaXMgbm90IHZhbGlkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHRlcm5hbCBhY2NvdW50IGF1dGhvcml6ZWQgdXNlciBvcHRpb24gb2JqZWN0IHR5cGljYWxseVxuICAgICAqICAgZnJvbSB0aGUgZXh0ZXJuYWwgYWNjb3V0biBhdXRob3JpemVkIHVzZXIgSlNPTiBjcmVkZW50aWFsIGZpbGUuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zICoqREVQUkVDQVRFRCwgYWxsIG9wdGlvbnMgYXJlIGF2YWlsYWJsZSBpbiB0aGVcbiAgICAgKiAgIGBvcHRpb25zYCBwYXJhbWV0ZXIuKiogT3B0aW9uYWwgYWRkaXRpb25hbCBiZWhhdmlvciBjdXN0b21pemF0aW9uIG9wdGlvbnMuXG4gICAgICogICBUaGVzZSBjdXJyZW50bHkgY3VzdG9taXplIGV4cGlyYXRpb24gdGhyZXNob2xkIHRpbWUgYW5kIHdoZXRoZXIgdG8gcmV0cnlcbiAgICAgKiAgIG9uIDQwMS80MDMgQVBJIHJlcXVlc3QgZXJyb3JzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoeyAuLi5vcHRpb25zLCAuLi5hZGRpdGlvbmFsT3B0aW9ucyB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMudW5pdmVyc2VfZG9tYWluKSB7XG4gICAgICAgICAgICB0aGlzLnVuaXZlcnNlRG9tYWluID0gb3B0aW9ucy51bml2ZXJzZV9kb21haW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBvcHRpb25zLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIGNvbnN0IGNsaWVudEF1dGggPSB7XG4gICAgICAgICAgICBjb25maWRlbnRpYWxDbGllbnRUeXBlOiAnYmFzaWMnLFxuICAgICAgICAgICAgY2xpZW50SWQ6IG9wdGlvbnMuY2xpZW50X2lkLFxuICAgICAgICAgICAgY2xpZW50U2VjcmV0OiBvcHRpb25zLmNsaWVudF9zZWNyZXQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJIYW5kbGVyID1cbiAgICAgICAgICAgIG5ldyBFeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckhhbmRsZXIoKF9hID0gb3B0aW9ucy50b2tlbl91cmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERFRkFVTFRfVE9LRU5fVVJMLnJlcGxhY2UoJ3t1bml2ZXJzZURvbWFpbn0nLCB0aGlzLnVuaXZlcnNlRG9tYWluKSwgdGhpcy50cmFuc3BvcnRlciwgY2xpZW50QXV0aCk7XG4gICAgICAgIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLnF1b3RhUHJvamVjdElkID0gb3B0aW9ucy5xdW90YV9wcm9qZWN0X2lkO1xuICAgICAgICAvLyBBcyB0aHJlc2hvbGQgY291bGQgYmUgemVybyxcbiAgICAgICAgLy8gZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIHx8IEVYUElSQVRJT05fVElNRV9PRkZTRVQgd2lsbCBvdmVycmlkZSB0aGVcbiAgICAgICAgLy8gemVybyB2YWx1ZS5cbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkaXRpb25hbE9wdGlvbnMgPT09IG51bGwgfHwgYWRkaXRpb25hbE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxPcHRpb25zLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcykgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9IGJhc2VleHRlcm5hbGNsaWVudF8xLkVYUElSQVRJT05fVElNRV9PRkZTRVQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9IGFkZGl0aW9uYWxPcHRpb25zXG4gICAgICAgICAgICAgICAgLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcmNlUmVmcmVzaE9uRmFpbHVyZSA9ICEhKGFkZGl0aW9uYWxPcHRpb25zID09PSBudWxsIHx8IGFkZGl0aW9uYWxPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZGRpdGlvbmFsT3B0aW9ucy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgLy8gSWYgY2FjaGVkIGFjY2VzcyB0b2tlbiBpcyB1bmF2YWlsYWJsZSBvciBleHBpcmVkLCBmb3JjZSByZWZyZXNoLlxuICAgICAgICBpZiAoIXRoaXMuY2FjaGVkQWNjZXNzVG9rZW4gfHwgdGhpcy5pc0V4cGlyZWQodGhpcy5jYWNoZWRBY2Nlc3NUb2tlbikpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gR0NQIGFjY2VzcyB0b2tlbiBpbiBHZXRBY2Nlc3NUb2tlblJlc3BvbnNlIGZvcm1hdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLmNhY2hlZEFjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIHJlczogdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbi5yZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldFJlcXVlc3RIZWFkZXJzKCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRBY2Nlc3NUb2tlbigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FjY2Vzc1Rva2VuUmVzcG9uc2UudG9rZW59YCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH1cbiAgICByZXF1ZXN0KG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QXN5bmMob3B0cykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSwgZS5yZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdXRoZW50aWNhdGVzIHRoZSBwcm92aWRlZCBIVFRQIHJlcXVlc3QsIHByb2Nlc3NlcyBpdCBhbmQgcmVzb2x2ZXMgd2l0aCB0aGVcbiAgICAgKiByZXR1cm5lZCByZXNwb25zZS5cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgSFRUUCByZXF1ZXN0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHJlQXV0aFJldHJpZWQgV2hldGhlciB0aGUgY3VycmVudCBhdHRlbXB0IGlzIGEgcmV0cnkgYWZ0ZXIgYSBmYWlsZWQgYXR0ZW1wdCBkdWUgdG8gYW4gYXV0aCBmYWlsdXJlLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0QXN5bmMob3B0cywgcmVBdXRoUmV0cmllZCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0SGVhZGVycygpO1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RIZWFkZXJzICYmIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXSA9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdEhlYWRlcnMgJiYgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbikge1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBlLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIFJldHJ5IHRoZSByZXF1ZXN0IGZvciBtZXRhZGF0YSBpZiB0aGUgZm9sbG93aW5nIGNyaXRlcmlhIGFyZSB0cnVlOlxuICAgICAgICAgICAgICAgIC8vIC0gV2UgaGF2ZW4ndCBhbHJlYWR5IHJldHJpZWQuICBJdCBvbmx5IG1ha2VzIHNlbnNlIHRvIHJldHJ5IG9uY2UuXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVzcG9uc2Ugd2FzIGEgNDAxIG9yIGEgNDAzXG4gICAgICAgICAgICAgICAgLy8gLSBUaGUgcmVxdWVzdCBkaWRuJ3Qgc2VuZCBhIHJlYWRhYmxlU3RyZWFtXG4gICAgICAgICAgICAgICAgLy8gLSBmb3JjZVJlZnJlc2hPbkZhaWx1cmUgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSByZXMuY29uZmlnLmRhdGEgaW5zdGFuY2VvZiBzdHJlYW0uUmVhZGFibGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdXRoRXJyID0gc3RhdHVzQ29kZSA9PT0gNDAxIHx8IHN0YXR1c0NvZGUgPT09IDQwMztcbiAgICAgICAgICAgICAgICBpZiAoIXJlQXV0aFJldHJpZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNBdXRoRXJyICYmXG4gICAgICAgICAgICAgICAgICAgICFpc1JlYWRhYmxlU3RyZWFtICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVxdWVzdEFzeW5jKG9wdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgdG9rZW4gcmVmcmVzaCwgZXZlbiBpZiB1bmV4cGlyZWQgdG9rZW5zIGFyZSBjdXJyZW50bHkgY2FjaGVkLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVmcmVzaGVkIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKSB7XG4gICAgICAgIC8vIFJlZnJlc2ggdGhlIGFjY2VzcyB0b2tlbiB1c2luZyB0aGUgcmVmcmVzaCB0b2tlbi5cbiAgICAgICAgY29uc3QgcmVmcmVzaFJlc3BvbnNlID0gYXdhaXQgdGhpcy5leHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckhhbmRsZXIucmVmcmVzaFRva2VuKHRoaXMucmVmcmVzaFRva2VuKTtcbiAgICAgICAgdGhpcy5jYWNoZWRBY2Nlc3NUb2tlbiA9IHtcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogcmVmcmVzaFJlc3BvbnNlLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHJlZnJlc2hSZXNwb25zZS5leHBpcmVzX2luICogMTAwMCxcbiAgICAgICAgICAgIHJlczogcmVmcmVzaFJlc3BvbnNlLnJlcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlZnJlc2hSZXNwb25zZS5yZWZyZXNoX3Rva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gcmVmcmVzaFJlc3BvbnNlLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkQWNjZXNzVG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgY3JlZGVudGlhbHMgYXJlIGV4cGlyZWQgb3Igbm90LlxuICAgICAqIElmIHRoZXJlIGlzIG5vIGV4cGlyeSB0aW1lLCBhc3N1bWVzIHRoZSB0b2tlbiBpcyBub3QgZXhwaXJlZCBvciBleHBpcmluZy5cbiAgICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgVGhlIGNyZWRlbnRpYWxzIHRvIGNoZWNrIGZvciBleHBpcmF0aW9uLlxuICAgICAqIEByZXR1cm4gV2hldGhlciB0aGUgY3JlZGVudGlhbHMgYXJlIGV4cGlyZWQgb3Igbm90LlxuICAgICAqL1xuICAgIGlzRXhwaXJlZChjcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWxzLmV4cGlyeV9kYXRlXG4gICAgICAgICAgICA/IG5vdyA+PSBjcmVkZW50aWFscy5leHBpcnlfZGF0ZSAtIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuRXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnQgPSBFeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50IiwiRVhURVJOQUxfQUNDT1VOVF9BVVRIT1JJWkVEX1VTRVJfVFlQRSIsImF1dGhjbGllbnRfMSIsInJlcXVpcmUiLCJvYXV0aDJjb21tb25fMSIsImdheGlvc18xIiwic3RyZWFtIiwiYmFzZWV4dGVybmFsY2xpZW50XzEiLCJERUZBVUxUX1RPS0VOX1VSTCIsIkV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VySGFuZGxlciIsIk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsInVybCIsInRyYW5zcG9ydGVyIiwiY2xpZW50QXV0aGVudGljYXRpb24iLCJyZWZyZXNoVG9rZW4iLCJhZGRpdGlvbmFsSGVhZGVycyIsInZhbHVlcyIsIlVSTFNlYXJjaFBhcmFtcyIsImdyYW50X3R5cGUiLCJyZWZyZXNoX3Rva2VuIiwiaGVhZGVycyIsIm9wdHMiLCJSRVRSWV9DT05GSUciLCJtZXRob2QiLCJkYXRhIiwidG9TdHJpbmciLCJyZXNwb25zZVR5cGUiLCJhcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uT3B0aW9ucyIsInJlc3BvbnNlIiwicmVxdWVzdCIsInRva2VuUmVmcmVzaFJlc3BvbnNlIiwicmVzIiwiZXJyb3IiLCJHYXhpb3NFcnJvciIsImdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSIsIkF1dGhDbGllbnQiLCJvcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJfYSIsInVuaXZlcnNlX2RvbWFpbiIsInVuaXZlcnNlRG9tYWluIiwiY2xpZW50QXV0aCIsImNvbmZpZGVudGlhbENsaWVudFR5cGUiLCJjbGllbnRJZCIsImNsaWVudF9pZCIsImNsaWVudFNlY3JldCIsImNsaWVudF9zZWNyZXQiLCJleHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckhhbmRsZXIiLCJ0b2tlbl91cmwiLCJyZXBsYWNlIiwiY2FjaGVkQWNjZXNzVG9rZW4iLCJxdW90YVByb2plY3RJZCIsInF1b3RhX3Byb2plY3RfaWQiLCJlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMiLCJFWFBJUkFUSU9OX1RJTUVfT0ZGU0VUIiwiZm9yY2VSZWZyZXNoT25GYWlsdXJlIiwiZ2V0QWNjZXNzVG9rZW4iLCJpc0V4cGlyZWQiLCJyZWZyZXNoQWNjZXNzVG9rZW5Bc3luYyIsInRva2VuIiwiYWNjZXNzX3Rva2VuIiwiZ2V0UmVxdWVzdEhlYWRlcnMiLCJhY2Nlc3NUb2tlblJlc3BvbnNlIiwiQXV0aG9yaXphdGlvbiIsImFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyIsImNhbGxiYWNrIiwicmVxdWVzdEFzeW5jIiwidGhlbiIsInIiLCJlIiwicmVBdXRoUmV0cmllZCIsInJlcXVlc3RIZWFkZXJzIiwic3RhdHVzQ29kZSIsInN0YXR1cyIsImlzUmVhZGFibGVTdHJlYW0iLCJjb25maWciLCJSZWFkYWJsZSIsImlzQXV0aEVyciIsInJlZnJlc2hSZXNwb25zZSIsImV4cGlyeV9kYXRlIiwiRGF0ZSIsImdldFRpbWUiLCJleHBpcmVzX2luIiwidW5kZWZpbmVkIiwiY3JlZGVudGlhbHMiLCJub3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/externalclient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ExternalAccountClient = void 0;\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst identitypoolclient_1 = __webpack_require__(/*! ./identitypoolclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\");\nconst awsclient_1 = __webpack_require__(/*! ./awsclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js\");\nconst pluggable_auth_client_1 = __webpack_require__(/*! ./pluggable-auth-client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\n/**\n * Dummy class with no constructor. Developers are expected to use fromJSON.\n */ class ExternalAccountClient {\n    constructor(){\n        throw new Error(\"ExternalAccountClients should be initialized via: \" + \"ExternalAccountClient.fromJSON(), \" + \"directly via explicit constructors, eg. \" + \"new AwsClient(options), new IdentityPoolClient(options), new\" + \"PluggableAuthClientOptions, or via \" + \"new GoogleAuth(options).getClient()\");\n    }\n    /**\n     * This static method will instantiate the\n     * corresponding type of external account credential depending on the\n     * underlying credential source.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     * @return A BaseExternalAccountClient instance or null if the options\n     *   provided do not correspond to an external account credential.\n     */ static fromJSON(options, additionalOptions) {\n        var _a, _b;\n        if (options && options.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            if ((_a = options.credential_source) === null || _a === void 0 ? void 0 : _a.environment_id) {\n                return new awsclient_1.AwsClient(options, additionalOptions);\n            } else if ((_b = options.credential_source) === null || _b === void 0 ? void 0 : _b.executable) {\n                return new pluggable_auth_client_1.PluggableAuthClient(options, additionalOptions);\n            } else {\n                return new identitypoolclient_1.IdentityPoolClient(options, additionalOptions);\n            }\n        } else {\n            return null;\n        }\n    }\n}\nexports.ExternalAccountClient = ExternalAccountClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9leHRlcm5hbGNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUcsdUJBQXVCQyxtQkFBT0EsQ0FBQywyR0FBc0I7QUFDM0QsTUFBTUMsdUJBQXVCRCxtQkFBT0EsQ0FBQywyR0FBc0I7QUFDM0QsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMseUZBQWE7QUFDekMsTUFBTUcsMEJBQTBCSCxtQkFBT0EsQ0FBQyxpSEFBeUI7QUFDakU7O0NBRUMsR0FDRCxNQUFNRjtJQUNGTSxhQUFjO1FBQ1YsTUFBTSxJQUFJQyxNQUFNLHVEQUNaLHVDQUNBLDZDQUNBLGlFQUNBLHdDQUNBO0lBQ1I7SUFDQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDRCxPQUFPQyxTQUFTQyxPQUFPLEVBQUVDLGlCQUFpQixFQUFFO1FBQ3hDLElBQUlDLElBQUlDO1FBQ1IsSUFBSUgsV0FBV0EsUUFBUUksSUFBSSxLQUFLWixxQkFBcUJhLHFCQUFxQixFQUFFO1lBQ3hFLElBQUksQ0FBQ0gsS0FBS0YsUUFBUU0saUJBQWlCLE1BQU0sUUFBUUosT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSyxjQUFjLEVBQUU7Z0JBQ3pGLE9BQU8sSUFBSVosWUFBWWEsU0FBUyxDQUFDUixTQUFTQztZQUM5QyxPQUNLLElBQUksQ0FBQ0UsS0FBS0gsUUFBUU0saUJBQWlCLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHTSxVQUFVLEVBQUU7Z0JBQzFGLE9BQU8sSUFBSWIsd0JBQXdCYyxtQkFBbUIsQ0FBQ1YsU0FBU0M7WUFDcEUsT0FDSztnQkFDRCxPQUFPLElBQUlQLHFCQUFxQmlCLGtCQUFrQixDQUFDWCxTQUFTQztZQUNoRTtRQUNKLE9BQ0s7WUFDRCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0FaLDZCQUE2QixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZXh0ZXJuYWxjbGllbnQuanM/OWM5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FeHRlcm5hbEFjY291bnRDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2Jhc2VleHRlcm5hbGNsaWVudFwiKTtcbmNvbnN0IGlkZW50aXR5cG9vbGNsaWVudF8xID0gcmVxdWlyZShcIi4vaWRlbnRpdHlwb29sY2xpZW50XCIpO1xuY29uc3QgYXdzY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hd3NjbGllbnRcIik7XG5jb25zdCBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3BsdWdnYWJsZS1hdXRoLWNsaWVudFwiKTtcbi8qKlxuICogRHVtbXkgY2xhc3Mgd2l0aCBubyBjb25zdHJ1Y3Rvci4gRGV2ZWxvcGVycyBhcmUgZXhwZWN0ZWQgdG8gdXNlIGZyb21KU09OLlxuICovXG5jbGFzcyBFeHRlcm5hbEFjY291bnRDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVybmFsQWNjb3VudENsaWVudHMgc2hvdWxkIGJlIGluaXRpYWxpemVkIHZpYTogJyArXG4gICAgICAgICAgICAnRXh0ZXJuYWxBY2NvdW50Q2xpZW50LmZyb21KU09OKCksICcgK1xuICAgICAgICAgICAgJ2RpcmVjdGx5IHZpYSBleHBsaWNpdCBjb25zdHJ1Y3RvcnMsIGVnLiAnICtcbiAgICAgICAgICAgICduZXcgQXdzQ2xpZW50KG9wdGlvbnMpLCBuZXcgSWRlbnRpdHlQb29sQ2xpZW50KG9wdGlvbnMpLCBuZXcnICtcbiAgICAgICAgICAgICdQbHVnZ2FibGVBdXRoQ2xpZW50T3B0aW9ucywgb3IgdmlhICcgK1xuICAgICAgICAgICAgJ25ldyBHb29nbGVBdXRoKG9wdGlvbnMpLmdldENsaWVudCgpJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgc3RhdGljIG1ldGhvZCB3aWxsIGluc3RhbnRpYXRlIHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgdHlwZSBvZiBleHRlcm5hbCBhY2NvdW50IGNyZWRlbnRpYWwgZGVwZW5kaW5nIG9uIHRoZVxuICAgICAqIHVuZGVybHlpbmcgY3JlZGVudGlhbCBzb3VyY2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGV4dGVybmFsIGFjY291bnQgb3B0aW9ucyBvYmplY3QgdHlwaWNhbGx5IGxvYWRlZFxuICAgICAqICAgZnJvbSB0aGUgZXh0ZXJuYWwgYWNjb3VudCBKU09OIGNyZWRlbnRpYWwgZmlsZS5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnMgKipERVBSRUNBVEVELCBhbGwgb3B0aW9ucyBhcmUgYXZhaWxhYmxlIGluIHRoZVxuICAgICAqICAgYG9wdGlvbnNgIHBhcmFtZXRlci4qKiBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb24gb3B0aW9ucy5cbiAgICAgKiAgIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmQgd2hldGhlciB0byByZXRyeVxuICAgICAqICAgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICogQHJldHVybiBBIEJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQgaW5zdGFuY2Ugb3IgbnVsbCBpZiB0aGUgb3B0aW9uc1xuICAgICAqICAgcHJvdmlkZWQgZG8gbm90IGNvcnJlc3BvbmQgdG8gYW4gZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihvcHRpb25zLCBhZGRpdGlvbmFsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgPT09IGJhc2VleHRlcm5hbGNsaWVudF8xLkVYVEVSTkFMX0FDQ09VTlRfVFlQRSkge1xuICAgICAgICAgICAgaWYgKChfYSA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbnZpcm9ubWVudF9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXdzY2xpZW50XzEuQXdzQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChfYiA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5leGVjdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMS5QbHVnZ2FibGVBdXRoQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaWRlbnRpdHlwb29sY2xpZW50XzEuSWRlbnRpdHlQb29sQ2xpZW50KG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbEFjY291bnRDbGllbnQgPSBFeHRlcm5hbEFjY291bnRDbGllbnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJFeHRlcm5hbEFjY291bnRDbGllbnQiLCJiYXNlZXh0ZXJuYWxjbGllbnRfMSIsInJlcXVpcmUiLCJpZGVudGl0eXBvb2xjbGllbnRfMSIsImF3c2NsaWVudF8xIiwicGx1Z2dhYmxlX2F1dGhfY2xpZW50XzEiLCJjb25zdHJ1Y3RvciIsIkVycm9yIiwiZnJvbUpTT04iLCJvcHRpb25zIiwiYWRkaXRpb25hbE9wdGlvbnMiLCJfYSIsIl9iIiwidHlwZSIsIkVYVEVSTkFMX0FDQ09VTlRfVFlQRSIsImNyZWRlbnRpYWxfc291cmNlIiwiZW52aXJvbm1lbnRfaWQiLCJBd3NDbGllbnQiLCJleGVjdXRhYmxlIiwiUGx1Z2dhYmxlQXV0aENsaWVudCIsIklkZW50aXR5UG9vbENsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2024 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FileSubjectTokenSupplier = void 0;\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n// fs.readfile is undefined in browser karma tests causing\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\n// src/index.ts.\n// Fallback to void function to avoid promisify throwing a TypeError.\nconst readFile = (0, util_1.promisify)((_a = fs.readFile) !== null && _a !== void 0 ? _a : ()=>{});\nconst realpath = (0, util_1.promisify)((_b = fs.realpath) !== null && _b !== void 0 ? _b : ()=>{});\nconst lstat = (0, util_1.promisify)((_c = fs.lstat) !== null && _c !== void 0 ? _c : ()=>{});\n/**\n * Internal subject token supplier implementation used when a file location\n * is configured in the credential configuration used to build an {@link IdentityPoolClient}\n */ class FileSubjectTokenSupplier {\n    /**\n     * Instantiates a new file based subject token supplier.\n     * @param opts The file subject token supplier options to build the supplier\n     *   with.\n     */ constructor(opts){\n        this.filePath = opts.filePath;\n        this.formatType = opts.formatType;\n        this.subjectTokenFieldName = opts.subjectTokenFieldName;\n    }\n    /**\n     * Returns the subject token stored at the file specified in the constructor.\n     * @param context {@link ExternalAccountSupplierContext} from the calling\n     *   {@link IdentityPoolClient}, contains the requested audience and subject\n     *   token type for the external account identity. Not used.\n     */ async getSubjectToken(context) {\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        let parsedFilePath = this.filePath;\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            parsedFilePath = await realpath(parsedFilePath);\n            if (!(await lstat(parsedFilePath)).isFile()) {\n                throw new Error();\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${parsedFilePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        let subjectToken;\n        const rawText = await readFile(parsedFilePath, {\n            encoding: \"utf8\"\n        });\n        if (this.formatType === \"text\") {\n            subjectToken = rawText;\n        } else if (this.formatType === \"json\" && this.subjectTokenFieldName) {\n            const json = JSON.parse(rawText);\n            subjectToken = json[this.subjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error(\"Unable to parse the subject_token from the credential_source file\");\n        }\n        return subjectToken;\n    }\n}\nexports.FileSubjectTokenSupplier = FileSubjectTokenSupplier;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9maWxlc3ViamVjdHRva2Vuc3VwcGxpZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsSUFBSUEsSUFBSUMsSUFBSUM7QUFDWkMsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdDQUFnQyxHQUFHLEtBQUs7QUFDeEMsTUFBTUcsU0FBU0MsbUJBQU9BLENBQUMsa0JBQU07QUFDN0IsTUFBTUMsS0FBS0QsbUJBQU9BLENBQUMsY0FBSTtBQUN2QiwwREFBMEQ7QUFDMUQseUVBQXlFO0FBQ3pFLGdCQUFnQjtBQUNoQixxRUFBcUU7QUFDckUsTUFBTUUsV0FBVyxDQUFDLEdBQUdILE9BQU9JLFNBQVMsRUFBRSxDQUFDWixLQUFLVSxHQUFHQyxRQUFRLE1BQU0sUUFBUVgsT0FBTyxLQUFLLElBQUlBLEtBQU0sS0FBUTtBQUNwRyxNQUFNYSxXQUFXLENBQUMsR0FBR0wsT0FBT0ksU0FBUyxFQUFFLENBQUNYLEtBQUtTLEdBQUdHLFFBQVEsTUFBTSxRQUFRWixPQUFPLEtBQUssSUFBSUEsS0FBTSxLQUFRO0FBQ3BHLE1BQU1hLFFBQVEsQ0FBQyxHQUFHTixPQUFPSSxTQUFTLEVBQUUsQ0FBQ1YsS0FBS1EsR0FBR0ksS0FBSyxNQUFNLFFBQVFaLE9BQU8sS0FBSyxJQUFJQSxLQUFNLEtBQVE7QUFDOUY7OztDQUdDLEdBQ0QsTUFBTUs7SUFDRjs7OztLQUlDLEdBQ0RRLFlBQVlDLElBQUksQ0FBRTtRQUNkLElBQUksQ0FBQ0MsUUFBUSxHQUFHRCxLQUFLQyxRQUFRO1FBQzdCLElBQUksQ0FBQ0MsVUFBVSxHQUFHRixLQUFLRSxVQUFVO1FBQ2pDLElBQUksQ0FBQ0MscUJBQXFCLEdBQUdILEtBQUtHLHFCQUFxQjtJQUMzRDtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTUMsZ0JBQWdCQyxPQUFPLEVBQUU7UUFDM0IsMEVBQTBFO1FBQzFFLGlCQUFpQjtRQUNqQixJQUFJQyxpQkFBaUIsSUFBSSxDQUFDTCxRQUFRO1FBQ2xDLElBQUk7WUFDQSx3RUFBd0U7WUFDeEUscUJBQXFCO1lBQ3JCSyxpQkFBaUIsTUFBTVQsU0FBU1M7WUFDaEMsSUFBSSxDQUFDLENBQUMsTUFBTVIsTUFBTVEsZUFBYyxFQUFHQyxNQUFNLElBQUk7Z0JBQ3pDLE1BQU0sSUFBSUM7WUFDZDtRQUNKLEVBQ0EsT0FBT0MsS0FBSztZQUNSLElBQUlBLGVBQWVELE9BQU87Z0JBQ3RCQyxJQUFJQyxPQUFPLEdBQUcsQ0FBQyxZQUFZLEVBQUVKLGVBQWUsc0NBQXNDLEVBQUVHLElBQUlDLE9BQU8sQ0FBQyxDQUFDO1lBQ3JHO1lBQ0EsTUFBTUQ7UUFDVjtRQUNBLElBQUlFO1FBQ0osTUFBTUMsVUFBVSxNQUFNakIsU0FBU1csZ0JBQWdCO1lBQUVPLFVBQVU7UUFBTztRQUNsRSxJQUFJLElBQUksQ0FBQ1gsVUFBVSxLQUFLLFFBQVE7WUFDNUJTLGVBQWVDO1FBQ25CLE9BQ0ssSUFBSSxJQUFJLENBQUNWLFVBQVUsS0FBSyxVQUFVLElBQUksQ0FBQ0MscUJBQXFCLEVBQUU7WUFDL0QsTUFBTVcsT0FBT0MsS0FBS0MsS0FBSyxDQUFDSjtZQUN4QkQsZUFBZUcsSUFBSSxDQUFDLElBQUksQ0FBQ1gscUJBQXFCLENBQUM7UUFDbkQ7UUFDQSxJQUFJLENBQUNRLGNBQWM7WUFDZixNQUFNLElBQUlILE1BQU07UUFDcEI7UUFDQSxPQUFPRztJQUNYO0FBQ0o7QUFDQXRCLGdDQUFnQyxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZmlsZXN1YmplY3R0b2tlbnN1cHBsaWVyLmpzPzkzZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyNCBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbnZhciBfYSwgX2IsIF9jO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWxlU3ViamVjdFRva2VuU3VwcGxpZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuLy8gZnMucmVhZGZpbGUgaXMgdW5kZWZpbmVkIGluIGJyb3dzZXIga2FybWEgdGVzdHMgY2F1c2luZ1xuLy8gYG5wbSBydW4gYnJvd3Nlci10ZXN0YCB0byBmYWlsIGFzIHRlc3Qub2F1dGgyLnRzIGltcG9ydHMgdGhpcyBmaWxlIHZpYVxuLy8gc3JjL2luZGV4LnRzLlxuLy8gRmFsbGJhY2sgdG8gdm9pZCBmdW5jdGlvbiB0byBhdm9pZCBwcm9taXNpZnkgdGhyb3dpbmcgYSBUeXBlRXJyb3IuXG5jb25zdCByZWFkRmlsZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KSgoX2EgPSBmcy5yZWFkRmlsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKCgpID0+IHsgfSkpO1xuY29uc3QgcmVhbHBhdGggPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoKF9iID0gZnMucmVhbHBhdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICgoKSA9PiB7IH0pKTtcbmNvbnN0IGxzdGF0ID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKChfYyA9IGZzLmxzdGF0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoKCkgPT4geyB9KSk7XG4vKipcbiAqIEludGVybmFsIHN1YmplY3QgdG9rZW4gc3VwcGxpZXIgaW1wbGVtZW50YXRpb24gdXNlZCB3aGVuIGEgZmlsZSBsb2NhdGlvblxuICogaXMgY29uZmlndXJlZCBpbiB0aGUgY3JlZGVudGlhbCBjb25maWd1cmF0aW9uIHVzZWQgdG8gYnVpbGQgYW4ge0BsaW5rIElkZW50aXR5UG9vbENsaWVudH1cbiAqL1xuY2xhc3MgRmlsZVN1YmplY3RUb2tlblN1cHBsaWVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYSBuZXcgZmlsZSBiYXNlZCBzdWJqZWN0IHRva2VuIHN1cHBsaWVyLlxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBmaWxlIHN1YmplY3QgdG9rZW4gc3VwcGxpZXIgb3B0aW9ucyB0byBidWlsZCB0aGUgc3VwcGxpZXJcbiAgICAgKiAgIHdpdGguXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB0aGlzLmZpbGVQYXRoID0gb3B0cy5maWxlUGF0aDtcbiAgICAgICAgdGhpcy5mb3JtYXRUeXBlID0gb3B0cy5mb3JtYXRUeXBlO1xuICAgICAgICB0aGlzLnN1YmplY3RUb2tlbkZpZWxkTmFtZSA9IG9wdHMuc3ViamVjdFRva2VuRmllbGROYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdWJqZWN0IHRva2VuIHN0b3JlZCBhdCB0aGUgZmlsZSBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBjb250ZXh0IHtAbGluayBFeHRlcm5hbEFjY291bnRTdXBwbGllckNvbnRleHR9IGZyb20gdGhlIGNhbGxpbmdcbiAgICAgKiAgIHtAbGluayBJZGVudGl0eVBvb2xDbGllbnR9LCBjb250YWlucyB0aGUgcmVxdWVzdGVkIGF1ZGllbmNlIGFuZCBzdWJqZWN0XG4gICAgICogICB0b2tlbiB0eXBlIGZvciB0aGUgZXh0ZXJuYWwgYWNjb3VudCBpZGVudGl0eS4gTm90IHVzZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3ViamVjdFRva2VuKGNvbnRleHQpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIGEgZmlsZSBhdCB0aGUgcGF0aC4gbHN0YXRTeW5jIHdpbGwgdGhyb3cgaWYgdGhlcmUgaXNcbiAgICAgICAgLy8gbm90aGluZyB0aGVyZS5cbiAgICAgICAgbGV0IHBhcnNlZEZpbGVQYXRoID0gdGhpcy5maWxlUGF0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFJlc29sdmUgcGF0aCB0byBhY3R1YWwgZmlsZSBpbiBjYXNlIG9mIHN5bWxpbmsuIEV4cGVjdCBhIHRocm93biBlcnJvclxuICAgICAgICAgICAgLy8gaWYgbm90IHJlc29sdmFibGUuXG4gICAgICAgICAgICBwYXJzZWRGaWxlUGF0aCA9IGF3YWl0IHJlYWxwYXRoKHBhcnNlZEZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmICghKGF3YWl0IGxzdGF0KHBhcnNlZEZpbGVQYXRoKSkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBUaGUgZmlsZSBhdCAke3BhcnNlZEZpbGVQYXRofSBkb2VzIG5vdCBleGlzdCwgb3IgaXQgaXMgbm90IGEgZmlsZS4gJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJqZWN0VG9rZW47XG4gICAgICAgIGNvbnN0IHJhd1RleHQgPSBhd2FpdCByZWFkRmlsZShwYXJzZWRGaWxlUGF0aCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgICAgICBpZiAodGhpcy5mb3JtYXRUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHN1YmplY3RUb2tlbiA9IHJhd1RleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mb3JtYXRUeXBlID09PSAnanNvbicgJiYgdGhpcy5zdWJqZWN0VG9rZW5GaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHJhd1RleHQpO1xuICAgICAgICAgICAgc3ViamVjdFRva2VuID0ganNvblt0aGlzLnN1YmplY3RUb2tlbkZpZWxkTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdWJqZWN0VG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIHRoZSBzdWJqZWN0X3Rva2VuIGZyb20gdGhlIGNyZWRlbnRpYWxfc291cmNlIGZpbGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViamVjdFRva2VuO1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsZVN1YmplY3RUb2tlblN1cHBsaWVyID0gRmlsZVN1YmplY3RUb2tlblN1cHBsaWVyO1xuIl0sIm5hbWVzIjpbIl9hIiwiX2IiLCJfYyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRmlsZVN1YmplY3RUb2tlblN1cHBsaWVyIiwidXRpbF8xIiwicmVxdWlyZSIsImZzIiwicmVhZEZpbGUiLCJwcm9taXNpZnkiLCJyZWFscGF0aCIsImxzdGF0IiwiY29uc3RydWN0b3IiLCJvcHRzIiwiZmlsZVBhdGgiLCJmb3JtYXRUeXBlIiwic3ViamVjdFRva2VuRmllbGROYW1lIiwiZ2V0U3ViamVjdFRva2VuIiwiY29udGV4dCIsInBhcnNlZEZpbGVQYXRoIiwiaXNGaWxlIiwiRXJyb3IiLCJlcnIiLCJtZXNzYWdlIiwic3ViamVjdFRva2VuIiwicmF3VGV4dCIsImVuY29kaW5nIiwianNvbiIsIkpTT04iLCJwYXJzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/googleauth.js":
/*!***********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/googleauth.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar _GoogleAuth_instances, _GoogleAuth_pendingAuthClient, _GoogleAuth_prepareAndCacheClient, _GoogleAuth_determineClient;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GoogleAuth = exports.GoogleAuthExceptionMessages = exports.CLOUD_SDK_CLIENT_ID = void 0;\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(rsc)/./node_modules/gcp-metadata/build/src/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nconst computeclient_1 = __webpack_require__(/*! ./computeclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js\");\nconst idtokenclient_1 = __webpack_require__(/*! ./idtokenclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\");\nconst envDetect_1 = __webpack_require__(/*! ./envDetect */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js\");\nconst jwtclient_1 = __webpack_require__(/*! ./jwtclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\");\nconst refreshclient_1 = __webpack_require__(/*! ./refreshclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\");\nconst impersonated_1 = __webpack_require__(/*! ./impersonated */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js\");\nconst externalclient_1 = __webpack_require__(/*! ./externalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js\");\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst externalAccountAuthorizedUserClient_1 = __webpack_require__(/*! ./externalAccountAuthorizedUserClient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/google-auth-library/build/src/util.js\");\nexports.CLOUD_SDK_CLIENT_ID = \"764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com\";\nexports.GoogleAuthExceptionMessages = {\n    API_KEY_WITH_CREDENTIALS: \"API Keys and Credentials are mutually exclusive authentication methods and cannot be used together.\",\n    NO_PROJECT_ID_FOUND: \"Unable to detect a Project Id in the current environment. \\n\" + \"To learn more about authentication and Google APIs, visit: \\n\" + \"https://cloud.google.com/docs/authentication/getting-started\",\n    NO_CREDENTIALS_FOUND: \"Unable to find credentials in current environment. \\n\" + \"To learn more about authentication and Google APIs, visit: \\n\" + \"https://cloud.google.com/docs/authentication/getting-started\",\n    NO_ADC_FOUND: \"Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.\",\n    NO_UNIVERSE_DOMAIN_FOUND: \"Unable to detect a Universe Domain in the current environment.\\n\" + \"To learn more about Universe Domain retrieval, visit: \\n\" + \"https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys\"\n};\nclass GoogleAuth {\n    // Note:  this properly is only public to satisfy unit tests.\n    // https://github.com/Microsoft/TypeScript/issues/5228\n    get isGCE() {\n        return this.checkIsGCE;\n    }\n    /**\n     * Configuration is resolved in the following order of precedence:\n     * - {@link GoogleAuthOptions.credentials `credentials`}\n     * - {@link GoogleAuthOptions.keyFilename `keyFilename`}\n     * - {@link GoogleAuthOptions.keyFile `keyFile`}\n     *\n     * {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the\n     * {@link AuthClient `AuthClient`s}.\n     *\n     * @param opts\n     */ constructor(opts = {}){\n        _GoogleAuth_instances.add(this);\n        /**\n         * Caches a value indicating whether the auth layer is running on Google\n         * Compute Engine.\n         * @private\n         */ this.checkIsGCE = undefined;\n        // To save the contents of the JSON credential file\n        this.jsonContent = null;\n        this.cachedCredential = null;\n        /**\n         * A pending {@link AuthClient}. Used for concurrent {@link GoogleAuth.getClient} calls.\n         */ _GoogleAuth_pendingAuthClient.set(this, null);\n        this.clientOptions = {};\n        this._cachedProjectId = opts.projectId || null;\n        this.cachedCredential = opts.authClient || null;\n        this.keyFilename = opts.keyFilename || opts.keyFile;\n        this.scopes = opts.scopes;\n        this.clientOptions = opts.clientOptions || {};\n        this.jsonContent = opts.credentials || null;\n        this.apiKey = opts.apiKey || this.clientOptions.apiKey || null;\n        // Cannot use both API Key + Credentials\n        if (this.apiKey && (this.jsonContent || this.clientOptions.credentials)) {\n            throw new RangeError(exports.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);\n        }\n        if (opts.universeDomain) {\n            this.clientOptions.universeDomain = opts.universeDomain;\n        }\n    }\n    // GAPIC client libraries should always use self-signed JWTs. The following\n    // variables are set on the JWT client in order to indicate the type of library,\n    // and sign the JWT with the correct audience and scopes (if not supplied).\n    setGapicJWTValues(client) {\n        client.defaultServicePath = this.defaultServicePath;\n        client.useJWTAccessWithScope = this.useJWTAccessWithScope;\n        client.defaultScopes = this.defaultScopes;\n    }\n    getProjectId(callback) {\n        if (callback) {\n            this.getProjectIdAsync().then((r)=>callback(null, r), callback);\n        } else {\n            return this.getProjectIdAsync();\n        }\n    }\n    /**\n     * A temporary method for internal `getProjectId` usages where `null` is\n     * acceptable. In a future major release, `getProjectId` should return `null`\n     * (as the `Promise<string | null>` base signature describes) and this private\n     * method should be removed.\n     *\n     * @returns Promise that resolves with project id (or `null`)\n     */ async getProjectIdOptional() {\n        try {\n            return await this.getProjectId();\n        } catch (e) {\n            if (e instanceof Error && e.message === exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {\n                return null;\n            } else {\n                throw e;\n            }\n        }\n    }\n    /**\n     * A private method for finding and caching a projectId.\n     *\n     * Supports environments in order of precedence:\n     * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable\n     * - GOOGLE_APPLICATION_CREDENTIALS JSON file\n     * - Cloud SDK: `gcloud config config-helper --format json`\n     * - GCE project ID from metadata server\n     *\n     * @returns projectId\n     */ async findAndCacheProjectId() {\n        let projectId = null;\n        projectId || (projectId = await this.getProductionProjectId());\n        projectId || (projectId = await this.getFileProjectId());\n        projectId || (projectId = await this.getDefaultServiceProjectId());\n        projectId || (projectId = await this.getGCEProjectId());\n        projectId || (projectId = await this.getExternalAccountClientProjectId());\n        if (projectId) {\n            this._cachedProjectId = projectId;\n            return projectId;\n        } else {\n            throw new Error(exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);\n        }\n    }\n    async getProjectIdAsync() {\n        if (this._cachedProjectId) {\n            return this._cachedProjectId;\n        }\n        if (!this._findProjectIdPromise) {\n            this._findProjectIdPromise = this.findAndCacheProjectId();\n        }\n        return this._findProjectIdPromise;\n    }\n    /**\n     * Retrieves a universe domain from the metadata server via\n     * {@link gcpMetadata.universe}.\n     *\n     * @returns a universe domain\n     */ async getUniverseDomainFromMetadataServer() {\n        var _a;\n        let universeDomain;\n        try {\n            universeDomain = await gcpMetadata.universe(\"universe-domain\");\n            universeDomain || (universeDomain = authclient_1.DEFAULT_UNIVERSE);\n        } catch (e) {\n            if (e && ((_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {\n                universeDomain = authclient_1.DEFAULT_UNIVERSE;\n            } else {\n                throw e;\n            }\n        }\n        return universeDomain;\n    }\n    /**\n     * Retrieves, caches, and returns the universe domain in the following order\n     * of precedence:\n     * - The universe domain in {@link GoogleAuth.clientOptions}\n     * - An existing or ADC {@link AuthClient}'s universe domain\n     * - {@link gcpMetadata.universe}, if {@link Compute} client\n     *\n     * @returns The universe domain\n     */ async getUniverseDomain() {\n        let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get(\"universe_domain\");\n        try {\n            universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = (await this.getClient()).universeDomain;\n        } catch (_a) {\n            // client or ADC is not available\n            universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = authclient_1.DEFAULT_UNIVERSE;\n        }\n        return universeDomain;\n    }\n    /**\n     * @returns Any scopes (user-specified or default scopes specified by the\n     *   client library) that need to be set on the current Auth client.\n     */ getAnyScopes() {\n        return this.scopes || this.defaultScopes;\n    }\n    getApplicationDefault(optionsOrCallback = {}, callback) {\n        let options;\n        if (typeof optionsOrCallback === \"function\") {\n            callback = optionsOrCallback;\n        } else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.getApplicationDefaultAsync(options).then((r)=>callback(null, r.credential, r.projectId), callback);\n        } else {\n            return this.getApplicationDefaultAsync(options);\n        }\n    }\n    async getApplicationDefaultAsync(options = {}) {\n        // If we've already got a cached credential, return it.\n        // This will also preserve one's configured quota project, in case they\n        // set one directly on the credential previously.\n        if (this.cachedCredential) {\n            // cache, while preserving existing quota project preferences\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, this.cachedCredential, null);\n        }\n        let credential;\n        // Check for the existence of a local environment variable pointing to the\n        // location of the credential file. This is typically used in local\n        // developer scenarios.\n        credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, credential);\n        }\n        // Look in the well-known credential file location.\n        credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);\n        if (credential) {\n            if (credential instanceof jwtclient_1.JWT) {\n                credential.scopes = this.scopes;\n            } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {\n                credential.scopes = this.getAnyScopes();\n            }\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, credential);\n        }\n        // Determine if we're running on GCE.\n        if (await this._checkIsGCE()) {\n            options.scopes = this.getAnyScopes();\n            return await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, new computeclient_1.Compute(options));\n        }\n        throw new Error(exports.GoogleAuthExceptionMessages.NO_ADC_FOUND);\n    }\n    /**\n     * Determines whether the auth layer is running on Google Compute Engine.\n     * Checks for GCP Residency, then fallback to checking if metadata server\n     * is available.\n     *\n     * @returns A promise that resolves with the boolean.\n     * @api private\n     */ async _checkIsGCE() {\n        if (this.checkIsGCE === undefined) {\n            this.checkIsGCE = gcpMetadata.getGCPResidency() || await gcpMetadata.isAvailable();\n        }\n        return this.checkIsGCE;\n    }\n    /**\n     * Attempts to load default credentials from the environment variable path..\n     * @returns Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */ async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {\n        const credentialsPath = process.env[\"GOOGLE_APPLICATION_CREDENTIALS\"] || process.env[\"google_application_credentials\"];\n        if (!credentialsPath || credentialsPath.length === 0) {\n            return null;\n        }\n        try {\n            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;\n            }\n            throw e;\n        }\n    }\n    /**\n     * Attempts to load default credentials from a well-known file location\n     * @return Promise that resolves with the OAuth2Client or null.\n     * @api private\n     */ async _tryGetApplicationCredentialsFromWellKnownFile(options) {\n        // First, figure out the location of the file, depending upon the OS type.\n        let location = null;\n        if (this._isWindows()) {\n            // Windows\n            location = process.env[\"APPDATA\"];\n        } else {\n            // Linux or Mac\n            const home = process.env[\"HOME\"];\n            if (home) {\n                location = path.join(home, \".config\");\n            }\n        }\n        // If we found the root path, expand it.\n        if (location) {\n            location = path.join(location, \"gcloud\", \"application_default_credentials.json\");\n            if (!fs.existsSync(location)) {\n                location = null;\n            }\n        }\n        // The file does not exist.\n        if (!location) {\n            return null;\n        }\n        // The file seems to exist. Try to use it.\n        const client = await this._getApplicationCredentialsFromFilePath(location, options);\n        return client;\n    }\n    /**\n     * Attempts to load default credentials from a file at the given path..\n     * @param filePath The path to the file to read.\n     * @returns Promise that resolves with the OAuth2Client\n     * @api private\n     */ async _getApplicationCredentialsFromFilePath(filePath, options = {}) {\n        // Make sure the path looks like a string.\n        if (!filePath || filePath.length === 0) {\n            throw new Error(\"The file path is invalid.\");\n        }\n        // Make sure there is a file at the path. lstatSync will throw if there is\n        // nothing there.\n        try {\n            // Resolve path to actual file in case of symlink. Expect a thrown error\n            // if not resolvable.\n            filePath = fs.realpathSync(filePath);\n            if (!fs.lstatSync(filePath).isFile()) {\n                throw new Error();\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n            }\n            throw err;\n        }\n        // Now open a read stream on the file, and parse it.\n        const readStream = fs.createReadStream(filePath);\n        return this.fromStream(readStream, options);\n    }\n    /**\n     * Create a credentials instance using a given impersonated input options.\n     * @param json The impersonated input object.\n     * @returns JWT or UserRefresh Client with data\n     */ fromImpersonatedJSON(json) {\n        var _a, _b, _c, _d;\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing an  impersonated refresh token\");\n        }\n        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            throw new Error(`The incoming JSON object does not have the \"${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}\" type`);\n        }\n        if (!json.source_credentials) {\n            throw new Error(\"The incoming JSON object does not contain a source_credentials field\");\n        }\n        if (!json.service_account_impersonation_url) {\n            throw new Error(\"The incoming JSON object does not contain a service_account_impersonation_url field\");\n        }\n        const sourceClient = this.fromJSON(json.source_credentials);\n        if (((_a = json.service_account_impersonation_url) === null || _a === void 0 ? void 0 : _a.length) > 256) {\n            /**\n             * Prevents DOS attacks.\n             * @see {@link https://github.com/googleapis/google-auth-library-nodejs/security/code-scanning/85}\n             **/ throw new RangeError(`Target principal is too long: ${json.service_account_impersonation_url}`);\n        }\n        // Extract service account from service_account_impersonation_url\n        const targetPrincipal = (_c = (_b = /(?<target>[^/]+):(generateAccessToken|generateIdToken)$/.exec(json.service_account_impersonation_url)) === null || _b === void 0 ? void 0 : _b.groups) === null || _c === void 0 ? void 0 : _c.target;\n        if (!targetPrincipal) {\n            throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);\n        }\n        const targetScopes = (_d = this.getAnyScopes()) !== null && _d !== void 0 ? _d : [];\n        return new impersonated_1.Impersonated({\n            ...json,\n            sourceClient,\n            targetPrincipal,\n            targetScopes: Array.isArray(targetScopes) ? targetScopes : [\n                targetScopes\n            ]\n        });\n    }\n    /**\n     * Create a credentials instance using the given input options.\n     * This client is not cached.\n     *\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */ fromJSON(json, options = {}) {\n        let client;\n        // user's preferred universe domain\n        const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get(\"universe_domain\");\n        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {\n            client = new refreshclient_1.UserRefreshClient(options);\n            client.fromJSON(json);\n        } else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {\n            client = this.fromImpersonatedJSON(json);\n        } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);\n            client.scopes = this.getAnyScopes();\n        } else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {\n            client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);\n        } else {\n            options.scopes = this.scopes;\n            client = new jwtclient_1.JWT(options);\n            this.setGapicJWTValues(client);\n            client.fromJSON(json);\n        }\n        if (preferredUniverseDomain) {\n            client.universeDomain = preferredUniverseDomain;\n        }\n        return client;\n    }\n    /**\n     * Return a JWT or UserRefreshClient from JavaScript object, caching both the\n     * object used to instantiate and the client.\n     * @param json The input object.\n     * @param options The JWT or UserRefresh options for the client\n     * @returns JWT or UserRefresh Client with data\n     */ _cacheClientFromJSON(json, options) {\n        const client = this.fromJSON(json, options);\n        // cache both raw data used to instantiate client and client itself.\n        this.jsonContent = json;\n        this.cachedCredential = client;\n        return client;\n    }\n    fromStream(inputStream, optionsOrCallback = {}, callback) {\n        let options = {};\n        if (typeof optionsOrCallback === \"function\") {\n            callback = optionsOrCallback;\n        } else {\n            options = optionsOrCallback;\n        }\n        if (callback) {\n            this.fromStreamAsync(inputStream, options).then((r)=>callback(null, r), callback);\n        } else {\n            return this.fromStreamAsync(inputStream, options);\n        }\n    }\n    fromStreamAsync(inputStream, options) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                throw new Error(\"Must pass in a stream containing the Google auth settings.\");\n            }\n            const chunks = [];\n            inputStream.setEncoding(\"utf8\").on(\"error\", reject).on(\"data\", (chunk)=>chunks.push(chunk)).on(\"end\", ()=>{\n                try {\n                    try {\n                        const data = JSON.parse(chunks.join(\"\"));\n                        const r = this._cacheClientFromJSON(data, options);\n                        return resolve(r);\n                    } catch (err) {\n                        // If we failed parsing this.keyFileName, assume that it\n                        // is a PEM or p12 certificate:\n                        if (!this.keyFilename) throw err;\n                        const client = new jwtclient_1.JWT({\n                            ...this.clientOptions,\n                            keyFile: this.keyFilename\n                        });\n                        this.cachedCredential = client;\n                        this.setGapicJWTValues(client);\n                        return resolve(client);\n                    }\n                } catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Create a credentials instance using the given API key string.\n     * The created client is not cached. In order to create and cache it use the {@link GoogleAuth.getClient `getClient`} method after first providing an {@link GoogleAuth.apiKey `apiKey`}.\n     *\n     * @param apiKey The API key string\n     * @param options An optional options object.\n     * @returns A JWT loaded from the key\n     */ fromAPIKey(apiKey, options = {}) {\n        return new jwtclient_1.JWT({\n            ...options,\n            apiKey\n        });\n    }\n    /**\n     * Determines whether the current operating system is Windows.\n     * @api private\n     */ _isWindows() {\n        const sys = os.platform();\n        if (sys && sys.length >= 3) {\n            if (sys.substring(0, 3).toLowerCase() === \"win\") {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Run the Google Cloud SDK command that prints the default project ID\n     */ async getDefaultServiceProjectId() {\n        return new Promise((resolve)=>{\n            (0, child_process_1.exec)(\"gcloud config config-helper --format json\", (err, stdout)=>{\n                if (!err && stdout) {\n                    try {\n                        const projectId = JSON.parse(stdout).configuration.properties.core.project;\n                        resolve(projectId);\n                        return;\n                    } catch (e) {\n                    // ignore errors\n                    }\n                }\n                resolve(null);\n            });\n        });\n    }\n    /**\n     * Loads the project id from environment variables.\n     * @api private\n     */ getProductionProjectId() {\n        return process.env[\"GCLOUD_PROJECT\"] || process.env[\"GOOGLE_CLOUD_PROJECT\"] || process.env[\"gcloud_project\"] || process.env[\"google_cloud_project\"];\n    }\n    /**\n     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.\n     * @api private\n     */ async getFileProjectId() {\n        if (this.cachedCredential) {\n            // Try to read the project ID from the cached credentials file\n            return this.cachedCredential.projectId;\n        }\n        // Ensure the projectId is loaded from the keyFile if available.\n        if (this.keyFilename) {\n            const creds = await this.getClient();\n            if (creds && creds.projectId) {\n                return creds.projectId;\n            }\n        }\n        // Try to load a credentials file and read its project ID\n        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();\n        if (r) {\n            return r.projectId;\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Gets the project ID from external account client if available.\n     */ async getExternalAccountClientProjectId() {\n        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {\n            return null;\n        }\n        const creds = await this.getClient();\n        // Do not suppress the underlying error, as the error could contain helpful\n        // information for debugging and fixing. This is especially true for\n        // external account creds as in order to get the project ID, the following\n        // operations have to succeed:\n        // 1. Valid credentials file should be supplied.\n        // 2. Ability to retrieve access tokens from STS token exchange API.\n        // 3. Ability to exchange for service account impersonated credentials (if\n        //    enabled).\n        // 4. Ability to get project info using the access token from step 2 or 3.\n        // Without surfacing the error, it is harder for developers to determine\n        // which step went wrong.\n        return await creds.getProjectId();\n    }\n    /**\n     * Gets the Compute Engine project ID if it can be inferred.\n     */ async getGCEProjectId() {\n        try {\n            const r = await gcpMetadata.project(\"project-id\");\n            return r;\n        } catch (e) {\n            // Ignore any errors\n            return null;\n        }\n    }\n    getCredentials(callback) {\n        if (callback) {\n            this.getCredentialsAsync().then((r)=>callback(null, r), callback);\n        } else {\n            return this.getCredentialsAsync();\n        }\n    }\n    async getCredentialsAsync() {\n        const client = await this.getClient();\n        if (client instanceof impersonated_1.Impersonated) {\n            return {\n                client_email: client.getTargetPrincipal()\n            };\n        }\n        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {\n            const serviceAccountEmail = client.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                return {\n                    client_email: serviceAccountEmail,\n                    universe_domain: client.universeDomain\n                };\n            }\n        }\n        if (this.jsonContent) {\n            return {\n                client_email: this.jsonContent.client_email,\n                private_key: this.jsonContent.private_key,\n                universe_domain: this.jsonContent.universe_domain\n            };\n        }\n        if (await this._checkIsGCE()) {\n            const [client_email, universe_domain] = await Promise.all([\n                gcpMetadata.instance(\"service-accounts/default/email\"),\n                this.getUniverseDomain()\n            ]);\n            return {\n                client_email,\n                universe_domain\n            };\n        }\n        throw new Error(exports.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);\n    }\n    /**\n     * Automatically obtain an {@link AuthClient `AuthClient`} based on the\n     * provided configuration. If no options were passed, use Application\n     * Default Credentials.\n     */ async getClient() {\n        if (this.cachedCredential) {\n            return this.cachedCredential;\n        }\n        // Use an existing auth client request, or cache a new one\n        __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, \"f\") || __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_determineClient).call(this), \"f\");\n        try {\n            return await __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, \"f\");\n        } finally{\n            // reset the pending auth client in case it is changed later\n            __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, null, \"f\");\n        }\n    }\n    /**\n     * Creates a client which will fetch an ID token for authorization.\n     * @param targetAudience the audience for the fetched ID token.\n     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.\n     */ async getIdTokenClient(targetAudience) {\n        const client = await this.getClient();\n        if (!(\"fetchIdToken\" in client)) {\n            throw new Error(\"Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.\");\n        }\n        return new idtokenclient_1.IdTokenClient({\n            targetAudience,\n            idTokenProvider: client\n        });\n    }\n    /**\n     * Automatically obtain application default credentials, and return\n     * an access token for making requests.\n     */ async getAccessToken() {\n        const client = await this.getClient();\n        return (await client.getAccessToken()).token;\n    }\n    /**\n     * Obtain the HTTP headers that will provide authorization for a given\n     * request.\n     */ async getRequestHeaders(url) {\n        const client = await this.getClient();\n        return client.getRequestHeaders(url);\n    }\n    /**\n     * Obtain credentials for a request, then attach the appropriate headers to\n     * the request options.\n     * @param opts Axios or Request options on which to attach the headers\n     */ async authorizeRequest(opts) {\n        opts = opts || {};\n        const url = opts.url || opts.uri;\n        const client = await this.getClient();\n        const headers = await client.getRequestHeaders(url);\n        opts.headers = Object.assign(opts.headers || {}, headers);\n        return opts;\n    }\n    /**\n     * Automatically obtain application default credentials, and make an\n     * HTTP request using the given options.\n     * @param opts Axios request options for the HTTP request.\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async request(opts) {\n        const client = await this.getClient();\n        return client.request(opts);\n    }\n    /**\n     * Determine the compute environment in which the code is running.\n     */ getEnv() {\n        return (0, envDetect_1.getEnv)();\n    }\n    /**\n     * Sign the given data with the current private key, or go out\n     * to the IAM API to sign it.\n     * @param data The data to be signed.\n     * @param endpoint A custom endpoint to use.\n     *\n     * @example\n     * ```\n     * sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');\n     * ```\n     */ async sign(data, endpoint) {\n        const client = await this.getClient();\n        const universe = await this.getUniverseDomain();\n        endpoint = endpoint || `https://iamcredentials.${universe}/v1/projects/-/serviceAccounts/`;\n        if (client instanceof impersonated_1.Impersonated) {\n            const signed = await client.sign(data);\n            return signed.signedBlob;\n        }\n        const crypto = (0, crypto_1.createCrypto)();\n        if (client instanceof jwtclient_1.JWT && client.key) {\n            const sign = await crypto.sign(client.key, data);\n            return sign;\n        }\n        const creds = await this.getCredentials();\n        if (!creds.client_email) {\n            throw new Error(\"Cannot sign data without `client_email`.\");\n        }\n        return this.signBlob(crypto, creds.client_email, data, endpoint);\n    }\n    async signBlob(crypto, emailOrUniqueId, data, endpoint) {\n        const url = new URL(endpoint + `${emailOrUniqueId}:signBlob`);\n        const res = await this.request({\n            method: \"POST\",\n            url: url.href,\n            data: {\n                payload: crypto.encodeBase64StringUtf8(data)\n            },\n            retry: true,\n            retryConfig: {\n                httpMethodsToRetry: [\n                    \"POST\"\n                ]\n            }\n        });\n        return res.data.signedBlob;\n    }\n}\nexports.GoogleAuth = GoogleAuth;\n_GoogleAuth_pendingAuthClient = new WeakMap(), _GoogleAuth_instances = new WeakSet(), _GoogleAuth_prepareAndCacheClient = async function _GoogleAuth_prepareAndCacheClient(credential, quotaProjectIdOverride = process.env[\"GOOGLE_CLOUD_QUOTA_PROJECT\"] || null) {\n    const projectId = await this.getProjectIdOptional();\n    if (quotaProjectIdOverride) {\n        credential.quotaProjectId = quotaProjectIdOverride;\n    }\n    this.cachedCredential = credential;\n    return {\n        credential,\n        projectId\n    };\n}, _GoogleAuth_determineClient = async function _GoogleAuth_determineClient() {\n    if (this.jsonContent) {\n        return this._cacheClientFromJSON(this.jsonContent, this.clientOptions);\n    } else if (this.keyFilename) {\n        const filePath = path.resolve(this.keyFilename);\n        const stream = fs.createReadStream(filePath);\n        return await this.fromStreamAsync(stream, this.clientOptions);\n    } else if (this.apiKey) {\n        const client = await this.fromAPIKey(this.apiKey, this.clientOptions);\n        client.scopes = this.scopes;\n        const { credential } = await __classPrivateFieldGet(this, _GoogleAuth_instances, \"m\", _GoogleAuth_prepareAndCacheClient).call(this, client);\n        return credential;\n    } else {\n        const { credential } = await this.getApplicationDefaultAsync(this.clientOptions);\n        return credential;\n    }\n};\n/**\n * Export DefaultTransporter as a static property of the class.\n */ GoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9nb29nbGVhdXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLElBQUlBLHlCQUF5QixJQUFLLElBQUksSUFBSSxDQUFDQSxzQkFBc0IsSUFBSyxTQUFVQyxRQUFRLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxDQUFDO0lBQ3BHLElBQUlELFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9ILFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRSxJQUFJLENBQUNGLE1BQU1JLEdBQUcsQ0FBQ0wsV0FBVyxNQUFNLElBQUlJLFVBQVU7SUFDdkcsT0FBT0YsU0FBUyxNQUFNQyxJQUFJRCxTQUFTLE1BQU1DLEVBQUVHLElBQUksQ0FBQ04sWUFBWUcsSUFBSUEsRUFBRUksS0FBSyxHQUFHTixNQUFNTyxHQUFHLENBQUNSO0FBQ3hGO0FBQ0EsSUFBSVMseUJBQXlCLElBQUssSUFBSSxJQUFJLENBQUNBLHNCQUFzQixJQUFLLFNBQVVULFFBQVEsRUFBRUMsS0FBSyxFQUFFTSxLQUFLLEVBQUVMLElBQUksRUFBRUMsQ0FBQztJQUMzRyxJQUFJRCxTQUFTLEtBQUssTUFBTSxJQUFJRSxVQUFVO0lBQ3RDLElBQUlGLFNBQVMsT0FBTyxDQUFDQyxHQUFHLE1BQU0sSUFBSUMsVUFBVTtJQUM1QyxJQUFJLE9BQU9ILFVBQVUsYUFBYUQsYUFBYUMsU0FBUyxDQUFDRSxJQUFJLENBQUNGLE1BQU1JLEdBQUcsQ0FBQ0wsV0FBVyxNQUFNLElBQUlJLFVB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TTtRQUMzQixNQUFNLEVBQUV3QyxVQUFVLEVBQUUsR0FBRyxNQUFNcEcsdUJBQXVCLElBQUksRUFBRVksdUJBQXVCLEtBQUtFLG1DQUFtQ1AsSUFBSSxDQUFDLElBQUksRUFBRTJEO1FBQ3BJLE9BQU9rQztJQUNYLE9BQ0s7UUFDRCxNQUFNLEVBQUVBLFVBQVUsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDRCwwQkFBMEIsQ0FBQyxJQUFJLENBQUM3QyxhQUFhO1FBQy9FLE9BQU84QztJQUNYO0FBQ0o7QUFDQTs7Q0FFQyxHQUNEakYsV0FBVzhNLGtCQUFrQixHQUFHcE0sZUFBZW9NLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvZ29vZ2xlYXV0aC5qcz8xZjM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX0dvb2dsZUF1dGhfaW5zdGFuY2VzLCBfR29vZ2xlQXV0aF9wZW5kaW5nQXV0aENsaWVudCwgX0dvb2dsZUF1dGhfcHJlcGFyZUFuZENhY2hlQ2xpZW50LCBfR29vZ2xlQXV0aF9kZXRlcm1pbmVDbGllbnQ7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdvb2dsZUF1dGggPSBleHBvcnRzLkdvb2dsZUF1dGhFeGNlcHRpb25NZXNzYWdlcyA9IGV4cG9ydHMuQ0xPVURfU0RLX0NMSUVOVF9JRCA9IHZvaWQgMDtcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBnY3BNZXRhZGF0YSA9IHJlcXVpcmUoXCJnY3AtbWV0YWRhdGFcIik7XG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9jcnlwdG9cIik7XG5jb25zdCB0cmFuc3BvcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRlcnNcIik7XG5jb25zdCBjb21wdXRlY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jb21wdXRlY2xpZW50XCIpO1xuY29uc3QgaWR0b2tlbmNsaWVudF8xID0gcmVxdWlyZShcIi4vaWR0b2tlbmNsaWVudFwiKTtcbmNvbnN0IGVudkRldGVjdF8xID0gcmVxdWlyZShcIi4vZW52RGV0ZWN0XCIpO1xuY29uc3Qgand0Y2xpZW50XzEgPSByZXF1aXJlKFwiLi9qd3RjbGllbnRcIik7XG5jb25zdCByZWZyZXNoY2xpZW50XzEgPSByZXF1aXJlKFwiLi9yZWZyZXNoY2xpZW50XCIpO1xuY29uc3QgaW1wZXJzb25hdGVkXzEgPSByZXF1aXJlKFwiLi9pbXBlcnNvbmF0ZWRcIik7XG5jb25zdCBleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxjbGllbnRcIik7XG5jb25zdCBiYXNlZXh0ZXJuYWxjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2Jhc2VleHRlcm5hbGNsaWVudFwiKTtcbmNvbnN0IGF1dGhjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGhjbGllbnRcIik7XG5jb25zdCBleHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudF8xID0gcmVxdWlyZShcIi4vZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmV4cG9ydHMuQ0xPVURfU0RLX0NMSUVOVF9JRCA9ICc3NjQwODYwNTE4NTAtNnFyNHA2Z3BpNmhuNTA2cHQ4ZWp1cTgzZGkzNDFodXIuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20nO1xuZXhwb3J0cy5Hb29nbGVBdXRoRXhjZXB0aW9uTWVzc2FnZXMgPSB7XG4gICAgQVBJX0tFWV9XSVRIX0NSRURFTlRJQUxTOiAnQVBJIEtleXMgYW5kIENyZWRlbnRpYWxzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgYXV0aGVudGljYXRpb24gbWV0aG9kcyBhbmQgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIuJyxcbiAgICBOT19QUk9KRUNUX0lEX0ZPVU5EOiAnVW5hYmxlIHRvIGRldGVjdCBhIFByb2plY3QgSWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIFxcbicgK1xuICAgICAgICAnVG8gbGVhcm4gbW9yZSBhYm91dCBhdXRoZW50aWNhdGlvbiBhbmQgR29vZ2xlIEFQSXMsIHZpc2l0OiBcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9kb2NzL2F1dGhlbnRpY2F0aW9uL2dldHRpbmctc3RhcnRlZCcsXG4gICAgTk9fQ1JFREVOVElBTFNfRk9VTkQ6ICdVbmFibGUgdG8gZmluZCBjcmVkZW50aWFscyBpbiBjdXJyZW50IGVudmlyb25tZW50LiBcXG4nICtcbiAgICAgICAgJ1RvIGxlYXJuIG1vcmUgYWJvdXQgYXV0aGVudGljYXRpb24gYW5kIEdvb2dsZSBBUElzLCB2aXNpdDogXFxuJyArXG4gICAgICAgICdodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vZG9jcy9hdXRoZW50aWNhdGlvbi9nZXR0aW5nLXN0YXJ0ZWQnLFxuICAgIE5PX0FEQ19GT1VORDogJ0NvdWxkIG5vdCBsb2FkIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzLiBCcm93c2UgdG8gaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RvY3MvYXV0aGVudGljYXRpb24vZ2V0dGluZy1zdGFydGVkIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG4gICAgTk9fVU5JVkVSU0VfRE9NQUlOX0ZPVU5EOiAnVW5hYmxlIHRvIGRldGVjdCBhIFVuaXZlcnNlIERvbWFpbiBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cXG4nICtcbiAgICAgICAgJ1RvIGxlYXJuIG1vcmUgYWJvdXQgVW5pdmVyc2UgRG9tYWluIHJldHJpZXZhbCwgdmlzaXQ6IFxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2NvbXB1dGUvZG9jcy9tZXRhZGF0YS9wcmVkZWZpbmVkLW1ldGFkYXRhLWtleXMnLFxufTtcbmNsYXNzIEdvb2dsZUF1dGgge1xuICAgIC8vIE5vdGU6ICB0aGlzIHByb3Blcmx5IGlzIG9ubHkgcHVibGljIHRvIHNhdGlzZnkgdW5pdCB0ZXN0cy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzUyMjhcbiAgICBnZXQgaXNHQ0UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrSXNHQ0U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gaXMgcmVzb2x2ZWQgaW4gdGhlIGZvbGxvd2luZyBvcmRlciBvZiBwcmVjZWRlbmNlOlxuICAgICAqIC0ge0BsaW5rIEdvb2dsZUF1dGhPcHRpb25zLmNyZWRlbnRpYWxzIGBjcmVkZW50aWFsc2B9XG4gICAgICogLSB7QGxpbmsgR29vZ2xlQXV0aE9wdGlvbnMua2V5RmlsZW5hbWUgYGtleUZpbGVuYW1lYH1cbiAgICAgKiAtIHtAbGluayBHb29nbGVBdXRoT3B0aW9ucy5rZXlGaWxlIGBrZXlGaWxlYH1cbiAgICAgKlxuICAgICAqIHtAbGluayBHb29nbGVBdXRoT3B0aW9ucy5jbGllbnRPcHRpb25zIGBjbGllbnRPcHRpb25zYH0gYXJlIHBhc3NlZCB0byB0aGVcbiAgICAgKiB7QGxpbmsgQXV0aENsaWVudCBgQXV0aENsaWVudGBzfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIF9Hb29nbGVBdXRoX2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZXMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGF1dGggbGF5ZXIgaXMgcnVubmluZyBvbiBHb29nbGVcbiAgICAgICAgICogQ29tcHV0ZSBFbmdpbmUuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrSXNHQ0UgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRvIHNhdmUgdGhlIGNvbnRlbnRzIG9mIHRoZSBKU09OIGNyZWRlbnRpYWwgZmlsZVxuICAgICAgICB0aGlzLmpzb25Db250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWNoZWRDcmVkZW50aWFsID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcGVuZGluZyB7QGxpbmsgQXV0aENsaWVudH0uIFVzZWQgZm9yIGNvbmN1cnJlbnQge0BsaW5rIEdvb2dsZUF1dGguZ2V0Q2xpZW50fSBjYWxscy5cbiAgICAgICAgICovXG4gICAgICAgIF9Hb29nbGVBdXRoX3BlbmRpbmdBdXRoQ2xpZW50LnNldCh0aGlzLCBudWxsKTtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zID0ge307XG4gICAgICAgIHRoaXMuX2NhY2hlZFByb2plY3RJZCA9IG9wdHMucHJvamVjdElkIHx8IG51bGw7XG4gICAgICAgIHRoaXMuY2FjaGVkQ3JlZGVudGlhbCA9IG9wdHMuYXV0aENsaWVudCB8fCBudWxsO1xuICAgICAgICB0aGlzLmtleUZpbGVuYW1lID0gb3B0cy5rZXlGaWxlbmFtZSB8fCBvcHRzLmtleUZpbGU7XG4gICAgICAgIHRoaXMuc2NvcGVzID0gb3B0cy5zY29wZXM7XG4gICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucyA9IG9wdHMuY2xpZW50T3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5qc29uQ29udGVudCA9IG9wdHMuY3JlZGVudGlhbHMgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBvcHRzLmFwaUtleSB8fCB0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5IHx8IG51bGw7XG4gICAgICAgIC8vIENhbm5vdCB1c2UgYm90aCBBUEkgS2V5ICsgQ3JlZGVudGlhbHNcbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5ICYmICh0aGlzLmpzb25Db250ZW50IHx8IHRoaXMuY2xpZW50T3B0aW9ucy5jcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGV4cG9ydHMuR29vZ2xlQXV0aEV4Y2VwdGlvbk1lc3NhZ2VzLkFQSV9LRVlfV0lUSF9DUkVERU5USUFMUyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMudW5pdmVyc2VEb21haW4pIHtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50T3B0aW9ucy51bml2ZXJzZURvbWFpbiA9IG9wdHMudW5pdmVyc2VEb21haW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR0FQSUMgY2xpZW50IGxpYnJhcmllcyBzaG91bGQgYWx3YXlzIHVzZSBzZWxmLXNpZ25lZCBKV1RzLiBUaGUgZm9sbG93aW5nXG4gICAgLy8gdmFyaWFibGVzIGFyZSBzZXQgb24gdGhlIEpXVCBjbGllbnQgaW4gb3JkZXIgdG8gaW5kaWNhdGUgdGhlIHR5cGUgb2YgbGlicmFyeSxcbiAgICAvLyBhbmQgc2lnbiB0aGUgSldUIHdpdGggdGhlIGNvcnJlY3QgYXVkaWVuY2UgYW5kIHNjb3BlcyAoaWYgbm90IHN1cHBsaWVkKS5cbiAgICBzZXRHYXBpY0pXVFZhbHVlcyhjbGllbnQpIHtcbiAgICAgICAgY2xpZW50LmRlZmF1bHRTZXJ2aWNlUGF0aCA9IHRoaXMuZGVmYXVsdFNlcnZpY2VQYXRoO1xuICAgICAgICBjbGllbnQudXNlSldUQWNjZXNzV2l0aFNjb3BlID0gdGhpcy51c2VKV1RBY2Nlc3NXaXRoU2NvcGU7XG4gICAgICAgIGNsaWVudC5kZWZhdWx0U2NvcGVzID0gdGhpcy5kZWZhdWx0U2NvcGVzO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0SWQoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldFByb2plY3RJZEFzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9qZWN0SWRBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgdGVtcG9yYXJ5IG1ldGhvZCBmb3IgaW50ZXJuYWwgYGdldFByb2plY3RJZGAgdXNhZ2VzIHdoZXJlIGBudWxsYCBpc1xuICAgICAqIGFjY2VwdGFibGUuIEluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UsIGBnZXRQcm9qZWN0SWRgIHNob3VsZCByZXR1cm4gYG51bGxgXG4gICAgICogKGFzIHRoZSBgUHJvbWlzZTxzdHJpbmcgfCBudWxsPmAgYmFzZSBzaWduYXR1cmUgZGVzY3JpYmVzKSBhbmQgdGhpcyBwcml2YXRlXG4gICAgICogbWV0aG9kIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggcHJvamVjdCBpZCAob3IgYG51bGxgKVxuICAgICAqL1xuICAgIGFzeW5jIGdldFByb2plY3RJZE9wdGlvbmFsKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UHJvamVjdElkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPT09IGV4cG9ydHMuR29vZ2xlQXV0aEV4Y2VwdGlvbk1lc3NhZ2VzLk5PX1BST0pFQ1RfSURfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBwcml2YXRlIG1ldGhvZCBmb3IgZmluZGluZyBhbmQgY2FjaGluZyBhIHByb2plY3RJZC5cbiAgICAgKlxuICAgICAqIFN1cHBvcnRzIGVudmlyb25tZW50cyBpbiBvcmRlciBvZiBwcmVjZWRlbmNlOlxuICAgICAqIC0gR0NMT1VEX1BST0pFQ1Qgb3IgR09PR0xFX0NMT1VEX1BST0pFQ1QgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICAgKiAtIEdPT0dMRV9BUFBMSUNBVElPTl9DUkVERU5USUFMUyBKU09OIGZpbGVcbiAgICAgKiAtIENsb3VkIFNESzogYGdjbG91ZCBjb25maWcgY29uZmlnLWhlbHBlciAtLWZvcm1hdCBqc29uYFxuICAgICAqIC0gR0NFIHByb2plY3QgSUQgZnJvbSBtZXRhZGF0YSBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHByb2plY3RJZFxuICAgICAqL1xuICAgIGFzeW5jIGZpbmRBbmRDYWNoZVByb2plY3RJZCgpIHtcbiAgICAgICAgbGV0IHByb2plY3RJZCA9IG51bGw7XG4gICAgICAgIHByb2plY3RJZCB8fCAocHJvamVjdElkID0gYXdhaXQgdGhpcy5nZXRQcm9kdWN0aW9uUHJvamVjdElkKCkpO1xuICAgICAgICBwcm9qZWN0SWQgfHwgKHByb2plY3RJZCA9IGF3YWl0IHRoaXMuZ2V0RmlsZVByb2plY3RJZCgpKTtcbiAgICAgICAgcHJvamVjdElkIHx8IChwcm9qZWN0SWQgPSBhd2FpdCB0aGlzLmdldERlZmF1bHRTZXJ2aWNlUHJvamVjdElkKCkpO1xuICAgICAgICBwcm9qZWN0SWQgfHwgKHByb2plY3RJZCA9IGF3YWl0IHRoaXMuZ2V0R0NFUHJvamVjdElkKCkpO1xuICAgICAgICBwcm9qZWN0SWQgfHwgKHByb2plY3RJZCA9IGF3YWl0IHRoaXMuZ2V0RXh0ZXJuYWxBY2NvdW50Q2xpZW50UHJvamVjdElkKCkpO1xuICAgICAgICBpZiAocHJvamVjdElkKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZWRQcm9qZWN0SWQgPSBwcm9qZWN0SWQ7XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4cG9ydHMuR29vZ2xlQXV0aEV4Y2VwdGlvbk1lc3NhZ2VzLk5PX1BST0pFQ1RfSURfRk9VTkQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFByb2plY3RJZEFzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkUHJvamVjdElkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUHJvamVjdElkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZmluZFByb2plY3RJZFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmRQcm9qZWN0SWRQcm9taXNlID0gdGhpcy5maW5kQW5kQ2FjaGVQcm9qZWN0SWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZFByb2plY3RJZFByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHVuaXZlcnNlIGRvbWFpbiBmcm9tIHRoZSBtZXRhZGF0YSBzZXJ2ZXIgdmlhXG4gICAgICoge0BsaW5rIGdjcE1ldGFkYXRhLnVuaXZlcnNlfS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgdW5pdmVyc2UgZG9tYWluXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VW5pdmVyc2VEb21haW5Gcm9tTWV0YWRhdGFTZXJ2ZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHVuaXZlcnNlRG9tYWluO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdW5pdmVyc2VEb21haW4gPSBhd2FpdCBnY3BNZXRhZGF0YS51bml2ZXJzZSgndW5pdmVyc2UtZG9tYWluJyk7XG4gICAgICAgICAgICB1bml2ZXJzZURvbWFpbiB8fCAodW5pdmVyc2VEb21haW4gPSBhdXRoY2xpZW50XzEuREVGQVVMVF9VTklWRVJTRSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlICYmICgoX2EgPSBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUucmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXMpID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICB1bml2ZXJzZURvbWFpbiA9IGF1dGhjbGllbnRfMS5ERUZBVUxUX1VOSVZFUlNFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pdmVyc2VEb21haW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcywgY2FjaGVzLCBhbmQgcmV0dXJucyB0aGUgdW5pdmVyc2UgZG9tYWluIGluIHRoZSBmb2xsb3dpbmcgb3JkZXJcbiAgICAgKiBvZiBwcmVjZWRlbmNlOlxuICAgICAqIC0gVGhlIHVuaXZlcnNlIGRvbWFpbiBpbiB7QGxpbmsgR29vZ2xlQXV0aC5jbGllbnRPcHRpb25zfVxuICAgICAqIC0gQW4gZXhpc3Rpbmcgb3IgQURDIHtAbGluayBBdXRoQ2xpZW50fSdzIHVuaXZlcnNlIGRvbWFpblxuICAgICAqIC0ge0BsaW5rIGdjcE1ldGFkYXRhLnVuaXZlcnNlfSwgaWYge0BsaW5rIENvbXB1dGV9IGNsaWVudFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHVuaXZlcnNlIGRvbWFpblxuICAgICAqL1xuICAgIGFzeW5jIGdldFVuaXZlcnNlRG9tYWluKCkge1xuICAgICAgICBsZXQgdW5pdmVyc2VEb21haW4gPSAoMCwgdXRpbF8xLm9yaWdpbmFsT3JDYW1lbE9wdGlvbnMpKHRoaXMuY2xpZW50T3B0aW9ucykuZ2V0KCd1bml2ZXJzZV9kb21haW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVuaXZlcnNlRG9tYWluICE9PSBudWxsICYmIHVuaXZlcnNlRG9tYWluICE9PSB2b2lkIDAgPyB1bml2ZXJzZURvbWFpbiA6ICh1bml2ZXJzZURvbWFpbiA9IChhd2FpdCB0aGlzLmdldENsaWVudCgpKS51bml2ZXJzZURvbWFpbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAvLyBjbGllbnQgb3IgQURDIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAgICAgIHVuaXZlcnNlRG9tYWluICE9PSBudWxsICYmIHVuaXZlcnNlRG9tYWluICE9PSB2b2lkIDAgPyB1bml2ZXJzZURvbWFpbiA6ICh1bml2ZXJzZURvbWFpbiA9IGF1dGhjbGllbnRfMS5ERUZBVUxUX1VOSVZFUlNFKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pdmVyc2VEb21haW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIEFueSBzY29wZXMgKHVzZXItc3BlY2lmaWVkIG9yIGRlZmF1bHQgc2NvcGVzIHNwZWNpZmllZCBieSB0aGVcbiAgICAgKiAgIGNsaWVudCBsaWJyYXJ5KSB0aGF0IG5lZWQgdG8gYmUgc2V0IG9uIHRoZSBjdXJyZW50IEF1dGggY2xpZW50LlxuICAgICAqL1xuICAgIGdldEFueVNjb3BlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVzIHx8IHRoaXMuZGVmYXVsdFNjb3BlcztcbiAgICB9XG4gICAgZ2V0QXBwbGljYXRpb25EZWZhdWx0KG9wdGlvbnNPckNhbGxiYWNrID0ge30sIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nZXRBcHBsaWNhdGlvbkRlZmF1bHRBc3luYyhvcHRpb25zKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgci5jcmVkZW50aWFsLCByLnByb2plY3RJZCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFwcGxpY2F0aW9uRGVmYXVsdEFzeW5jKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEFwcGxpY2F0aW9uRGVmYXVsdEFzeW5jKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhIGNhY2hlZCBjcmVkZW50aWFsLCByZXR1cm4gaXQuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIHByZXNlcnZlIG9uZSdzIGNvbmZpZ3VyZWQgcXVvdGEgcHJvamVjdCwgaW4gY2FzZSB0aGV5XG4gICAgICAgIC8vIHNldCBvbmUgZGlyZWN0bHkgb24gdGhlIGNyZWRlbnRpYWwgcHJldmlvdXNseS5cbiAgICAgICAgaWYgKHRoaXMuY2FjaGVkQ3JlZGVudGlhbCkge1xuICAgICAgICAgICAgLy8gY2FjaGUsIHdoaWxlIHByZXNlcnZpbmcgZXhpc3RpbmcgcXVvdGEgcHJvamVjdCBwcmVmZXJlbmNlc1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0dvb2dsZUF1dGhfaW5zdGFuY2VzLCBcIm1cIiwgX0dvb2dsZUF1dGhfcHJlcGFyZUFuZENhY2hlQ2xpZW50KS5jYWxsKHRoaXMsIHRoaXMuY2FjaGVkQ3JlZGVudGlhbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNyZWRlbnRpYWw7XG4gICAgICAgIC8vIENoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGEgbG9jYWwgZW52aXJvbm1lbnQgdmFyaWFibGUgcG9pbnRpbmcgdG8gdGhlXG4gICAgICAgIC8vIGxvY2F0aW9uIG9mIHRoZSBjcmVkZW50aWFsIGZpbGUuIFRoaXMgaXMgdHlwaWNhbGx5IHVzZWQgaW4gbG9jYWxcbiAgICAgICAgLy8gZGV2ZWxvcGVyIHNjZW5hcmlvcy5cbiAgICAgICAgY3JlZGVudGlhbCA9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbUVudmlyb25tZW50VmFyaWFibGUob3B0aW9ucyk7XG4gICAgICAgIGlmIChjcmVkZW50aWFsKSB7XG4gICAgICAgICAgICBpZiAoY3JlZGVudGlhbCBpbnN0YW5jZW9mIGp3dGNsaWVudF8xLkpXVCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjcmVkZW50aWFsIGluc3RhbmNlb2YgYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5nZXRBbnlTY29wZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Hb29nbGVBdXRoX2luc3RhbmNlcywgXCJtXCIsIF9Hb29nbGVBdXRoX3ByZXBhcmVBbmRDYWNoZUNsaWVudCkuY2FsbCh0aGlzLCBjcmVkZW50aWFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb29rIGluIHRoZSB3ZWxsLWtub3duIGNyZWRlbnRpYWwgZmlsZSBsb2NhdGlvbi5cbiAgICAgICAgY3JlZGVudGlhbCA9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbVdlbGxLbm93bkZpbGUob3B0aW9ucyk7XG4gICAgICAgIGlmIChjcmVkZW50aWFsKSB7XG4gICAgICAgICAgICBpZiAoY3JlZGVudGlhbCBpbnN0YW5jZW9mIGp3dGNsaWVudF8xLkpXVCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjcmVkZW50aWFsIGluc3RhbmNlb2YgYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCkge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWwuc2NvcGVzID0gdGhpcy5nZXRBbnlTY29wZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Hb29nbGVBdXRoX2luc3RhbmNlcywgXCJtXCIsIF9Hb29nbGVBdXRoX3ByZXBhcmVBbmRDYWNoZUNsaWVudCkuY2FsbCh0aGlzLCBjcmVkZW50aWFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBvbiBHQ0UuXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLl9jaGVja0lzR0NFKCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2NvcGVzID0gdGhpcy5nZXRBbnlTY29wZXMoKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Hb29nbGVBdXRoX2luc3RhbmNlcywgXCJtXCIsIF9Hb29nbGVBdXRoX3ByZXBhcmVBbmRDYWNoZUNsaWVudCkuY2FsbCh0aGlzLCBuZXcgY29tcHV0ZWNsaWVudF8xLkNvbXB1dGUob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLkdvb2dsZUF1dGhFeGNlcHRpb25NZXNzYWdlcy5OT19BRENfRk9VTkQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGF1dGggbGF5ZXIgaXMgcnVubmluZyBvbiBHb29nbGUgQ29tcHV0ZSBFbmdpbmUuXG4gICAgICogQ2hlY2tzIGZvciBHQ1AgUmVzaWRlbmN5LCB0aGVuIGZhbGxiYWNrIHRvIGNoZWNraW5nIGlmIG1ldGFkYXRhIHNlcnZlclxuICAgICAqIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGJvb2xlYW4uXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX2NoZWNrSXNHQ0UoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrSXNHQ0UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0lzR0NFID1cbiAgICAgICAgICAgICAgICBnY3BNZXRhZGF0YS5nZXRHQ1BSZXNpZGVuY3koKSB8fCAoYXdhaXQgZ2NwTWV0YWRhdGEuaXNBdmFpbGFibGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tJc0dDRTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gbG9hZCBkZWZhdWx0IGNyZWRlbnRpYWxzIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIHBhdGguLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBPQXV0aDJDbGllbnQgb3IgbnVsbC5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBfdHJ5R2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21FbnZpcm9ubWVudFZhcmlhYmxlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbHNQYXRoID0gcHJvY2Vzcy5lbnZbJ0dPT0dMRV9BUFBMSUNBVElPTl9DUkVERU5USUFMUyddIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudlsnZ29vZ2xlX2FwcGxpY2F0aW9uX2NyZWRlbnRpYWxzJ107XG4gICAgICAgIGlmICghY3JlZGVudGlhbHNQYXRoIHx8IGNyZWRlbnRpYWxzUGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21GaWxlUGF0aChjcmVkZW50aWFsc1BhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYFVuYWJsZSB0byByZWFkIHRoZSBjcmVkZW50aWFsIGZpbGUgc3BlY2lmaWVkIGJ5IHRoZSBHT09HTEVfQVBQTElDQVRJT05fQ1JFREVOVElBTFMgZW52aXJvbm1lbnQgdmFyaWFibGU6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGxvYWQgZGVmYXVsdCBjcmVkZW50aWFscyBmcm9tIGEgd2VsbC1rbm93biBmaWxlIGxvY2F0aW9uXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgT0F1dGgyQ2xpZW50IG9yIG51bGwuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX3RyeUdldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tV2VsbEtub3duRmlsZShvcHRpb25zKSB7XG4gICAgICAgIC8vIEZpcnN0LCBmaWd1cmUgb3V0IHRoZSBsb2NhdGlvbiBvZiB0aGUgZmlsZSwgZGVwZW5kaW5nIHVwb24gdGhlIE9TIHR5cGUuXG4gICAgICAgIGxldCBsb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9pc1dpbmRvd3MoKSkge1xuICAgICAgICAgICAgLy8gV2luZG93c1xuICAgICAgICAgICAgbG9jYXRpb24gPSBwcm9jZXNzLmVudlsnQVBQREFUQSddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTGludXggb3IgTWFjXG4gICAgICAgICAgICBjb25zdCBob21lID0gcHJvY2Vzcy5lbnZbJ0hPTUUnXTtcbiAgICAgICAgICAgIGlmIChob21lKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBwYXRoLmpvaW4oaG9tZSwgJy5jb25maWcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBmb3VuZCB0aGUgcm9vdCBwYXRoLCBleHBhbmQgaXQuXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICAgICAgbG9jYXRpb24gPSBwYXRoLmpvaW4obG9jYXRpb24sICdnY2xvdWQnLCAnYXBwbGljYXRpb25fZGVmYXVsdF9jcmVkZW50aWFscy5qc29uJyk7XG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMobG9jYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBmaWxlIGRvZXMgbm90IGV4aXN0LlxuICAgICAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZmlsZSBzZWVtcyB0byBleGlzdC4gVHJ5IHRvIHVzZSBpdC5cbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5fZ2V0QXBwbGljYXRpb25DcmVkZW50aWFsc0Zyb21GaWxlUGF0aChsb2NhdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGxvYWQgZGVmYXVsdCBjcmVkZW50aWFscyBmcm9tIGEgZmlsZSBhdCB0aGUgZ2l2ZW4gcGF0aC4uXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIFRoZSBwYXRoIHRvIHRoZSBmaWxlIHRvIHJlYWQuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIE9BdXRoMkNsaWVudFxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbUZpbGVQYXRoKGZpbGVQYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXRoIGxvb2tzIGxpa2UgYSBzdHJpbmcuXG4gICAgICAgIGlmICghZmlsZVBhdGggfHwgZmlsZVBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBmaWxlIHBhdGggaXMgaW52YWxpZC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgaXMgYSBmaWxlIGF0IHRoZSBwYXRoLiBsc3RhdFN5bmMgd2lsbCB0aHJvdyBpZiB0aGVyZSBpc1xuICAgICAgICAvLyBub3RoaW5nIHRoZXJlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUmVzb2x2ZSBwYXRoIHRvIGFjdHVhbCBmaWxlIGluIGNhc2Ugb2Ygc3ltbGluay4gRXhwZWN0IGEgdGhyb3duIGVycm9yXG4gICAgICAgICAgICAvLyBpZiBub3QgcmVzb2x2YWJsZS5cbiAgICAgICAgICAgIGZpbGVQYXRoID0gZnMucmVhbHBhdGhTeW5jKGZpbGVQYXRoKTtcbiAgICAgICAgICAgIGlmICghZnMubHN0YXRTeW5jKGZpbGVQYXRoKS5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYFRoZSBmaWxlIGF0ICR7ZmlsZVBhdGh9IGRvZXMgbm90IGV4aXN0LCBvciBpdCBpcyBub3QgYSBmaWxlLiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IG9wZW4gYSByZWFkIHN0cmVhbSBvbiB0aGUgZmlsZSwgYW5kIHBhcnNlIGl0LlxuICAgICAgICBjb25zdCByZWFkU3RyZWFtID0gZnMuY3JlYXRlUmVhZFN0cmVhbShmaWxlUGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21TdHJlYW0ocmVhZFN0cmVhbSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNyZWRlbnRpYWxzIGluc3RhbmNlIHVzaW5nIGEgZ2l2ZW4gaW1wZXJzb25hdGVkIGlucHV0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGltcGVyc29uYXRlZCBpbnB1dCBvYmplY3QuXG4gICAgICogQHJldHVybnMgSldUIG9yIFVzZXJSZWZyZXNoIENsaWVudCB3aXRoIGRhdGFcbiAgICAgKi9cbiAgICBmcm9tSW1wZXJzb25hdGVkSlNPTihqc29uKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKCFqc29uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcGFzcyBpbiBhIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgYW4gIGltcGVyc29uYXRlZCByZWZyZXNoIHRva2VuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24udHlwZSAhPT0gaW1wZXJzb25hdGVkXzEuSU1QRVJTT05BVEVEX0FDQ09VTlRfVFlQRSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgaGF2ZSB0aGUgXCIke2ltcGVyc29uYXRlZF8xLklNUEVSU09OQVRFRF9BQ0NPVU5UX1RZUEV9XCIgdHlwZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanNvbi5zb3VyY2VfY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGluY29taW5nIEpTT04gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gYSBzb3VyY2VfY3JlZGVudGlhbHMgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlQ2xpZW50ID0gdGhpcy5mcm9tSlNPTihqc29uLnNvdXJjZV9jcmVkZW50aWFscyk7XG4gICAgICAgIGlmICgoKF9hID0ganNvbi5zZXJ2aWNlX2FjY291bnRfaW1wZXJzb25hdGlvbl91cmwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID4gMjU2KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByZXZlbnRzIERPUyBhdHRhY2tzLlxuICAgICAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvZ29vZ2xlLWF1dGgtbGlicmFyeS1ub2RlanMvc2VjdXJpdHkvY29kZS1zY2FubmluZy84NX1cbiAgICAgICAgICAgICAqKi9cbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUYXJnZXQgcHJpbmNpcGFsIGlzIHRvbyBsb25nOiAke2pzb24uc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJhY3Qgc2VydmljZSBhY2NvdW50IGZyb20gc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsXG4gICAgICAgIGNvbnN0IHRhcmdldFByaW5jaXBhbCA9IChfYyA9IChfYiA9IC8oPzx0YXJnZXQ+W14vXSspOihnZW5lcmF0ZUFjY2Vzc1Rva2VufGdlbmVyYXRlSWRUb2tlbikkLy5leGVjKGpzb24uc2VydmljZV9hY2NvdW50X2ltcGVyc29uYXRpb25fdXJsKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdyb3VwcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRhcmdldDtcbiAgICAgICAgaWYgKCF0YXJnZXRQcmluY2lwYWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgZXh0cmFjdCB0YXJnZXQgcHJpbmNpcGFsIGZyb20gJHtqc29uLnNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRTY29wZXMgPSAoX2QgPSB0aGlzLmdldEFueVNjb3BlcygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXTtcbiAgICAgICAgcmV0dXJuIG5ldyBpbXBlcnNvbmF0ZWRfMS5JbXBlcnNvbmF0ZWQoe1xuICAgICAgICAgICAgLi4uanNvbixcbiAgICAgICAgICAgIHNvdXJjZUNsaWVudCxcbiAgICAgICAgICAgIHRhcmdldFByaW5jaXBhbCxcbiAgICAgICAgICAgIHRhcmdldFNjb3BlczogQXJyYXkuaXNBcnJheSh0YXJnZXRTY29wZXMpID8gdGFyZ2V0U2NvcGVzIDogW3RhcmdldFNjb3Blc10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyB0aGUgZ2l2ZW4gaW5wdXQgb3B0aW9ucy5cbiAgICAgKiBUaGlzIGNsaWVudCBpcyBub3QgY2FjaGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgSldUIG9yIFVzZXJSZWZyZXNoIG9wdGlvbnMgZm9yIHRoZSBjbGllbnRcbiAgICAgKiBAcmV0dXJucyBKV1Qgb3IgVXNlclJlZnJlc2ggQ2xpZW50IHdpdGggZGF0YVxuICAgICAqL1xuICAgIGZyb21KU09OKGpzb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY2xpZW50O1xuICAgICAgICAvLyB1c2VyJ3MgcHJlZmVycmVkIHVuaXZlcnNlIGRvbWFpblxuICAgICAgICBjb25zdCBwcmVmZXJyZWRVbml2ZXJzZURvbWFpbiA9ICgwLCB1dGlsXzEub3JpZ2luYWxPckNhbWVsT3B0aW9ucykob3B0aW9ucykuZ2V0KCd1bml2ZXJzZV9kb21haW4nKTtcbiAgICAgICAgaWYgKGpzb24udHlwZSA9PT0gcmVmcmVzaGNsaWVudF8xLlVTRVJfUkVGUkVTSF9BQ0NPVU5UX1RZUEUpIHtcbiAgICAgICAgICAgIGNsaWVudCA9IG5ldyByZWZyZXNoY2xpZW50XzEuVXNlclJlZnJlc2hDbGllbnQob3B0aW9ucyk7XG4gICAgICAgICAgICBjbGllbnQuZnJvbUpTT04oanNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanNvbi50eXBlID09PSBpbXBlcnNvbmF0ZWRfMS5JTVBFUlNPTkFURURfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICBjbGllbnQgPSB0aGlzLmZyb21JbXBlcnNvbmF0ZWRKU09OKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24udHlwZSA9PT0gYmFzZWV4dGVybmFsY2xpZW50XzEuRVhURVJOQUxfQUNDT1VOVF9UWVBFKSB7XG4gICAgICAgICAgICBjbGllbnQgPSBleHRlcm5hbGNsaWVudF8xLkV4dGVybmFsQWNjb3VudENsaWVudC5mcm9tSlNPTihqc29uLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNsaWVudC5zY29wZXMgPSB0aGlzLmdldEFueVNjb3BlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24udHlwZSA9PT0gZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRfMS5FWFRFUk5BTF9BQ0NPVU5UX0FVVEhPUklaRURfVVNFUl9UWVBFKSB7XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRfMS5FeHRlcm5hbEFjY291bnRBdXRob3JpemVkVXNlckNsaWVudChqc29uLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICBjbGllbnQgPSBuZXcgand0Y2xpZW50XzEuSldUKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zZXRHYXBpY0pXVFZhbHVlcyhjbGllbnQpO1xuICAgICAgICAgICAgY2xpZW50LmZyb21KU09OKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmZXJyZWRVbml2ZXJzZURvbWFpbikge1xuICAgICAgICAgICAgY2xpZW50LnVuaXZlcnNlRG9tYWluID0gcHJlZmVycmVkVW5pdmVyc2VEb21haW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgSldUIG9yIFVzZXJSZWZyZXNoQ2xpZW50IGZyb20gSmF2YVNjcmlwdCBvYmplY3QsIGNhY2hpbmcgYm90aCB0aGVcbiAgICAgKiBvYmplY3QgdXNlZCB0byBpbnN0YW50aWF0ZSBhbmQgdGhlIGNsaWVudC5cbiAgICAgKiBAcGFyYW0ganNvbiBUaGUgaW5wdXQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBKV1Qgb3IgVXNlclJlZnJlc2ggb3B0aW9ucyBmb3IgdGhlIGNsaWVudFxuICAgICAqIEByZXR1cm5zIEpXVCBvciBVc2VyUmVmcmVzaCBDbGllbnQgd2l0aCBkYXRhXG4gICAgICovXG4gICAgX2NhY2hlQ2xpZW50RnJvbUpTT04oanNvbiwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmZyb21KU09OKGpzb24sIG9wdGlvbnMpO1xuICAgICAgICAvLyBjYWNoZSBib3RoIHJhdyBkYXRhIHVzZWQgdG8gaW5zdGFudGlhdGUgY2xpZW50IGFuZCBjbGllbnQgaXRzZWxmLlxuICAgICAgICB0aGlzLmpzb25Db250ZW50ID0ganNvbjtcbiAgICAgICAgdGhpcy5jYWNoZWRDcmVkZW50aWFsID0gY2xpZW50O1xuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH1cbiAgICBmcm9tU3RyZWFtKGlucHV0U3RyZWFtLCBvcHRpb25zT3JDYWxsYmFjayA9IHt9LCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNPckNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnNPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5mcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0sIG9wdGlvbnMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcGFzcyBpbiBhIHN0cmVhbSBjb250YWluaW5nIHRoZSBHb29nbGUgYXV0aCBzZXR0aW5ncy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW1cbiAgICAgICAgICAgICAgICAuc2V0RW5jb2RpbmcoJ3V0ZjgnKVxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAgICAgLm9uKCdkYXRhJywgY2h1bmsgPT4gY2h1bmtzLnB1c2goY2h1bmspKVxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShjaHVua3Muam9pbignJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuX2NhY2hlQ2xpZW50RnJvbUpTT04oZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmYWlsZWQgcGFyc2luZyB0aGlzLmtleUZpbGVOYW1lLCBhc3N1bWUgdGhhdCBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgYSBQRU0gb3IgcDEyIGNlcnRpZmljYXRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmtleUZpbGVuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBqd3RjbGllbnRfMS5KV1Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuY2xpZW50T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlGaWxlOiB0aGlzLmtleUZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZENyZWRlbnRpYWwgPSBjbGllbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEdhcGljSldUVmFsdWVzKGNsaWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjbGllbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIEFQSSBrZXkgc3RyaW5nLlxuICAgICAqIFRoZSBjcmVhdGVkIGNsaWVudCBpcyBub3QgY2FjaGVkLiBJbiBvcmRlciB0byBjcmVhdGUgYW5kIGNhY2hlIGl0IHVzZSB0aGUge0BsaW5rIEdvb2dsZUF1dGguZ2V0Q2xpZW50IGBnZXRDbGllbnRgfSBtZXRob2QgYWZ0ZXIgZmlyc3QgcHJvdmlkaW5nIGFuIHtAbGluayBHb29nbGVBdXRoLmFwaUtleSBgYXBpS2V5YH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXBpS2V5IFRoZSBBUEkga2V5IHN0cmluZ1xuICAgICAqIEBwYXJhbSBvcHRpb25zIEFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIEEgSldUIGxvYWRlZCBmcm9tIHRoZSBrZXlcbiAgICAgKi9cbiAgICBmcm9tQVBJS2V5KGFwaUtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgand0Y2xpZW50XzEuSldUKHsgLi4ub3B0aW9ucywgYXBpS2V5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgb3BlcmF0aW5nIHN5c3RlbSBpcyBXaW5kb3dzLlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pc1dpbmRvd3MoKSB7XG4gICAgICAgIGNvbnN0IHN5cyA9IG9zLnBsYXRmb3JtKCk7XG4gICAgICAgIGlmIChzeXMgJiYgc3lzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICBpZiAoc3lzLnN1YnN0cmluZygwLCAzKS50b0xvd2VyQ2FzZSgpID09PSAnd2luJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIHRoZSBHb29nbGUgQ2xvdWQgU0RLIGNvbW1hbmQgdGhhdCBwcmludHMgdGhlIGRlZmF1bHQgcHJvamVjdCBJRFxuICAgICAqL1xuICAgIGFzeW5jIGdldERlZmF1bHRTZXJ2aWNlUHJvamVjdElkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAoMCwgY2hpbGRfcHJvY2Vzc18xLmV4ZWMpKCdnY2xvdWQgY29uZmlnIGNvbmZpZy1oZWxwZXIgLS1mb3JtYXQganNvbicsIChlcnIsIHN0ZG91dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZXJyICYmIHN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdElkID0gSlNPTi5wYXJzZShzdGRvdXQpLmNvbmZpZ3VyYXRpb24ucHJvcGVydGllcy5jb3JlLnByb2plY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHByb2plY3RJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgcHJvamVjdCBpZCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRQcm9kdWN0aW9uUHJvamVjdElkKCkge1xuICAgICAgICByZXR1cm4gKHByb2Nlc3MuZW52WydHQ0xPVURfUFJPSkVDVCddIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudlsnR09PR0xFX0NMT1VEX1BST0pFQ1QnXSB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnZbJ2djbG91ZF9wcm9qZWN0J10gfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Wydnb29nbGVfY2xvdWRfcHJvamVjdCddKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIHByb2plY3QgaWQgZnJvbSB0aGUgR09PR0xFX0FQUExJQ0FUSU9OX0NSRURFTlRJQUxTIGpzb24gZmlsZS5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRGaWxlUHJvamVjdElkKCkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZWRDcmVkZW50aWFsKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcmVhZCB0aGUgcHJvamVjdCBJRCBmcm9tIHRoZSBjYWNoZWQgY3JlZGVudGlhbHMgZmlsZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkQ3JlZGVudGlhbC5wcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBwcm9qZWN0SWQgaXMgbG9hZGVkIGZyb20gdGhlIGtleUZpbGUgaWYgYXZhaWxhYmxlLlxuICAgICAgICBpZiAodGhpcy5rZXlGaWxlbmFtZSkge1xuICAgICAgICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICAgICAgaWYgKGNyZWRzICYmIGNyZWRzLnByb2plY3RJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVkcy5wcm9qZWN0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIGxvYWQgYSBjcmVkZW50aWFscyBmaWxlIGFuZCByZWFkIGl0cyBwcm9qZWN0IElEXG4gICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLl90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbUVudmlyb25tZW50VmFyaWFibGUoKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByLnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb2plY3QgSUQgZnJvbSBleHRlcm5hbCBhY2NvdW50IGNsaWVudCBpZiBhdmFpbGFibGUuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0RXh0ZXJuYWxBY2NvdW50Q2xpZW50UHJvamVjdElkKCkge1xuICAgICAgICBpZiAoIXRoaXMuanNvbkNvbnRlbnQgfHwgdGhpcy5qc29uQ29udGVudC50eXBlICE9PSBiYXNlZXh0ZXJuYWxjbGllbnRfMS5FWFRFUk5BTF9BQ0NPVU5UX1RZUEUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWRzID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgLy8gRG8gbm90IHN1cHByZXNzIHRoZSB1bmRlcmx5aW5nIGVycm9yLCBhcyB0aGUgZXJyb3IgY291bGQgY29udGFpbiBoZWxwZnVsXG4gICAgICAgIC8vIGluZm9ybWF0aW9uIGZvciBkZWJ1Z2dpbmcgYW5kIGZpeGluZy4gVGhpcyBpcyBlc3BlY2lhbGx5IHRydWUgZm9yXG4gICAgICAgIC8vIGV4dGVybmFsIGFjY291bnQgY3JlZHMgYXMgaW4gb3JkZXIgdG8gZ2V0IHRoZSBwcm9qZWN0IElELCB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIG9wZXJhdGlvbnMgaGF2ZSB0byBzdWNjZWVkOlxuICAgICAgICAvLyAxLiBWYWxpZCBjcmVkZW50aWFscyBmaWxlIHNob3VsZCBiZSBzdXBwbGllZC5cbiAgICAgICAgLy8gMi4gQWJpbGl0eSB0byByZXRyaWV2ZSBhY2Nlc3MgdG9rZW5zIGZyb20gU1RTIHRva2VuIGV4Y2hhbmdlIEFQSS5cbiAgICAgICAgLy8gMy4gQWJpbGl0eSB0byBleGNoYW5nZSBmb3Igc2VydmljZSBhY2NvdW50IGltcGVyc29uYXRlZCBjcmVkZW50aWFscyAoaWZcbiAgICAgICAgLy8gICAgZW5hYmxlZCkuXG4gICAgICAgIC8vIDQuIEFiaWxpdHkgdG8gZ2V0IHByb2plY3QgaW5mbyB1c2luZyB0aGUgYWNjZXNzIHRva2VuIGZyb20gc3RlcCAyIG9yIDMuXG4gICAgICAgIC8vIFdpdGhvdXQgc3VyZmFjaW5nIHRoZSBlcnJvciwgaXQgaXMgaGFyZGVyIGZvciBkZXZlbG9wZXJzIHRvIGRldGVybWluZVxuICAgICAgICAvLyB3aGljaCBzdGVwIHdlbnQgd3JvbmcuXG4gICAgICAgIHJldHVybiBhd2FpdCBjcmVkcy5nZXRQcm9qZWN0SWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgQ29tcHV0ZSBFbmdpbmUgcHJvamVjdCBJRCBpZiBpdCBjYW4gYmUgaW5mZXJyZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0R0NFUHJvamVjdElkKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgciA9IGF3YWl0IGdjcE1ldGFkYXRhLnByb2plY3QoJ3Byb2plY3QtaWQnKTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgYW55IGVycm9yc1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q3JlZGVudGlhbHMoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldENyZWRlbnRpYWxzQXN5bmMoKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgciksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENyZWRlbnRpYWxzQXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRDcmVkZW50aWFsc0FzeW5jKCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBpZiAoY2xpZW50IGluc3RhbmNlb2YgaW1wZXJzb25hdGVkXzEuSW1wZXJzb25hdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjbGllbnRfZW1haWw6IGNsaWVudC5nZXRUYXJnZXRQcmluY2lwYWwoKSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnQgaW5zdGFuY2VvZiBiYXNlZXh0ZXJuYWxjbGllbnRfMS5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlQWNjb3VudEVtYWlsID0gY2xpZW50LmdldFNlcnZpY2VBY2NvdW50RW1haWwoKTtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlQWNjb3VudEVtYWlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50X2VtYWlsOiBzZXJ2aWNlQWNjb3VudEVtYWlsLFxuICAgICAgICAgICAgICAgICAgICB1bml2ZXJzZV9kb21haW46IGNsaWVudC51bml2ZXJzZURvbWFpbixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmpzb25Db250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsaWVudF9lbWFpbDogdGhpcy5qc29uQ29udGVudC5jbGllbnRfZW1haWwsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZV9rZXk6IHRoaXMuanNvbkNvbnRlbnQucHJpdmF0ZV9rZXksXG4gICAgICAgICAgICAgICAgdW5pdmVyc2VfZG9tYWluOiB0aGlzLmpzb25Db250ZW50LnVuaXZlcnNlX2RvbWFpbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuX2NoZWNrSXNHQ0UoKSkge1xuICAgICAgICAgICAgY29uc3QgW2NsaWVudF9lbWFpbCwgdW5pdmVyc2VfZG9tYWluXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBnY3BNZXRhZGF0YS5pbnN0YW5jZSgnc2VydmljZS1hY2NvdW50cy9kZWZhdWx0L2VtYWlsJyksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRVbml2ZXJzZURvbWFpbigpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4geyBjbGllbnRfZW1haWwsIHVuaXZlcnNlX2RvbWFpbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLkdvb2dsZUF1dGhFeGNlcHRpb25NZXNzYWdlcy5OT19DUkVERU5USUFMU19GT1VORCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgb2J0YWluIGFuIHtAbGluayBBdXRoQ2xpZW50IGBBdXRoQ2xpZW50YH0gYmFzZWQgb24gdGhlXG4gICAgICogcHJvdmlkZWQgY29uZmlndXJhdGlvbi4gSWYgbm8gb3B0aW9ucyB3ZXJlIHBhc3NlZCwgdXNlIEFwcGxpY2F0aW9uXG4gICAgICogRGVmYXVsdCBDcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDbGllbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZENyZWRlbnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlZENyZWRlbnRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGFuIGV4aXN0aW5nIGF1dGggY2xpZW50IHJlcXVlc3QsIG9yIGNhY2hlIGEgbmV3IG9uZVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Hb29nbGVBdXRoX3BlbmRpbmdBdXRoQ2xpZW50LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Hb29nbGVBdXRoX3BlbmRpbmdBdXRoQ2xpZW50LCBcImZcIikgfHwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfR29vZ2xlQXV0aF9pbnN0YW5jZXMsIFwibVwiLCBfR29vZ2xlQXV0aF9kZXRlcm1pbmVDbGllbnQpLmNhbGwodGhpcyksIFwiZlwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Hb29nbGVBdXRoX3BlbmRpbmdBdXRoQ2xpZW50LCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyByZXNldCB0aGUgcGVuZGluZyBhdXRoIGNsaWVudCBpbiBjYXNlIGl0IGlzIGNoYW5nZWQgbGF0ZXJcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0dvb2dsZUF1dGhfcGVuZGluZ0F1dGhDbGllbnQsIG51bGwsIFwiZlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xpZW50IHdoaWNoIHdpbGwgZmV0Y2ggYW4gSUQgdG9rZW4gZm9yIGF1dGhvcml6YXRpb24uXG4gICAgICogQHBhcmFtIHRhcmdldEF1ZGllbmNlIHRoZSBhdWRpZW5jZSBmb3IgdGhlIGZldGNoZWQgSUQgdG9rZW4uXG4gICAgICogQHJldHVybnMgSWRUb2tlbkNsaWVudCBmb3IgbWFraW5nIEhUVFAgY2FsbHMgYXV0aGVudGljYXRlZCB3aXRoIElEIHRva2Vucy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRJZFRva2VuQ2xpZW50KHRhcmdldEF1ZGllbmNlKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIGlmICghKCdmZXRjaElkVG9rZW4nIGluIGNsaWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZldGNoIElEIHRva2VuIGluIHRoaXMgZW52aXJvbm1lbnQsIHVzZSBHQ0Ugb3Igc2V0IHRoZSBHT09HTEVfQVBQTElDQVRJT05fQ1JFREVOVElBTFMgZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gYSBzZXJ2aWNlIGFjY291bnQgY3JlZGVudGlhbHMgSlNPTiBmaWxlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgaWR0b2tlbmNsaWVudF8xLklkVG9rZW5DbGllbnQoeyB0YXJnZXRBdWRpZW5jZSwgaWRUb2tlblByb3ZpZGVyOiBjbGllbnQgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgb2J0YWluIGFwcGxpY2F0aW9uIGRlZmF1bHQgY3JlZGVudGlhbHMsIGFuZCByZXR1cm5cbiAgICAgKiBhbiBhY2Nlc3MgdG9rZW4gZm9yIG1ha2luZyByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5nZXRDbGllbnQoKTtcbiAgICAgICAgcmV0dXJuIChhd2FpdCBjbGllbnQuZ2V0QWNjZXNzVG9rZW4oKSkudG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9idGFpbiB0aGUgSFRUUCBoZWFkZXJzIHRoYXQgd2lsbCBwcm92aWRlIGF1dGhvcml6YXRpb24gZm9yIGEgZ2l2ZW5cbiAgICAgKiByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlcXVlc3RIZWFkZXJzKHVybCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmdldFJlcXVlc3RIZWFkZXJzKHVybCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9idGFpbiBjcmVkZW50aWFscyBmb3IgYSByZXF1ZXN0LCB0aGVuIGF0dGFjaCB0aGUgYXBwcm9wcmlhdGUgaGVhZGVycyB0b1xuICAgICAqIHRoZSByZXF1ZXN0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdHMgQXhpb3Mgb3IgUmVxdWVzdCBvcHRpb25zIG9uIHdoaWNoIHRvIGF0dGFjaCB0aGUgaGVhZGVyc1xuICAgICAqL1xuICAgIGFzeW5jIGF1dGhvcml6ZVJlcXVlc3Qob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgY29uc3QgdXJsID0gb3B0cy51cmwgfHwgb3B0cy51cmk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBjbGllbnQuZ2V0UmVxdWVzdEhlYWRlcnModXJsKTtcbiAgICAgICAgb3B0cy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihvcHRzLmhlYWRlcnMgfHwge30sIGhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljYWxseSBvYnRhaW4gYXBwbGljYXRpb24gZGVmYXVsdCBjcmVkZW50aWFscywgYW5kIG1ha2UgYW5cbiAgICAgKiBIVFRQIHJlcXVlc3QgdXNpbmcgdGhlIGdpdmVuIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdHMgQXhpb3MgcmVxdWVzdCBvcHRpb25zIGZvciB0aGUgSFRUUCByZXF1ZXN0LlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgYXN5bmMgcmVxdWVzdChvcHRzKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgICAgIHJldHVybiBjbGllbnQucmVxdWVzdChvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBjb21wdXRlIGVudmlyb25tZW50IGluIHdoaWNoIHRoZSBjb2RlIGlzIHJ1bm5pbmcuXG4gICAgICovXG4gICAgZ2V0RW52KCkge1xuICAgICAgICByZXR1cm4gKDAsIGVudkRldGVjdF8xLmdldEVudikoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbiB0aGUgZ2l2ZW4gZGF0YSB3aXRoIHRoZSBjdXJyZW50IHByaXZhdGUga2V5LCBvciBnbyBvdXRcbiAgICAgKiB0byB0aGUgSUFNIEFQSSB0byBzaWduIGl0LlxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGJlIHNpZ25lZC5cbiAgICAgKiBAcGFyYW0gZW5kcG9pbnQgQSBjdXN0b20gZW5kcG9pbnQgdG8gdXNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKCdkYXRhJywgJ2h0dHBzOi8vaWFtY3JlZGVudGlhbHMuZ29vZ2xlYXBpcy5jb20vdjEvcHJvamVjdHMvLS9zZXJ2aWNlQWNjb3VudHMvJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2lnbihkYXRhLCBlbmRwb2ludCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmdldENsaWVudCgpO1xuICAgICAgICBjb25zdCB1bml2ZXJzZSA9IGF3YWl0IHRoaXMuZ2V0VW5pdmVyc2VEb21haW4oKTtcbiAgICAgICAgZW5kcG9pbnQgPVxuICAgICAgICAgICAgZW5kcG9pbnQgfHxcbiAgICAgICAgICAgICAgICBgaHR0cHM6Ly9pYW1jcmVkZW50aWFscy4ke3VuaXZlcnNlfS92MS9wcm9qZWN0cy8tL3NlcnZpY2VBY2NvdW50cy9gO1xuICAgICAgICBpZiAoY2xpZW50IGluc3RhbmNlb2YgaW1wZXJzb25hdGVkXzEuSW1wZXJzb25hdGVkKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWQgPSBhd2FpdCBjbGllbnQuc2lnbihkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBzaWduZWQuc2lnbmVkQmxvYjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcnlwdG8gPSAoMCwgY3J5cHRvXzEuY3JlYXRlQ3J5cHRvKSgpO1xuICAgICAgICBpZiAoY2xpZW50IGluc3RhbmNlb2Ygand0Y2xpZW50XzEuSldUICYmIGNsaWVudC5rZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ24gPSBhd2FpdCBjcnlwdG8uc2lnbihjbGllbnQua2V5LCBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBzaWduO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWRzID0gYXdhaXQgdGhpcy5nZXRDcmVkZW50aWFscygpO1xuICAgICAgICBpZiAoIWNyZWRzLmNsaWVudF9lbWFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2lnbiBkYXRhIHdpdGhvdXQgYGNsaWVudF9lbWFpbGAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkJsb2IoY3J5cHRvLCBjcmVkcy5jbGllbnRfZW1haWwsIGRhdGEsIGVuZHBvaW50KTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbkJsb2IoY3J5cHRvLCBlbWFpbE9yVW5pcXVlSWQsIGRhdGEsIGVuZHBvaW50KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoZW5kcG9pbnQgKyBgJHtlbWFpbE9yVW5pcXVlSWR9OnNpZ25CbG9iYCk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogdXJsLmhyZWYsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogY3J5cHRvLmVuY29kZUJhc2U2NFN0cmluZ1V0ZjgoZGF0YSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0cnk6IHRydWUsXG4gICAgICAgICAgICByZXRyeUNvbmZpZzoge1xuICAgICAgICAgICAgICAgIGh0dHBNZXRob2RzVG9SZXRyeTogWydQT1NUJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnNpZ25lZEJsb2I7XG4gICAgfVxufVxuZXhwb3J0cy5Hb29nbGVBdXRoID0gR29vZ2xlQXV0aDtcbl9Hb29nbGVBdXRoX3BlbmRpbmdBdXRoQ2xpZW50ID0gbmV3IFdlYWtNYXAoKSwgX0dvb2dsZUF1dGhfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX0dvb2dsZUF1dGhfcHJlcGFyZUFuZENhY2hlQ2xpZW50ID0gYXN5bmMgZnVuY3Rpb24gX0dvb2dsZUF1dGhfcHJlcGFyZUFuZENhY2hlQ2xpZW50KGNyZWRlbnRpYWwsIHF1b3RhUHJvamVjdElkT3ZlcnJpZGUgPSBwcm9jZXNzLmVudlsnR09PR0xFX0NMT1VEX1FVT1RBX1BST0pFQ1QnXSB8fCBudWxsKSB7XG4gICAgY29uc3QgcHJvamVjdElkID0gYXdhaXQgdGhpcy5nZXRQcm9qZWN0SWRPcHRpb25hbCgpO1xuICAgIGlmIChxdW90YVByb2plY3RJZE92ZXJyaWRlKSB7XG4gICAgICAgIGNyZWRlbnRpYWwucXVvdGFQcm9qZWN0SWQgPSBxdW90YVByb2plY3RJZE92ZXJyaWRlO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlZENyZWRlbnRpYWwgPSBjcmVkZW50aWFsO1xuICAgIHJldHVybiB7IGNyZWRlbnRpYWwsIHByb2plY3RJZCB9O1xufSwgX0dvb2dsZUF1dGhfZGV0ZXJtaW5lQ2xpZW50ID0gYXN5bmMgZnVuY3Rpb24gX0dvb2dsZUF1dGhfZGV0ZXJtaW5lQ2xpZW50KCkge1xuICAgIGlmICh0aGlzLmpzb25Db250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZUNsaWVudEZyb21KU09OKHRoaXMuanNvbkNvbnRlbnQsIHRoaXMuY2xpZW50T3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMua2V5RmlsZW5hbWUpIHtcbiAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5rZXlGaWxlbmFtZSk7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZVBhdGgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mcm9tU3RyZWFtQXN5bmMoc3RyZWFtLCB0aGlzLmNsaWVudE9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmZyb21BUElLZXkodGhpcy5hcGlLZXksIHRoaXMuY2xpZW50T3B0aW9ucyk7XG4gICAgICAgIGNsaWVudC5zY29wZXMgPSB0aGlzLnNjb3BlcztcbiAgICAgICAgY29uc3QgeyBjcmVkZW50aWFsIH0gPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Hb29nbGVBdXRoX2luc3RhbmNlcywgXCJtXCIsIF9Hb29nbGVBdXRoX3ByZXBhcmVBbmRDYWNoZUNsaWVudCkuY2FsbCh0aGlzLCBjbGllbnQpO1xuICAgICAgICByZXR1cm4gY3JlZGVudGlhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgY3JlZGVudGlhbCB9ID0gYXdhaXQgdGhpcy5nZXRBcHBsaWNhdGlvbkRlZmF1bHRBc3luYyh0aGlzLmNsaWVudE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gY3JlZGVudGlhbDtcbiAgICB9XG59O1xuLyoqXG4gKiBFeHBvcnQgRGVmYXVsdFRyYW5zcG9ydGVyIGFzIGEgc3RhdGljIHByb3BlcnR5IG9mIHRoZSBjbGFzcy5cbiAqL1xuR29vZ2xlQXV0aC5EZWZhdWx0VHJhbnNwb3J0ZXIgPSB0cmFuc3BvcnRlcnNfMS5EZWZhdWx0VHJhbnNwb3J0ZXI7XG4iXSwibmFtZXMiOlsiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsInJlY2VpdmVyIiwic3RhdGUiLCJraW5kIiwiZiIsIlR5cGVFcnJvciIsImhhcyIsImNhbGwiLCJ2YWx1ZSIsImdldCIsIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJzZXQiLCJfR29vZ2xlQXV0aF9pbnN0YW5jZXMiLCJfR29vZ2xlQXV0aF9wZW5kaW5nQXV0aENsaWVudCIsIl9Hb29nbGVBdXRoX3ByZXBhcmVBbmRDYWNoZUNsaWVudCIsIl9Hb29nbGVBdXRoX2RldGVybWluZUNsaWVudCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsIkdvb2dsZUF1dGgiLCJHb29nbGVBdXRoRXhjZXB0aW9uTWVzc2FnZXMiLCJDTE9VRF9TREtfQ0xJRU5UX0lEIiwiY2hpbGRfcHJvY2Vzc18xIiwicmVxdWlyZSIsImZzIiwiZ2NwTWV0YWRhdGEiLCJvcyIsInBhdGgiLCJjcnlwdG9fMSIsInRyYW5zcG9ydGVyc18xIiwiY29tcHV0ZWNsaWVudF8xIiwiaWR0b2tlbmNsaWVudF8xIiwiZW52RGV0ZWN0XzEiLCJqd3RjbGllbnRfMSIsInJlZnJlc2hjbGllbnRfMSIsImltcGVyc29uYXRlZF8xIiwiZXh0ZXJuYWxjbGllbnRfMSIsImJhc2VleHRlcm5hbGNsaWVudF8xIiwiYXV0aGNsaWVudF8xIiwiZXh0ZXJuYWxBY2NvdW50QXV0aG9yaXplZFVzZXJDbGllbnRfMSIsInV0aWxfMSIsIkFQSV9LRVlfV0lUSF9DUkVERU5USUFMUyIsIk5PX1BST0pFQ1RfSURfRk9VTkQiLCJOT19DUkVERU5USUFMU19GT1VORCIsIk5PX0FEQ19GT1VORCIsIk5PX1VOSVZFUlNFX0RPTUFJTl9GT1VORCIsImlzR0NFIiwiY2hlY2tJc0dDRSIsImNvbnN0cnVjdG9yIiwib3B0cyIsImFkZCIsInVuZGVmaW5lZCIsImpzb25Db250ZW50IiwiY2FjaGVkQ3JlZGVudGlhbCIsImNsaWVudE9wdGlvbnMiLCJfY2FjaGVkUHJvamVjdElkIiwicHJvamVjdElkIiwiYXV0aENsaWVudCIsImtleUZpbGVuYW1lIiwia2V5RmlsZSIsInNjb3BlcyIsImNyZWRlbnRpYWxzIiwiYXBpS2V5IiwiUmFuZ2VFcnJvciIsInVuaXZlcnNlRG9tYWluIiwic2V0R2FwaWNKV1RWYWx1ZXMiLCJjbGllbnQiLCJkZWZhdWx0U2VydmljZVBhdGgiLCJ1c2VKV1RBY2Nlc3NXaXRoU2NvcGUiLCJkZWZhdWx0U2NvcGVzIiwiZ2V0UHJvamVjdElkIiwiY2FsbGJhY2siLCJnZXRQcm9qZWN0SWRBc3luYyIsInRoZW4iLCJyIiwiZ2V0UHJvamVjdElkT3B0aW9uYWwiLCJlIiwiRXJyb3IiLCJtZXNzYWdlIiwiZmluZEFuZENhY2hlUHJvamVjdElkIiwiZ2V0UHJvZHVjdGlvblByb2plY3RJZCIsImdldEZpbGVQcm9qZWN0SWQiLCJnZXREZWZhdWx0U2VydmljZVByb2plY3RJZCIsImdldEdDRVByb2plY3RJZCIsImdldEV4dGVybmFsQWNjb3VudENsaWVudFByb2plY3RJZCIsIl9maW5kUHJvamVjdElkUHJvbWlzZSIsImdldFVuaXZlcnNlRG9tYWluRnJvbU1ldGFkYXRhU2VydmVyIiwiX2EiLCJ1bml2ZXJzZSIsIkRFRkFVTFRfVU5JVkVSU0UiLCJyZXNwb25zZSIsInN0YXR1cyIsImdldFVuaXZlcnNlRG9tYWluIiwib3JpZ2luYWxPckNhbWVsT3B0aW9ucyIsImdldENsaWVudCIsImdldEFueVNjb3BlcyIsImdldEFwcGxpY2F0aW9uRGVmYXVsdCIsIm9wdGlvbnNPckNhbGxiYWNrIiwib3B0aW9ucyIsImdldEFwcGxpY2F0aW9uRGVmYXVsdEFzeW5jIiwiY3JlZGVudGlhbCIsIl90cnlHZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbUVudmlyb25tZW50VmFyaWFibGUiLCJKV1QiLCJCYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50IiwiX3RyeUdldEFwcGxpY2F0aW9uQ3JlZGVudGlhbHNGcm9tV2VsbEtub3duRmlsZSIsIl9jaGVja0lzR0NFIiwiQ29tcHV0ZSIsImdldEdDUFJlc2lkZW5jeSIsImlzQXZhaWxhYmxlIiwiY3JlZGVudGlhbHNQYXRoIiwicHJvY2VzcyIsImVudiIsImxlbmd0aCIsIl9nZXRBcHBsaWNhdGlvbkNyZWRlbnRpYWxzRnJvbUZpbGVQYXRoIiwibG9jYXRpb24iLCJfaXNXaW5kb3dzIiwiaG9tZSIsImpvaW4iLCJleGlzdHNTeW5jIiwiZmlsZVBhdGgiLCJyZWFscGF0aFN5bmMiLCJsc3RhdFN5bmMiLCJpc0ZpbGUiLCJlcnIiLCJyZWFkU3RyZWFtIiwiY3JlYXRlUmVhZFN0cmVhbSIsImZyb21TdHJlYW0iLCJmcm9tSW1wZXJzb25hdGVkSlNPTiIsImpzb24iLCJfYiIsIl9jIiwiX2QiLCJ0eXBlIiwiSU1QRVJTT05BVEVEX0FDQ09VTlRfVFlQRSIsInNvdXJjZV9jcmVkZW50aWFscyIsInNlcnZpY2VfYWNjb3VudF9pbXBlcnNvbmF0aW9uX3VybCIsInNvdXJjZUNsaWVudCIsImZyb21KU09OIiwidGFyZ2V0UHJpbmNpcGFsIiwiZXhlYyIsImdyb3VwcyIsInRhcmdldCIsInRhcmdldFNjb3BlcyIsIkltcGVyc29uYXRlZCIsIkFycmF5IiwiaXNBcnJheSIsInByZWZlcnJlZFVuaXZlcnNlRG9tYWluIiwiVVNFUl9SRUZSRVNIX0FDQ09VTlRfVFlQRSIsIlVzZXJSZWZyZXNoQ2xpZW50IiwiRVhURVJOQUxfQUNDT1VOVF9UWVBFIiwiRXh0ZXJuYWxBY2NvdW50Q2xpZW50IiwiRVhURVJOQUxfQUNDT1VOVF9BVVRIT1JJWkVEX1VTRVJfVFlQRSIsIkV4dGVybmFsQWNjb3VudEF1dGhvcml6ZWRVc2VyQ2xpZW50IiwiX2NhY2hlQ2xpZW50RnJvbUpTT04iLCJpbnB1dFN0cmVhbSIsImZyb21TdHJlYW1Bc3luYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2h1bmtzIiwic2V0RW5jb2RpbmciLCJvbiIsImNodW5rIiwicHVzaCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJmcm9tQVBJS2V5Iiwic3lzIiwicGxhdGZvcm0iLCJzdWJzdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInN0ZG91dCIsImNvbmZpZ3VyYXRpb24iLCJwcm9wZXJ0aWVzIiwiY29yZSIsInByb2plY3QiLCJjcmVkcyIsImdldENyZWRlbnRpYWxzIiwiZ2V0Q3JlZGVudGlhbHNBc3luYyIsImNsaWVudF9lbWFpbCIsImdldFRhcmdldFByaW5jaXBhbCIsInNlcnZpY2VBY2NvdW50RW1haWwiLCJnZXRTZXJ2aWNlQWNjb3VudEVtYWlsIiwidW5pdmVyc2VfZG9tYWluIiwicHJpdmF0ZV9rZXkiLCJhbGwiLCJpbnN0YW5jZSIsImdldElkVG9rZW5DbGllbnQiLCJ0YXJnZXRBdWRpZW5jZSIsIklkVG9rZW5DbGllbnQiLCJpZFRva2VuUHJvdmlkZXIiLCJnZXRBY2Nlc3NUb2tlbiIsInRva2VuIiwiZ2V0UmVxdWVzdEhlYWRlcnMiLCJ1cmwiLCJhdXRob3JpemVSZXF1ZXN0IiwidXJpIiwiaGVhZGVycyIsImFzc2lnbiIsInJlcXVlc3QiLCJnZXRFbnYiLCJzaWduIiwiZW5kcG9pbnQiLCJzaWduZWQiLCJzaWduZWRCbG9iIiwiY3J5cHRvIiwiY3JlYXRlQ3J5cHRvIiwia2V5Iiwic2lnbkJsb2IiLCJlbWFpbE9yVW5pcXVlSWQiLCJVUkwiLCJyZXMiLCJtZXRob2QiLCJocmVmIiwicGF5bG9hZCIsImVuY29kZUJhc2U2NFN0cmluZ1V0ZjgiLCJyZXRyeSIsInJldHJ5Q29uZmlnIiwiaHR0cE1ldGhvZHNUb1JldHJ5IiwiV2Vha01hcCIsIldlYWtTZXQiLCJxdW90YVByb2plY3RJZE92ZXJyaWRlIiwicXVvdGFQcm9qZWN0SWQiLCJzdHJlYW0iLCJEZWZhdWx0VHJhbnNwb3J0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/googleauth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/iam.js":
/*!****************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/iam.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.IAMAuth = void 0;\nclass IAMAuth {\n    /**\n     * IAM credentials.\n     *\n     * @param selector the iam authority selector\n     * @param token the token\n     * @constructor\n     */ constructor(selector, token){\n        this.selector = selector;\n        this.token = token;\n        this.selector = selector;\n        this.token = token;\n    }\n    /**\n     * Acquire the HTTP headers required to make an authenticated request.\n     */ getRequestHeaders() {\n        return {\n            \"x-goog-iam-authority-selector\": this.selector,\n            \"x-goog-iam-authorization-token\": this.token\n        };\n    }\n}\nexports.IAMAuth = IAMAuth;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pYW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUcsS0FBSztBQUN2QixNQUFNRTtJQUNGOzs7Ozs7S0FNQyxHQUNEQyxZQUFZQyxRQUFRLEVBQUVDLEtBQUssQ0FBRTtRQUN6QixJQUFJLENBQUNELFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtJQUNqQjtJQUNBOztLQUVDLEdBQ0RDLG9CQUFvQjtRQUNoQixPQUFPO1lBQ0gsaUNBQWlDLElBQUksQ0FBQ0YsUUFBUTtZQUM5QyxrQ0FBa0MsSUFBSSxDQUFDQyxLQUFLO1FBQ2hEO0lBQ0o7QUFDSjtBQUNBTCxlQUFlLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pYW0uanM/YmNmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE0IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JQU1BdXRoID0gdm9pZCAwO1xuY2xhc3MgSUFNQXV0aCB7XG4gICAgLyoqXG4gICAgICogSUFNIGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIHRoZSBpYW0gYXV0aG9yaXR5IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHRva2VuIHRoZSB0b2tlblxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCB0b2tlbikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjcXVpcmUgdGhlIEhUVFAgaGVhZGVycyByZXF1aXJlZCB0byBtYWtlIGFuIGF1dGhlbnRpY2F0ZWQgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBnZXRSZXF1ZXN0SGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd4LWdvb2ctaWFtLWF1dGhvcml0eS1zZWxlY3Rvcic6IHRoaXMuc2VsZWN0b3IsXG4gICAgICAgICAgICAneC1nb29nLWlhbS1hdXRob3JpemF0aW9uLXRva2VuJzogdGhpcy50b2tlbixcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLklBTUF1dGggPSBJQU1BdXRoO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSUFNQXV0aCIsImNvbnN0cnVjdG9yIiwic2VsZWN0b3IiLCJ0b2tlbiIsImdldFJlcXVlc3RIZWFkZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/iam.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/identitypoolclient.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.IdentityPoolClient = void 0;\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/google-auth-library/build/src/util.js\");\nconst filesubjecttokensupplier_1 = __webpack_require__(/*! ./filesubjecttokensupplier */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js\");\nconst urlsubjecttokensupplier_1 = __webpack_require__(/*! ./urlsubjecttokensupplier */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js\");\n/**\n * Defines the Url-sourced and file-sourced external account clients mainly\n * used for K8s and Azure workloads.\n */ class IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiate an IdentityPoolClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid file-sourced or\n     * url-sourced credential or a workforce pool user project is provided\n     * with a non workforce audience.\n     * @param options The external account options object typically loaded\n     *   from the external account JSON credential file. The camelCased options\n     *   are aliases for the snake_cased options.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        super(options, additionalOptions);\n        const opts = (0, util_1.originalOrCamelOptions)(options);\n        const credentialSource = opts.get(\"credential_source\");\n        const subjectTokenSupplier = opts.get(\"subject_token_supplier\");\n        // Validate credential sourcing configuration.\n        if (!credentialSource && !subjectTokenSupplier) {\n            throw new Error(\"A credential source or subject token supplier must be specified.\");\n        }\n        if (credentialSource && subjectTokenSupplier) {\n            throw new Error(\"Only one of credential source or subject token supplier can be specified.\");\n        }\n        if (subjectTokenSupplier) {\n            this.subjectTokenSupplier = subjectTokenSupplier;\n            this.credentialSourceType = \"programmatic\";\n        } else {\n            const credentialSourceOpts = (0, util_1.originalOrCamelOptions)(credentialSource);\n            const formatOpts = (0, util_1.originalOrCamelOptions)(credentialSourceOpts.get(\"format\"));\n            // Text is the default format type.\n            const formatType = formatOpts.get(\"type\") || \"text\";\n            const formatSubjectTokenFieldName = formatOpts.get(\"subject_token_field_name\");\n            if (formatType !== \"json\" && formatType !== \"text\") {\n                throw new Error(`Invalid credential_source format \"${formatType}\"`);\n            }\n            if (formatType === \"json\" && !formatSubjectTokenFieldName) {\n                throw new Error(\"Missing subject_token_field_name for JSON credential_source format\");\n            }\n            const file = credentialSourceOpts.get(\"file\");\n            const url = credentialSourceOpts.get(\"url\");\n            const headers = credentialSourceOpts.get(\"headers\");\n            if (file && url) {\n                throw new Error('No valid Identity Pool \"credential_source\" provided, must be either file or url.');\n            } else if (file && !url) {\n                this.credentialSourceType = \"file\";\n                this.subjectTokenSupplier = new filesubjecttokensupplier_1.FileSubjectTokenSupplier({\n                    filePath: file,\n                    formatType: formatType,\n                    subjectTokenFieldName: formatSubjectTokenFieldName\n                });\n            } else if (!file && url) {\n                this.credentialSourceType = \"url\";\n                this.subjectTokenSupplier = new urlsubjecttokensupplier_1.UrlSubjectTokenSupplier({\n                    url: url,\n                    formatType: formatType,\n                    subjectTokenFieldName: formatSubjectTokenFieldName,\n                    headers: headers,\n                    additionalGaxiosOptions: IdentityPoolClient.RETRY_CONFIG\n                });\n            } else {\n                throw new Error('No valid Identity Pool \"credential_source\" provided, must be either file or url.');\n            }\n        }\n    }\n    /**\n     * Triggered when a external subject token is needed to be exchanged for a GCP\n     * access token via GCP STS endpoint. Gets a subject token by calling\n     * the configured {@link SubjectTokenSupplier}\n     * @return A promise that resolves with the external subject token.\n     */ async retrieveSubjectToken() {\n        return this.subjectTokenSupplier.getSubjectToken(this.supplierContext);\n    }\n}\nexports.IdentityPoolClient = IdentityPoolClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pZGVudGl0eXBvb2xjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBRyxLQUFLO0FBQ2xDLE1BQU1HLHVCQUF1QkMsbUJBQU9BLENBQUMsMkdBQXNCO0FBQzNELE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLDJFQUFTO0FBQ2hDLE1BQU1FLDZCQUE2QkYsbUJBQU9BLENBQUMsdUhBQTRCO0FBQ3ZFLE1BQU1HLDRCQUE0QkgsbUJBQU9BLENBQUMscUhBQTJCO0FBQ3JFOzs7Q0FHQyxHQUNELE1BQU1GLDJCQUEyQkMscUJBQXFCSyx5QkFBeUI7SUFDM0U7Ozs7Ozs7Ozs7Ozs7S0FhQyxHQUNEQyxZQUFZQyxPQUFPLEVBQUVDLGlCQUFpQixDQUFFO1FBQ3BDLEtBQUssQ0FBQ0QsU0FBU0M7UUFDZixNQUFNQyxPQUFPLENBQUMsR0FBR1AsT0FBT1Esc0JBQXNCLEVBQUVIO1FBQ2hELE1BQU1JLG1CQUFtQkYsS0FBS0csR0FBRyxDQUFDO1FBQ2xDLE1BQU1DLHVCQUF1QkosS0FBS0csR0FBRyxDQUFDO1FBQ3RDLDhDQUE4QztRQUM5QyxJQUFJLENBQUNELG9CQUFvQixDQUFDRSxzQkFBc0I7WUFDNUMsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSUgsb0JBQW9CRSxzQkFBc0I7WUFDMUMsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSUQsc0JBQXNCO1lBQ3RCLElBQUksQ0FBQ0Esb0JBQW9CLEdBQUdBO1lBQzVCLElBQUksQ0FBQ0Usb0JBQW9CLEdBQUc7UUFDaEMsT0FDSztZQUNELE1BQU1DLHVCQUF1QixDQUFDLEdBQUdkLE9BQU9RLHNCQUFzQixFQUFFQztZQUNoRSxNQUFNTSxhQUFhLENBQUMsR0FBR2YsT0FBT1Esc0JBQXNCLEVBQUVNLHFCQUFxQkosR0FBRyxDQUFDO1lBQy9FLG1DQUFtQztZQUNuQyxNQUFNTSxhQUFhRCxXQUFXTCxHQUFHLENBQUMsV0FBVztZQUM3QyxNQUFNTyw4QkFBOEJGLFdBQVdMLEdBQUcsQ0FBQztZQUNuRCxJQUFJTSxlQUFlLFVBQVVBLGVBQWUsUUFBUTtnQkFDaEQsTUFBTSxJQUFJSixNQUFNLENBQUMsa0NBQWtDLEVBQUVJLFdBQVcsQ0FBQyxDQUFDO1lBQ3RFO1lBQ0EsSUFBSUEsZUFBZSxVQUFVLENBQUNDLDZCQUE2QjtnQkFDdkQsTUFBTSxJQUFJTCxNQUFNO1lBQ3BCO1lBQ0EsTUFBTU0sT0FBT0oscUJBQXFCSixHQUFHLENBQUM7WUFDdEMsTUFBTVMsTUFBTUwscUJBQXFCSixHQUFHLENBQUM7WUFDckMsTUFBTVUsVUFBVU4scUJBQXFCSixHQUFHLENBQUM7WUFDekMsSUFBSVEsUUFBUUMsS0FBSztnQkFDYixNQUFNLElBQUlQLE1BQU07WUFDcEIsT0FDSyxJQUFJTSxRQUFRLENBQUNDLEtBQUs7Z0JBQ25CLElBQUksQ0FBQ04sb0JBQW9CLEdBQUc7Z0JBQzVCLElBQUksQ0FBQ0Ysb0JBQW9CLEdBQUcsSUFBSVYsMkJBQTJCb0Isd0JBQXdCLENBQUM7b0JBQ2hGQyxVQUFVSjtvQkFDVkYsWUFBWUE7b0JBQ1pPLHVCQUF1Qk47Z0JBQzNCO1lBQ0osT0FDSyxJQUFJLENBQUNDLFFBQVFDLEtBQUs7Z0JBQ25CLElBQUksQ0FBQ04sb0JBQW9CLEdBQUc7Z0JBQzVCLElBQUksQ0FBQ0Ysb0JBQW9CLEdBQUcsSUFBSVQsMEJBQTBCc0IsdUJBQXVCLENBQUM7b0JBQzlFTCxLQUFLQTtvQkFDTEgsWUFBWUE7b0JBQ1pPLHVCQUF1Qk47b0JBQ3ZCRyxTQUFTQTtvQkFDVEsseUJBQXlCNUIsbUJBQW1CNkIsWUFBWTtnQkFDNUQ7WUFDSixPQUNLO2dCQUNELE1BQU0sSUFBSWQsTUFBTTtZQUNwQjtRQUNKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU1lLHVCQUF1QjtRQUN6QixPQUFPLElBQUksQ0FBQ2hCLG9CQUFvQixDQUFDaUIsZUFBZSxDQUFDLElBQUksQ0FBQ0MsZUFBZTtJQUN6RTtBQUNKO0FBQ0FsQywwQkFBMEIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWNvbW1lbnRlci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2lkZW50aXR5cG9vbGNsaWVudC5qcz9jM2FhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklkZW50aXR5UG9vbENsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBmaWxlc3ViamVjdHRva2Vuc3VwcGxpZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbGVzdWJqZWN0dG9rZW5zdXBwbGllclwiKTtcbmNvbnN0IHVybHN1YmplY3R0b2tlbnN1cHBsaWVyXzEgPSByZXF1aXJlKFwiLi91cmxzdWJqZWN0dG9rZW5zdXBwbGllclwiKTtcbi8qKlxuICogRGVmaW5lcyB0aGUgVXJsLXNvdXJjZWQgYW5kIGZpbGUtc291cmNlZCBleHRlcm5hbCBhY2NvdW50IGNsaWVudHMgbWFpbmx5XG4gKiB1c2VkIGZvciBLOHMgYW5kIEF6dXJlIHdvcmtsb2Fkcy5cbiAqL1xuY2xhc3MgSWRlbnRpdHlQb29sQ2xpZW50IGV4dGVuZHMgYmFzZWV4dGVybmFsY2xpZW50XzEuQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYW4gSWRlbnRpdHlQb29sQ2xpZW50IGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBKU09OXG4gICAgICogb2JqZWN0IGxvYWRlZCBmcm9tIGFuIGV4dGVybmFsIGFjY291bnQgY3JlZGVudGlhbHMgZmlsZS5cbiAgICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIGNyZWRlbnRpYWwgaXMgbm90IGEgdmFsaWQgZmlsZS1zb3VyY2VkIG9yXG4gICAgICogdXJsLXNvdXJjZWQgY3JlZGVudGlhbCBvciBhIHdvcmtmb3JjZSBwb29sIHVzZXIgcHJvamVjdCBpcyBwcm92aWRlZFxuICAgICAqIHdpdGggYSBub24gd29ya2ZvcmNlIGF1ZGllbmNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHRlcm5hbCBhY2NvdW50IG9wdGlvbnMgb2JqZWN0IHR5cGljYWxseSBsb2FkZWRcbiAgICAgKiAgIGZyb20gdGhlIGV4dGVybmFsIGFjY291bnQgSlNPTiBjcmVkZW50aWFsIGZpbGUuIFRoZSBjYW1lbENhc2VkIG9wdGlvbnNcbiAgICAgKiAgIGFyZSBhbGlhc2VzIGZvciB0aGUgc25ha2VfY2FzZWQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbE9wdGlvbnMgKipERVBSRUNBVEVELCBhbGwgb3B0aW9ucyBhcmUgYXZhaWxhYmxlIGluIHRoZVxuICAgICAqICAgYG9wdGlvbnNgIHBhcmFtZXRlci4qKiBPcHRpb25hbCBhZGRpdGlvbmFsIGJlaGF2aW9yIGN1c3RvbWl6YXRpb24gb3B0aW9ucy5cbiAgICAgKiAgIFRoZXNlIGN1cnJlbnRseSBjdXN0b21pemUgZXhwaXJhdGlvbiB0aHJlc2hvbGQgdGltZSBhbmQgd2hldGhlciB0byByZXRyeVxuICAgICAqICAgb24gNDAxLzQwMyBBUEkgcmVxdWVzdCBlcnJvcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYWRkaXRpb25hbE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBvcHRzID0gKDAsIHV0aWxfMS5vcmlnaW5hbE9yQ2FtZWxPcHRpb25zKShvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY3JlZGVudGlhbFNvdXJjZSA9IG9wdHMuZ2V0KCdjcmVkZW50aWFsX3NvdXJjZScpO1xuICAgICAgICBjb25zdCBzdWJqZWN0VG9rZW5TdXBwbGllciA9IG9wdHMuZ2V0KCdzdWJqZWN0X3Rva2VuX3N1cHBsaWVyJyk7XG4gICAgICAgIC8vIFZhbGlkYXRlIGNyZWRlbnRpYWwgc291cmNpbmcgY29uZmlndXJhdGlvbi5cbiAgICAgICAgaWYgKCFjcmVkZW50aWFsU291cmNlICYmICFzdWJqZWN0VG9rZW5TdXBwbGllcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGNyZWRlbnRpYWwgc291cmNlIG9yIHN1YmplY3QgdG9rZW4gc3VwcGxpZXIgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNyZWRlbnRpYWxTb3VyY2UgJiYgc3ViamVjdFRva2VuU3VwcGxpZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgb2YgY3JlZGVudGlhbCBzb3VyY2Ugb3Igc3ViamVjdCB0b2tlbiBzdXBwbGllciBjYW4gYmUgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJqZWN0VG9rZW5TdXBwbGllcikge1xuICAgICAgICAgICAgdGhpcy5zdWJqZWN0VG9rZW5TdXBwbGllciA9IHN1YmplY3RUb2tlblN1cHBsaWVyO1xuICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFsU291cmNlVHlwZSA9ICdwcm9ncmFtbWF0aWMnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3JlZGVudGlhbFNvdXJjZU9wdHMgPSAoMCwgdXRpbF8xLm9yaWdpbmFsT3JDYW1lbE9wdGlvbnMpKGNyZWRlbnRpYWxTb3VyY2UpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0T3B0cyA9ICgwLCB1dGlsXzEub3JpZ2luYWxPckNhbWVsT3B0aW9ucykoY3JlZGVudGlhbFNvdXJjZU9wdHMuZ2V0KCdmb3JtYXQnKSk7XG4gICAgICAgICAgICAvLyBUZXh0IGlzIHRoZSBkZWZhdWx0IGZvcm1hdCB0eXBlLlxuICAgICAgICAgICAgY29uc3QgZm9ybWF0VHlwZSA9IGZvcm1hdE9wdHMuZ2V0KCd0eXBlJykgfHwgJ3RleHQnO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0U3ViamVjdFRva2VuRmllbGROYW1lID0gZm9ybWF0T3B0cy5nZXQoJ3N1YmplY3RfdG9rZW5fZmllbGRfbmFtZScpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdFR5cGUgIT09ICdqc29uJyAmJiBmb3JtYXRUeXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY3JlZGVudGlhbF9zb3VyY2UgZm9ybWF0IFwiJHtmb3JtYXRUeXBlfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0VHlwZSA9PT0gJ2pzb24nICYmICFmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc3ViamVjdF90b2tlbl9maWVsZF9uYW1lIGZvciBKU09OIGNyZWRlbnRpYWxfc291cmNlIGZvcm1hdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGNyZWRlbnRpYWxTb3VyY2VPcHRzLmdldCgnZmlsZScpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gY3JlZGVudGlhbFNvdXJjZU9wdHMuZ2V0KCd1cmwnKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBjcmVkZW50aWFsU291cmNlT3B0cy5nZXQoJ2hlYWRlcnMnKTtcbiAgICAgICAgICAgIGlmIChmaWxlICYmIHVybCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgSWRlbnRpdHkgUG9vbCBcImNyZWRlbnRpYWxfc291cmNlXCIgcHJvdmlkZWQsIG11c3QgYmUgZWl0aGVyIGZpbGUgb3IgdXJsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsZSAmJiAhdXJsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFsU291cmNlVHlwZSA9ICdmaWxlJztcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmplY3RUb2tlblN1cHBsaWVyID0gbmV3IGZpbGVzdWJqZWN0dG9rZW5zdXBwbGllcl8xLkZpbGVTdWJqZWN0VG9rZW5TdXBwbGllcih7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBmaWxlLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRUeXBlOiBmb3JtYXRUeXBlLFxuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0VG9rZW5GaWVsZE5hbWU6IGZvcm1hdFN1YmplY3RUb2tlbkZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaWxlICYmIHVybCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbFNvdXJjZVR5cGUgPSAndXJsJztcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmplY3RUb2tlblN1cHBsaWVyID0gbmV3IHVybHN1YmplY3R0b2tlbnN1cHBsaWVyXzEuVXJsU3ViamVjdFRva2VuU3VwcGxpZXIoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VHlwZTogZm9ybWF0VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdFRva2VuRmllbGROYW1lOiBmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxHYXhpb3NPcHRpb25zOiBJZGVudGl0eVBvb2xDbGllbnQuUkVUUllfQ09ORklHLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBJZGVudGl0eSBQb29sIFwiY3JlZGVudGlhbF9zb3VyY2VcIiBwcm92aWRlZCwgbXVzdCBiZSBlaXRoZXIgZmlsZSBvciB1cmwuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSBleHRlcm5hbCBzdWJqZWN0IHRva2VuIGlzIG5lZWRlZCB0byBiZSBleGNoYW5nZWQgZm9yIGEgR0NQXG4gICAgICogYWNjZXNzIHRva2VuIHZpYSBHQ1AgU1RTIGVuZHBvaW50LiBHZXRzIGEgc3ViamVjdCB0b2tlbiBieSBjYWxsaW5nXG4gICAgICogdGhlIGNvbmZpZ3VyZWQge0BsaW5rIFN1YmplY3RUb2tlblN1cHBsaWVyfVxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgZXh0ZXJuYWwgc3ViamVjdCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZVN1YmplY3RUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViamVjdFRva2VuU3VwcGxpZXIuZ2V0U3ViamVjdFRva2VuKHRoaXMuc3VwcGxpZXJDb250ZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLklkZW50aXR5UG9vbENsaWVudCA9IElkZW50aXR5UG9vbENsaWVudDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIklkZW50aXR5UG9vbENsaWVudCIsImJhc2VleHRlcm5hbGNsaWVudF8xIiwicmVxdWlyZSIsInV0aWxfMSIsImZpbGVzdWJqZWN0dG9rZW5zdXBwbGllcl8xIiwidXJsc3ViamVjdHRva2Vuc3VwcGxpZXJfMSIsIkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJhZGRpdGlvbmFsT3B0aW9ucyIsIm9wdHMiLCJvcmlnaW5hbE9yQ2FtZWxPcHRpb25zIiwiY3JlZGVudGlhbFNvdXJjZSIsImdldCIsInN1YmplY3RUb2tlblN1cHBsaWVyIiwiRXJyb3IiLCJjcmVkZW50aWFsU291cmNlVHlwZSIsImNyZWRlbnRpYWxTb3VyY2VPcHRzIiwiZm9ybWF0T3B0cyIsImZvcm1hdFR5cGUiLCJmb3JtYXRTdWJqZWN0VG9rZW5GaWVsZE5hbWUiLCJmaWxlIiwidXJsIiwiaGVhZGVycyIsIkZpbGVTdWJqZWN0VG9rZW5TdXBwbGllciIsImZpbGVQYXRoIiwic3ViamVjdFRva2VuRmllbGROYW1lIiwiVXJsU3ViamVjdFRva2VuU3VwcGxpZXIiLCJhZGRpdGlvbmFsR2F4aW9zT3B0aW9ucyIsIlJFVFJZX0NPTkZJRyIsInJldHJpZXZlU3ViamVjdFRva2VuIiwiZ2V0U3ViamVjdFRva2VuIiwic3VwcGxpZXJDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/idtokenclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.IdTokenClient = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nclass IdTokenClient extends oauth2client_1.OAuth2Client {\n    /**\n     * Google ID Token client\n     *\n     * Retrieve ID token from the metadata server.\n     * See: https://cloud.google.com/docs/authentication/get-id-token#metadata-server\n     */ constructor(options){\n        super(options);\n        this.targetAudience = options.targetAudience;\n        this.idTokenProvider = options.idTokenProvider;\n    }\n    async getRequestMetadataAsync(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        if (!this.credentials.id_token || !this.credentials.expiry_date || this.isTokenExpiring()) {\n            const idToken = await this.idTokenProvider.fetchIdToken(this.targetAudience);\n            this.credentials = {\n                id_token: idToken,\n                expiry_date: this.getIdTokenExpiryDate(idToken)\n            };\n        }\n        const headers = {\n            Authorization: \"Bearer \" + this.credentials.id_token\n        };\n        return {\n            headers\n        };\n    }\n    getIdTokenExpiryDate(idToken) {\n        const payloadB64 = idToken.split(\".\")[1];\n        if (payloadB64) {\n            const payload = JSON.parse(Buffer.from(payloadB64, \"base64\").toString(\"ascii\"));\n            return payload.exp * 1000;\n        }\n    }\n}\nexports.IdTokenClient = IdTokenClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pZHRva2VuY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUcsS0FBSztBQUM3QixNQUFNRyxpQkFBaUJDLG1CQUFPQSxDQUFDLCtGQUFnQjtBQUMvQyxNQUFNRixzQkFBc0JDLGVBQWVFLFlBQVk7SUFDbkQ7Ozs7O0tBS0MsR0FDREMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLGNBQWMsR0FBR0QsUUFBUUMsY0FBYztRQUM1QyxJQUFJLENBQUNDLGVBQWUsR0FBR0YsUUFBUUUsZUFBZTtJQUNsRDtJQUNBLE1BQU1DLHdCQUNOLDZEQUE2RDtJQUM3REMsR0FBRyxFQUFFO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQ0MsV0FBVyxDQUFDQyxRQUFRLElBQzFCLENBQUMsSUFBSSxDQUFDRCxXQUFXLENBQUNFLFdBQVcsSUFDN0IsSUFBSSxDQUFDQyxlQUFlLElBQUk7WUFDeEIsTUFBTUMsVUFBVSxNQUFNLElBQUksQ0FBQ1AsZUFBZSxDQUFDUSxZQUFZLENBQUMsSUFBSSxDQUFDVCxjQUFjO1lBQzNFLElBQUksQ0FBQ0ksV0FBVyxHQUFHO2dCQUNmQyxVQUFVRztnQkFDVkYsYUFBYSxJQUFJLENBQUNJLG9CQUFvQixDQUFDRjtZQUMzQztRQUNKO1FBQ0EsTUFBTUcsVUFBVTtZQUNaQyxlQUFlLFlBQVksSUFBSSxDQUFDUixXQUFXLENBQUNDLFFBQVE7UUFDeEQ7UUFDQSxPQUFPO1lBQUVNO1FBQVE7SUFDckI7SUFDQUQscUJBQXFCRixPQUFPLEVBQUU7UUFDMUIsTUFBTUssYUFBYUwsUUFBUU0sS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ3hDLElBQUlELFlBQVk7WUFDWixNQUFNRSxVQUFVQyxLQUFLQyxLQUFLLENBQUNDLE9BQU9DLElBQUksQ0FBQ04sWUFBWSxVQUFVTyxRQUFRLENBQUM7WUFDdEUsT0FBT0wsUUFBUU0sR0FBRyxHQUFHO1FBQ3pCO0lBQ0o7QUFDSjtBQUNBN0IscUJBQXFCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pZHRva2VuY2xpZW50LmpzPzJiMzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSWRUb2tlbkNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IG9hdXRoMmNsaWVudF8xID0gcmVxdWlyZShcIi4vb2F1dGgyY2xpZW50XCIpO1xuY2xhc3MgSWRUb2tlbkNsaWVudCBleHRlbmRzIG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR29vZ2xlIElEIFRva2VuIGNsaWVudFxuICAgICAqXG4gICAgICogUmV0cmlldmUgSUQgdG9rZW4gZnJvbSB0aGUgbWV0YWRhdGEgc2VydmVyLlxuICAgICAqIFNlZTogaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2RvY3MvYXV0aGVudGljYXRpb24vZ2V0LWlkLXRva2VuI21ldGFkYXRhLXNlcnZlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMudGFyZ2V0QXVkaWVuY2UgPSBvcHRpb25zLnRhcmdldEF1ZGllbmNlO1xuICAgICAgICB0aGlzLmlkVG9rZW5Qcm92aWRlciA9IG9wdGlvbnMuaWRUb2tlblByb3ZpZGVyO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgdXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5jcmVkZW50aWFscy5pZF90b2tlbiB8fFxuICAgICAgICAgICAgIXRoaXMuY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGUgfHxcbiAgICAgICAgICAgIHRoaXMuaXNUb2tlbkV4cGlyaW5nKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB0aGlzLmlkVG9rZW5Qcm92aWRlci5mZXRjaElkVG9rZW4odGhpcy50YXJnZXRBdWRpZW5jZSk7XG4gICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0ge1xuICAgICAgICAgICAgICAgIGlkX3Rva2VuOiBpZFRva2VuLFxuICAgICAgICAgICAgICAgIGV4cGlyeV9kYXRlOiB0aGlzLmdldElkVG9rZW5FeHBpcnlEYXRlKGlkVG9rZW4pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgdGhpcy5jcmVkZW50aWFscy5pZF90b2tlbixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgaGVhZGVycyB9O1xuICAgIH1cbiAgICBnZXRJZFRva2VuRXhwaXJ5RGF0ZShpZFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWRCNjQgPSBpZFRva2VuLnNwbGl0KCcuJylbMV07XG4gICAgICAgIGlmIChwYXlsb2FkQjY0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShwYXlsb2FkQjY0LCAnYmFzZTY0JykudG9TdHJpbmcoJ2FzY2lpJykpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQuZXhwICogMTAwMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSWRUb2tlbkNsaWVudCA9IElkVG9rZW5DbGllbnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJJZFRva2VuQ2xpZW50Iiwib2F1dGgyY2xpZW50XzEiLCJyZXF1aXJlIiwiT0F1dGgyQ2xpZW50IiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwidGFyZ2V0QXVkaWVuY2UiLCJpZFRva2VuUHJvdmlkZXIiLCJnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyIsInVybCIsImNyZWRlbnRpYWxzIiwiaWRfdG9rZW4iLCJleHBpcnlfZGF0ZSIsImlzVG9rZW5FeHBpcmluZyIsImlkVG9rZW4iLCJmZXRjaElkVG9rZW4iLCJnZXRJZFRva2VuRXhwaXJ5RGF0ZSIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwicGF5bG9hZEI2NCIsInNwbGl0IiwicGF5bG9hZCIsIkpTT04iLCJwYXJzZSIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsImV4cCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/impersonated.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/google-auth-library/build/src/util.js\");\nexports.IMPERSONATED_ACCOUNT_TYPE = \"impersonated_service_account\";\nclass Impersonated extends oauth2client_1.OAuth2Client {\n    /**\n     * Impersonated service account credentials.\n     *\n     * Create a new access token by impersonating another service account.\n     *\n     * Impersonated Credentials allowing credentials issued to a user or\n     * service account to impersonate another. The source project using\n     * Impersonated Credentials must enable the \"IAMCredentials\" API.\n     * Also, the target service account must grant the orginating principal\n     * the \"Service Account Token Creator\" IAM role.\n     *\n     * @param {object} options - The configuration object.\n     * @param {object} [options.sourceClient] the source credential used as to\n     * acquire the impersonated credentials.\n     * @param {string} [options.targetPrincipal] the service account to\n     * impersonate.\n     * @param {string[]} [options.delegates] the chained list of delegates\n     * required to grant the final access_token. If set, the sequence of\n     * identities must have \"Service Account Token Creator\" capability granted to\n     * the preceding identity. For example, if set to [serviceAccountB,\n     * serviceAccountC], the sourceCredential must have the Token Creator role on\n     * serviceAccountB. serviceAccountB must have the Token Creator on\n     * serviceAccountC. Finally, C must have Token Creator on target_principal.\n     * If left unset, sourceCredential must have that role on targetPrincipal.\n     * @param {string[]} [options.targetScopes] scopes to request during the\n     * authorization grant.\n     * @param {number} [options.lifetime] number of seconds the delegated\n     * credential should be valid for up to 3600 seconds by default, or 43,200\n     * seconds by extending the token's lifetime, see:\n     * https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth\n     * @param {string} [options.endpoint] api endpoint override.\n     */ constructor(options = {}){\n        var _a, _b, _c, _d, _e, _f;\n        super(options);\n        // Start with an expired refresh token, which will automatically be\n        // refreshed before the first API call is made.\n        this.credentials = {\n            expiry_date: 1,\n            refresh_token: \"impersonated-placeholder\"\n        };\n        this.sourceClient = (_a = options.sourceClient) !== null && _a !== void 0 ? _a : new oauth2client_1.OAuth2Client();\n        this.targetPrincipal = (_b = options.targetPrincipal) !== null && _b !== void 0 ? _b : \"\";\n        this.delegates = (_c = options.delegates) !== null && _c !== void 0 ? _c : [];\n        this.targetScopes = (_d = options.targetScopes) !== null && _d !== void 0 ? _d : [];\n        this.lifetime = (_e = options.lifetime) !== null && _e !== void 0 ? _e : 3600;\n        const usingExplicitUniverseDomain = !!(0, util_1.originalOrCamelOptions)(options).get(\"universe_domain\");\n        if (!usingExplicitUniverseDomain) {\n            // override the default universe with the source's universe\n            this.universeDomain = this.sourceClient.universeDomain;\n        } else if (this.sourceClient.universeDomain !== this.universeDomain) {\n            // non-default universe and is not matching the source - this could be a credential leak\n            throw new RangeError(`Universe domain ${this.sourceClient.universeDomain} in source credentials does not match ${this.universeDomain} universe domain set for impersonated credentials.`);\n        }\n        this.endpoint = (_f = options.endpoint) !== null && _f !== void 0 ? _f : `https://iamcredentials.${this.universeDomain}`;\n    }\n    /**\n     * Signs some bytes.\n     *\n     * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob Reference Documentation}\n     * @param blobToSign String to sign.\n     *\n     * @returns A {@link SignBlobResponse} denoting the keyID and signedBlob in base64 string\n     */ async sign(blobToSign) {\n        await this.sourceClient.getAccessToken();\n        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;\n        const u = `${this.endpoint}/v1/${name}:signBlob`;\n        const body = {\n            delegates: this.delegates,\n            payload: Buffer.from(blobToSign).toString(\"base64\")\n        };\n        const res = await this.sourceClient.request({\n            ...Impersonated.RETRY_CONFIG,\n            url: u,\n            data: body,\n            method: \"POST\"\n        });\n        return res.data;\n    }\n    /** The service account email to be impersonated. */ getTargetPrincipal() {\n        return this.targetPrincipal;\n    }\n    /**\n     * Refreshes the access token.\n     */ async refreshToken() {\n        var _a, _b, _c, _d, _e, _f;\n        try {\n            await this.sourceClient.getAccessToken();\n            const name = \"projects/-/serviceAccounts/\" + this.targetPrincipal;\n            const u = `${this.endpoint}/v1/${name}:generateAccessToken`;\n            const body = {\n                delegates: this.delegates,\n                scope: this.targetScopes,\n                lifetime: this.lifetime + \"s\"\n            };\n            const res = await this.sourceClient.request({\n                ...Impersonated.RETRY_CONFIG,\n                url: u,\n                data: body,\n                method: \"POST\"\n            });\n            const tokenResponse = res.data;\n            this.credentials.access_token = tokenResponse.accessToken;\n            this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);\n            return {\n                tokens: this.credentials,\n                res\n            };\n        } catch (error) {\n            if (!(error instanceof Error)) throw error;\n            let status = 0;\n            let message = \"\";\n            if (error instanceof gaxios_1.GaxiosError) {\n                status = (_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.status;\n                message = (_f = (_e = (_d = error === null || error === void 0 ? void 0 : error.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.message;\n            }\n            if (status && message) {\n                error.message = `${status}: unable to impersonate: ${message}`;\n                throw error;\n            } else {\n                error.message = `unable to impersonate: ${error}`;\n                throw error;\n            }\n        }\n    }\n    /**\n     * Generates an OpenID Connect ID token for a service account.\n     *\n     * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}\n     *\n     * @param targetAudience the audience for the fetched ID token.\n     * @param options the for the request\n     * @return an OpenID Connect ID token\n     */ async fetchIdToken(targetAudience, options) {\n        var _a, _b;\n        await this.sourceClient.getAccessToken();\n        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;\n        const u = `${this.endpoint}/v1/${name}:generateIdToken`;\n        const body = {\n            delegates: this.delegates,\n            audience: targetAudience,\n            includeEmail: (_a = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _a !== void 0 ? _a : true,\n            useEmailAzp: (_b = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _b !== void 0 ? _b : true\n        };\n        const res = await this.sourceClient.request({\n            ...Impersonated.RETRY_CONFIG,\n            url: u,\n            data: body,\n            method: \"POST\"\n        });\n        return res.data.token;\n    }\n}\nexports.Impersonated = Impersonated;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pbXBlcnNvbmF0ZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUdBLGlDQUFpQyxHQUFHLEtBQUs7QUFDaEUsTUFBTUksaUJBQWlCQyxtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDL0MsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsOERBQVE7QUFDakMsTUFBTUUsU0FBU0YsbUJBQU9BLENBQUMsMkVBQVM7QUFDaENMLGlDQUFpQyxHQUFHO0FBQ3BDLE1BQU1FLHFCQUFxQkUsZUFBZUksWUFBWTtJQUNsRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQStCQyxHQUNEQyxZQUFZQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQ3RCLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDO1FBQ3hCLEtBQUssQ0FBQ047UUFDTixtRUFBbUU7UUFDbkUsK0NBQStDO1FBQy9DLElBQUksQ0FBQ08sV0FBVyxHQUFHO1lBQ2ZDLGFBQWE7WUFDYkMsZUFBZTtRQUNuQjtRQUNBLElBQUksQ0FBQ0MsWUFBWSxHQUFHLENBQUNULEtBQUtELFFBQVFVLFlBQVksTUFBTSxRQUFRVCxPQUFPLEtBQUssSUFBSUEsS0FBSyxJQUFJUCxlQUFlSSxZQUFZO1FBQ2hILElBQUksQ0FBQ2EsZUFBZSxHQUFHLENBQUNULEtBQUtGLFFBQVFXLGVBQWUsTUFBTSxRQUFRVCxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUN2RixJQUFJLENBQUNVLFNBQVMsR0FBRyxDQUFDVCxLQUFLSCxRQUFRWSxTQUFTLE1BQU0sUUFBUVQsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtRQUM3RSxJQUFJLENBQUNVLFlBQVksR0FBRyxDQUFDVCxLQUFLSixRQUFRYSxZQUFZ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QU8sRUFBRTtRQUN4QyxJQUFJQyxJQUFJQztRQUNSLE1BQU0sSUFBSSxDQUFDUSxZQUFZLENBQUNhLGNBQWM7UUFDdEMsTUFBTUMsT0FBTyxDQUFDLDJCQUEyQixFQUFFLElBQUksQ0FBQ2IsZUFBZSxDQUFDLENBQUM7UUFDakUsTUFBTWMsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDTCxRQUFRLENBQUMsSUFBSSxFQUFFSSxLQUFLLGdCQUFnQixDQUFDO1FBQ3ZELE1BQU1FLE9BQU87WUFDVGQsV0FBVyxJQUFJLENBQUNBLFNBQVM7WUFDekIyQyxVQUFVRDtZQUNWRSxjQUFjLENBQUN2RCxLQUFLRCxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUXdELFlBQVksTUFBTSxRQUFRdkQsT0FBTyxLQUFLLElBQUlBLEtBQUs7WUFDN0h3RCxhQUFhLENBQUN2RCxLQUFLRixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUXdELFlBQVksTUFBTSxRQUFRdEQsT0FBTyxLQUFLLElBQUlBLEtBQUs7UUFDaEk7UUFDQSxNQUFNNkIsTUFBTSxNQUFNLElBQUksQ0FBQ3JCLFlBQVksQ0FBQ3NCLE9BQU8sQ0FBQztZQUN4QyxHQUFHeEMsYUFBYXlDLFlBQVk7WUFDNUJDLEtBQUtUO1lBQ0xVLE1BQU1UO1lBQ05VLFFBQVE7UUFDWjtRQUNBLE9BQU9MLElBQUlJLElBQUksQ0FBQ3VCLEtBQUs7SUFDekI7QUFDSjtBQUNBcEUsb0JBQW9CLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9pbXBlcnNvbmF0ZWQuanM/NWM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW1wZXJzb25hdGVkID0gZXhwb3J0cy5JTVBFUlNPTkFURURfQUNDT1VOVF9UWVBFID0gdm9pZCAwO1xuY29uc3Qgb2F1dGgyY2xpZW50XzEgPSByZXF1aXJlKFwiLi9vYXV0aDJjbGllbnRcIik7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmV4cG9ydHMuSU1QRVJTT05BVEVEX0FDQ09VTlRfVFlQRSA9ICdpbXBlcnNvbmF0ZWRfc2VydmljZV9hY2NvdW50JztcbmNsYXNzIEltcGVyc29uYXRlZCBleHRlbmRzIG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW1wZXJzb25hdGVkIHNlcnZpY2UgYWNjb3VudCBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIENyZWF0ZSBhIG5ldyBhY2Nlc3MgdG9rZW4gYnkgaW1wZXJzb25hdGluZyBhbm90aGVyIHNlcnZpY2UgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEltcGVyc29uYXRlZCBDcmVkZW50aWFscyBhbGxvd2luZyBjcmVkZW50aWFscyBpc3N1ZWQgdG8gYSB1c2VyIG9yXG4gICAgICogc2VydmljZSBhY2NvdW50IHRvIGltcGVyc29uYXRlIGFub3RoZXIuIFRoZSBzb3VyY2UgcHJvamVjdCB1c2luZ1xuICAgICAqIEltcGVyc29uYXRlZCBDcmVkZW50aWFscyBtdXN0IGVuYWJsZSB0aGUgXCJJQU1DcmVkZW50aWFsc1wiIEFQSS5cbiAgICAgKiBBbHNvLCB0aGUgdGFyZ2V0IHNlcnZpY2UgYWNjb3VudCBtdXN0IGdyYW50IHRoZSBvcmdpbmF0aW5nIHByaW5jaXBhbFxuICAgICAqIHRoZSBcIlNlcnZpY2UgQWNjb3VudCBUb2tlbiBDcmVhdG9yXCIgSUFNIHJvbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuc291cmNlQ2xpZW50XSB0aGUgc291cmNlIGNyZWRlbnRpYWwgdXNlZCBhcyB0b1xuICAgICAqIGFjcXVpcmUgdGhlIGltcGVyc29uYXRlZCBjcmVkZW50aWFscy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGFyZ2V0UHJpbmNpcGFsXSB0aGUgc2VydmljZSBhY2NvdW50IHRvXG4gICAgICogaW1wZXJzb25hdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMuZGVsZWdhdGVzXSB0aGUgY2hhaW5lZCBsaXN0IG9mIGRlbGVnYXRlc1xuICAgICAqIHJlcXVpcmVkIHRvIGdyYW50IHRoZSBmaW5hbCBhY2Nlc3NfdG9rZW4uIElmIHNldCwgdGhlIHNlcXVlbmNlIG9mXG4gICAgICogaWRlbnRpdGllcyBtdXN0IGhhdmUgXCJTZXJ2aWNlIEFjY291bnQgVG9rZW4gQ3JlYXRvclwiIGNhcGFiaWxpdHkgZ3JhbnRlZCB0b1xuICAgICAqIHRoZSBwcmVjZWRpbmcgaWRlbnRpdHkuIEZvciBleGFtcGxlLCBpZiBzZXQgdG8gW3NlcnZpY2VBY2NvdW50QixcbiAgICAgKiBzZXJ2aWNlQWNjb3VudENdLCB0aGUgc291cmNlQ3JlZGVudGlhbCBtdXN0IGhhdmUgdGhlIFRva2VuIENyZWF0b3Igcm9sZSBvblxuICAgICAqIHNlcnZpY2VBY2NvdW50Qi4gc2VydmljZUFjY291bnRCIG11c3QgaGF2ZSB0aGUgVG9rZW4gQ3JlYXRvciBvblxuICAgICAqIHNlcnZpY2VBY2NvdW50Qy4gRmluYWxseSwgQyBtdXN0IGhhdmUgVG9rZW4gQ3JlYXRvciBvbiB0YXJnZXRfcHJpbmNpcGFsLlxuICAgICAqIElmIGxlZnQgdW5zZXQsIHNvdXJjZUNyZWRlbnRpYWwgbXVzdCBoYXZlIHRoYXQgcm9sZSBvbiB0YXJnZXRQcmluY2lwYWwuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMudGFyZ2V0U2NvcGVzXSBzY29wZXMgdG8gcmVxdWVzdCBkdXJpbmcgdGhlXG4gICAgICogYXV0aG9yaXphdGlvbiBncmFudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGlmZXRpbWVdIG51bWJlciBvZiBzZWNvbmRzIHRoZSBkZWxlZ2F0ZWRcbiAgICAgKiBjcmVkZW50aWFsIHNob3VsZCBiZSB2YWxpZCBmb3IgdXAgdG8gMzYwMCBzZWNvbmRzIGJ5IGRlZmF1bHQsIG9yIDQzLDIwMFxuICAgICAqIHNlY29uZHMgYnkgZXh0ZW5kaW5nIHRoZSB0b2tlbidzIGxpZmV0aW1lLCBzZWU6XG4gICAgICogaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lhbS9kb2NzL2NyZWF0aW5nLXNob3J0LWxpdmVkLXNlcnZpY2UtYWNjb3VudC1jcmVkZW50aWFscyNzYS1jcmVkZW50aWFscy1vYXV0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmRwb2ludF0gYXBpIGVuZHBvaW50IG92ZXJyaWRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYW4gZXhwaXJlZCByZWZyZXNoIHRva2VuLCB3aGljaCB3aWxsIGF1dG9tYXRpY2FsbHkgYmVcbiAgICAgICAgLy8gcmVmcmVzaGVkIGJlZm9yZSB0aGUgZmlyc3QgQVBJIGNhbGwgaXMgbWFkZS5cbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHtcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiAxLFxuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogJ2ltcGVyc29uYXRlZC1wbGFjZWhvbGRlcicsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc291cmNlQ2xpZW50ID0gKF9hID0gb3B0aW9ucy5zb3VyY2VDbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBvYXV0aDJjbGllbnRfMS5PQXV0aDJDbGllbnQoKTtcbiAgICAgICAgdGhpcy50YXJnZXRQcmluY2lwYWwgPSAoX2IgPSBvcHRpb25zLnRhcmdldFByaW5jaXBhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVzID0gKF9jID0gb3B0aW9ucy5kZWxlZ2F0ZXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xuICAgICAgICB0aGlzLnRhcmdldFNjb3BlcyA9IChfZCA9IG9wdGlvbnMudGFyZ2V0U2NvcGVzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXTtcbiAgICAgICAgdGhpcy5saWZldGltZSA9IChfZSA9IG9wdGlvbnMubGlmZXRpbWUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDM2MDA7XG4gICAgICAgIGNvbnN0IHVzaW5nRXhwbGljaXRVbml2ZXJzZURvbWFpbiA9ICEhKDAsIHV0aWxfMS5vcmlnaW5hbE9yQ2FtZWxPcHRpb25zKShvcHRpb25zKS5nZXQoJ3VuaXZlcnNlX2RvbWFpbicpO1xuICAgICAgICBpZiAoIXVzaW5nRXhwbGljaXRVbml2ZXJzZURvbWFpbikge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdW5pdmVyc2Ugd2l0aCB0aGUgc291cmNlJ3MgdW5pdmVyc2VcbiAgICAgICAgICAgIHRoaXMudW5pdmVyc2VEb21haW4gPSB0aGlzLnNvdXJjZUNsaWVudC51bml2ZXJzZURvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNvdXJjZUNsaWVudC51bml2ZXJzZURvbWFpbiAhPT0gdGhpcy51bml2ZXJzZURvbWFpbikge1xuICAgICAgICAgICAgLy8gbm9uLWRlZmF1bHQgdW5pdmVyc2UgYW5kIGlzIG5vdCBtYXRjaGluZyB0aGUgc291cmNlIC0gdGhpcyBjb3VsZCBiZSBhIGNyZWRlbnRpYWwgbGVha1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuaXZlcnNlIGRvbWFpbiAke3RoaXMuc291cmNlQ2xpZW50LnVuaXZlcnNlRG9tYWlufSBpbiBzb3VyY2UgY3JlZGVudGlhbHMgZG9lcyBub3QgbWF0Y2ggJHt0aGlzLnVuaXZlcnNlRG9tYWlufSB1bml2ZXJzZSBkb21haW4gc2V0IGZvciBpbXBlcnNvbmF0ZWQgY3JlZGVudGlhbHMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRwb2ludCA9XG4gICAgICAgICAgICAoX2YgPSBvcHRpb25zLmVuZHBvaW50KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBgaHR0cHM6Ly9pYW1jcmVkZW50aWFscy4ke3RoaXMudW5pdmVyc2VEb21haW59YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgc29tZSBieXRlcy5cbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWFtL2RvY3MvcmVmZXJlbmNlL2NyZWRlbnRpYWxzL3Jlc3QvdjEvcHJvamVjdHMuc2VydmljZUFjY291bnRzL3NpZ25CbG9iIFJlZmVyZW5jZSBEb2N1bWVudGF0aW9ufVxuICAgICAqIEBwYXJhbSBibG9iVG9TaWduIFN0cmluZyB0byBzaWduLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB7QGxpbmsgU2lnbkJsb2JSZXNwb25zZX0gZGVub3RpbmcgdGhlIGtleUlEIGFuZCBzaWduZWRCbG9iIGluIGJhc2U2NCBzdHJpbmdcbiAgICAgKi9cbiAgICBhc3luYyBzaWduKGJsb2JUb1NpZ24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zb3VyY2VDbGllbnQuZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGBwcm9qZWN0cy8tL3NlcnZpY2VBY2NvdW50cy8ke3RoaXMudGFyZ2V0UHJpbmNpcGFsfWA7XG4gICAgICAgIGNvbnN0IHUgPSBgJHt0aGlzLmVuZHBvaW50fS92MS8ke25hbWV9OnNpZ25CbG9iYDtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGRlbGVnYXRlczogdGhpcy5kZWxlZ2F0ZXMsXG4gICAgICAgICAgICBwYXlsb2FkOiBCdWZmZXIuZnJvbShibG9iVG9TaWduKS50b1N0cmluZygnYmFzZTY0JyksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuc291cmNlQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgLi4uSW1wZXJzb25hdGVkLlJFVFJZX0NPTkZJRyxcbiAgICAgICAgICAgIHVybDogdSxcbiAgICAgICAgICAgIGRhdGE6IGJvZHksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXMuZGF0YTtcbiAgICB9XG4gICAgLyoqIFRoZSBzZXJ2aWNlIGFjY291bnQgZW1haWwgdG8gYmUgaW1wZXJzb25hdGVkLiAqL1xuICAgIGdldFRhcmdldFByaW5jaXBhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0UHJpbmNpcGFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW4oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zb3VyY2VDbGllbnQuZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAncHJvamVjdHMvLS9zZXJ2aWNlQWNjb3VudHMvJyArIHRoaXMudGFyZ2V0UHJpbmNpcGFsO1xuICAgICAgICAgICAgY29uc3QgdSA9IGAke3RoaXMuZW5kcG9pbnR9L3YxLyR7bmFtZX06Z2VuZXJhdGVBY2Nlc3NUb2tlbmA7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgICAgIGRlbGVnYXRlczogdGhpcy5kZWxlZ2F0ZXMsXG4gICAgICAgICAgICAgICAgc2NvcGU6IHRoaXMudGFyZ2V0U2NvcGVzLFxuICAgICAgICAgICAgICAgIGxpZmV0aW1lOiB0aGlzLmxpZmV0aW1lICsgJ3MnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuc291cmNlQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIC4uLkltcGVyc29uYXRlZC5SRVRSWV9DT05GSUcsXG4gICAgICAgICAgICAgICAgdXJsOiB1LFxuICAgICAgICAgICAgICAgIGRhdGE6IGJvZHksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuUmVzcG9uc2UgPSByZXMuZGF0YTtcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuID0gdG9rZW5SZXNwb25zZS5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIHRoaXMuY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGUgPSBEYXRlLnBhcnNlKHRva2VuUmVzcG9uc2UuZXhwaXJlVGltZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5jcmVkZW50aWFscyxcbiAgICAgICAgICAgICAgICByZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBsZXQgc3RhdHVzID0gMDtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBnYXhpb3NfMS5HYXhpb3NFcnJvcikge1xuICAgICAgICAgICAgICAgIHN0YXR1cyA9IChfYyA9IChfYiA9IChfYSA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5yZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5lcnJvcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0YXR1cztcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gKF9mID0gKF9lID0gKF9kID0gZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZGF0YSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmVycm9yKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0dXMgJiYgbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgJHtzdGF0dXN9OiB1bmFibGUgdG8gaW1wZXJzb25hdGU6ICR7bWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGB1bmFibGUgdG8gaW1wZXJzb25hdGU6ICR7ZXJyb3J9YDtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4gT3BlbklEIENvbm5lY3QgSUQgdG9rZW4gZm9yIGEgc2VydmljZSBhY2NvdW50LlxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pYW0vZG9jcy9yZWZlcmVuY2UvY3JlZGVudGlhbHMvcmVzdC92MS9wcm9qZWN0cy5zZXJ2aWNlQWNjb3VudHMvZ2VuZXJhdGVJZFRva2VuIFJlZmVyZW5jZSBEb2N1bWVudGF0aW9ufVxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldEF1ZGllbmNlIHRoZSBhdWRpZW5jZSBmb3IgdGhlIGZldGNoZWQgSUQgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIGZvciB0aGUgcmVxdWVzdFxuICAgICAqIEByZXR1cm4gYW4gT3BlbklEIENvbm5lY3QgSUQgdG9rZW5cbiAgICAgKi9cbiAgICBhc3luYyBmZXRjaElkVG9rZW4odGFyZ2V0QXVkaWVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgYXdhaXQgdGhpcy5zb3VyY2VDbGllbnQuZ2V0QWNjZXNzVG9rZW4oKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGBwcm9qZWN0cy8tL3NlcnZpY2VBY2NvdW50cy8ke3RoaXMudGFyZ2V0UHJpbmNpcGFsfWA7XG4gICAgICAgIGNvbnN0IHUgPSBgJHt0aGlzLmVuZHBvaW50fS92MS8ke25hbWV9OmdlbmVyYXRlSWRUb2tlbmA7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBkZWxlZ2F0ZXM6IHRoaXMuZGVsZWdhdGVzLFxuICAgICAgICAgICAgYXVkaWVuY2U6IHRhcmdldEF1ZGllbmNlLFxuICAgICAgICAgICAgaW5jbHVkZUVtYWlsOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5jbHVkZUVtYWlsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlLFxuICAgICAgICAgICAgdXNlRW1haWxBenA6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pbmNsdWRlRW1haWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuc291cmNlQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgLi4uSW1wZXJzb25hdGVkLlJFVFJZX0NPTkZJRyxcbiAgICAgICAgICAgIHVybDogdSxcbiAgICAgICAgICAgIGRhdGE6IGJvZHksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXMuZGF0YS50b2tlbjtcbiAgICB9XG59XG5leHBvcnRzLkltcGVyc29uYXRlZCA9IEltcGVyc29uYXRlZDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkltcGVyc29uYXRlZCIsIklNUEVSU09OQVRFRF9BQ0NPVU5UX1RZUEUiLCJvYXV0aDJjbGllbnRfMSIsInJlcXVpcmUiLCJnYXhpb3NfMSIsInV0aWxfMSIsIk9BdXRoMkNsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsImNyZWRlbnRpYWxzIiwiZXhwaXJ5X2RhdGUiLCJyZWZyZXNoX3Rva2VuIiwic291cmNlQ2xpZW50IiwidGFyZ2V0UHJpbmNpcGFsIiwiZGVsZWdhdGVzIiwidGFyZ2V0U2NvcGVzIiwibGlmZXRpbWUiLCJ1c2luZ0V4cGxpY2l0VW5pdmVyc2VEb21haW4iLCJvcmlnaW5hbE9yQ2FtZWxPcHRpb25zIiwiZ2V0IiwidW5pdmVyc2VEb21haW4iLCJSYW5nZUVycm9yIiwiZW5kcG9pbnQiLCJzaWduIiwiYmxvYlRvU2lnbiIsImdldEFjY2Vzc1Rva2VuIiwibmFtZSIsInUiLCJib2R5IiwicGF5bG9hZCIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsInJlcyIsInJlcXVlc3QiLCJSRVRSWV9DT05GSUciLCJ1cmwiLCJkYXRhIiwibWV0aG9kIiwiZ2V0VGFyZ2V0UHJpbmNpcGFsIiwicmVmcmVzaFRva2VuIiwic2NvcGUiLCJ0b2tlblJlc3BvbnNlIiwiYWNjZXNzX3Rva2VuIiwiYWNjZXNzVG9rZW4iLCJEYXRlIiwicGFyc2UiLCJleHBpcmVUaW1lIiwidG9rZW5zIiwiZXJyb3IiLCJFcnJvciIsInN0YXR1cyIsIm1lc3NhZ2UiLCJHYXhpb3NFcnJvciIsInJlc3BvbnNlIiwiZmV0Y2hJZFRva2VuIiwidGFyZ2V0QXVkaWVuY2UiLCJhdWRpZW5jZSIsImluY2x1ZGVFbWFpbCIsInVzZUVtYWlsQXpwIiwidG9rZW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/jwtaccess.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JWTAccess = void 0;\nconst jws = __webpack_require__(/*! jws */ \"(rsc)/./node_modules/jws/index.js\");\nconst util_1 = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/google-auth-library/build/src/util.js\");\nconst DEFAULT_HEADER = {\n    alg: \"RS256\",\n    typ: \"JWT\"\n};\nclass JWTAccess {\n    /**\n     * JWTAccess service account credentials.\n     *\n     * Create a new access token by using the credential to create a new JWT token\n     * that's recognized as the access token.\n     *\n     * @param email the service account email address.\n     * @param key the private key that will be used to sign the token.\n     * @param keyId the ID of the private key used to sign the token.\n     */ constructor(email, key, keyId, eagerRefreshThresholdMillis){\n        this.cache = new util_1.LRUCache({\n            capacity: 500,\n            maxAge: 60 * 60 * 1000\n        });\n        this.email = email;\n        this.key = key;\n        this.keyId = keyId;\n        this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;\n    }\n    /**\n     * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url\n     *\n     * @param url The URI being authorized.\n     * @param scopes The scope or scopes being authorized\n     * @returns A string that returns the cached key.\n     */ getCachedKey(url, scopes) {\n        let cacheKey = url;\n        if (scopes && Array.isArray(scopes) && scopes.length) {\n            cacheKey = url ? `${url}_${scopes.join(\"_\")}` : `${scopes.join(\"_\")}`;\n        } else if (typeof scopes === \"string\") {\n            cacheKey = url ? `${url}_${scopes}` : scopes;\n        }\n        if (!cacheKey) {\n            throw Error(\"Scopes or url must be provided\");\n        }\n        return cacheKey;\n    }\n    /**\n     * Get a non-expired access token, after refreshing if necessary.\n     *\n     * @param url The URI being authorized.\n     * @param additionalClaims An object with a set of additional claims to\n     * include in the payload.\n     * @returns An object that includes the authorization header.\n     */ getRequestHeaders(url, additionalClaims, scopes) {\n        // Return cached authorization headers, unless we are within\n        // eagerRefreshThresholdMillis ms of them expiring:\n        const key = this.getCachedKey(url, scopes);\n        const cachedToken = this.cache.get(key);\n        const now = Date.now();\n        if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {\n            return cachedToken.headers;\n        }\n        const iat = Math.floor(Date.now() / 1000);\n        const exp = JWTAccess.getExpirationTime(iat);\n        let defaultClaims;\n        // Turn scopes into space-separated string\n        if (Array.isArray(scopes)) {\n            scopes = scopes.join(\" \");\n        }\n        // If scopes are specified, sign with scopes\n        if (scopes) {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                scope: scopes,\n                exp,\n                iat\n            };\n        } else {\n            defaultClaims = {\n                iss: this.email,\n                sub: this.email,\n                aud: url,\n                exp,\n                iat\n            };\n        }\n        // if additionalClaims are provided, ensure they do not collide with\n        // other required claims.\n        if (additionalClaims) {\n            for(const claim in defaultClaims){\n                if (additionalClaims[claim]) {\n                    throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);\n                }\n            }\n        }\n        const header = this.keyId ? {\n            ...DEFAULT_HEADER,\n            kid: this.keyId\n        } : DEFAULT_HEADER;\n        const payload = Object.assign(defaultClaims, additionalClaims);\n        // Sign the jwt and add it to the cache\n        const signedJWT = jws.sign({\n            header,\n            payload,\n            secret: this.key\n        });\n        const headers = {\n            Authorization: `Bearer ${signedJWT}`\n        };\n        this.cache.set(key, {\n            expiration: exp * 1000,\n            headers\n        });\n        return headers;\n    }\n    /**\n     * Returns an expiration time for the JWT token.\n     *\n     * @param iat The issued at time for the JWT.\n     * @returns An expiration time for the JWT.\n     */ static getExpirationTime(iat) {\n        const exp = iat + 3600; // 3600 seconds = 1 hour\n        return exp;\n    }\n    /**\n     * Create a JWTAccess credentials instance using the given input options.\n     * @param json The input object.\n     */ fromJSON(json) {\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing the service account auth settings.\");\n        }\n        if (!json.client_email) {\n            throw new Error(\"The incoming JSON object does not contain a client_email field\");\n        }\n        if (!json.private_key) {\n            throw new Error(\"The incoming JSON object does not contain a private_key field\");\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(()=>callback(), callback);\n        } else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                reject(new Error(\"Must pass in a stream containing the service account auth settings.\"));\n            }\n            let s = \"\";\n            inputStream.setEncoding(\"utf8\").on(\"data\", (chunk)=>s += chunk).on(\"error\", reject).on(\"end\", ()=>{\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                } catch (err) {\n                    reject(err);\n                }\n            });\n        });\n    }\n}\nexports.JWTAccess = JWTAccess;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9qd3RhY2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLE1BQU1DLG1CQUFPQSxDQUFDLDhDQUFLO0FBQ3pCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDLDJFQUFTO0FBQ2hDLE1BQU1FLGlCQUFpQjtJQUNuQkMsS0FBSztJQUNMQyxLQUFLO0FBQ1Q7QUFDQSxNQUFNTjtJQUNGOzs7Ozs7Ozs7S0FTQyxHQUNETyxZQUFZQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQywyQkFBMkIsQ0FBRTtRQUN4RCxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJVCxPQUFPVSxRQUFRLENBQUM7WUFDN0JDLFVBQVU7WUFDVkMsUUFBUSxLQUFLLEtBQUs7UUFDdEI7UUFDQSxJQUFJLENBQUNQLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLDJCQUEyQixHQUM1QkEsZ0NBQWdDLFFBQVFBLGdDQUFnQyxLQUFLLElBQUlBLDhCQUE4QixJQUFJLEtBQUs7SUFDaEk7SUFDQTs7Ozs7O0tBTUMsR0FDREssYUFBYUMsR0FBRyxFQUFFQyxNQUFNLEVBQUU7UUFDdEIsSUFBSUMsV0FBV0Y7UUFDZixJQUFJQyxVQUFVRSxNQUFNQyxPQUFPLENBQUNILFdBQVdBLE9BQU9J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L2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvand0YWNjZXNzLmpzP2NiOTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSldUQWNjZXNzID0gdm9pZCAwO1xuY29uc3QgandzID0gcmVxdWlyZShcImp3c1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgREVGQVVMVF9IRUFERVIgPSB7XG4gICAgYWxnOiAnUlMyNTYnLFxuICAgIHR5cDogJ0pXVCcsXG59O1xuY2xhc3MgSldUQWNjZXNzIHtcbiAgICAvKipcbiAgICAgKiBKV1RBY2Nlc3Mgc2VydmljZSBhY2NvdW50IGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQ3JlYXRlIGEgbmV3IGFjY2VzcyB0b2tlbiBieSB1c2luZyB0aGUgY3JlZGVudGlhbCB0byBjcmVhdGUgYSBuZXcgSldUIHRva2VuXG4gICAgICogdGhhdCdzIHJlY29nbml6ZWQgYXMgdGhlIGFjY2VzcyB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbWFpbCB0aGUgc2VydmljZSBhY2NvdW50IGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGtleSB0aGUgcHJpdmF0ZSBrZXkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gc2lnbiB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIGtleUlkIHRoZSBJRCBvZiB0aGUgcHJpdmF0ZSBrZXkgdXNlZCB0byBzaWduIHRoZSB0b2tlbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbWFpbCwga2V5LCBrZXlJZCwgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgdXRpbF8xLkxSVUNhY2hlKHtcbiAgICAgICAgICAgIGNhcGFjaXR5OiA1MDAsXG4gICAgICAgICAgICBtYXhBZ2U6IDYwICogNjAgKiAxMDAwLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWFpbCA9IGVtYWlsO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IGtleUlkO1xuICAgICAgICB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyA9XG4gICAgICAgICAgICBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgIT09IG51bGwgJiYgZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzICE9PSB2b2lkIDAgPyBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMgOiA1ICogNjAgKiAxMDAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgd2UncmUgY2FjaGluZyBhIGtleSBhcHByb3ByaWF0ZWx5LCBnaXZpbmcgcHJlY2VkZW5jZSB0byBzY29wZXMgdnMuIHVybFxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJJIGJlaW5nIGF1dGhvcml6ZWQuXG4gICAgICogQHBhcmFtIHNjb3BlcyBUaGUgc2NvcGUgb3Igc2NvcGVzIGJlaW5nIGF1dGhvcml6ZWRcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyB0aGF0IHJldHVybnMgdGhlIGNhY2hlZCBrZXkuXG4gICAgICovXG4gICAgZ2V0Q2FjaGVkS2V5KHVybCwgc2NvcGVzKSB7XG4gICAgICAgIGxldCBjYWNoZUtleSA9IHVybDtcbiAgICAgICAgaWYgKHNjb3BlcyAmJiBBcnJheS5pc0FycmF5KHNjb3BlcykgJiYgc2NvcGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FjaGVLZXkgPSB1cmwgPyBgJHt1cmx9XyR7c2NvcGVzLmpvaW4oJ18nKX1gIDogYCR7c2NvcGVzLmpvaW4oJ18nKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY29wZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjYWNoZUtleSA9IHVybCA/IGAke3VybH1fJHtzY29wZXN9YCA6IHNjb3BlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhY2hlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU2NvcGVzIG9yIHVybCBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBub24tZXhwaXJlZCBhY2Nlc3MgdG9rZW4sIGFmdGVyIHJlZnJlc2hpbmcgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCBUaGUgVVJJIGJlaW5nIGF1dGhvcml6ZWQuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxDbGFpbXMgQW4gb2JqZWN0IHdpdGggYSBzZXQgb2YgYWRkaXRpb25hbCBjbGFpbXMgdG9cbiAgICAgKiBpbmNsdWRlIGluIHRoZSBwYXlsb2FkLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB0aGF0IGluY2x1ZGVzIHRoZSBhdXRob3JpemF0aW9uIGhlYWRlci5cbiAgICAgKi9cbiAgICBnZXRSZXF1ZXN0SGVhZGVycyh1cmwsIGFkZGl0aW9uYWxDbGFpbXMsIHNjb3Blcykge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGF1dGhvcml6YXRpb24gaGVhZGVycywgdW5sZXNzIHdlIGFyZSB3aXRoaW5cbiAgICAgICAgLy8gZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzIG1zIG9mIHRoZW0gZXhwaXJpbmc6XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0Q2FjaGVkS2V5KHVybCwgc2NvcGVzKTtcbiAgICAgICAgY29uc3QgY2FjaGVkVG9rZW4gPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoY2FjaGVkVG9rZW4gJiZcbiAgICAgICAgICAgIGNhY2hlZFRva2VuLmV4cGlyYXRpb24gLSBub3cgPiB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFRva2VuLmhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWF0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgIGNvbnN0IGV4cCA9IEpXVEFjY2Vzcy5nZXRFeHBpcmF0aW9uVGltZShpYXQpO1xuICAgICAgICBsZXQgZGVmYXVsdENsYWltcztcbiAgICAgICAgLy8gVHVybiBzY29wZXMgaW50byBzcGFjZS1zZXBhcmF0ZWQgc3RyaW5nXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjb3BlcykpIHtcbiAgICAgICAgICAgIHNjb3BlcyA9IHNjb3Blcy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgc2NvcGVzIGFyZSBzcGVjaWZpZWQsIHNpZ24gd2l0aCBzY29wZXNcbiAgICAgICAgaWYgKHNjb3Blcykge1xuICAgICAgICAgICAgZGVmYXVsdENsYWltcyA9IHtcbiAgICAgICAgICAgICAgICBpc3M6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICAgICAgc3ViOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAgICAgIHNjb3BlOiBzY29wZXMsXG4gICAgICAgICAgICAgICAgZXhwLFxuICAgICAgICAgICAgICAgIGlhdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0Q2xhaW1zID0ge1xuICAgICAgICAgICAgICAgIGlzczogdGhpcy5lbWFpbCxcbiAgICAgICAgICAgICAgICBzdWI6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICAgICAgYXVkOiB1cmwsXG4gICAgICAgICAgICAgICAgZXhwLFxuICAgICAgICAgICAgICAgIGlhdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYWRkaXRpb25hbENsYWltcyBhcmUgcHJvdmlkZWQsIGVuc3VyZSB0aGV5IGRvIG5vdCBjb2xsaWRlIHdpdGhcbiAgICAgICAgLy8gb3RoZXIgcmVxdWlyZWQgY2xhaW1zLlxuICAgICAgICBpZiAoYWRkaXRpb25hbENsYWltcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjbGFpbSBpbiBkZWZhdWx0Q2xhaW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxDbGFpbXNbY2xhaW1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICcke2NsYWltfScgcHJvcGVydHkgaXMgbm90IGFsbG93ZWQgd2hlbiBwYXNzaW5nIGFkZGl0aW9uYWxDbGFpbXMuIFRoaXMgY2xhaW0gaXMgaW5jbHVkZWQgaW4gdGhlIEpXVCBieSBkZWZhdWx0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLmtleUlkXG4gICAgICAgICAgICA/IHsgLi4uREVGQVVMVF9IRUFERVIsIGtpZDogdGhpcy5rZXlJZCB9XG4gICAgICAgICAgICA6IERFRkFVTFRfSEVBREVSO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0Q2xhaW1zLCBhZGRpdGlvbmFsQ2xhaW1zKTtcbiAgICAgICAgLy8gU2lnbiB0aGUgand0IGFuZCBhZGQgaXQgdG8gdGhlIGNhY2hlXG4gICAgICAgIGNvbnN0IHNpZ25lZEpXVCA9IGp3cy5zaWduKHsgaGVhZGVyLCBwYXlsb2FkLCBzZWNyZXQ6IHRoaXMua2V5IH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7c2lnbmVkSldUfWAgfTtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB7XG4gICAgICAgICAgICBleHBpcmF0aW9uOiBleHAgKiAxMDAwLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIEpXVCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpYXQgVGhlIGlzc3VlZCBhdCB0aW1lIGZvciB0aGUgSldULlxuICAgICAqIEByZXR1cm5zIEFuIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIEpXVC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RXhwaXJhdGlvblRpbWUoaWF0KSB7XG4gICAgICAgIGNvbnN0IGV4cCA9IGlhdCArIDM2MDA7IC8vIDM2MDAgc2Vjb25kcyA9IDEgaG91clxuICAgICAgICByZXR1cm4gZXhwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBKV1RBY2Nlc3MgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGlucHV0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXJ2aWNlIGFjY291bnQgYXV0aCBzZXR0aW5ncy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uY2xpZW50X2VtYWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgY2xpZW50X2VtYWlsIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgcHJpdmF0ZV9rZXkgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IHRoZSByZWxldmFudCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBqc29uIGtleSBmaWxlLlxuICAgICAgICB0aGlzLmVtYWlsID0ganNvbi5jbGllbnRfZW1haWw7XG4gICAgICAgIHRoaXMua2V5ID0ganNvbi5wcml2YXRlX2tleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IGpzb24ucHJpdmF0ZV9rZXlfaWQ7XG4gICAgICAgIHRoaXMucHJvamVjdElkID0ganNvbi5wcm9qZWN0X2lkO1xuICAgIH1cbiAgICBmcm9tU3RyZWFtKGlucHV0U3RyZWFtLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKS50aGVuKCgpID0+IGNhbGxiYWNrKCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIHNlcnZpY2UgYWNjb3VudCBhdXRoIHNldHRpbmdzLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbVxuICAgICAgICAgICAgICAgIC5zZXRFbmNvZGluZygndXRmOCcpXG4gICAgICAgICAgICAgICAgLm9uKCdkYXRhJywgY2h1bmsgPT4gKHMgKz0gY2h1bmspKVxuICAgICAgICAgICAgICAgIC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgICAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uocyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUpTT04oZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5KV1RBY2Nlc3MgPSBKV1RBY2Nlc3M7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJKV1RBY2Nlc3MiLCJqd3MiLCJyZXF1aXJlIiwidXRpbF8xIiwiREVGQVVMVF9IRUFERVIiLCJhbGciLCJ0eXAiLCJjb25zdHJ1Y3RvciIsImVtYWlsIiwia2V5Iiwia2V5SWQiLCJlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMiLCJjYWNoZSIsIkxSVUNhY2hlIiwiY2FwYWNpdHkiLCJtYXhBZ2UiLCJnZXRDYWNoZWRLZXkiLCJ1cmwiLCJzY29wZXMiLCJjYWNoZUtleSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImpvaW4iLCJFcnJvciIsImdldFJlcXVlc3RIZWFkZXJzIiwiYWRkaXRpb25hbENsYWltcyIsImNhY2hlZFRva2VuIiwiZ2V0Iiwibm93IiwiRGF0ZSIsImV4cGlyYXRpb24iLCJoZWFkZXJzIiwiaWF0IiwiTWF0aCIsImZsb29yIiwiZXhwIiwiZ2V0RXhwaXJhdGlvblRpbWUiLCJkZWZhdWx0Q2xhaW1zIiwiaXNzIiwic3ViIiwic2NvcGUiLCJhdWQiLCJjbGFpbSIsImhlYWRlciIsImtpZCIsInBheWxvYWQiLCJhc3NpZ24iLCJzaWduZWRKV1QiLCJzaWduIiwic2VjcmV0IiwiQXV0aG9yaXphdGlvbiIsInNldCIsImZyb21KU09OIiwianNvbiIsImNsaWVudF9lbWFpbCIsInByaXZhdGVfa2V5IiwicHJpdmF0ZV9rZXlfaWQiLCJwcm9qZWN0SWQiLCJwcm9qZWN0X2lkIiwiZnJvbVN0cmVhbSIsImlucHV0U3RyZWFtIiwiY2FsbGJhY2siLCJmcm9tU3RyZWFtQXN5bmMiLCJ0aGVuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzIiwic2V0RW5jb2RpbmciLCJvbiIsImNodW5rIiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsImVyciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/jwtclient.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.JWT = void 0;\nconst gtoken_1 = __webpack_require__(/*! gtoken */ \"(rsc)/./node_modules/gtoken/build/src/index.js\");\nconst jwtaccess_1 = __webpack_require__(/*! ./jwtaccess */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\");\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nclass JWT extends oauth2client_1.OAuth2Client {\n    constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId){\n        const opts = optionsOrEmail && typeof optionsOrEmail === \"object\" ? optionsOrEmail : {\n            email: optionsOrEmail,\n            keyFile,\n            key,\n            keyId,\n            scopes,\n            subject\n        };\n        super(opts);\n        this.email = opts.email;\n        this.keyFile = opts.keyFile;\n        this.key = opts.key;\n        this.keyId = opts.keyId;\n        this.scopes = opts.scopes;\n        this.subject = opts.subject;\n        this.additionalClaims = opts.additionalClaims;\n        // Start with an expired refresh token, which will automatically be\n        // refreshed before the first API call is made.\n        this.credentials = {\n            refresh_token: \"jwt-placeholder\",\n            expiry_date: 1\n        };\n    }\n    /**\n     * Creates a copy of the credential with the specified scopes.\n     * @param scopes List of requested scopes or a single scope.\n     * @return The cloned instance.\n     */ createScoped(scopes) {\n        const jwt = new JWT(this);\n        jwt.scopes = scopes;\n        return jwt;\n    }\n    /**\n     * Obtains the metadata to be sent with the request.\n     *\n     * @param url the URI being authorized.\n     */ async getRequestMetadataAsync(url) {\n        url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;\n        const useSelfSignedJWT = !this.hasUserScopes() && url || this.useJWTAccessWithScope && this.hasAnyScopes() || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;\n        if (this.subject && this.universeDomain !== authclient_1.DEFAULT_UNIVERSE) {\n            throw new RangeError(`Service Account user is configured for the credential. Domain-wide delegation is not supported in universes other than ${authclient_1.DEFAULT_UNIVERSE}`);\n        }\n        if (!this.apiKey && useSelfSignedJWT) {\n            if (this.additionalClaims && this.additionalClaims.target_audience) {\n                const { tokens } = await this.refreshToken();\n                return {\n                    headers: this.addSharedMetadataHeaders({\n                        Authorization: `Bearer ${tokens.id_token}`\n                    })\n                };\n            } else {\n                // no scopes have been set, but a uri has been provided. Use JWTAccess\n                // credentials.\n                if (!this.access) {\n                    this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);\n                }\n                let scopes;\n                if (this.hasUserScopes()) {\n                    scopes = this.scopes;\n                } else if (!url) {\n                    scopes = this.defaultScopes;\n                }\n                const useScopes = this.useJWTAccessWithScope || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;\n                const headers = await this.access.getRequestHeaders(url !== null && url !== void 0 ? url : undefined, this.additionalClaims, // Scopes take precedent over audience for signing,\n                // so we only provide them if `useJWTAccessWithScope` is on or\n                // if we are in a non-default universe\n                useScopes ? scopes : undefined);\n                return {\n                    headers: this.addSharedMetadataHeaders(headers)\n                };\n            }\n        } else if (this.hasAnyScopes() || this.apiKey) {\n            return super.getRequestMetadataAsync(url);\n        } else {\n            // If no audience, apiKey, or scopes are provided, we should not attempt\n            // to populate any headers:\n            return {\n                headers: {}\n            };\n        }\n    }\n    /**\n     * Fetches an ID token.\n     * @param targetAudience the audience for the fetched ID token.\n     */ async fetchIdToken(targetAudience) {\n        // Create a new gToken for fetching an ID token\n        const gtoken = new gtoken_1.GoogleToken({\n            iss: this.email,\n            sub: this.subject,\n            scope: this.scopes || this.defaultScopes,\n            keyFile: this.keyFile,\n            key: this.key,\n            additionalClaims: {\n                target_audience: targetAudience\n            },\n            transporter: this.transporter\n        });\n        await gtoken.getToken({\n            forceRefresh: true\n        });\n        if (!gtoken.idToken) {\n            throw new Error(\"Unknown error: Failed to fetch ID token\");\n        }\n        return gtoken.idToken;\n    }\n    /**\n     * Determine if there are currently scopes available.\n     */ hasUserScopes() {\n        if (!this.scopes) {\n            return false;\n        }\n        return this.scopes.length > 0;\n    }\n    /**\n     * Are there any default or user scopes defined.\n     */ hasAnyScopes() {\n        if (this.scopes && this.scopes.length > 0) return true;\n        if (this.defaultScopes && this.defaultScopes.length > 0) return true;\n        return false;\n    }\n    authorize(callback) {\n        if (callback) {\n            this.authorizeAsync().then((r)=>callback(null, r), callback);\n        } else {\n            return this.authorizeAsync();\n        }\n    }\n    async authorizeAsync() {\n        const result = await this.refreshToken();\n        if (!result) {\n            throw new Error(\"No result returned\");\n        }\n        this.credentials = result.tokens;\n        this.credentials.refresh_token = \"jwt-placeholder\";\n        this.key = this.gtoken.key;\n        this.email = this.gtoken.iss;\n        return result.tokens;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken ignored\n     * @private\n     */ async refreshTokenNoCache(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        const gtoken = this.createGToken();\n        const token = await gtoken.getToken({\n            forceRefresh: this.isTokenExpiring()\n        });\n        const tokens = {\n            access_token: token.access_token,\n            token_type: \"Bearer\",\n            expiry_date: gtoken.expiresAt,\n            id_token: gtoken.idToken\n        };\n        this.emit(\"tokens\", tokens);\n        return {\n            res: null,\n            tokens\n        };\n    }\n    /**\n     * Create a gToken if it doesn't already exist.\n     */ createGToken() {\n        if (!this.gtoken) {\n            this.gtoken = new gtoken_1.GoogleToken({\n                iss: this.email,\n                sub: this.subject,\n                scope: this.scopes || this.defaultScopes,\n                keyFile: this.keyFile,\n                key: this.key,\n                additionalClaims: this.additionalClaims,\n                transporter: this.transporter\n            });\n        }\n        return this.gtoken;\n    }\n    /**\n     * Create a JWT credentials instance using the given input options.\n     * @param json The input object.\n     */ fromJSON(json) {\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing the service account auth settings.\");\n        }\n        if (!json.client_email) {\n            throw new Error(\"The incoming JSON object does not contain a client_email field\");\n        }\n        if (!json.private_key) {\n            throw new Error(\"The incoming JSON object does not contain a private_key field\");\n        }\n        // Extract the relevant information from the json key file.\n        this.email = json.client_email;\n        this.key = json.private_key;\n        this.keyId = json.private_key_id;\n        this.projectId = json.project_id;\n        this.quotaProjectId = json.quota_project_id;\n        this.universeDomain = json.universe_domain || this.universeDomain;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(()=>callback(), callback);\n        } else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                throw new Error(\"Must pass in a stream containing the service account auth settings.\");\n            }\n            let s = \"\";\n            inputStream.setEncoding(\"utf8\").on(\"error\", reject).on(\"data\", (chunk)=>s += chunk).on(\"end\", ()=>{\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    resolve();\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    /**\n     * Creates a JWT credentials instance using an API Key for authentication.\n     * @param apiKey The API Key in string form.\n     */ fromAPIKey(apiKey) {\n        if (typeof apiKey !== \"string\") {\n            throw new Error(\"Must provide an API Key string.\");\n        }\n        this.apiKey = apiKey;\n    }\n    /**\n     * Using the key or keyFile on the JWT client, obtain an object that contains\n     * the key and the client email.\n     */ async getCredentials() {\n        if (this.key) {\n            return {\n                private_key: this.key,\n                client_email: this.email\n            };\n        } else if (this.keyFile) {\n            const gtoken = this.createGToken();\n            const creds = await gtoken.getCredentials(this.keyFile);\n            return {\n                private_key: creds.privateKey,\n                client_email: creds.clientEmail\n            };\n        }\n        throw new Error(\"A key or a keyFile must be provided to getCredentials.\");\n    }\n}\nexports.JWT = JWT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9qd3RjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUcsS0FBSztBQUNuQixNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyw4REFBUTtBQUNqQyxNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyx5RkFBYTtBQUN6QyxNQUFNRSxpQkFBaUJGLG1CQUFPQSxDQUFDLCtGQUFnQjtBQUMvQyxNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQywyRkFBYztBQUMzQyxNQUFNRixZQUFZSSxlQUFlRSxZQUFZO0lBQ3pDQyxZQUFZQyxjQUFjLEVBQUVDLE9BQU8sRUFBRUMsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxDQUFFO1FBQzlELE1BQU1DLE9BQU9OLGtCQUFrQixPQUFPQSxtQkFBbUIsV0FDbkRBLGlCQUNBO1lBQUVPLE9BQU9QO1lBQWdCQztZQUFTQztZQUFLRztZQUFPRjtZQUFRQztRQUFRO1FBQ3BFLEtBQUssQ0FBQ0U7UUFDTixJQUFJLENBQUNDLEtBQUssR0FBR0QsS0FBS0MsS0FBSztRQUN2QixJQUFJLENBQUNOLE9BQU8sR0FBR0ssS0FBS0wsT0FBTztRQUMzQixJQUFJLENBQUNDLEdBQUcsR0FBR0ksS0FBS0osR0FBRztRQUNuQixJQUFJLENBQUNHLEtBQUssR0FBR0MsS0FBS0QsS0FBSztRQUN2QixJQUFJLENBQUNGLE1BQU0sR0FBR0csS0FBS0gsTUFBTTtRQUN6QixJ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YXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2p3dGNsaWVudC5qcz9jMmQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTMgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpXVCA9IHZvaWQgMDtcbmNvbnN0IGd0b2tlbl8xID0gcmVxdWlyZShcImd0b2tlblwiKTtcbmNvbnN0IGp3dGFjY2Vzc18xID0gcmVxdWlyZShcIi4vand0YWNjZXNzXCIpO1xuY29uc3Qgb2F1dGgyY2xpZW50XzEgPSByZXF1aXJlKFwiLi9vYXV0aDJjbGllbnRcIik7XG5jb25zdCBhdXRoY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoY2xpZW50XCIpO1xuY2xhc3MgSldUIGV4dGVuZHMgb2F1dGgyY2xpZW50XzEuT0F1dGgyQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zT3JFbWFpbCwga2V5RmlsZSwga2V5LCBzY29wZXMsIHN1YmplY3QsIGtleUlkKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zT3JFbWFpbCAmJiB0eXBlb2Ygb3B0aW9uc09yRW1haWwgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IG9wdGlvbnNPckVtYWlsXG4gICAgICAgICAgICA6IHsgZW1haWw6IG9wdGlvbnNPckVtYWlsLCBrZXlGaWxlLCBrZXksIGtleUlkLCBzY29wZXMsIHN1YmplY3QgfTtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMuZW1haWwgPSBvcHRzLmVtYWlsO1xuICAgICAgICB0aGlzLmtleUZpbGUgPSBvcHRzLmtleUZpbGU7XG4gICAgICAgIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gICAgICAgIHRoaXMua2V5SWQgPSBvcHRzLmtleUlkO1xuICAgICAgICB0aGlzLnNjb3BlcyA9IG9wdHMuc2NvcGVzO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBvcHRzLnN1YmplY3Q7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbENsYWltcyA9IG9wdHMuYWRkaXRpb25hbENsYWltcztcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhbiBleHBpcmVkIHJlZnJlc2ggdG9rZW4sIHdoaWNoIHdpbGwgYXV0b21hdGljYWxseSBiZVxuICAgICAgICAvLyByZWZyZXNoZWQgYmVmb3JlIHRoZSBmaXJzdCBBUEkgY2FsbCBpcyBtYWRlLlxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0geyByZWZyZXNoX3Rva2VuOiAnand0LXBsYWNlaG9sZGVyJywgZXhwaXJ5X2RhdGU6IDEgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGNyZWRlbnRpYWwgd2l0aCB0aGUgc3BlY2lmaWVkIHNjb3Blcy5cbiAgICAgKiBAcGFyYW0gc2NvcGVzIExpc3Qgb2YgcmVxdWVzdGVkIHNjb3BlcyBvciBhIHNpbmdsZSBzY29wZS5cbiAgICAgKiBAcmV0dXJuIFRoZSBjbG9uZWQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY3JlYXRlU2NvcGVkKHNjb3Blcykge1xuICAgICAgICBjb25zdCBqd3QgPSBuZXcgSldUKHRoaXMpO1xuICAgICAgICBqd3Quc2NvcGVzID0gc2NvcGVzO1xuICAgICAgICByZXR1cm4gand0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIHRoZSBtZXRhZGF0YSB0byBiZSBzZW50IHdpdGggdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIHRoZSBVUkkgYmVpbmcgYXV0aG9yaXplZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyh1cmwpIHtcbiAgICAgICAgdXJsID0gdGhpcy5kZWZhdWx0U2VydmljZVBhdGggPyBgaHR0cHM6Ly8ke3RoaXMuZGVmYXVsdFNlcnZpY2VQYXRofS9gIDogdXJsO1xuICAgICAgICBjb25zdCB1c2VTZWxmU2lnbmVkSldUID0gKCF0aGlzLmhhc1VzZXJTY29wZXMoKSAmJiB1cmwpIHx8XG4gICAgICAgICAgICAodGhpcy51c2VKV1RBY2Nlc3NXaXRoU2NvcGUgJiYgdGhpcy5oYXNBbnlTY29wZXMoKSkgfHxcbiAgICAgICAgICAgIHRoaXMudW5pdmVyc2VEb21haW4gIT09IGF1dGhjbGllbnRfMS5ERUZBVUxUX1VOSVZFUlNFO1xuICAgICAgICBpZiAodGhpcy5zdWJqZWN0ICYmIHRoaXMudW5pdmVyc2VEb21haW4gIT09IGF1dGhjbGllbnRfMS5ERUZBVUxUX1VOSVZFUlNFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgU2VydmljZSBBY2NvdW50IHVzZXIgaXMgY29uZmlndXJlZCBmb3IgdGhlIGNyZWRlbnRpYWwuIERvbWFpbi13aWRlIGRlbGVnYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB1bml2ZXJzZXMgb3RoZXIgdGhhbiAke2F1dGhjbGllbnRfMS5ERUZBVUxUX1VOSVZFUlNFfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hcGlLZXkgJiYgdXNlU2VsZlNpZ25lZEpXVCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkaXRpb25hbENsYWltcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYWRkaXRpb25hbENsYWltcy50YXJnZXRfYXVkaWVuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VucyB9ID0gYXdhaXQgdGhpcy5yZWZyZXNoVG9rZW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW5zLmlkX3Rva2VufWAsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBubyBzY29wZXMgaGF2ZSBiZWVuIHNldCwgYnV0IGEgdXJpIGhhcyBiZWVuIHByb3ZpZGVkLiBVc2UgSldUQWNjZXNzXG4gICAgICAgICAgICAgICAgLy8gY3JlZGVudGlhbHMuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY2VzcyA9IG5ldyBqd3RhY2Nlc3NfMS5KV1RBY2Nlc3ModGhpcy5lbWFpbCwgdGhpcy5rZXksIHRoaXMua2V5SWQsIHRoaXMuZWFnZXJSZWZyZXNoVGhyZXNob2xkTWlsbGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHNjb3BlcztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNVc2VyU2NvcGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzID0gdGhpcy5zY29wZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzID0gdGhpcy5kZWZhdWx0U2NvcGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB1c2VTY29wZXMgPSB0aGlzLnVzZUpXVEFjY2Vzc1dpdGhTY29wZSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuaXZlcnNlRG9tYWluICE9PSBhdXRoY2xpZW50XzEuREVGQVVMVF9VTklWRVJTRTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgdGhpcy5hY2Nlc3MuZ2V0UmVxdWVzdEhlYWRlcnModXJsICE9PSBudWxsICYmIHVybCAhPT0gdm9pZCAwID8gdXJsIDogdW5kZWZpbmVkLCB0aGlzLmFkZGl0aW9uYWxDbGFpbXMsIFxuICAgICAgICAgICAgICAgIC8vIFNjb3BlcyB0YWtlIHByZWNlZGVudCBvdmVyIGF1ZGllbmNlIGZvciBzaWduaW5nLFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIG9ubHkgcHJvdmlkZSB0aGVtIGlmIGB1c2VKV1RBY2Nlc3NXaXRoU2NvcGVgIGlzIG9uIG9yXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGluIGEgbm9uLWRlZmF1bHQgdW5pdmVyc2VcbiAgICAgICAgICAgICAgICB1c2VTY29wZXMgPyBzY29wZXMgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNBbnlTY29wZXMoKSB8fCB0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmdldFJlcXVlc3RNZXRhZGF0YUFzeW5jKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBubyBhdWRpZW5jZSwgYXBpS2V5LCBvciBzY29wZXMgYXJlIHByb3ZpZGVkLCB3ZSBzaG91bGQgbm90IGF0dGVtcHRcbiAgICAgICAgICAgIC8vIHRvIHBvcHVsYXRlIGFueSBoZWFkZXJzOlxuICAgICAgICAgICAgcmV0dXJuIHsgaGVhZGVyczoge30gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGFuIElEIHRva2VuLlxuICAgICAqIEBwYXJhbSB0YXJnZXRBdWRpZW5jZSB0aGUgYXVkaWVuY2UgZm9yIHRoZSBmZXRjaGVkIElEIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIGZldGNoSWRUb2tlbih0YXJnZXRBdWRpZW5jZSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZ1Rva2VuIGZvciBmZXRjaGluZyBhbiBJRCB0b2tlblxuICAgICAgICBjb25zdCBndG9rZW4gPSBuZXcgZ3Rva2VuXzEuR29vZ2xlVG9rZW4oe1xuICAgICAgICAgICAgaXNzOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAgc3ViOiB0aGlzLnN1YmplY3QsXG4gICAgICAgICAgICBzY29wZTogdGhpcy5zY29wZXMgfHwgdGhpcy5kZWZhdWx0U2NvcGVzLFxuICAgICAgICAgICAga2V5RmlsZTogdGhpcy5rZXlGaWxlLFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxDbGFpbXM6IHsgdGFyZ2V0X2F1ZGllbmNlOiB0YXJnZXRBdWRpZW5jZSB9LFxuICAgICAgICAgICAgdHJhbnNwb3J0ZXI6IHRoaXMudHJhbnNwb3J0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBndG9rZW4uZ2V0VG9rZW4oe1xuICAgICAgICAgICAgZm9yY2VSZWZyZXNoOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFndG9rZW4uaWRUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVycm9yOiBGYWlsZWQgdG8gZmV0Y2ggSUQgdG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3Rva2VuLmlkVG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGVyZSBhcmUgY3VycmVudGx5IHNjb3BlcyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgaGFzVXNlclNjb3BlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNjb3Blcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3Blcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcmUgdGhlcmUgYW55IGRlZmF1bHQgb3IgdXNlciBzY29wZXMgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBoYXNBbnlTY29wZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlcyAmJiB0aGlzLnNjb3Blcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRTY29wZXMgJiYgdGhpcy5kZWZhdWx0U2NvcGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhdXRob3JpemUoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGhvcml6ZUFzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRob3JpemVBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGF1dGhvcml6ZUFzeW5jKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlZnJlc2hUb2tlbigpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZXN1bHQgcmV0dXJuZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gcmVzdWx0LnRva2VucztcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuID0gJ2p3dC1wbGFjZWhvbGRlcic7XG4gICAgICAgIHRoaXMua2V5ID0gdGhpcy5ndG9rZW4ua2V5O1xuICAgICAgICB0aGlzLmVtYWlsID0gdGhpcy5ndG9rZW4uaXNzO1xuICAgICAgICByZXR1cm4gcmVzdWx0LnRva2VucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBpZ25vcmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW5Ob0NhY2hlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICByZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZ3Rva2VuID0gdGhpcy5jcmVhdGVHVG9rZW4oKTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBndG9rZW4uZ2V0VG9rZW4oe1xuICAgICAgICAgICAgZm9yY2VSZWZyZXNoOiB0aGlzLmlzVG9rZW5FeHBpcmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0ge1xuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB0b2tlbl90eXBlOiAnQmVhcmVyJyxcbiAgICAgICAgICAgIGV4cGlyeV9kYXRlOiBndG9rZW4uZXhwaXJlc0F0LFxuICAgICAgICAgICAgaWRfdG9rZW46IGd0b2tlbi5pZFRva2VuLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB7IHJlczogbnVsbCwgdG9rZW5zIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGdUb2tlbiBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3QuXG4gICAgICovXG4gICAgY3JlYXRlR1Rva2VuKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3Rva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmd0b2tlbiA9IG5ldyBndG9rZW5fMS5Hb29nbGVUb2tlbih7XG4gICAgICAgICAgICAgICAgaXNzOiB0aGlzLmVtYWlsLFxuICAgICAgICAgICAgICAgIHN1YjogdGhpcy5zdWJqZWN0LFxuICAgICAgICAgICAgICAgIHNjb3BlOiB0aGlzLnNjb3BlcyB8fCB0aGlzLmRlZmF1bHRTY29wZXMsXG4gICAgICAgICAgICAgICAga2V5RmlsZTogdGhpcy5rZXlGaWxlLFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbENsYWltczogdGhpcy5hZGRpdGlvbmFsQ2xhaW1zLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyOiB0aGlzLnRyYW5zcG9ydGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3Rva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBKV1QgY3JlZGVudGlhbHMgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGlucHV0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXJ2aWNlIGFjY291bnQgYXV0aCBzZXR0aW5ncy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWpzb24uY2xpZW50X2VtYWlsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgY2xpZW50X2VtYWlsIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLnByaXZhdGVfa2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgcHJpdmF0ZV9rZXkgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRyYWN0IHRoZSByZWxldmFudCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBqc29uIGtleSBmaWxlLlxuICAgICAgICB0aGlzLmVtYWlsID0ganNvbi5jbGllbnRfZW1haWw7XG4gICAgICAgIHRoaXMua2V5ID0ganNvbi5wcml2YXRlX2tleTtcbiAgICAgICAgdGhpcy5rZXlJZCA9IGpzb24ucHJpdmF0ZV9rZXlfaWQ7XG4gICAgICAgIHRoaXMucHJvamVjdElkID0ganNvbi5wcm9qZWN0X2lkO1xuICAgICAgICB0aGlzLnF1b3RhUHJvamVjdElkID0ganNvbi5xdW90YV9wcm9qZWN0X2lkO1xuICAgICAgICB0aGlzLnVuaXZlcnNlRG9tYWluID0ganNvbi51bml2ZXJzZV9kb21haW4gfHwgdGhpcy51bml2ZXJzZURvbWFpbjtcbiAgICB9XG4gICAgZnJvbVN0cmVhbShpbnB1dFN0cmVhbSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSkudGhlbigoKSA9PiBjYWxsYmFjaygpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tU3RyZWFtQXN5bmMoaW5wdXRTdHJlYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwYXNzIGluIGEgc3RyZWFtIGNvbnRhaW5pbmcgdGhlIHNlcnZpY2UgYWNjb3VudCBhdXRoIHNldHRpbmdzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgICAgIGlucHV0U3RyZWFtXG4gICAgICAgICAgICAgICAgLnNldEVuY29kaW5nKCd1dGY4JylcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgICAgICAgICAgIC5vbignZGF0YScsIGNodW5rID0+IChzICs9IGNodW5rKSlcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm9tSlNPTihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgSldUIGNyZWRlbnRpYWxzIGluc3RhbmNlIHVzaW5nIGFuIEFQSSBLZXkgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBhcGlLZXkgVGhlIEFQSSBLZXkgaW4gc3RyaW5nIGZvcm0uXG4gICAgICovXG4gICAgZnJvbUFQSUtleShhcGlLZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcGlLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhbiBBUEkgS2V5IHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgdGhlIGtleSBvciBrZXlGaWxlIG9uIHRoZSBKV1QgY2xpZW50LCBvYnRhaW4gYW4gb2JqZWN0IHRoYXQgY29udGFpbnNcbiAgICAgKiB0aGUga2V5IGFuZCB0aGUgY2xpZW50IGVtYWlsLlxuICAgICAqL1xuICAgIGFzeW5jIGdldENyZWRlbnRpYWxzKCkge1xuICAgICAgICBpZiAodGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHByaXZhdGVfa2V5OiB0aGlzLmtleSwgY2xpZW50X2VtYWlsOiB0aGlzLmVtYWlsIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5rZXlGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBndG9rZW4gPSB0aGlzLmNyZWF0ZUdUb2tlbigpO1xuICAgICAgICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCBndG9rZW4uZ2V0Q3JlZGVudGlhbHModGhpcy5rZXlGaWxlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHByaXZhdGVfa2V5OiBjcmVkcy5wcml2YXRlS2V5LCBjbGllbnRfZW1haWw6IGNyZWRzLmNsaWVudEVtYWlsIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGtleSBvciBhIGtleUZpbGUgbXVzdCBiZSBwcm92aWRlZCB0byBnZXRDcmVkZW50aWFscy4nKTtcbiAgICB9XG59XG5leHBvcnRzLkpXVCA9IEpXVDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkpXVCIsImd0b2tlbl8xIiwicmVxdWlyZSIsImp3dGFjY2Vzc18xIiwib2F1dGgyY2xpZW50XzEiLCJhdXRoY2xpZW50XzEiLCJPQXV0aDJDbGllbnQiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnNPckVtYWlsIiwia2V5RmlsZSIsImtleSIsInNjb3BlcyIsInN1YmplY3QiLCJrZXlJZCIsIm9wdHMiLCJlbWFpbCIsImFkZGl0aW9uYWxDbGFpbXMiLCJjcmVkZW50aWFscyIsInJlZnJlc2hfdG9rZW4iLCJleHBpcnlfZGF0ZSIsImNyZWF0ZVNjb3BlZCIsImp3dCIsImdldFJlcXVlc3RNZXRhZGF0YUFzeW5jIiwidXJsIiwiZGVmYXVsdFNlcnZpY2VQYXRoIiwidXNlU2VsZlNpZ25lZEpXVCIsImhhc1VzZXJTY29wZXMiLCJ1c2VKV1RBY2Nlc3NXaXRoU2NvcGUiLCJoYXNBbnlTY29wZXMiLCJ1bml2ZXJzZURvbWFpbiIsIkRFRkFVTFRfVU5JVkVSU0UiLCJSYW5nZUVycm9yIiwiYXBpS2V5IiwidGFyZ2V0X2F1ZGllbmNlIiwidG9rZW5zIiwicmVmcmVzaFRva2VuIiwiaGVhZGVycyIsImFkZFNoYXJlZE1ldGFkYXRhSGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJpZF90b2tlbiIsImFjY2VzcyIsIkpXVEFjY2VzcyIsImVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyIsImRlZmF1bHRTY29wZXMiLCJ1c2VTY29wZXMiLCJnZXRSZXF1ZXN0SGVhZGVycyIsInVuZGVmaW5lZCIsImZldGNoSWRUb2tlbiIsInRhcmdldEF1ZGllbmNlIiwiZ3Rva2VuIiwiR29vZ2xlVG9rZW4iLCJpc3MiLCJzdWIiLCJzY29wZSIsInRyYW5zcG9ydGVyIiwiZ2V0VG9rZW4iLCJmb3JjZVJlZnJlc2giLCJpZFRva2VuIiwiRXJyb3IiLCJsZW5ndGgiLCJhdXRob3JpemUiLCJjYWxsYmFjayIsImF1dGhvcml6ZUFzeW5jIiwidGhlbiIsInIiLCJyZXN1bHQiLCJyZWZyZXNoVG9rZW5Ob0NhY2hlIiwiY3JlYXRlR1Rva2VuIiwidG9rZW4iLCJpc1Rva2VuRXhwaXJpbmciLCJhY2Nlc3NfdG9rZW4iLCJ0b2tlbl90eXBlIiwiZXhwaXJlc0F0IiwiZW1pdCIsInJlcyIsImZyb21KU09OIiwianNvbiIsImNsaWVudF9lbWFpbCIsInByaXZhdGVfa2V5IiwicHJpdmF0ZV9rZXlfaWQiLCJwcm9qZWN0SWQiLCJwcm9qZWN0X2lkIiwicXVvdGFQcm9qZWN0SWQiLCJxdW90YV9wcm9qZWN0X2lkIiwidW5pdmVyc2VfZG9tYWluIiwiZnJvbVN0cmVhbSIsImlucHV0U3RyZWFtIiwiZnJvbVN0cmVhbUFzeW5jIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzIiwic2V0RW5jb2RpbmciLCJvbiIsImNodW5rIiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsImUiLCJmcm9tQVBJS2V5IiwiZ2V0Q3JlZGVudGlhbHMiLCJjcmVkcyIsInByaXZhdGVLZXkiLCJjbGllbnRFbWFpbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js":
/*!************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/loginticket.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2014 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LoginTicket = void 0;\nclass LoginTicket {\n    /**\n     * Create a simple class to extract user ID from an ID Token\n     *\n     * @param {string} env Envelope of the jwt\n     * @param {TokenPayload} pay Payload of the jwt\n     * @constructor\n     */ constructor(env, pay){\n        this.envelope = env;\n        this.payload = pay;\n    }\n    getEnvelope() {\n        return this.envelope;\n    }\n    getPayload() {\n        return this.payload;\n    }\n    /**\n     * Create a simple class to extract user ID from an ID Token\n     *\n     * @return The user ID\n     */ getUserId() {\n        const payload = this.getPayload();\n        if (payload && payload.sub) {\n            return payload.sub;\n        }\n        return null;\n    }\n    /**\n     * Returns attributes from the login ticket.  This can contain\n     * various information about the user session.\n     *\n     * @return The envelope and payload\n     */ getAttributes() {\n        return {\n            envelope: this.getEnvelope(),\n            payload: this.getPayload()\n        };\n    }\n}\nexports.LoginTicket = LoginTicket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9sb2dpbnRpY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHLEtBQUs7QUFDM0IsTUFBTUU7SUFDRjs7Ozs7O0tBTUMsR0FDREMsWUFBWUMsR0FBRyxFQUFFQyxHQUFHLENBQUU7UUFDbEIsSUFBSSxDQUFDQyxRQUFRLEdBQUdGO1FBQ2hCLElBQUksQ0FBQ0csT0FBTyxHQUFHRjtJQUNuQjtJQUNBRyxjQUFjO1FBQ1YsT0FBTyxJQUFJLENBQUNGLFFBQVE7SUFDeEI7SUFDQUcsYUFBYTtRQUNULE9BQU8sSUFBSSxDQUFDRixPQUFPO0lBQ3ZCO0lBQ0E7Ozs7S0FJQyxHQUNERyxZQUFZO1FBQ1IsTUFBTUgsVUFBVSxJQUFJLENBQUNFLFVBQVU7UUFDL0IsSUFBSUYsV0FBV0EsUUFBUUksR0FBRyxFQUFFO1lBQ3hCLE9BQU9KLFFBQVFJLEdBQUc7UUFDdEI7UUFDQSxPQUFPO0lBQ1g7SUFDQTs7Ozs7S0FLQyxHQUNEQyxnQkFBZ0I7UUFDWixPQUFPO1lBQUVOLFVBQVUsSUFBSSxDQUFDRSxXQUFXO1lBQUlELFNBQVMsSUFBSSxDQUFDRSxVQUFVO1FBQUc7SUFDdEU7QUFDSjtBQUNBVCxtQkFBbUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWNvbW1lbnRlci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL2xvZ2ludGlja2V0LmpzP2Y3OWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNCBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9naW5UaWNrZXQgPSB2b2lkIDA7XG5jbGFzcyBMb2dpblRpY2tldCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2ltcGxlIGNsYXNzIHRvIGV4dHJhY3QgdXNlciBJRCBmcm9tIGFuIElEIFRva2VuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW52IEVudmVsb3BlIG9mIHRoZSBqd3RcbiAgICAgKiBAcGFyYW0ge1Rva2VuUGF5bG9hZH0gcGF5IFBheWxvYWQgb2YgdGhlIGp3dFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVudiwgcGF5KSB7XG4gICAgICAgIHRoaXMuZW52ZWxvcGUgPSBlbnY7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheTtcbiAgICB9XG4gICAgZ2V0RW52ZWxvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudmVsb3BlO1xuICAgIH1cbiAgICBnZXRQYXlsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXlsb2FkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzaW1wbGUgY2xhc3MgdG8gZXh0cmFjdCB1c2VyIElEIGZyb20gYW4gSUQgVG9rZW5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIHVzZXIgSURcbiAgICAgKi9cbiAgICBnZXRVc2VySWQoKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLmdldFBheWxvYWQoKTtcbiAgICAgICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5zdWIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkLnN1YjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhdHRyaWJ1dGVzIGZyb20gdGhlIGxvZ2luIHRpY2tldC4gIFRoaXMgY2FuIGNvbnRhaW5cbiAgICAgKiB2YXJpb3VzIGluZm9ybWF0aW9uIGFib3V0IHRoZSB1c2VyIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBlbnZlbG9wZSBhbmQgcGF5bG9hZFxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7IGVudmVsb3BlOiB0aGlzLmdldEVudmVsb3BlKCksIHBheWxvYWQ6IHRoaXMuZ2V0UGF5bG9hZCgpIH07XG4gICAgfVxufVxuZXhwb3J0cy5Mb2dpblRpY2tldCA9IExvZ2luVGlja2V0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTG9naW5UaWNrZXQiLCJjb25zdHJ1Y3RvciIsImVudiIsInBheSIsImVudmVsb3BlIiwicGF5bG9hZCIsImdldEVudmVsb3BlIiwiZ2V0UGF5bG9hZCIsImdldFVzZXJJZCIsInN1YiIsImdldEF0dHJpYnV0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/oauth2client.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OAuth2Client = exports.ClientAuthentication = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst formatEcdsa = __webpack_require__(/*! ecdsa-sig-formatter */ \"(rsc)/./node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nconst loginticket_1 = __webpack_require__(/*! ./loginticket */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js\");\nvar CodeChallengeMethod;\n(function(CodeChallengeMethod) {\n    CodeChallengeMethod[\"Plain\"] = \"plain\";\n    CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod || (exports.CodeChallengeMethod = CodeChallengeMethod = {}));\nvar CertificateFormat;\n(function(CertificateFormat) {\n    CertificateFormat[\"PEM\"] = \"PEM\";\n    CertificateFormat[\"JWK\"] = \"JWK\";\n})(CertificateFormat || (exports.CertificateFormat = CertificateFormat = {}));\n/**\n * The client authentication type. Supported values are basic, post, and none.\n * https://datatracker.ietf.org/doc/html/rfc7591#section-2\n */ var ClientAuthentication;\n(function(ClientAuthentication) {\n    ClientAuthentication[\"ClientSecretPost\"] = \"ClientSecretPost\";\n    ClientAuthentication[\"ClientSecretBasic\"] = \"ClientSecretBasic\";\n    ClientAuthentication[\"None\"] = \"None\";\n})(ClientAuthentication || (exports.ClientAuthentication = ClientAuthentication = {}));\nclass OAuth2Client extends authclient_1.AuthClient {\n    constructor(optionsOrClientId, clientSecret, redirectUri){\n        const opts = optionsOrClientId && typeof optionsOrClientId === \"object\" ? optionsOrClientId : {\n            clientId: optionsOrClientId,\n            clientSecret,\n            redirectUri\n        };\n        super(opts);\n        this.certificateCache = {};\n        this.certificateExpiry = null;\n        this.certificateCacheFormat = CertificateFormat.PEM;\n        this.refreshTokenPromises = new Map();\n        this._clientId = opts.clientId;\n        this._clientSecret = opts.clientSecret;\n        this.redirectUri = opts.redirectUri;\n        this.endpoints = {\n            tokenInfoUrl: \"https://oauth2.googleapis.com/tokeninfo\",\n            oauth2AuthBaseUrl: \"https://accounts.google.com/o/oauth2/v2/auth\",\n            oauth2TokenUrl: \"https://oauth2.googleapis.com/token\",\n            oauth2RevokeUrl: \"https://oauth2.googleapis.com/revoke\",\n            oauth2FederatedSignonPemCertsUrl: \"https://www.googleapis.com/oauth2/v1/certs\",\n            oauth2FederatedSignonJwkCertsUrl: \"https://www.googleapis.com/oauth2/v3/certs\",\n            oauth2IapPublicKeyUrl: \"https://www.gstatic.com/iap/verify/public_key\",\n            ...opts.endpoints\n        };\n        this.clientAuthentication = opts.clientAuthentication || ClientAuthentication.ClientSecretPost;\n        this.issuers = opts.issuers || [\n            \"accounts.google.com\",\n            \"https://accounts.google.com\",\n            this.universeDomain\n        ];\n    }\n    /**\n     * Generates URL for consent page landing.\n     * @param opts Options.\n     * @return URL to consent page.\n     */ generateAuthUrl(opts = {}) {\n        if (opts.code_challenge_method && !opts.code_challenge) {\n            throw new Error(\"If a code_challenge_method is provided, code_challenge must be included.\");\n        }\n        opts.response_type = opts.response_type || \"code\";\n        opts.client_id = opts.client_id || this._clientId;\n        opts.redirect_uri = opts.redirect_uri || this.redirectUri;\n        // Allow scopes to be passed either as array or a string\n        if (Array.isArray(opts.scope)) {\n            opts.scope = opts.scope.join(\" \");\n        }\n        const rootUrl = this.endpoints.oauth2AuthBaseUrl.toString();\n        return rootUrl + \"?\" + querystring.stringify(opts);\n    }\n    generateCodeVerifier() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error(\"generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.\");\n    }\n    /**\n     * Convenience method to automatically generate a code_verifier, and its\n     * resulting SHA256. If used, this must be paired with a S256\n     * code_challenge_method.\n     *\n     * For a full example see:\n     * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js\n     */ async generateCodeVerifierAsync() {\n        // base64 encoding uses 6 bits per character, and we want to generate128\n        // characters. 6*128/8 = 96.\n        const crypto = (0, crypto_1.createCrypto)();\n        const randomString = crypto.randomBytesBase64(96);\n        // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n        // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n        // swapping out a few chars.\n        const codeVerifier = randomString.replace(/\\+/g, \"~\").replace(/=/g, \"_\").replace(/\\//g, \"-\");\n        // Generate the base64 encoded SHA256\n        const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);\n        // We need to use base64UrlEncoding instead of standard base64\n        const codeChallenge = unencodedCodeChallenge.split(\"=\")[0].replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n        return {\n            codeVerifier,\n            codeChallenge\n        };\n    }\n    getToken(codeOrOptions, callback) {\n        const options = typeof codeOrOptions === \"string\" ? {\n            code: codeOrOptions\n        } : codeOrOptions;\n        if (callback) {\n            this.getTokenAsync(options).then((r)=>callback(null, r.tokens, r.res), (e)=>callback(e, null, e.response));\n        } else {\n            return this.getTokenAsync(options);\n        }\n    }\n    async getTokenAsync(options) {\n        const url = this.endpoints.oauth2TokenUrl.toString();\n        const headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        };\n        const values = {\n            client_id: options.client_id || this._clientId,\n            code_verifier: options.codeVerifier,\n            code: options.code,\n            grant_type: \"authorization_code\",\n            redirect_uri: options.redirect_uri || this.redirectUri\n        };\n        if (this.clientAuthentication === ClientAuthentication.ClientSecretBasic) {\n            const basic = Buffer.from(`${this._clientId}:${this._clientSecret}`);\n            headers[\"Authorization\"] = `Basic ${basic.toString(\"base64\")}`;\n        }\n        if (this.clientAuthentication === ClientAuthentication.ClientSecretPost) {\n            values.client_secret = this._clientSecret;\n        }\n        const res = await this.transporter.request({\n            ...OAuth2Client.RETRY_CONFIG,\n            method: \"POST\",\n            url,\n            data: querystring.stringify(values),\n            headers\n        });\n        const tokens = res.data;\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit(\"tokens\", tokens);\n        return {\n            tokens,\n            res\n        };\n    }\n    /**\n     * Refreshes the access token.\n     * @param refresh_token Existing refresh token.\n     * @private\n     */ async refreshToken(refreshToken) {\n        if (!refreshToken) {\n            return this.refreshTokenNoCache(refreshToken);\n        }\n        // If a request to refresh using the same token has started,\n        // return the same promise.\n        if (this.refreshTokenPromises.has(refreshToken)) {\n            return this.refreshTokenPromises.get(refreshToken);\n        }\n        const p = this.refreshTokenNoCache(refreshToken).then((r)=>{\n            this.refreshTokenPromises.delete(refreshToken);\n            return r;\n        }, (e)=>{\n            this.refreshTokenPromises.delete(refreshToken);\n            throw e;\n        });\n        this.refreshTokenPromises.set(refreshToken, p);\n        return p;\n    }\n    async refreshTokenNoCache(refreshToken) {\n        var _a;\n        if (!refreshToken) {\n            throw new Error(\"No refresh token is set.\");\n        }\n        const url = this.endpoints.oauth2TokenUrl.toString();\n        const data = {\n            refresh_token: refreshToken,\n            client_id: this._clientId,\n            client_secret: this._clientSecret,\n            grant_type: \"refresh_token\"\n        };\n        let res;\n        try {\n            // request for new token\n            res = await this.transporter.request({\n                ...OAuth2Client.RETRY_CONFIG,\n                method: \"POST\",\n                url,\n                data: querystring.stringify(data),\n                headers: {\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            });\n        } catch (e) {\n            if (e instanceof gaxios_1.GaxiosError && e.message === \"invalid_grant\" && ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) && /ReAuth/i.test(e.response.data.error_description)) {\n                e.message = JSON.stringify(e.response.data);\n            }\n            throw e;\n        }\n        const tokens = res.data;\n        // TODO: de-duplicate this code from a few spots\n        if (res.data && res.data.expires_in) {\n            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n            delete tokens.expires_in;\n        }\n        this.emit(\"tokens\", tokens);\n        return {\n            tokens,\n            res\n        };\n    }\n    refreshAccessToken(callback) {\n        if (callback) {\n            this.refreshAccessTokenAsync().then((r)=>callback(null, r.credentials, r.res), callback);\n        } else {\n            return this.refreshAccessTokenAsync();\n        }\n    }\n    async refreshAccessTokenAsync() {\n        const r = await this.refreshToken(this.credentials.refresh_token);\n        const tokens = r.tokens;\n        tokens.refresh_token = this.credentials.refresh_token;\n        this.credentials = tokens;\n        return {\n            credentials: this.credentials,\n            res: r.res\n        };\n    }\n    getAccessToken(callback) {\n        if (callback) {\n            this.getAccessTokenAsync().then((r)=>callback(null, r.token, r.res), callback);\n        } else {\n            return this.getAccessTokenAsync();\n        }\n    }\n    async getAccessTokenAsync() {\n        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n        if (shouldRefresh) {\n            if (!this.credentials.refresh_token) {\n                if (this.refreshHandler) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                        return {\n                            token: this.credentials.access_token\n                        };\n                    }\n                } else {\n                    throw new Error(\"No refresh token or refresh handler callback is set.\");\n                }\n            }\n            const r = await this.refreshAccessTokenAsync();\n            if (!r.credentials || r.credentials && !r.credentials.access_token) {\n                throw new Error(\"Could not refresh access token.\");\n            }\n            return {\n                token: r.credentials.access_token,\n                res: r.res\n            };\n        } else {\n            return {\n                token: this.credentials.access_token\n            };\n        }\n    }\n    /**\n     * The main authentication interface.  It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * In OAuth2Client, the result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     * @param url The optional url being authorized\n     */ async getRequestHeaders(url) {\n        const headers = (await this.getRequestMetadataAsync(url)).headers;\n        return headers;\n    }\n    async getRequestMetadataAsync(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    url) {\n        const thisCreds = this.credentials;\n        if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler) {\n            throw new Error(\"No access, refresh token, API key or refresh handler callback is set.\");\n        }\n        if (thisCreds.access_token && !this.isTokenExpiring()) {\n            thisCreds.token_type = thisCreds.token_type || \"Bearer\";\n            const headers = {\n                Authorization: thisCreds.token_type + \" \" + thisCreds.access_token\n            };\n            return {\n                headers: this.addSharedMetadataHeaders(headers)\n            };\n        }\n        // If refreshHandler exists, call processAndValidateRefreshHandler().\n        if (this.refreshHandler) {\n            const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n            if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                this.setCredentials(refreshedAccessToken);\n                const headers = {\n                    Authorization: \"Bearer \" + this.credentials.access_token\n                };\n                return {\n                    headers: this.addSharedMetadataHeaders(headers)\n                };\n            }\n        }\n        if (this.apiKey) {\n            return {\n                headers: {\n                    \"X-Goog-Api-Key\": this.apiKey\n                }\n            };\n        }\n        let r = null;\n        let tokens = null;\n        try {\n            r = await this.refreshToken(thisCreds.refresh_token);\n            tokens = r.tokens;\n        } catch (err) {\n            const e = err;\n            if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n                e.message = `Could not refresh access token: ${e.message}`;\n            }\n            throw e;\n        }\n        const credentials = this.credentials;\n        credentials.token_type = credentials.token_type || \"Bearer\";\n        tokens.refresh_token = credentials.refresh_token;\n        this.credentials = tokens;\n        const headers = {\n            Authorization: credentials.token_type + \" \" + tokens.access_token\n        };\n        return {\n            headers: this.addSharedMetadataHeaders(headers),\n            res: r.res\n        };\n    }\n    /**\n     * Generates an URL to revoke the given token.\n     * @param token The existing token to be revoked.\n     *\n     * @deprecated use instance method {@link OAuth2Client.getRevokeTokenURL}\n     */ static getRevokeTokenUrl(token) {\n        return new OAuth2Client().getRevokeTokenURL(token).toString();\n    }\n    /**\n     * Generates a URL to revoke the given token.\n     *\n     * @param token The existing token to be revoked.\n     */ getRevokeTokenURL(token) {\n        const url = new URL(this.endpoints.oauth2RevokeUrl);\n        url.searchParams.append(\"token\", token);\n        return url;\n    }\n    revokeToken(token, callback) {\n        const opts = {\n            ...OAuth2Client.RETRY_CONFIG,\n            url: this.getRevokeTokenURL(token).toString(),\n            method: \"POST\"\n        };\n        if (callback) {\n            this.transporter.request(opts).then((r)=>callback(null, r), callback);\n        } else {\n            return this.transporter.request(opts);\n        }\n    }\n    revokeCredentials(callback) {\n        if (callback) {\n            this.revokeCredentialsAsync().then((res)=>callback(null, res), callback);\n        } else {\n            return this.revokeCredentialsAsync();\n        }\n    }\n    async revokeCredentialsAsync() {\n        const token = this.credentials.access_token;\n        this.credentials = {};\n        if (token) {\n            return this.revokeToken(token);\n        } else {\n            throw new Error(\"No access token to revoke.\");\n        }\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then((r)=>callback(null, r), (e)=>{\n                return callback(e, e.response);\n            });\n        } else {\n            return this.requestAsync(opts);\n        }\n    }\n    async requestAsync(opts, reAuthRetried = false) {\n        let r2;\n        try {\n            const r = await this.getRequestMetadataAsync(opts.url);\n            opts.headers = opts.headers || {};\n            if (r.headers && r.headers[\"x-goog-user-project\"]) {\n                opts.headers[\"x-goog-user-project\"] = r.headers[\"x-goog-user-project\"];\n            }\n            if (r.headers && r.headers.Authorization) {\n                opts.headers.Authorization = r.headers.Authorization;\n            }\n            if (this.apiKey) {\n                opts.headers[\"X-Goog-Api-Key\"] = this.apiKey;\n            }\n            r2 = await this.transporter.request(opts);\n        } catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - An access_token and refresh_token were available, but either no\n                //   expiry_date was available or the forceRefreshOnFailure flag is set.\n                //   The absent expiry_date case can happen when developers stash the\n                //   access_token and refresh_token for later use, but the access_token\n                //   fails on the first try because it's expired. Some developers may\n                //   choose to enable forceRefreshOnFailure to mitigate time-related\n                //   errors.\n                // Or the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - No refresh_token was available\n                // - An access_token and a refreshHandler callback were available, but\n                //   either no expiry_date was available or the forceRefreshOnFailure\n                //   flag is set. The access_token fails on the first try because it's\n                //   expired. Some developers may choose to enable forceRefreshOnFailure\n                //   to mitigate time-related errors.\n                const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);\n                const mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefresh) {\n                    await this.refreshAccessTokenAsync();\n                    return this.requestAsync(opts, true);\n                } else if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken) {\n                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();\n                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {\n                        this.setCredentials(refreshedAccessToken);\n                    }\n                    return this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return r2;\n    }\n    verifyIdToken(options, callback) {\n        // This function used to accept two arguments instead of an options object.\n        // Check the types to help users upgrade with less pain.\n        // This check can be removed after a 2.0 release.\n        if (callback && typeof callback !== \"function\") {\n            throw new Error(\"This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.\");\n        }\n        if (callback) {\n            this.verifyIdTokenAsync(options).then((r)=>callback(null, r), callback);\n        } else {\n            return this.verifyIdTokenAsync(options);\n        }\n    }\n    async verifyIdTokenAsync(options) {\n        if (!options.idToken) {\n            throw new Error(\"The verifyIdToken method requires an ID Token\");\n        }\n        const response = await this.getFederatedSignonCertsAsync();\n        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, this.issuers, options.maxExpiry);\n        return login;\n    }\n    /**\n     * Obtains information about the provisioned access token.  Especially useful\n     * if you want to check the scopes that were provisioned to a given token.\n     *\n     * @param accessToken Required.  The Access Token for which you want to get\n     * user info.\n     */ async getTokenInfo(accessToken) {\n        const { data } = await this.transporter.request({\n            ...OAuth2Client.RETRY_CONFIG,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                Authorization: `Bearer ${accessToken}`\n            },\n            url: this.endpoints.tokenInfoUrl.toString()\n        });\n        const info = Object.assign({\n            expiry_date: new Date().getTime() + data.expires_in * 1000,\n            scopes: data.scope.split(\" \")\n        }, data);\n        delete info.expires_in;\n        delete info.scope;\n        return info;\n    }\n    getFederatedSignonCerts(callback) {\n        if (callback) {\n            this.getFederatedSignonCertsAsync().then((r)=>callback(null, r.certs, r.res), callback);\n        } else {\n            return this.getFederatedSignonCertsAsync();\n        }\n    }\n    async getFederatedSignonCertsAsync() {\n        const nowTime = new Date().getTime();\n        const format = (0, crypto_1.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;\n        if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format) {\n            return {\n                certs: this.certificateCache,\n                format\n            };\n        }\n        let res;\n        let url;\n        switch(format){\n            case CertificateFormat.PEM:\n                url = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();\n                break;\n            case CertificateFormat.JWK:\n                url = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        try {\n            res = await this.transporter.request({\n                ...OAuth2Client.RETRY_CONFIG,\n                url\n            });\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        const cacheControl = res ? res.headers[\"cache-control\"] : undefined;\n        let cacheAge = -1;\n        if (cacheControl) {\n            const pattern = new RegExp(\"max-age=([0-9]*)\");\n            const regexResult = pattern.exec(cacheControl);\n            if (regexResult && regexResult.length === 2) {\n                // Cache results with max-age (in seconds)\n                cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n            }\n        }\n        let certificates = {};\n        switch(format){\n            case CertificateFormat.PEM:\n                certificates = res.data;\n                break;\n            case CertificateFormat.JWK:\n                for (const key of res.data.keys){\n                    certificates[key.kid] = key;\n                }\n                break;\n            default:\n                throw new Error(`Unsupported certificate format ${format}`);\n        }\n        const now = new Date();\n        this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n        this.certificateCache = certificates;\n        this.certificateCacheFormat = format;\n        return {\n            certs: certificates,\n            format,\n            res\n        };\n    }\n    getIapPublicKeys(callback) {\n        if (callback) {\n            this.getIapPublicKeysAsync().then((r)=>callback(null, r.pubkeys, r.res), callback);\n        } else {\n            return this.getIapPublicKeysAsync();\n        }\n    }\n    async getIapPublicKeysAsync() {\n        let res;\n        const url = this.endpoints.oauth2IapPublicKeyUrl.toString();\n        try {\n            res = await this.transporter.request({\n                ...OAuth2Client.RETRY_CONFIG,\n                url\n            });\n        } catch (e) {\n            if (e instanceof Error) {\n                e.message = `Failed to retrieve verification certificates: ${e.message}`;\n            }\n            throw e;\n        }\n        return {\n            pubkeys: res.data,\n            res\n        };\n    }\n    verifySignedJwtWithCerts() {\n        // To make the code compatible with browser SubtleCrypto we need to make\n        // this method async.\n        throw new Error(\"verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.\");\n    }\n    /**\n     * Verify the id token is signed with the correct certificate\n     * and is from the correct audience.\n     * @param jwt The jwt to verify (The ID Token in this case).\n     * @param certs The array of certs to test the jwt against.\n     * @param requiredAudience The audience to test the jwt against.\n     * @param issuers The allowed issuers of the jwt (Optional).\n     * @param maxExpiry The max expiry the certificate can be (Optional).\n     * @return Returns a promise resolving to LoginTicket on verification.\n     */ async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {\n        const crypto = (0, crypto_1.createCrypto)();\n        if (!maxExpiry) {\n            maxExpiry = OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_;\n        }\n        const segments = jwt.split(\".\");\n        if (segments.length !== 3) {\n            throw new Error(\"Wrong number of segments in token: \" + jwt);\n        }\n        const signed = segments[0] + \".\" + segments[1];\n        let signature = segments[2];\n        let envelope;\n        let payload;\n        try {\n            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;\n            }\n            throw err;\n        }\n        if (!envelope) {\n            throw new Error(\"Can't parse token envelope: \" + segments[0]);\n        }\n        try {\n            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));\n        } catch (err) {\n            if (err instanceof Error) {\n                err.message = `Can't parse token payload '${segments[0]}`;\n            }\n            throw err;\n        }\n        if (!payload) {\n            throw new Error(\"Can't parse token payload: \" + segments[1]);\n        }\n        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {\n            // If this is not present, then there's no reason to attempt verification\n            throw new Error(\"No pem found for envelope: \" + JSON.stringify(envelope));\n        }\n        const cert = certs[envelope.kid];\n        if (envelope.alg === \"ES256\") {\n            signature = formatEcdsa.joseToDer(signature, \"ES256\").toString(\"base64\");\n        }\n        const verified = await crypto.verify(cert, signed, signature);\n        if (!verified) {\n            throw new Error(\"Invalid token signature: \" + jwt);\n        }\n        if (!payload.iat) {\n            throw new Error(\"No issue time in token: \" + JSON.stringify(payload));\n        }\n        if (!payload.exp) {\n            throw new Error(\"No expiration time in token: \" + JSON.stringify(payload));\n        }\n        const iat = Number(payload.iat);\n        if (isNaN(iat)) throw new Error(\"iat field using invalid format\");\n        const exp = Number(payload.exp);\n        if (isNaN(exp)) throw new Error(\"exp field using invalid format\");\n        const now = new Date().getTime() / 1000;\n        if (exp >= now + maxExpiry) {\n            throw new Error(\"Expiration time too far in future: \" + JSON.stringify(payload));\n        }\n        const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n        const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n        if (now < earliest) {\n            throw new Error(\"Token used too early, \" + now + \" < \" + earliest + \": \" + JSON.stringify(payload));\n        }\n        if (now > latest) {\n            throw new Error(\"Token used too late, \" + now + \" > \" + latest + \": \" + JSON.stringify(payload));\n        }\n        if (issuers && issuers.indexOf(payload.iss) < 0) {\n            throw new Error(\"Invalid issuer, expected one of [\" + issuers + \"], but got \" + payload.iss);\n        }\n        // Check the audience matches if we have one\n        if (typeof requiredAudience !== \"undefined\" && requiredAudience !== null) {\n            const aud = payload.aud;\n            let audVerified = false;\n            // If the requiredAudience is an array, check if it contains token\n            // audience\n            if (requiredAudience.constructor === Array) {\n                audVerified = requiredAudience.indexOf(aud) > -1;\n            } else {\n                audVerified = aud === requiredAudience;\n            }\n            if (!audVerified) {\n                throw new Error(\"Wrong recipient, payload audience != requiredAudience\");\n            }\n        }\n        return new loginticket_1.LoginTicket(envelope, payload);\n    }\n    /**\n     * Returns a promise that resolves with AccessTokenResponse type if\n     * refreshHandler is defined.\n     * If not, nothing is returned.\n     */ async processAndValidateRefreshHandler() {\n        if (this.refreshHandler) {\n            const accessTokenResponse = await this.refreshHandler();\n            if (!accessTokenResponse.access_token) {\n                throw new Error(\"No access token is returned by the refreshHandler callback.\");\n            }\n            return accessTokenResponse;\n        }\n        return;\n    }\n    /**\n     * Returns true if a token is expired or will expire within\n     * eagerRefreshThresholdMillismilliseconds.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     */ isTokenExpiring() {\n        const expiryDate = this.credentials.expiry_date;\n        return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n    }\n}\nexports.OAuth2Client = OAuth2Client;\n/**\n * @deprecated use instance's {@link OAuth2Client.endpoints}\n */ OAuth2Client.GOOGLE_TOKEN_INFO_URL = \"https://oauth2.googleapis.com/tokeninfo\";\n/**\n * Clock skew - five minutes in seconds\n */ OAuth2Client.CLOCK_SKEW_SECS_ = 300;\n/**\n * The default max Token Lifetime is one day in seconds\n */ OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_ = 86400;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0EsNEJBQTRCLEdBQUdBLHlCQUF5QixHQUFHQSwyQkFBMkIsR0FBRyxLQUFLO0FBQ3JILE1BQU1NLFdBQVdDLG1CQUFPQSxDQUFDLDhEQUFRO0FBQ2pDLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLGdDQUFhO0FBQ3pDLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDLHNCQUFRO0FBQy9CLE1BQU1HLGNBQWNILG1CQUFPQSxDQUFDLGdHQUFxQjtBQUNqRCxNQUFNSSxXQUFXSixtQkFBT0EsQ0FBQyw2RkFBa0I7QUFDM0MsTUFBTUssZUFBZUwsbUJBQU9BLENBQUMsMkZBQWM7QUFDM0MsTUFBTU0sZ0JBQWdCTixtQkFBT0EsQ0FBQyw2RkFBZTtBQUM3QyxJQUFJRjtBQUNILFVBQVVBLG1CQUFtQjtJQUMxQkEsbUJBQW1CLENBQUMsUUFBUSxHQUFHO0lBQy9CQSxtQkFBbUIsQ0FBQyxPQUFPLEdBQUc7QUFDbEMsR0FBR0EsdUJBQXdCTCxDQUFBQSwyQkFBMkIsR0FBR0ssc0JBQXNCLENBQUM7QUFDaEYsSUFBSUQ7QUFDSCxVQUFVQSxpQkFBaUI7SUFDeEJBLGlCQUFpQixDQUFDLE1BQU0sR0FBRztJQUMzQkEsaUJBQWlCLENBQUMsTUFBTSxHQUFHO0FBQy9CLEdBQUdBLHFCQUFzQkosQ0FBQUEseUJBQXlCLEdBQUdJLG9CQUFv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SUFDQTs7OztLQUlDLEdBQ0QsTUFBTTFFLG1DQUFtQztRQUNyQyxJQUFJLElBQUksQ0FBQ0YsY0FBYyxFQUFFO1lBQ3JCLE1BQU1rRyxzQkFBc0IsTUFBTSxJQUFJLENBQUNsRyxjQUFjO1lBQ3JELElBQUksQ0FBQ2tHLG9CQUFvQnBHLFlBQVksRUFBRTtnQkFDbkMsTUFBTSxJQUFJNUUsTUFBTTtZQUNwQjtZQUNBLE9BQU9nTDtRQUNYO1FBQ0E7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRG5HLGtCQUFrQjtRQUNkLE1BQU1vRyxhQUFhLElBQUksQ0FBQzFHLFdBQVcsQ0FBQ3BCLFdBQVc7UUFDL0MsT0FBTzhILGFBQ0RBLGNBQWMsSUFBSTdILE9BQU9DLE9BQU8sS0FBSyxJQUFJLENBQUM2SCwyQkFBMkIsR0FDckU7SUFDVjtBQUNKO0FBQ0E5TixvQkFBb0IsR0FBR0U7QUFDdkI7O0NBRUMsR0FDREEsYUFBYTZOLHFCQUFxQixHQUFHO0FBQ3JDOztDQUVDLEdBQ0Q3TixhQUFhbU4sZ0JBQWdCLEdBQUc7QUFDaEM7O0NBRUMsR0FDRG5OLGFBQWErTCxnQ0FBZ0MsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvb2F1dGgyY2xpZW50LmpzPzY4NmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT0F1dGgyQ2xpZW50ID0gZXhwb3J0cy5DbGllbnRBdXRoZW50aWNhdGlvbiA9IGV4cG9ydHMuQ2VydGlmaWNhdGVGb3JtYXQgPSBleHBvcnRzLkNvZGVDaGFsbGVuZ2VNZXRob2QgPSB2b2lkIDA7XG5jb25zdCBnYXhpb3NfMSA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCBmb3JtYXRFY2RzYSA9IHJlcXVpcmUoXCJlY2RzYS1zaWctZm9ybWF0dGVyXCIpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiLi4vY3J5cHRvL2NyeXB0b1wiKTtcbmNvbnN0IGF1dGhjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGhjbGllbnRcIik7XG5jb25zdCBsb2dpbnRpY2tldF8xID0gcmVxdWlyZShcIi4vbG9naW50aWNrZXRcIik7XG52YXIgQ29kZUNoYWxsZW5nZU1ldGhvZDtcbihmdW5jdGlvbiAoQ29kZUNoYWxsZW5nZU1ldGhvZCkge1xuICAgIENvZGVDaGFsbGVuZ2VNZXRob2RbXCJQbGFpblwiXSA9IFwicGxhaW5cIjtcbiAgICBDb2RlQ2hhbGxlbmdlTWV0aG9kW1wiUzI1NlwiXSA9IFwiUzI1NlwiO1xufSkoQ29kZUNoYWxsZW5nZU1ldGhvZCB8fCAoZXhwb3J0cy5Db2RlQ2hhbGxlbmdlTWV0aG9kID0gQ29kZUNoYWxsZW5nZU1ldGhvZCA9IHt9KSk7XG52YXIgQ2VydGlmaWNhdGVGb3JtYXQ7XG4oZnVuY3Rpb24gKENlcnRpZmljYXRlRm9ybWF0KSB7XG4gICAgQ2VydGlmaWNhdGVGb3JtYXRbXCJQRU1cIl0gPSBcIlBFTVwiO1xuICAgIENlcnRpZmljYXRlRm9ybWF0W1wiSldLXCJdID0gXCJKV0tcIjtcbn0pKENlcnRpZmljYXRlRm9ybWF0IHx8IChleHBvcnRzLkNlcnRpZmljYXRlRm9ybWF0ID0gQ2VydGlmaWNhdGVGb3JtYXQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgY2xpZW50IGF1dGhlbnRpY2F0aW9uIHR5cGUuIFN1cHBvcnRlZCB2YWx1ZXMgYXJlIGJhc2ljLCBwb3N0LCBhbmQgbm9uZS5cbiAqIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzU5MSNzZWN0aW9uLTJcbiAqL1xudmFyIENsaWVudEF1dGhlbnRpY2F0aW9uO1xuKGZ1bmN0aW9uIChDbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgIENsaWVudEF1dGhlbnRpY2F0aW9uW1wiQ2xpZW50U2VjcmV0UG9zdFwiXSA9IFwiQ2xpZW50U2VjcmV0UG9zdFwiO1xuICAgIENsaWVudEF1dGhlbnRpY2F0aW9uW1wiQ2xpZW50U2VjcmV0QmFzaWNcIl0gPSBcIkNsaWVudFNlY3JldEJhc2ljXCI7XG4gICAgQ2xpZW50QXV0aGVudGljYXRpb25bXCJOb25lXCJdID0gXCJOb25lXCI7XG59KShDbGllbnRBdXRoZW50aWNhdGlvbiB8fCAoZXhwb3J0cy5DbGllbnRBdXRoZW50aWNhdGlvbiA9IENsaWVudEF1dGhlbnRpY2F0aW9uID0ge30pKTtcbmNsYXNzIE9BdXRoMkNsaWVudCBleHRlbmRzIGF1dGhjbGllbnRfMS5BdXRoQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zT3JDbGllbnRJZCwgY2xpZW50U2VjcmV0LCByZWRpcmVjdFVyaSkge1xuICAgICAgICBjb25zdCBvcHRzID0gb3B0aW9uc09yQ2xpZW50SWQgJiYgdHlwZW9mIG9wdGlvbnNPckNsaWVudElkID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBvcHRpb25zT3JDbGllbnRJZFxuICAgICAgICAgICAgOiB7IGNsaWVudElkOiBvcHRpb25zT3JDbGllbnRJZCwgY2xpZW50U2VjcmV0LCByZWRpcmVjdFVyaSB9O1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUNhY2hlID0ge307XG4gICAgICAgIHRoaXMuY2VydGlmaWNhdGVFeHBpcnkgPSBudWxsO1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlQ2FjaGVGb3JtYXQgPSBDZXJ0aWZpY2F0ZUZvcm1hdC5QRU07XG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NsaWVudElkID0gb3B0cy5jbGllbnRJZDtcbiAgICAgICAgdGhpcy5fY2xpZW50U2VjcmV0ID0gb3B0cy5jbGllbnRTZWNyZXQ7XG4gICAgICAgIHRoaXMucmVkaXJlY3RVcmkgPSBvcHRzLnJlZGlyZWN0VXJpO1xuICAgICAgICB0aGlzLmVuZHBvaW50cyA9IHtcbiAgICAgICAgICAgIHRva2VuSW5mb1VybDogJ2h0dHBzOi8vb2F1dGgyLmdvb2dsZWFwaXMuY29tL3Rva2VuaW5mbycsXG4gICAgICAgICAgICBvYXV0aDJBdXRoQmFzZVVybDogJ2h0dHBzOi8vYWNjb3VudHMuZ29vZ2xlLmNvbS9vL29hdXRoMi92Mi9hdXRoJyxcbiAgICAgICAgICAgIG9hdXRoMlRva2VuVXJsOiAnaHR0cHM6Ly9vYXV0aDIuZ29vZ2xlYXBpcy5jb20vdG9rZW4nLFxuICAgICAgICAgICAgb2F1dGgyUmV2b2tlVXJsOiAnaHR0cHM6Ly9vYXV0aDIuZ29vZ2xlYXBpcy5jb20vcmV2b2tlJyxcbiAgICAgICAgICAgIG9hdXRoMkZlZGVyYXRlZFNpZ25vblBlbUNlcnRzVXJsOiAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vb2F1dGgyL3YxL2NlcnRzJyxcbiAgICAgICAgICAgIG9hdXRoMkZlZGVyYXRlZFNpZ25vbkp3a0NlcnRzVXJsOiAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vb2F1dGgyL3YzL2NlcnRzJyxcbiAgICAgICAgICAgIG9hdXRoMklhcFB1YmxpY0tleVVybDogJ2h0dHBzOi8vd3d3LmdzdGF0aWMuY29tL2lhcC92ZXJpZnkvcHVibGljX2tleScsXG4gICAgICAgICAgICAuLi5vcHRzLmVuZHBvaW50cyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbiA9XG4gICAgICAgICAgICBvcHRzLmNsaWVudEF1dGhlbnRpY2F0aW9uIHx8IENsaWVudEF1dGhlbnRpY2F0aW9uLkNsaWVudFNlY3JldFBvc3Q7XG4gICAgICAgIHRoaXMuaXNzdWVycyA9IG9wdHMuaXNzdWVycyB8fCBbXG4gICAgICAgICAgICAnYWNjb3VudHMuZ29vZ2xlLmNvbScsXG4gICAgICAgICAgICAnaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tJyxcbiAgICAgICAgICAgIHRoaXMudW5pdmVyc2VEb21haW4sXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBVUkwgZm9yIGNvbnNlbnQgcGFnZSBsYW5kaW5nLlxuICAgICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMuXG4gICAgICogQHJldHVybiBVUkwgdG8gY29uc2VudCBwYWdlLlxuICAgICAqL1xuICAgIGdlbmVyYXRlQXV0aFVybChvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKG9wdHMuY29kZV9jaGFsbGVuZ2VfbWV0aG9kICYmICFvcHRzLmNvZGVfY2hhbGxlbmdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIGEgY29kZV9jaGFsbGVuZ2VfbWV0aG9kIGlzIHByb3ZpZGVkLCBjb2RlX2NoYWxsZW5nZSBtdXN0IGJlIGluY2x1ZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMucmVzcG9uc2VfdHlwZSA9IG9wdHMucmVzcG9uc2VfdHlwZSB8fCAnY29kZSc7XG4gICAgICAgIG9wdHMuY2xpZW50X2lkID0gb3B0cy5jbGllbnRfaWQgfHwgdGhpcy5fY2xpZW50SWQ7XG4gICAgICAgIG9wdHMucmVkaXJlY3RfdXJpID0gb3B0cy5yZWRpcmVjdF91cmkgfHwgdGhpcy5yZWRpcmVjdFVyaTtcbiAgICAgICAgLy8gQWxsb3cgc2NvcGVzIHRvIGJlIHBhc3NlZCBlaXRoZXIgYXMgYXJyYXkgb3IgYSBzdHJpbmdcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5zY29wZSkpIHtcbiAgICAgICAgICAgIG9wdHMuc2NvcGUgPSBvcHRzLnNjb3BlLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb290VXJsID0gdGhpcy5lbmRwb2ludHMub2F1dGgyQXV0aEJhc2VVcmwudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIChyb290VXJsICtcbiAgICAgICAgICAgICc/JyArXG4gICAgICAgICAgICBxdWVyeXN0cmluZy5zdHJpbmdpZnkob3B0cykpO1xuICAgIH1cbiAgICBnZW5lcmF0ZUNvZGVWZXJpZmllcigpIHtcbiAgICAgICAgLy8gVG8gbWFrZSB0aGUgY29kZSBjb21wYXRpYmxlIHdpdGggYnJvd3NlciBTdWJ0bGVDcnlwdG8gd2UgbmVlZCB0byBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRlQ29kZVZlcmlmaWVyIGlzIHJlbW92ZWQsIHBsZWFzZSB1c2UgZ2VuZXJhdGVDb2RlVmVyaWZpZXJBc3luYyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIGNvZGVfdmVyaWZpZXIsIGFuZCBpdHNcbiAgICAgKiByZXN1bHRpbmcgU0hBMjU2LiBJZiB1c2VkLCB0aGlzIG11c3QgYmUgcGFpcmVkIHdpdGggYSBTMjU2XG4gICAgICogY29kZV9jaGFsbGVuZ2VfbWV0aG9kLlxuICAgICAqXG4gICAgICogRm9yIGEgZnVsbCBleGFtcGxlIHNlZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlYXBpcy9nb29nbGUtYXV0aC1saWJyYXJ5LW5vZGVqcy9ibG9iL21haW4vc2FtcGxlcy9vYXV0aDItY29kZVZlcmlmaWVyLmpzXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVDb2RlVmVyaWZpZXJBc3luYygpIHtcbiAgICAgICAgLy8gYmFzZTY0IGVuY29kaW5nIHVzZXMgNiBiaXRzIHBlciBjaGFyYWN0ZXIsIGFuZCB3ZSB3YW50IHRvIGdlbmVyYXRlMTI4XG4gICAgICAgIC8vIGNoYXJhY3RlcnMuIDYqMTI4LzggPSA5Ni5cbiAgICAgICAgY29uc3QgY3J5cHRvID0gKDAsIGNyeXB0b18xLmNyZWF0ZUNyeXB0bykoKTtcbiAgICAgICAgY29uc3QgcmFuZG9tU3RyaW5nID0gY3J5cHRvLnJhbmRvbUJ5dGVzQmFzZTY0KDk2KTtcbiAgICAgICAgLy8gVGhlIHZhbGlkIGNoYXJhY3RlcnMgaW4gdGhlIGNvZGVfdmVyaWZpZXIgYXJlIFtBLVpdL1thLXpdL1swLTldL1xuICAgICAgICAvLyBcIi1cIi9cIi5cIi9cIl9cIi9cIn5cIi4gQmFzZTY0IGVuY29kZWQgc3RyaW5ncyBhcmUgcHJldHR5IGNsb3NlLCBzbyB3ZSdyZSBqdXN0XG4gICAgICAgIC8vIHN3YXBwaW5nIG91dCBhIGZldyBjaGFycy5cbiAgICAgICAgY29uc3QgY29kZVZlcmlmaWVyID0gcmFuZG9tU3RyaW5nXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwrL2csICd+JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC89L2csICdfJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJy0nKTtcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGJhc2U2NCBlbmNvZGVkIFNIQTI1NlxuICAgICAgICBjb25zdCB1bmVuY29kZWRDb2RlQ2hhbGxlbmdlID0gYXdhaXQgY3J5cHRvLnNoYTI1NkRpZ2VzdEJhc2U2NChjb2RlVmVyaWZpZXIpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHVzZSBiYXNlNjRVcmxFbmNvZGluZyBpbnN0ZWFkIG9mIHN0YW5kYXJkIGJhc2U2NFxuICAgICAgICBjb25zdCBjb2RlQ2hhbGxlbmdlID0gdW5lbmNvZGVkQ29kZUNoYWxsZW5nZVxuICAgICAgICAgICAgLnNwbGl0KCc9JylbMF1cbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xuICAgICAgICByZXR1cm4geyBjb2RlVmVyaWZpZXIsIGNvZGVDaGFsbGVuZ2UgfTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oY29kZU9yT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBjb2RlT3JPcHRpb25zID09PSAnc3RyaW5nJyA/IHsgY29kZTogY29kZU9yT3B0aW9ucyB9IDogY29kZU9yT3B0aW9ucztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldFRva2VuQXN5bmMob3B0aW9ucykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIudG9rZW5zLCByLnJlcyksIGUgPT4gY2FsbGJhY2soZSwgbnVsbCwgZS5yZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5Bc3luYyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUb2tlbkFzeW5jKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5lbmRwb2ludHMub2F1dGgyVG9rZW5VcmwudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgICAgICAgY2xpZW50X2lkOiBvcHRpb25zLmNsaWVudF9pZCB8fCB0aGlzLl9jbGllbnRJZCxcbiAgICAgICAgICAgIGNvZGVfdmVyaWZpZXI6IG9wdGlvbnMuY29kZVZlcmlmaWVyLFxuICAgICAgICAgICAgY29kZTogb3B0aW9ucy5jb2RlLFxuICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ2F1dGhvcml6YXRpb25fY29kZScsXG4gICAgICAgICAgICByZWRpcmVjdF91cmk6IG9wdGlvbnMucmVkaXJlY3RfdXJpIHx8IHRoaXMucmVkaXJlY3RVcmksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uID09PSBDbGllbnRBdXRoZW50aWNhdGlvbi5DbGllbnRTZWNyZXRCYXNpYykge1xuICAgICAgICAgICAgY29uc3QgYmFzaWMgPSBCdWZmZXIuZnJvbShgJHt0aGlzLl9jbGllbnRJZH06JHt0aGlzLl9jbGllbnRTZWNyZXR9YCk7XG4gICAgICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmFzaWMgJHtiYXNpYy50b1N0cmluZygnYmFzZTY0Jyl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbiA9PT0gQ2xpZW50QXV0aGVudGljYXRpb24uQ2xpZW50U2VjcmV0UG9zdCkge1xuICAgICAgICAgICAgdmFsdWVzLmNsaWVudF9zZWNyZXQgPSB0aGlzLl9jbGllbnRTZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgIC4uLk9BdXRoMkNsaWVudC5SRVRSWV9DT05GSUcsXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGRhdGE6IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh2YWx1ZXMpLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHJlcy5kYXRhO1xuICAgICAgICBpZiAocmVzLmRhdGEgJiYgcmVzLmRhdGEuZXhwaXJlc19pbikge1xuICAgICAgICAgICAgdG9rZW5zLmV4cGlyeV9kYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyByZXMuZGF0YS5leHBpcmVzX2luICogMTAwMDtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbnMuZXhwaXJlc19pbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3Rva2VucycsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB7IHRva2VucywgcmVzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZnJlc2hlcyB0aGUgYWNjZXNzIHRva2VuLlxuICAgICAqIEBwYXJhbSByZWZyZXNoX3Rva2VuIEV4aXN0aW5nIHJlZnJlc2ggdG9rZW4uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhc3luYyByZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGlmICghcmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoVG9rZW5Ob0NhY2hlKHJlZnJlc2hUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSByZXF1ZXN0IHRvIHJlZnJlc2ggdXNpbmcgdGhlIHNhbWUgdG9rZW4gaGFzIHN0YXJ0ZWQsXG4gICAgICAgIC8vIHJldHVybiB0aGUgc2FtZSBwcm9taXNlLlxuICAgICAgICBpZiAodGhpcy5yZWZyZXNoVG9rZW5Qcm9taXNlcy5oYXMocmVmcmVzaFRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaFRva2VuUHJvbWlzZXMuZ2V0KHJlZnJlc2hUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcCA9IHRoaXMucmVmcmVzaFRva2VuTm9DYWNoZShyZWZyZXNoVG9rZW4pLnRoZW4ociA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUb2tlblByb21pc2VzLmRlbGV0ZShyZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0sIGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW5Qcm9taXNlcy5kZWxldGUocmVmcmVzaFRva2VuKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlblByb21pc2VzLnNldChyZWZyZXNoVG9rZW4sIHApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaFRva2VuTm9DYWNoZShyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyByZWZyZXNoIHRva2VuIGlzIHNldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmVuZHBvaW50cy5vYXV0aDJUb2tlblVybC50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLl9jbGllbnRJZCxcbiAgICAgICAgICAgIGNsaWVudF9zZWNyZXQ6IHRoaXMuX2NsaWVudFNlY3JldCxcbiAgICAgICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgZm9yIG5ldyB0b2tlblxuICAgICAgICAgICAgcmVzID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAuLi5PQXV0aDJDbGllbnQuUkVUUllfQ09ORklHLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBkYXRhOiBxdWVyeXN0cmluZy5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIGdheGlvc18xLkdheGlvc0Vycm9yICYmXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID09PSAnaW52YWxpZF9ncmFudCcgJiZcbiAgICAgICAgICAgICAgICAoKF9hID0gZS5yZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpICYmXG4gICAgICAgICAgICAgICAgL1JlQXV0aC9pLnRlc3QoZS5yZXNwb25zZS5kYXRhLmVycm9yX2Rlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGUucmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHJlcy5kYXRhO1xuICAgICAgICAvLyBUT0RPOiBkZS1kdXBsaWNhdGUgdGhpcyBjb2RlIGZyb20gYSBmZXcgc3BvdHNcbiAgICAgICAgaWYgKHJlcy5kYXRhICYmIHJlcy5kYXRhLmV4cGlyZXNfaW4pIHtcbiAgICAgICAgICAgIHRva2Vucy5leHBpcnlfZGF0ZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgcmVzLmRhdGEuZXhwaXJlc19pbiAqIDEwMDA7XG4gICAgICAgICAgICBkZWxldGUgdG9rZW5zLmV4cGlyZXNfaW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCd0b2tlbnMnLCB0b2tlbnMpO1xuICAgICAgICByZXR1cm4geyB0b2tlbnMsIHJlcyB9O1xuICAgIH1cbiAgICByZWZyZXNoQWNjZXNzVG9rZW4oY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCkudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIuY3JlZGVudGlhbHMsIHIucmVzKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpIHtcbiAgICAgICAgY29uc3QgciA9IGF3YWl0IHRoaXMucmVmcmVzaFRva2VuKHRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbik7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHIudG9rZW5zO1xuICAgICAgICB0b2tlbnMucmVmcmVzaF90b2tlbiA9IHRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbjtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHRva2VucztcbiAgICAgICAgcmV0dXJuIHsgY3JlZGVudGlhbHM6IHRoaXMuY3JlZGVudGlhbHMsIHJlczogci5yZXMgfTtcbiAgICB9XG4gICAgZ2V0QWNjZXNzVG9rZW4oY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldEFjY2Vzc1Rva2VuQXN5bmMoKS50aGVuKHIgPT4gY2FsbGJhY2sobnVsbCwgci50b2tlbiwgci5yZXMpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0QWNjZXNzVG9rZW5Bc3luYygpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkUmVmcmVzaCA9ICF0aGlzLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbiB8fCB0aGlzLmlzVG9rZW5FeHBpcmluZygpO1xuICAgICAgICBpZiAoc2hvdWxkUmVmcmVzaCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZyZXNoSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMucHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSBudWxsIHx8IHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWZyZXNoZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3JlZGVudGlhbHMocmVmcmVzaGVkQWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdG9rZW46IHRoaXMuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVmcmVzaCB0b2tlbiBvciByZWZyZXNoIGhhbmRsZXIgY2FsbGJhY2sgaXMgc2V0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnJlZnJlc2hBY2Nlc3NUb2tlbkFzeW5jKCk7XG4gICAgICAgICAgICBpZiAoIXIuY3JlZGVudGlhbHMgfHwgKHIuY3JlZGVudGlhbHMgJiYgIXIuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlZnJlc2ggYWNjZXNzIHRva2VuLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdG9rZW46IHIuY3JlZGVudGlhbHMuYWNjZXNzX3Rva2VuLCByZXM6IHIucmVzIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyB0b2tlbjogdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBhdXRoZW50aWNhdGlvbiBpbnRlcmZhY2UuICBJdCB0YWtlcyBhbiBvcHRpb25hbCB1cmwgd2hpY2ggd2hlblxuICAgICAqIHByZXNlbnQgaXMgdGhlIGVuZHBvaW50IGJlaW5nIGFjY2Vzc2VkLCBhbmQgcmV0dXJucyBhIFByb21pc2Ugd2hpY2hcbiAgICAgKiByZXNvbHZlcyB3aXRoIGF1dGhvcml6YXRpb24gaGVhZGVyIGZpZWxkcy5cbiAgICAgKlxuICAgICAqIEluIE9BdXRoMkNsaWVudCwgdGhlIHJlc3VsdCBoYXMgdGhlIGZvcm06XG4gICAgICogeyBBdXRob3JpemF0aW9uOiAnQmVhcmVyIDxhY2Nlc3NfdG9rZW5fdmFsdWU+JyB9XG4gICAgICogQHBhcmFtIHVybCBUaGUgb3B0aW9uYWwgdXJsIGJlaW5nIGF1dGhvcml6ZWRcbiAgICAgKi9cbiAgICBhc3luYyBnZXRSZXF1ZXN0SGVhZGVycyh1cmwpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IChhd2FpdCB0aGlzLmdldFJlcXVlc3RNZXRhZGF0YUFzeW5jKHVybCkpLmhlYWRlcnM7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgdXJsKSB7XG4gICAgICAgIGNvbnN0IHRoaXNDcmVkcyA9IHRoaXMuY3JlZGVudGlhbHM7XG4gICAgICAgIGlmICghdGhpc0NyZWRzLmFjY2Vzc190b2tlbiAmJlxuICAgICAgICAgICAgIXRoaXNDcmVkcy5yZWZyZXNoX3Rva2VuICYmXG4gICAgICAgICAgICAhdGhpcy5hcGlLZXkgJiZcbiAgICAgICAgICAgICF0aGlzLnJlZnJlc2hIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcywgcmVmcmVzaCB0b2tlbiwgQVBJIGtleSBvciByZWZyZXNoIGhhbmRsZXIgY2FsbGJhY2sgaXMgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzQ3JlZHMuYWNjZXNzX3Rva2VuICYmICF0aGlzLmlzVG9rZW5FeHBpcmluZygpKSB7XG4gICAgICAgICAgICB0aGlzQ3JlZHMudG9rZW5fdHlwZSA9IHRoaXNDcmVkcy50b2tlbl90eXBlIHx8ICdCZWFyZXInO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiB0aGlzQ3JlZHMudG9rZW5fdHlwZSArICcgJyArIHRoaXNDcmVkcy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgaGVhZGVyczogdGhpcy5hZGRTaGFyZWRNZXRhZGF0YUhlYWRlcnMoaGVhZGVycykgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiByZWZyZXNoSGFuZGxlciBleGlzdHMsIGNhbGwgcHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIoKS5cbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaEhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZnJlc2hlZEFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5wcm9jZXNzQW5kVmFsaWRhdGVSZWZyZXNoSGFuZGxlcigpO1xuICAgICAgICAgICAgaWYgKHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSBudWxsIHx8IHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWZyZXNoZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENyZWRlbnRpYWxzKHJlZnJlc2hlZEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyICcgKyB0aGlzLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4geyBoZWFkZXJzOiB7ICdYLUdvb2ctQXBpLUtleSc6IHRoaXMuYXBpS2V5IH0gfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgciA9IG51bGw7XG4gICAgICAgIGxldCB0b2tlbnMgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgciA9IGF3YWl0IHRoaXMucmVmcmVzaFRva2VuKHRoaXNDcmVkcy5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgIHRva2VucyA9IHIudG9rZW5zO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlcnI7XG4gICAgICAgICAgICBpZiAoZS5yZXNwb25zZSAmJlxuICAgICAgICAgICAgICAgIChlLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzIHx8IGUucmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpKSB7XG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gYENvdWxkIG5vdCByZWZyZXNoIGFjY2VzcyB0b2tlbjogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlZGVudGlhbHMgPSB0aGlzLmNyZWRlbnRpYWxzO1xuICAgICAgICBjcmVkZW50aWFscy50b2tlbl90eXBlID0gY3JlZGVudGlhbHMudG9rZW5fdHlwZSB8fCAnQmVhcmVyJztcbiAgICAgICAgdG9rZW5zLnJlZnJlc2hfdG9rZW4gPSBjcmVkZW50aWFscy5yZWZyZXNoX3Rva2VuO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gdG9rZW5zO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogY3JlZGVudGlhbHMudG9rZW5fdHlwZSArICcgJyArIHRva2Vucy5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGhlYWRlcnM6IHRoaXMuYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzKGhlYWRlcnMpLCByZXM6IHIucmVzIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBVUkwgdG8gcmV2b2tlIHRoZSBnaXZlbiB0b2tlbi5cbiAgICAgKiBAcGFyYW0gdG9rZW4gVGhlIGV4aXN0aW5nIHRva2VuIHRvIGJlIHJldm9rZWQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgaW5zdGFuY2UgbWV0aG9kIHtAbGluayBPQXV0aDJDbGllbnQuZ2V0UmV2b2tlVG9rZW5VUkx9XG4gICAgICovXG4gICAgc3RhdGljIGdldFJldm9rZVRva2VuVXJsKHRva2VuKSB7XG4gICAgICAgIHJldHVybiBuZXcgT0F1dGgyQ2xpZW50KCkuZ2V0UmV2b2tlVG9rZW5VUkwodG9rZW4pLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFVSTCB0byByZXZva2UgdGhlIGdpdmVuIHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIFRoZSBleGlzdGluZyB0b2tlbiB0byBiZSByZXZva2VkLlxuICAgICAqL1xuICAgIGdldFJldm9rZVRva2VuVVJMKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy5lbmRwb2ludHMub2F1dGgyUmV2b2tlVXJsKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3Rva2VuJywgdG9rZW4pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICByZXZva2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIC4uLk9BdXRoMkNsaWVudC5SRVRSWV9DT05GSUcsXG4gICAgICAgICAgICB1cmw6IHRoaXMuZ2V0UmV2b2tlVG9rZW5VUkwodG9rZW4pLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydGVyXG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qob3B0cylcbiAgICAgICAgICAgICAgICAudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldm9rZUNyZWRlbnRpYWxzKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5yZXZva2VDcmVkZW50aWFsc0FzeW5jKCkudGhlbihyZXMgPT4gY2FsbGJhY2sobnVsbCwgcmVzKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV2b2tlQ3JlZGVudGlhbHNBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJldm9rZUNyZWRlbnRpYWxzQXN5bmMoKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW47XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB7fTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZva2VUb2tlbih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjY2VzcyB0b2tlbiB0byByZXZva2UuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdChvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFzeW5jKG9wdHMpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByKSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIGUucmVzcG9uc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdEFzeW5jKG9wdHMsIHJlQXV0aFJldHJpZWQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcjI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyhvcHRzLnVybCk7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICBpZiAoci5oZWFkZXJzICYmIHIuaGVhZGVyc1sneC1nb29nLXVzZXItcHJvamVjdCddKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWyd4LWdvb2ctdXNlci1wcm9qZWN0J10gPSByLmhlYWRlcnNbJ3gtZ29vZy11c2VyLXByb2plY3QnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyLmhlYWRlcnMgJiYgci5oZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IHIuaGVhZGVycy5BdXRob3JpemF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWydYLUdvb2ctQXBpLUtleSddID0gdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByMiA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gZS5yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICAvLyBSZXRyeSB0aGUgcmVxdWVzdCBmb3IgbWV0YWRhdGEgaWYgdGhlIGZvbGxvd2luZyBjcml0ZXJpYSBhcmUgdHJ1ZTpcbiAgICAgICAgICAgICAgICAvLyAtIFdlIGhhdmVuJ3QgYWxyZWFkeSByZXRyaWVkLiAgSXQgb25seSBtYWtlcyBzZW5zZSB0byByZXRyeSBvbmNlLlxuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlc3BvbnNlIHdhcyBhIDQwMSBvciBhIDQwM1xuICAgICAgICAgICAgICAgIC8vIC0gVGhlIHJlcXVlc3QgZGlkbid0IHNlbmQgYSByZWFkYWJsZVN0cmVhbVxuICAgICAgICAgICAgICAgIC8vIC0gQW4gYWNjZXNzX3Rva2VuIGFuZCByZWZyZXNoX3Rva2VuIHdlcmUgYXZhaWxhYmxlLCBidXQgZWl0aGVyIG5vXG4gICAgICAgICAgICAgICAgLy8gICBleHBpcnlfZGF0ZSB3YXMgYXZhaWxhYmxlIG9yIHRoZSBmb3JjZVJlZnJlc2hPbkZhaWx1cmUgZmxhZyBpcyBzZXQuXG4gICAgICAgICAgICAgICAgLy8gICBUaGUgYWJzZW50IGV4cGlyeV9kYXRlIGNhc2UgY2FuIGhhcHBlbiB3aGVuIGRldmVsb3BlcnMgc3Rhc2ggdGhlXG4gICAgICAgICAgICAgICAgLy8gICBhY2Nlc3NfdG9rZW4gYW5kIHJlZnJlc2hfdG9rZW4gZm9yIGxhdGVyIHVzZSwgYnV0IHRoZSBhY2Nlc3NfdG9rZW5cbiAgICAgICAgICAgICAgICAvLyAgIGZhaWxzIG9uIHRoZSBmaXJzdCB0cnkgYmVjYXVzZSBpdCdzIGV4cGlyZWQuIFNvbWUgZGV2ZWxvcGVycyBtYXlcbiAgICAgICAgICAgICAgICAvLyAgIGNob29zZSB0byBlbmFibGUgZm9yY2VSZWZyZXNoT25GYWlsdXJlIHRvIG1pdGlnYXRlIHRpbWUtcmVsYXRlZFxuICAgICAgICAgICAgICAgIC8vICAgZXJyb3JzLlxuICAgICAgICAgICAgICAgIC8vIE9yIHRoZSBmb2xsb3dpbmcgY3JpdGVyaWEgYXJlIHRydWU6XG4gICAgICAgICAgICAgICAgLy8gLSBXZSBoYXZlbid0IGFscmVhZHkgcmV0cmllZC4gIEl0IG9ubHkgbWFrZXMgc2Vuc2UgdG8gcmV0cnkgb25jZS5cbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXNwb25zZSB3YXMgYSA0MDEgb3IgYSA0MDNcbiAgICAgICAgICAgICAgICAvLyAtIFRoZSByZXF1ZXN0IGRpZG4ndCBzZW5kIGEgcmVhZGFibGVTdHJlYW1cbiAgICAgICAgICAgICAgICAvLyAtIE5vIHJlZnJlc2hfdG9rZW4gd2FzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIC8vIC0gQW4gYWNjZXNzX3Rva2VuIGFuZCBhIHJlZnJlc2hIYW5kbGVyIGNhbGxiYWNrIHdlcmUgYXZhaWxhYmxlLCBidXRcbiAgICAgICAgICAgICAgICAvLyAgIGVpdGhlciBubyBleHBpcnlfZGF0ZSB3YXMgYXZhaWxhYmxlIG9yIHRoZSBmb3JjZVJlZnJlc2hPbkZhaWx1cmVcbiAgICAgICAgICAgICAgICAvLyAgIGZsYWcgaXMgc2V0LiBUaGUgYWNjZXNzX3Rva2VuIGZhaWxzIG9uIHRoZSBmaXJzdCB0cnkgYmVjYXVzZSBpdCdzXG4gICAgICAgICAgICAgICAgLy8gICBleHBpcmVkLiBTb21lIGRldmVsb3BlcnMgbWF5IGNob29zZSB0byBlbmFibGUgZm9yY2VSZWZyZXNoT25GYWlsdXJlXG4gICAgICAgICAgICAgICAgLy8gICB0byBtaXRpZ2F0ZSB0aW1lLXJlbGF0ZWQgZXJyb3JzLlxuICAgICAgICAgICAgICAgIGNvbnN0IG1heVJlcXVpcmVSZWZyZXNoID0gdGhpcy5jcmVkZW50aWFscyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzLmFjY2Vzc190b2tlbiAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLmNyZWRlbnRpYWxzLmV4cGlyeV9kYXRlIHx8IHRoaXMuZm9yY2VSZWZyZXNoT25GYWlsdXJlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXlSZXF1aXJlUmVmcmVzaFdpdGhOb1JlZnJlc2hUb2tlbiA9IHRoaXMuY3JlZGVudGlhbHMgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFscy5hY2Nlc3NfdG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuY3JlZGVudGlhbHMucmVmcmVzaF90b2tlbiAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMuY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGUgfHwgdGhpcy5mb3JjZVJlZnJlc2hPbkZhaWx1cmUpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaEhhbmRsZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWFkYWJsZVN0cmVhbSA9IHJlcy5jb25maWcuZGF0YSBpbnN0YW5jZW9mIHN0cmVhbS5SZWFkYWJsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F1dGhFcnIgPSBzdGF0dXNDb2RlID09PSA0MDEgfHwgc3RhdHVzQ29kZSA9PT0gNDAzO1xuICAgICAgICAgICAgICAgIGlmICghcmVBdXRoUmV0cmllZCAmJlxuICAgICAgICAgICAgICAgICAgICBpc0F1dGhFcnIgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzUmVhZGFibGVTdHJlYW0gJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5UmVxdWlyZVJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW5Bc3luYygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QXN5bmMob3B0cywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFyZUF1dGhSZXRyaWVkICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0aEVyciAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNSZWFkYWJsZVN0cmVhbSAmJlxuICAgICAgICAgICAgICAgICAgICBtYXlSZXF1aXJlUmVmcmVzaFdpdGhOb1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZyZXNoZWRBY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMucHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSBudWxsIHx8IHJlZnJlc2hlZEFjY2Vzc1Rva2VuID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWZyZXNoZWRBY2Nlc3NUb2tlbi5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3JlZGVudGlhbHMocmVmcmVzaGVkQWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyhvcHRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByMjtcbiAgICB9XG4gICAgdmVyaWZ5SWRUb2tlbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZWQgdG8gYWNjZXB0IHR3byBhcmd1bWVudHMgaW5zdGVhZCBvZiBhbiBvcHRpb25zIG9iamVjdC5cbiAgICAgICAgLy8gQ2hlY2sgdGhlIHR5cGVzIHRvIGhlbHAgdXNlcnMgdXBncmFkZSB3aXRoIGxlc3MgcGFpbi5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBjYW4gYmUgcmVtb3ZlZCBhZnRlciBhIDIuMCByZWxlYXNlLlxuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9ucyBvYmplY3QgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciwgd2hpY2ggaW5jbHVkZXMgdGhlIGlkVG9rZW4sIGF1ZGllbmNlLCBhbmQgbWF4RXhwaXJ5LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy52ZXJpZnlJZFRva2VuQXN5bmMob3B0aW9ucykudGhlbihyID0+IGNhbGxiYWNrKG51bGwsIHIpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlJZFRva2VuQXN5bmMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5SWRUb2tlbkFzeW5jKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmlkVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZlcmlmeUlkVG9rZW4gbWV0aG9kIHJlcXVpcmVzIGFuIElEIFRva2VuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldEZlZGVyYXRlZFNpZ25vbkNlcnRzQXN5bmMoKTtcbiAgICAgICAgY29uc3QgbG9naW4gPSBhd2FpdCB0aGlzLnZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0c0FzeW5jKG9wdGlvbnMuaWRUb2tlbiwgcmVzcG9uc2UuY2VydHMsIG9wdGlvbnMuYXVkaWVuY2UsIHRoaXMuaXNzdWVycywgb3B0aW9ucy5tYXhFeHBpcnkpO1xuICAgICAgICByZXR1cm4gbG9naW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9idGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHByb3Zpc2lvbmVkIGFjY2VzcyB0b2tlbi4gIEVzcGVjaWFsbHkgdXNlZnVsXG4gICAgICogaWYgeW91IHdhbnQgdG8gY2hlY2sgdGhlIHNjb3BlcyB0aGF0IHdlcmUgcHJvdmlzaW9uZWQgdG8gYSBnaXZlbiB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiBSZXF1aXJlZC4gIFRoZSBBY2Nlc3MgVG9rZW4gZm9yIHdoaWNoIHlvdSB3YW50IHRvIGdldFxuICAgICAqIHVzZXIgaW5mby5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUb2tlbkluZm8oYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgLi4uT0F1dGgyQ2xpZW50LlJFVFJZX0NPTkZJRyxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cmw6IHRoaXMuZW5kcG9pbnRzLnRva2VuSW5mb1VybC50b1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW5mbyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgZXhwaXJ5X2RhdGU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgZGF0YS5leHBpcmVzX2luICogMTAwMCxcbiAgICAgICAgICAgIHNjb3BlczogZGF0YS5zY29wZS5zcGxpdCgnICcpLFxuICAgICAgICB9LCBkYXRhKTtcbiAgICAgICAgZGVsZXRlIGluZm8uZXhwaXJlc19pbjtcbiAgICAgICAgZGVsZXRlIGluZm8uc2NvcGU7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgICBnZXRGZWRlcmF0ZWRTaWdub25DZXJ0cyhjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0RmVkZXJhdGVkU2lnbm9uQ2VydHNBc3luYygpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByLmNlcnRzLCByLnJlcyksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZlZGVyYXRlZFNpZ25vbkNlcnRzQXN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRGZWRlcmF0ZWRTaWdub25DZXJ0c0FzeW5jKCkge1xuICAgICAgICBjb25zdCBub3dUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9ICgwLCBjcnlwdG9fMS5oYXNCcm93c2VyQ3J5cHRvKSgpXG4gICAgICAgICAgICA/IENlcnRpZmljYXRlRm9ybWF0LkpXS1xuICAgICAgICAgICAgOiBDZXJ0aWZpY2F0ZUZvcm1hdC5QRU07XG4gICAgICAgIGlmICh0aGlzLmNlcnRpZmljYXRlRXhwaXJ5ICYmXG4gICAgICAgICAgICBub3dUaW1lIDwgdGhpcy5jZXJ0aWZpY2F0ZUV4cGlyeS5nZXRUaW1lKCkgJiZcbiAgICAgICAgICAgIHRoaXMuY2VydGlmaWNhdGVDYWNoZUZvcm1hdCA9PT0gZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4geyBjZXJ0czogdGhpcy5jZXJ0aWZpY2F0ZUNhY2hlLCBmb3JtYXQgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSBDZXJ0aWZpY2F0ZUZvcm1hdC5QRU06XG4gICAgICAgICAgICAgICAgdXJsID0gdGhpcy5lbmRwb2ludHMub2F1dGgyRmVkZXJhdGVkU2lnbm9uUGVtQ2VydHNVcmwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ2VydGlmaWNhdGVGb3JtYXQuSldLOlxuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuZW5kcG9pbnRzLm9hdXRoMkZlZGVyYXRlZFNpZ25vbkp3a0NlcnRzVXJsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY2VydGlmaWNhdGUgZm9ybWF0ICR7Zm9ybWF0fWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIC4uLk9BdXRoMkNsaWVudC5SRVRSWV9DT05GSUcsXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBgRmFpbGVkIHRvIHJldHJpZXZlIHZlcmlmaWNhdGlvbiBjZXJ0aWZpY2F0ZXM6ICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlQ29udHJvbCA9IHJlcyA/IHJlcy5oZWFkZXJzWydjYWNoZS1jb250cm9sJ10gOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjYWNoZUFnZSA9IC0xO1xuICAgICAgICBpZiAoY2FjaGVDb250cm9sKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCgnbWF4LWFnZT0oWzAtOV0qKScpO1xuICAgICAgICAgICAgY29uc3QgcmVnZXhSZXN1bHQgPSBwYXR0ZXJuLmV4ZWMoY2FjaGVDb250cm9sKTtcbiAgICAgICAgICAgIGlmIChyZWdleFJlc3VsdCAmJiByZWdleFJlc3VsdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWNoZSByZXN1bHRzIHdpdGggbWF4LWFnZSAoaW4gc2Vjb25kcylcbiAgICAgICAgICAgICAgICBjYWNoZUFnZSA9IE51bWJlcihyZWdleFJlc3VsdFsxXSkgKiAxMDAwOyAvLyBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2VydGlmaWNhdGVzID0ge307XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIENlcnRpZmljYXRlRm9ybWF0LlBFTTpcbiAgICAgICAgICAgICAgICBjZXJ0aWZpY2F0ZXMgPSByZXMuZGF0YTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ2VydGlmaWNhdGVGb3JtYXQuSldLOlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJlcy5kYXRhLmtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VydGlmaWNhdGVzW2tleS5raWRdID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjZXJ0aWZpY2F0ZSBmb3JtYXQgJHtmb3JtYXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUV4cGlyeSA9XG4gICAgICAgICAgICBjYWNoZUFnZSA9PT0gLTEgPyBudWxsIDogbmV3IERhdGUobm93LmdldFRpbWUoKSArIGNhY2hlQWdlKTtcbiAgICAgICAgdGhpcy5jZXJ0aWZpY2F0ZUNhY2hlID0gY2VydGlmaWNhdGVzO1xuICAgICAgICB0aGlzLmNlcnRpZmljYXRlQ2FjaGVGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHJldHVybiB7IGNlcnRzOiBjZXJ0aWZpY2F0ZXMsIGZvcm1hdCwgcmVzIH07XG4gICAgfVxuICAgIGdldElhcFB1YmxpY0tleXMoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdldElhcFB1YmxpY0tleXNBc3luYygpLnRoZW4ociA9PiBjYWxsYmFjayhudWxsLCByLnB1YmtleXMsIHIucmVzKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWFwUHVibGljS2V5c0FzeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0SWFwUHVibGljS2V5c0FzeW5jKCkge1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmVuZHBvaW50cy5vYXV0aDJJYXBQdWJsaWNLZXlVcmwudG9TdHJpbmcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGF3YWl0IHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgLi4uT0F1dGgyQ2xpZW50LlJFVFJZX0NPTkZJRyxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGUubWVzc2FnZSA9IGBGYWlsZWQgdG8gcmV0cmlldmUgdmVyaWZpY2F0aW9uIGNlcnRpZmljYXRlczogJHtlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcHVia2V5czogcmVzLmRhdGEsIHJlcyB9O1xuICAgIH1cbiAgICB2ZXJpZnlTaWduZWRKd3RXaXRoQ2VydHMoKSB7XG4gICAgICAgIC8vIFRvIG1ha2UgdGhlIGNvZGUgY29tcGF0aWJsZSB3aXRoIGJyb3dzZXIgU3VidGxlQ3J5cHRvIHdlIG5lZWQgdG8gbWFrZVxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBhc3luYy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJpZnlTaWduZWRKd3RXaXRoQ2VydHMgaXMgcmVtb3ZlZCwgcGxlYXNlIHVzZSB2ZXJpZnlTaWduZWRKd3RXaXRoQ2VydHNBc3luYyBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgdGhlIGlkIHRva2VuIGlzIHNpZ25lZCB3aXRoIHRoZSBjb3JyZWN0IGNlcnRpZmljYXRlXG4gICAgICogYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgYXVkaWVuY2UuXG4gICAgICogQHBhcmFtIGp3dCBUaGUgand0IHRvIHZlcmlmeSAoVGhlIElEIFRva2VuIGluIHRoaXMgY2FzZSkuXG4gICAgICogQHBhcmFtIGNlcnRzIFRoZSBhcnJheSBvZiBjZXJ0cyB0byB0ZXN0IHRoZSBqd3QgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0gcmVxdWlyZWRBdWRpZW5jZSBUaGUgYXVkaWVuY2UgdG8gdGVzdCB0aGUgand0IGFnYWluc3QuXG4gICAgICogQHBhcmFtIGlzc3VlcnMgVGhlIGFsbG93ZWQgaXNzdWVycyBvZiB0aGUgand0IChPcHRpb25hbCkuXG4gICAgICogQHBhcmFtIG1heEV4cGlyeSBUaGUgbWF4IGV4cGlyeSB0aGUgY2VydGlmaWNhdGUgY2FuIGJlIChPcHRpb25hbCkuXG4gICAgICogQHJldHVybiBSZXR1cm5zIGEgcHJvbWlzZSByZXNvbHZpbmcgdG8gTG9naW5UaWNrZXQgb24gdmVyaWZpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0c0FzeW5jKGp3dCwgY2VydHMsIHJlcXVpcmVkQXVkaWVuY2UsIGlzc3VlcnMsIG1heEV4cGlyeSkge1xuICAgICAgICBjb25zdCBjcnlwdG8gPSAoMCwgY3J5cHRvXzEuY3JlYXRlQ3J5cHRvKSgpO1xuICAgICAgICBpZiAoIW1heEV4cGlyeSkge1xuICAgICAgICAgICAgbWF4RXhwaXJ5ID0gT0F1dGgyQ2xpZW50LkRFRkFVTFRfTUFYX1RPS0VOX0xJRkVUSU1FX1NFQ1NfO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gand0LnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRva2VuOiAnICsgand0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduZWQgPSBzZWdtZW50c1swXSArICcuJyArIHNlZ21lbnRzWzFdO1xuICAgICAgICBsZXQgc2lnbmF0dXJlID0gc2VnbWVudHNbMl07XG4gICAgICAgIGxldCBlbnZlbG9wZTtcbiAgICAgICAgbGV0IHBheWxvYWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBlbnZlbG9wZSA9IEpTT04ucGFyc2UoY3J5cHRvLmRlY29kZUJhc2U2NFN0cmluZ1V0Zjgoc2VnbWVudHNbMF0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBDYW4ndCBwYXJzZSB0b2tlbiBlbnZlbG9wZTogJHtzZWdtZW50c1swXX0nOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbnZlbG9wZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGFyc2UgdG9rZW4gZW52ZWxvcGU6IFwiICsgc2VnbWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjcnlwdG8uZGVjb2RlQmFzZTY0U3RyaW5nVXRmOChzZWdtZW50c1sxXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYENhbid0IHBhcnNlIHRva2VuIHBheWxvYWQgJyR7c2VnbWVudHNbMF19YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBheWxvYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBhcnNlIHRva2VuIHBheWxvYWQ6IFwiICsgc2VnbWVudHNbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNlcnRzLCBlbnZlbG9wZS5raWQpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBwcmVzZW50LCB0aGVuIHRoZXJlJ3Mgbm8gcmVhc29uIHRvIGF0dGVtcHQgdmVyaWZpY2F0aW9uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBlbSBmb3VuZCBmb3IgZW52ZWxvcGU6ICcgKyBKU09OLnN0cmluZ2lmeShlbnZlbG9wZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlcnQgPSBjZXJ0c1tlbnZlbG9wZS5raWRdO1xuICAgICAgICBpZiAoZW52ZWxvcGUuYWxnID09PSAnRVMyNTYnKSB7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBmb3JtYXRFY2RzYS5qb3NlVG9EZXIoc2lnbmF0dXJlLCAnRVMyNTYnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCBjcnlwdG8udmVyaWZ5KGNlcnQsIHNpZ25lZCwgc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKCF2ZXJpZmllZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRva2VuIHNpZ25hdHVyZTogJyArIGp3dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXlsb2FkLmlhdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpc3N1ZSB0aW1lIGluIHRva2VuOiAnICsgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF5bG9hZC5leHApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXhwaXJhdGlvbiB0aW1lIGluIHRva2VuOiAnICsgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlhdCA9IE51bWJlcihwYXlsb2FkLmlhdCk7XG4gICAgICAgIGlmIChpc05hTihpYXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpYXQgZmllbGQgdXNpbmcgaW52YWxpZCBmb3JtYXQnKTtcbiAgICAgICAgY29uc3QgZXhwID0gTnVtYmVyKHBheWxvYWQuZXhwKTtcbiAgICAgICAgaWYgKGlzTmFOKGV4cCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cCBmaWVsZCB1c2luZyBpbnZhbGlkIGZvcm1hdCcpO1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDA7XG4gICAgICAgIGlmIChleHAgPj0gbm93ICsgbWF4RXhwaXJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGlyYXRpb24gdGltZSB0b28gZmFyIGluIGZ1dHVyZTogJyArIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlYXJsaWVzdCA9IGlhdCAtIE9BdXRoMkNsaWVudC5DTE9DS19TS0VXX1NFQ1NfO1xuICAgICAgICBjb25zdCBsYXRlc3QgPSBleHAgKyBPQXV0aDJDbGllbnQuQ0xPQ0tfU0tFV19TRUNTXztcbiAgICAgICAgaWYgKG5vdyA8IGVhcmxpZXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIHVzZWQgdG9vIGVhcmx5LCAnICtcbiAgICAgICAgICAgICAgICBub3cgK1xuICAgICAgICAgICAgICAgICcgPCAnICtcbiAgICAgICAgICAgICAgICBlYXJsaWVzdCArXG4gICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3cgPiBsYXRlc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gdXNlZCB0b28gbGF0ZSwgJyArXG4gICAgICAgICAgICAgICAgbm93ICtcbiAgICAgICAgICAgICAgICAnID4gJyArXG4gICAgICAgICAgICAgICAgbGF0ZXN0ICtcbiAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzc3VlcnMgJiYgaXNzdWVycy5pbmRleE9mKHBheWxvYWQuaXNzKSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpc3N1ZXIsIGV4cGVjdGVkIG9uZSBvZiBbJyArXG4gICAgICAgICAgICAgICAgaXNzdWVycyArXG4gICAgICAgICAgICAgICAgJ10sIGJ1dCBnb3QgJyArXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoZSBhdWRpZW5jZSBtYXRjaGVzIGlmIHdlIGhhdmUgb25lXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWlyZWRBdWRpZW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVxdWlyZWRBdWRpZW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYXVkID0gcGF5bG9hZC5hdWQ7XG4gICAgICAgICAgICBsZXQgYXVkVmVyaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXF1aXJlZEF1ZGllbmNlIGlzIGFuIGFycmF5LCBjaGVjayBpZiBpdCBjb250YWlucyB0b2tlblxuICAgICAgICAgICAgLy8gYXVkaWVuY2VcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZEF1ZGllbmNlLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgIGF1ZFZlcmlmaWVkID0gcmVxdWlyZWRBdWRpZW5jZS5pbmRleE9mKGF1ZCkgPiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF1ZFZlcmlmaWVkID0gYXVkID09PSByZXF1aXJlZEF1ZGllbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdWRWZXJpZmllZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgcmVjaXBpZW50LCBwYXlsb2FkIGF1ZGllbmNlICE9IHJlcXVpcmVkQXVkaWVuY2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGxvZ2ludGlja2V0XzEuTG9naW5UaWNrZXQoZW52ZWxvcGUsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggQWNjZXNzVG9rZW5SZXNwb25zZSB0eXBlIGlmXG4gICAgICogcmVmcmVzaEhhbmRsZXIgaXMgZGVmaW5lZC5cbiAgICAgKiBJZiBub3QsIG5vdGhpbmcgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgYXN5bmMgcHJvY2Vzc0FuZFZhbGlkYXRlUmVmcmVzaEhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZWZyZXNoSGFuZGxlcigpO1xuICAgICAgICAgICAgaWYgKCFhY2Nlc3NUb2tlblJlc3BvbnNlLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYWNjZXNzIHRva2VuIGlzIHJldHVybmVkIGJ5IHRoZSByZWZyZXNoSGFuZGxlciBjYWxsYmFjay4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3NUb2tlblJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGEgdG9rZW4gaXMgZXhwaXJlZCBvciB3aWxsIGV4cGlyZSB3aXRoaW5cbiAgICAgKiBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXNtaWxsaXNlY29uZHMuXG4gICAgICogSWYgdGhlcmUgaXMgbm8gZXhwaXJ5IHRpbWUsIGFzc3VtZXMgdGhlIHRva2VuIGlzIG5vdCBleHBpcmVkIG9yIGV4cGlyaW5nLlxuICAgICAqL1xuICAgIGlzVG9rZW5FeHBpcmluZygpIHtcbiAgICAgICAgY29uc3QgZXhwaXJ5RGF0ZSA9IHRoaXMuY3JlZGVudGlhbHMuZXhwaXJ5X2RhdGU7XG4gICAgICAgIHJldHVybiBleHBpcnlEYXRlXG4gICAgICAgICAgICA/IGV4cGlyeURhdGUgPD0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLmVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpc1xuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk9BdXRoMkNsaWVudCA9IE9BdXRoMkNsaWVudDtcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGluc3RhbmNlJ3Mge0BsaW5rIE9BdXRoMkNsaWVudC5lbmRwb2ludHN9XG4gKi9cbk9BdXRoMkNsaWVudC5HT09HTEVfVE9LRU5fSU5GT19VUkwgPSAnaHR0cHM6Ly9vYXV0aDIuZ29vZ2xlYXBpcy5jb20vdG9rZW5pbmZvJztcbi8qKlxuICogQ2xvY2sgc2tldyAtIGZpdmUgbWludXRlcyBpbiBzZWNvbmRzXG4gKi9cbk9BdXRoMkNsaWVudC5DTE9DS19TS0VXX1NFQ1NfID0gMzAwO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBtYXggVG9rZW4gTGlmZXRpbWUgaXMgb25lIGRheSBpbiBzZWNvbmRzXG4gKi9cbk9BdXRoMkNsaWVudC5ERUZBVUxUX01BWF9UT0tFTl9MSUZFVElNRV9TRUNTXyA9IDg2NDAwO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiT0F1dGgyQ2xpZW50IiwiQ2xpZW50QXV0aGVudGljYXRpb24iLCJDZXJ0aWZpY2F0ZUZvcm1hdCIsIkNvZGVDaGFsbGVuZ2VNZXRob2QiLCJnYXhpb3NfMSIsInJlcXVpcmUiLCJxdWVyeXN0cmluZyIsInN0cmVhbSIsImZvcm1hdEVjZHNhIiwiY3J5cHRvXzEiLCJhdXRoY2xpZW50XzEiLCJsb2dpbnRpY2tldF8xIiwiQXV0aENsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9uc09yQ2xpZW50SWQiLCJjbGllbnRTZWNyZXQiLCJyZWRpcmVjdFVyaSIsIm9wdHMiLCJjbGllbnRJZCIsImNlcnRpZmljYXRlQ2FjaGUiLCJjZXJ0aWZpY2F0ZUV4cGlyeSIsImNlcnRpZmljYXRlQ2FjaGVGb3JtYXQiLCJQRU0iLCJyZWZyZXNoVG9rZW5Qcm9taXNlcyIsIk1hcCIsIl9jbGllbnRJZCIsIl9jbGllbnRTZWNyZXQiLCJlbmRwb2ludHMiLCJ0b2tlbkluZm9VcmwiLCJvYXV0aDJBdXRoQmFzZVVybCIsIm9hdXRoMlRva2VuVXJsIiwib2F1dGgyUmV2b2tlVXJsIiwib2F1dGgyRmVkZXJhdGVkU2lnbm9uUGVtQ2VydHNVcmwiLCJvYXV0aDJGZWRlcmF0ZWRTaWdub25Kd2tDZXJ0c1VybCIsIm9hdXRoMklhcFB1YmxpY0tleVVybCIsImNsaWVudEF1dGhlbnRpY2F0aW9uIiwiQ2xpZW50U2VjcmV0UG9zdCIsImlzc3VlcnMiLCJ1bml2ZXJzZURvbWFpbiIsImdlbmVyYXRlQXV0aFVybCIsImNvZGVfY2hhbGxlbmdlX21ldGhvZCIsImNvZGVfY2hhbGxlbmdlIiwiRXJyb3IiLCJyZXNwb25zZV90eXBlIiwiY2xpZW50X2lkIiwicmVkaXJlY3RfdXJpIiwiQXJyYXkiLCJpc0FycmF5Iiwic2NvcGUiLCJqb2luIiwicm9vdFVybCIsInRvU3RyaW5nIiwic3RyaW5naWZ5IiwiZ2VuZXJhdGVDb2RlVmVyaWZpZXIiLCJnZW5lcmF0ZUNvZGVWZXJpZmllckFzeW5jIiwiY3J5cHRvIiwiY3JlYXRlQ3J5cHRvIiwicmFuZG9tU3RyaW5nIiwicmFuZG9tQnl0ZXNCYXNlNjQiLCJjb2RlVmVyaWZpZXIiLCJyZXBsYWNlIiwidW5lbmNvZGVkQ29kZUNoYWxsZW5nZSIsInNoYTI1NkRpZ2VzdEJhc2U2NCIsImNvZGVDaGFsbGVuZ2UiLCJzcGxpdCIsImdldFRva2VuIiwiY29kZU9yT3B0aW9ucyIsImNhbGxiYWNrIiwib3B0aW9ucyIsImNvZGUiLCJnZXRUb2tlbkFzeW5jIiwidGhlbiIsInIiLCJ0b2tlbnMiLCJyZXMiLCJlIiwicmVzcG9uc2UiLCJ1cmwiLCJoZWFkZXJzIiwidmFsdWVzIiwiY29kZV92ZXJpZmllciIsImdyYW50X3R5cGUiLCJDbGllbnRTZWNyZXRCYXNpYyIsImJhc2ljIiwiQnVmZmVyIiwiZnJvbSIsImNsaWVudF9zZWNyZXQiLCJ0cmFuc3BvcnRlciIsInJlcXVlc3QiLCJSRVRSWV9DT05GSUciLCJtZXRob2QiLCJkYXRhIiwiZXhwaXJlc19pbiIsImV4cGlyeV9kYXRlIiwiRGF0ZSIsImdldFRpbWUiLCJlbWl0IiwicmVmcmVzaFRva2VuIiwicmVmcmVzaFRva2VuTm9DYWNoZSIsImhhcyIsImdldCIsInAiLCJkZWxldGUiLCJzZXQiLCJfYSIsInJlZnJlc2hfdG9rZW4iLCJHYXhpb3NFcnJvciIsIm1lc3NhZ2UiLCJ0ZXN0IiwiZXJyb3JfZGVzY3JpcHRpb24iLCJKU09OIiwicmVmcmVzaEFjY2Vzc1Rva2VuIiwicmVmcmVzaEFjY2Vzc1Rva2VuQXN5bmMiLCJjcmVkZW50aWFscyIsImdldEFjY2Vzc1Rva2VuIiwiZ2V0QWNjZXNzVG9rZW5Bc3luYyIsInRva2VuIiwic2hvdWxkUmVmcmVzaCIsImFjY2Vzc190b2tlbiIsImlzVG9rZW5FeHBpcmluZyIsInJlZnJlc2hIYW5kbGVyIiwicmVmcmVzaGVkQWNjZXNzVG9rZW4iLCJwcm9jZXNzQW5kVmFsaWRhdGVSZWZyZXNoSGFuZGxlciIsInNldENyZWRlbnRpYWxzIiwiZ2V0UmVxdWVzdEhlYWRlcnMiLCJnZXRSZXF1ZXN0TWV0YWRhdGFBc3luYyIsInRoaXNDcmVkcyIsImFwaUtleSIsInRva2VuX3R5cGUiLCJBdXRob3JpemF0aW9uIiwiYWRkU2hhcmVkTWV0YWRhdGFIZWFkZXJzIiwiZXJyIiwic3RhdHVzIiwiZ2V0UmV2b2tlVG9rZW5VcmwiLCJnZXRSZXZva2VUb2tlblVSTCIsIlVSTCIsInNlYXJjaFBhcmFtcyIsImFwcGVuZCIsInJldm9rZVRva2VuIiwicmV2b2tlQ3JlZGVudGlhbHMiLCJyZXZva2VDcmVkZW50aWFsc0FzeW5jIiwicmVxdWVzdEFzeW5jIiwicmVBdXRoUmV0cmllZCIsInIyIiwic3RhdHVzQ29kZSIsIm1heVJlcXVpcmVSZWZyZXNoIiwiZm9yY2VSZWZyZXNoT25GYWlsdXJlIiwibWF5UmVxdWlyZVJlZnJlc2hXaXRoTm9SZWZyZXNoVG9rZW4iLCJpc1JlYWRhYmxlU3RyZWFtIiwiY29uZmlnIiwiUmVhZGFibGUiLCJpc0F1dGhFcnIiLCJ2ZXJpZnlJZFRva2VuIiwidmVyaWZ5SWRUb2tlbkFzeW5jIiwiaWRUb2tlbiIsImdldEZlZGVyYXRlZFNpZ25vbkNlcnRzQXN5bmMiLCJsb2dpbiIsInZlcmlmeVNpZ25lZEp3dFdpdGhDZXJ0c0FzeW5jIiwiY2VydHMiLCJhdWRpZW5jZSIsIm1heEV4cGlyeSIsImdldFRva2VuSW5mbyIsImFjY2Vzc1Rva2VuIiwiaW5mbyIsImFzc2lnbiIsInNjb3BlcyIsImdldEZlZGVyYXRlZFNpZ25vbkNlcnRzIiwibm93VGltZSIsImZvcm1hdCIsImhhc0Jyb3dzZXJDcnlwdG8iLCJKV0siLCJjYWNoZUNvbnRyb2wiLCJ1bmRlZmluZWQiLCJjYWNoZUFnZSIsInBhdHRlcm4iLCJSZWdFeHAiLCJyZWdleFJlc3VsdCIsImV4ZWMiLCJsZW5ndGgiLCJOdW1iZXIiLCJjZXJ0aWZpY2F0ZXMiLCJrZXkiLCJrZXlzIiwia2lkIiwibm93IiwiZ2V0SWFwUHVibGljS2V5cyIsImdldElhcFB1YmxpY0tleXNBc3luYyIsInB1YmtleXMiLCJ2ZXJpZnlTaWduZWRKd3RXaXRoQ2VydHMiLCJqd3QiLCJyZXF1aXJlZEF1ZGllbmNlIiwiREVGQVVMVF9NQVhfVE9LRU5fTElGRVRJTUVfU0VDU18iLCJzZWdtZW50cyIsInNpZ25lZCIsInNpZ25hdHVyZSIsImVudmVsb3BlIiwicGF5bG9hZCIsInBhcnNlIiwiZGVjb2RlQmFzZTY0U3RyaW5nVXRmOCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImNlcnQiLCJhbGciLCJqb3NlVG9EZXIiLCJ2ZXJpZmllZCIsInZlcmlmeSIsImlhdCIsImV4cCIsImlzTmFOIiwiZWFybGllc3QiLCJDTE9DS19TS0VXX1NFQ1NfIiwibGF0ZXN0IiwiaW5kZXhPZiIsImlzcyIsImF1ZCIsImF1ZFZlcmlmaWVkIiwiTG9naW5UaWNrZXQiLCJhY2Nlc3NUb2tlblJlc3BvbnNlIiwiZXhwaXJ5RGF0ZSIsImVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyIsIkdPT0dMRV9UT0tFTl9JTkZPX1VSTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js":
/*!*************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/oauth2common.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OAuthClientAuthHandler = void 0;\nexports.getErrorFromOAuthErrorResponse = getErrorFromOAuthErrorResponse;\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst crypto_1 = __webpack_require__(/*! ../crypto/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\n/** List of HTTP methods that accept request bodies. */ const METHODS_SUPPORTING_REQUEST_BODY = [\n    \"PUT\",\n    \"POST\",\n    \"PATCH\"\n];\n/**\n * Abstract class for handling client authentication in OAuth-based\n * operations.\n * When request-body client authentication is used, only application/json and\n * application/x-www-form-urlencoded content types for HTTP methods that support\n * request bodies are supported.\n */ class OAuthClientAuthHandler {\n    /**\n     * Instantiates an OAuth client authentication handler.\n     * @param clientAuthentication The client auth credentials.\n     */ constructor(clientAuthentication){\n        this.clientAuthentication = clientAuthentication;\n        this.crypto = (0, crypto_1.createCrypto)();\n    }\n    /**\n     * Applies client authentication on the OAuth request's headers or POST\n     * body but does not process the request.\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     * @param bearerToken The optional bearer token to use for authentication.\n     *   When this is used, no client authentication credentials are needed.\n     */ applyClientAuthenticationOptions(opts, bearerToken) {\n        // Inject authenticated header.\n        this.injectAuthenticatedHeaders(opts, bearerToken);\n        // Inject authenticated request body.\n        if (!bearerToken) {\n            this.injectAuthenticatedRequestBody(opts);\n        }\n    }\n    /**\n     * Applies client authentication on the request's header if either\n     * basic authentication or bearer token authentication is selected.\n     *\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     * @param bearerToken The optional bearer token to use for authentication.\n     *   When this is used, no client authentication credentials are needed.\n     */ injectAuthenticatedHeaders(opts, bearerToken) {\n        var _a;\n        // Bearer token prioritized higher than basic Auth.\n        if (bearerToken) {\n            opts.headers = opts.headers || {};\n            Object.assign(opts.headers, {\n                Authorization: `Bearer ${bearerToken}}`\n            });\n        } else if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === \"basic\") {\n            opts.headers = opts.headers || {};\n            const clientId = this.clientAuthentication.clientId;\n            const clientSecret = this.clientAuthentication.clientSecret || \"\";\n            const base64EncodedCreds = this.crypto.encodeBase64StringUtf8(`${clientId}:${clientSecret}`);\n            Object.assign(opts.headers, {\n                Authorization: `Basic ${base64EncodedCreds}`\n            });\n        }\n    }\n    /**\n     * Applies client authentication on the request's body if request-body\n     * client authentication is selected.\n     *\n     * @param opts The GaxiosOptions whose headers or data are to be modified\n     *   depending on the client authentication mechanism to be used.\n     */ injectAuthenticatedRequestBody(opts) {\n        var _a;\n        if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === \"request-body\") {\n            const method = (opts.method || \"GET\").toUpperCase();\n            // Inject authenticated request body.\n            if (METHODS_SUPPORTING_REQUEST_BODY.indexOf(method) !== -1) {\n                // Get content-type.\n                let contentType;\n                const headers = opts.headers || {};\n                for(const key in headers){\n                    if (key.toLowerCase() === \"content-type\" && headers[key]) {\n                        contentType = headers[key].toLowerCase();\n                        break;\n                    }\n                }\n                if (contentType === \"application/x-www-form-urlencoded\") {\n                    opts.data = opts.data || \"\";\n                    const data = querystring.parse(opts.data);\n                    Object.assign(data, {\n                        client_id: this.clientAuthentication.clientId,\n                        client_secret: this.clientAuthentication.clientSecret || \"\"\n                    });\n                    opts.data = querystring.stringify(data);\n                } else if (contentType === \"application/json\") {\n                    opts.data = opts.data || {};\n                    Object.assign(opts.data, {\n                        client_id: this.clientAuthentication.clientId,\n                        client_secret: this.clientAuthentication.clientSecret || \"\"\n                    });\n                } else {\n                    throw new Error(`${contentType} content-types are not supported with ` + `${this.clientAuthentication.confidentialClientType} ` + \"client authentication\");\n                }\n            } else {\n                throw new Error(`${method} HTTP method does not support ` + `${this.clientAuthentication.confidentialClientType} ` + \"client authentication\");\n            }\n        }\n    }\n    /**\n     * Retry config for Auth-related requests.\n     *\n     * @remarks\n     *\n     * This is not a part of the default {@link AuthClient.transporter transporter/gaxios}\n     * config as some downstream APIs would prefer if customers explicitly enable retries,\n     * such as GCS.\n     */ static get RETRY_CONFIG() {\n        return {\n            retry: true,\n            retryConfig: {\n                httpMethodsToRetry: [\n                    \"GET\",\n                    \"PUT\",\n                    \"POST\",\n                    \"HEAD\",\n                    \"OPTIONS\",\n                    \"DELETE\"\n                ]\n            }\n        };\n    }\n}\nexports.OAuthClientAuthHandler = OAuthClientAuthHandler;\n/**\n * Converts an OAuth error response to a native JavaScript Error.\n * @param resp The OAuth error response to convert to a native Error object.\n * @param err The optional original error. If provided, the error properties\n *   will be copied to the new error.\n * @return The converted native Error object.\n */ function getErrorFromOAuthErrorResponse(resp, err) {\n    // Error response.\n    const errorCode = resp.error;\n    const errorDescription = resp.error_description;\n    const errorUri = resp.error_uri;\n    let message = `Error code ${errorCode}`;\n    if (typeof errorDescription !== \"undefined\") {\n        message += `: ${errorDescription}`;\n    }\n    if (typeof errorUri !== \"undefined\") {\n        message += ` - ${errorUri}`;\n    }\n    const newError = new Error(message);\n    // Copy properties from original error to newly generated error.\n    if (err) {\n        const keys = Object.keys(err);\n        if (err.stack) {\n            // Copy error.stack if available.\n            keys.push(\"stack\");\n        }\n        keys.forEach((key)=>{\n            // Do not overwrite the message field.\n            if (key !== \"message\") {\n                Object.defineProperty(newError, key, {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    value: err[key],\n                    writable: false,\n                    enumerable: true\n                });\n            }\n        });\n    }\n    return newError;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw4QkFBOEIsR0FBRyxLQUFLO0FBQ3RDQSxzQ0FBc0MsR0FBR0c7QUFDekMsTUFBTUMsY0FBY0MsbUJBQU9BLENBQUMsZ0NBQWE7QUFDekMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsNkZBQWtCO0FBQzNDLHFEQUFxRCxHQUNyRCxNQUFNRSxrQ0FBa0M7SUFBQztJQUFPO0lBQVE7Q0FBUTtBQUNoRTs7Ozs7O0NBTUMsR0FDRCxNQUFNTDtJQUNGOzs7S0FHQyxHQUNETSxZQUFZQyxvQkFBb0IsQ0FBRTtRQUM5QixJQUFJLENBQUNBLG9CQUFvQixHQUFHQTtRQUM1QixJQUFJLENBQUNDLE1BQU0sR0FBRyxDQUFDLEdBQUdKLFNBQVNLLFlBQVk7SUFDM0M7SUFDQTs7Ozs7OztLQU9DLEdBQ0RDLGlDQUFpQ0MsSUFBSSxFQUFFQyxXQUFXLEVBQUU7UUFDaEQsK0JBQStCO1FBQy9CLElBQUksQ0FBQ0MsMEJBQTBCLENBQUNGLE1BQU1DO1FBQ3RDLHFDQUFxQztRQUNyQyxJQUFJLENBQUNBLGFBQWE7WUFDZCxJQUFJLENBQUNFLDhCQUE4QixDQUFDSDtRQUN4QztJQUNKO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDREUsMkJBQTJCRixJQUFJLEVBQUVDLFdBQVcsRUFBRTtRQUMxQyxJQUFJRztRQUNKLG1EQUFtRDtRQUNuRCxJQUFJSCxhQUFhO1lBQ2JE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WTtnQkFDaEI7WUFDSjtRQUNKO0lBQ0o7SUFDQSxPQUFPTjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9vYXV0aDJjb21tb24uanM/MWYxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PQXV0aENsaWVudEF1dGhIYW5kbGVyID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UgPSBnZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2U7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0by9jcnlwdG9cIik7XG4vKiogTGlzdCBvZiBIVFRQIG1ldGhvZHMgdGhhdCBhY2NlcHQgcmVxdWVzdCBib2RpZXMuICovXG5jb25zdCBNRVRIT0RTX1NVUFBPUlRJTkdfUkVRVUVTVF9CT0RZID0gWydQVVQnLCAnUE9TVCcsICdQQVRDSCddO1xuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBmb3IgaGFuZGxpbmcgY2xpZW50IGF1dGhlbnRpY2F0aW9uIGluIE9BdXRoLWJhc2VkXG4gKiBvcGVyYXRpb25zLlxuICogV2hlbiByZXF1ZXN0LWJvZHkgY2xpZW50IGF1dGhlbnRpY2F0aW9uIGlzIHVzZWQsIG9ubHkgYXBwbGljYXRpb24vanNvbiBhbmRcbiAqIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBjb250ZW50IHR5cGVzIGZvciBIVFRQIG1ldGhvZHMgdGhhdCBzdXBwb3J0XG4gKiByZXF1ZXN0IGJvZGllcyBhcmUgc3VwcG9ydGVkLlxuICovXG5jbGFzcyBPQXV0aENsaWVudEF1dGhIYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gT0F1dGggY2xpZW50IGF1dGhlbnRpY2F0aW9uIGhhbmRsZXIuXG4gICAgICogQHBhcmFtIGNsaWVudEF1dGhlbnRpY2F0aW9uIFRoZSBjbGllbnQgYXV0aCBjcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uID0gY2xpZW50QXV0aGVudGljYXRpb247XG4gICAgICAgIHRoaXMuY3J5cHRvID0gKDAsIGNyeXB0b18xLmNyZWF0ZUNyeXB0bykoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBjbGllbnQgYXV0aGVudGljYXRpb24gb24gdGhlIE9BdXRoIHJlcXVlc3QncyBoZWFkZXJzIG9yIFBPU1RcbiAgICAgKiBib2R5IGJ1dCBkb2VzIG5vdCBwcm9jZXNzIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzIFRoZSBHYXhpb3NPcHRpb25zIHdob3NlIGhlYWRlcnMgb3IgZGF0YSBhcmUgdG8gYmUgbW9kaWZpZWRcbiAgICAgKiAgIGRlcGVuZGluZyBvbiB0aGUgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSB0byBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSBiZWFyZXJUb2tlbiBUaGUgb3B0aW9uYWwgYmVhcmVyIHRva2VuIHRvIHVzZSBmb3IgYXV0aGVudGljYXRpb24uXG4gICAgICogICBXaGVuIHRoaXMgaXMgdXNlZCwgbm8gY2xpZW50IGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGFyZSBuZWVkZWQuXG4gICAgICovXG4gICAgYXBwbHlDbGllbnRBdXRoZW50aWNhdGlvbk9wdGlvbnMob3B0cywgYmVhcmVyVG9rZW4pIHtcbiAgICAgICAgLy8gSW5qZWN0IGF1dGhlbnRpY2F0ZWQgaGVhZGVyLlxuICAgICAgICB0aGlzLmluamVjdEF1dGhlbnRpY2F0ZWRIZWFkZXJzKG9wdHMsIGJlYXJlclRva2VuKTtcbiAgICAgICAgLy8gSW5qZWN0IGF1dGhlbnRpY2F0ZWQgcmVxdWVzdCBib2R5LlxuICAgICAgICBpZiAoIWJlYXJlclRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmluamVjdEF1dGhlbnRpY2F0ZWRSZXF1ZXN0Qm9keShvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGNsaWVudCBhdXRoZW50aWNhdGlvbiBvbiB0aGUgcmVxdWVzdCdzIGhlYWRlciBpZiBlaXRoZXJcbiAgICAgKiBiYXNpYyBhdXRoZW50aWNhdGlvbiBvciBiZWFyZXIgdG9rZW4gYXV0aGVudGljYXRpb24gaXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgR2F4aW9zT3B0aW9ucyB3aG9zZSBoZWFkZXJzIG9yIGRhdGEgYXJlIHRvIGJlIG1vZGlmaWVkXG4gICAgICogICBkZXBlbmRpbmcgb24gdGhlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc20gdG8gYmUgdXNlZC5cbiAgICAgKiBAcGFyYW0gYmVhcmVyVG9rZW4gVGhlIG9wdGlvbmFsIGJlYXJlciB0b2tlbiB0byB1c2UgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqICAgV2hlbiB0aGlzIGlzIHVzZWQsIG5vIGNsaWVudCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBhcmUgbmVlZGVkLlxuICAgICAqL1xuICAgIGluamVjdEF1dGhlbnRpY2F0ZWRIZWFkZXJzKG9wdHMsIGJlYXJlclRva2VuKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gQmVhcmVyIHRva2VuIHByaW9yaXRpemVkIGhpZ2hlciB0aGFuIGJhc2ljIEF1dGguXG4gICAgICAgIGlmIChiZWFyZXJUb2tlbikge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YmVhcmVyVG9rZW59fWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9hID0gdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZGVudGlhbENsaWVudFR5cGUpID09PSAnYmFzaWMnKSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICBjb25zdCBjbGllbnRJZCA9IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50SWQ7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRTZWNyZXQgPSB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudFNlY3JldCB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NEVuY29kZWRDcmVkcyA9IHRoaXMuY3J5cHRvLmVuY29kZUJhc2U2NFN0cmluZ1V0ZjgoYCR7Y2xpZW50SWR9OiR7Y2xpZW50U2VjcmV0fWApO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmFzaWMgJHtiYXNlNjRFbmNvZGVkQ3JlZHN9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgY2xpZW50IGF1dGhlbnRpY2F0aW9uIG9uIHRoZSByZXF1ZXN0J3MgYm9keSBpZiByZXF1ZXN0LWJvZHlcbiAgICAgKiBjbGllbnQgYXV0aGVudGljYXRpb24gaXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgR2F4aW9zT3B0aW9ucyB3aG9zZSBoZWFkZXJzIG9yIGRhdGEgYXJlIHRvIGJlIG1vZGlmaWVkXG4gICAgICogICBkZXBlbmRpbmcgb24gdGhlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZWNoYW5pc20gdG8gYmUgdXNlZC5cbiAgICAgKi9cbiAgICBpbmplY3RBdXRoZW50aWNhdGVkUmVxdWVzdEJvZHkob3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZGVudGlhbENsaWVudFR5cGUpID09PSAncmVxdWVzdC1ib2R5Jykge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gKG9wdHMubWV0aG9kIHx8ICdHRVQnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgLy8gSW5qZWN0IGF1dGhlbnRpY2F0ZWQgcmVxdWVzdCBib2R5LlxuICAgICAgICAgICAgaWYgKE1FVEhPRFNfU1VQUE9SVElOR19SRVFVRVNUX0JPRFkuaW5kZXhPZihtZXRob2QpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIEdldCBjb250ZW50LXR5cGUuXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnICYmIGhlYWRlcnNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBoZWFkZXJzW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kYXRhID0gb3B0cy5kYXRhIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcXVlcnlzdHJpbmcucGFyc2Uob3B0cy5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudFNlY3JldCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuZGF0YSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmRhdGEgPSBvcHRzLmRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cy5kYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLmNsaWVudEF1dGhlbnRpY2F0aW9uLmNsaWVudFNlY3JldCB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGVudFR5cGV9IGNvbnRlbnQtdHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke3RoaXMuY2xpZW50QXV0aGVudGljYXRpb24uY29uZmlkZW50aWFsQ2xpZW50VHlwZX0gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xpZW50IGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21ldGhvZH0gSFRUUCBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5jbGllbnRBdXRoZW50aWNhdGlvbi5jb25maWRlbnRpYWxDbGllbnRUeXBlfSBgICtcbiAgICAgICAgICAgICAgICAgICAgJ2NsaWVudCBhdXRoZW50aWNhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJ5IGNvbmZpZyBmb3IgQXV0aC1yZWxhdGVkIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbm90IGEgcGFydCBvZiB0aGUgZGVmYXVsdCB7QGxpbmsgQXV0aENsaWVudC50cmFuc3BvcnRlciB0cmFuc3BvcnRlci9nYXhpb3N9XG4gICAgICogY29uZmlnIGFzIHNvbWUgZG93bnN0cmVhbSBBUElzIHdvdWxkIHByZWZlciBpZiBjdXN0b21lcnMgZXhwbGljaXRseSBlbmFibGUgcmV0cmllcyxcbiAgICAgKiBzdWNoIGFzIEdDUy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFJFVFJZX0NPTkZJRygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJldHJ5OiB0cnVlLFxuICAgICAgICAgICAgcmV0cnlDb25maWc6IHtcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kc1RvUmV0cnk6IFsnR0VUJywgJ1BVVCcsICdQT1NUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdERUxFVEUnXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5PQXV0aENsaWVudEF1dGhIYW5kbGVyID0gT0F1dGhDbGllbnRBdXRoSGFuZGxlcjtcbi8qKlxuICogQ29udmVydHMgYW4gT0F1dGggZXJyb3IgcmVzcG9uc2UgdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBFcnJvci5cbiAqIEBwYXJhbSByZXNwIFRoZSBPQXV0aCBlcnJvciByZXNwb25zZSB0byBjb252ZXJ0IHRvIGEgbmF0aXZlIEVycm9yIG9iamVjdC5cbiAqIEBwYXJhbSBlcnIgVGhlIG9wdGlvbmFsIG9yaWdpbmFsIGVycm9yLiBJZiBwcm92aWRlZCwgdGhlIGVycm9yIHByb3BlcnRpZXNcbiAqICAgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBlcnJvci5cbiAqIEByZXR1cm4gVGhlIGNvbnZlcnRlZCBuYXRpdmUgRXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UocmVzcCwgZXJyKSB7XG4gICAgLy8gRXJyb3IgcmVzcG9uc2UuXG4gICAgY29uc3QgZXJyb3JDb2RlID0gcmVzcC5lcnJvcjtcbiAgICBjb25zdCBlcnJvckRlc2NyaXB0aW9uID0gcmVzcC5lcnJvcl9kZXNjcmlwdGlvbjtcbiAgICBjb25zdCBlcnJvclVyaSA9IHJlc3AuZXJyb3JfdXJpO1xuICAgIGxldCBtZXNzYWdlID0gYEVycm9yIGNvZGUgJHtlcnJvckNvZGV9YDtcbiAgICBpZiAodHlwZW9mIGVycm9yRGVzY3JpcHRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYDogJHtlcnJvckRlc2NyaXB0aW9ufWA7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXJyb3JVcmkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYCAtICR7ZXJyb3JVcml9YDtcbiAgICB9XG4gICAgY29uc3QgbmV3RXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gb3JpZ2luYWwgZXJyb3IgdG8gbmV3bHkgZ2VuZXJhdGVkIGVycm9yLlxuICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGVycik7XG4gICAgICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgICAgICAgIC8vIENvcHkgZXJyb3Iuc3RhY2sgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAga2V5cy5wdXNoKCdzdGFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLy8gRG8gbm90IG92ZXJ3cml0ZSB0aGUgbWVzc2FnZSBmaWVsZC5cbiAgICAgICAgICAgIGlmIChrZXkgIT09ICdtZXNzYWdlJykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdFcnJvciwga2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlcnJba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0Vycm9yO1xufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiT0F1dGhDbGllbnRBdXRoSGFuZGxlciIsImdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSIsInF1ZXJ5c3RyaW5nIiwicmVxdWlyZSIsImNyeXB0b18xIiwiTUVUSE9EU19TVVBQT1JUSU5HX1JFUVVFU1RfQk9EWSIsImNvbnN0cnVjdG9yIiwiY2xpZW50QXV0aGVudGljYXRpb24iLCJjcnlwdG8iLCJjcmVhdGVDcnlwdG8iLCJhcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uT3B0aW9ucyIsIm9wdHMiLCJiZWFyZXJUb2tlbiIsImluamVjdEF1dGhlbnRpY2F0ZWRIZWFkZXJzIiwiaW5qZWN0QXV0aGVudGljYXRlZFJlcXVlc3RCb2R5IiwiX2EiLCJoZWFkZXJzIiwiYXNzaWduIiwiQXV0aG9yaXphdGlvbiIsImNvbmZpZGVudGlhbENsaWVudFR5cGUiLCJjbGllbnRJZCIsImNsaWVudFNlY3JldCIsImJhc2U2NEVuY29kZWRDcmVkcyIsImVuY29kZUJhc2U2NFN0cmluZ1V0ZjgiLCJtZXRob2QiLCJ0b1VwcGVyQ2FzZSIsImluZGV4T2YiLCJjb250ZW50VHlwZSIsImtleSIsInRvTG93ZXJDYXNlIiwiZGF0YSIsInBhcnNlIiwiY2xpZW50X2lkIiwiY2xpZW50X3NlY3JldCIsInN0cmluZ2lmeSIsIkVycm9yIiwiUkVUUllfQ09ORklHIiwicmV0cnkiLCJyZXRyeUNvbmZpZyIsImh0dHBNZXRob2RzVG9SZXRyeSIsInJlc3AiLCJlcnIiLCJlcnJvckNvZGUiLCJlcnJvciIsImVycm9yRGVzY3JpcHRpb24iLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yVXJpIiwiZXJyb3JfdXJpIiwibWVzc2FnZSIsIm5ld0Vycm9yIiwia2V5cyIsInN0YWNrIiwicHVzaCIsImZvckVhY2giLCJ3cml0YWJsZSIsImVudW1lcmFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/passthrough.js":
/*!************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/passthrough.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2024 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PassThroughClient = void 0;\nconst authclient_1 = __webpack_require__(/*! ./authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\n/**\n * An AuthClient without any Authentication information. Useful for:\n * - Anonymous access\n * - Local Emulators\n * - Testing Environments\n *\n */ class PassThroughClient extends authclient_1.AuthClient {\n    /**\n     * Creates a request without any authentication headers or checks.\n     *\n     * @remarks\n     *\n     * In testing environments it may be useful to change the provided\n     * {@link AuthClient.transporter} for any desired request overrides/handling.\n     *\n     * @param opts\n     * @returns The response of the request.\n     */ async request(opts) {\n        return this.transporter.request(opts);\n    }\n    /**\n     * A required method of the base class.\n     * Always will return an empty object.\n     *\n     * @returns {}\n     */ async getAccessToken() {\n        return {};\n    }\n    /**\n     * A required method of the base class.\n     * Always will return an empty object.\n     *\n     * @returns {}\n     */ async getRequestHeaders() {\n        return {};\n    }\n}\nexports.PassThroughClient = PassThroughClient;\nconst a = new PassThroughClient();\na.getAccessToken();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wYXNzdGhyb3VnaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHlCQUF5QixHQUFHLEtBQUs7QUFDakMsTUFBTUcsZUFBZUMsbUJBQU9BLENBQUMsMkZBQWM7QUFDM0M7Ozs7OztDQU1DLEdBQ0QsTUFBTUYsMEJBQTBCQyxhQUFhRSxVQUFVO0lBQ25EOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNQyxRQUFRQyxJQUFJLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0YsT0FBTyxDQUFDQztJQUNwQztJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTUUsaUJBQWlCO1FBQ25CLE9BQU8sQ0FBQztJQUNaO0lBQ0E7Ozs7O0tBS0MsR0FDRCxNQUFNQyxvQkFBb0I7UUFDdEIsT0FBTyxDQUFDO0lBQ1o7QUFDSjtBQUNBVix5QkFBeUIsR0FBR0U7QUFDNUIsTUFBTVMsSUFBSSxJQUFJVDtBQUNkUyxFQUFFRixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wYXNzdGhyb3VnaC5qcz8zMWE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjQgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhc3NUaHJvdWdoQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aGNsaWVudFwiKTtcbi8qKlxuICogQW4gQXV0aENsaWVudCB3aXRob3V0IGFueSBBdXRoZW50aWNhdGlvbiBpbmZvcm1hdGlvbi4gVXNlZnVsIGZvcjpcbiAqIC0gQW5vbnltb3VzIGFjY2Vzc1xuICogLSBMb2NhbCBFbXVsYXRvcnNcbiAqIC0gVGVzdGluZyBFbnZpcm9ubWVudHNcbiAqXG4gKi9cbmNsYXNzIFBhc3NUaHJvdWdoQ2xpZW50IGV4dGVuZHMgYXV0aGNsaWVudF8xLkF1dGhDbGllbnQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZXF1ZXN0IHdpdGhvdXQgYW55IGF1dGhlbnRpY2F0aW9uIGhlYWRlcnMgb3IgY2hlY2tzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIEluIHRlc3RpbmcgZW52aXJvbm1lbnRzIGl0IG1heSBiZSB1c2VmdWwgdG8gY2hhbmdlIHRoZSBwcm92aWRlZFxuICAgICAqIHtAbGluayBBdXRoQ2xpZW50LnRyYW5zcG9ydGVyfSBmb3IgYW55IGRlc2lyZWQgcmVxdWVzdCBvdmVycmlkZXMvaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0c1xuICAgICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBvZiB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyByZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0ZXIucmVxdWVzdChvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZXF1aXJlZCBtZXRob2Qgb2YgdGhlIGJhc2UgY2xhc3MuXG4gICAgICogQWx3YXlzIHdpbGwgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZXF1aXJlZCBtZXRob2Qgb2YgdGhlIGJhc2UgY2xhc3MuXG4gICAgICogQWx3YXlzIHdpbGwgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWVzdEhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59XG5leHBvcnRzLlBhc3NUaHJvdWdoQ2xpZW50ID0gUGFzc1Rocm91Z2hDbGllbnQ7XG5jb25zdCBhID0gbmV3IFBhc3NUaHJvdWdoQ2xpZW50KCk7XG5hLmdldEFjY2Vzc1Rva2VuKCk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQYXNzVGhyb3VnaENsaWVudCIsImF1dGhjbGllbnRfMSIsInJlcXVpcmUiLCJBdXRoQ2xpZW50IiwicmVxdWVzdCIsIm9wdHMiLCJ0cmFuc3BvcnRlciIsImdldEFjY2Vzc1Rva2VuIiwiZ2V0UmVxdWVzdEhlYWRlcnMiLCJhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/passthrough.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PluggableAuthClient = exports.ExecutableError = void 0;\nconst baseexternalclient_1 = __webpack_require__(/*! ./baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nconst executable_response_1 = __webpack_require__(/*! ./executable-response */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js\");\nconst pluggable_auth_handler_1 = __webpack_require__(/*! ./pluggable-auth-handler */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js\");\n/**\n * Error thrown from the executable run by PluggableAuthClient.\n */ class ExecutableError extends Error {\n    constructor(message, code){\n        super(`The executable failed with exit code: ${code} and error message: ${message}.`);\n        this.code = code;\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.ExecutableError = ExecutableError;\n/**\n * The default executable timeout when none is provided, in milliseconds.\n */ const DEFAULT_EXECUTABLE_TIMEOUT_MILLIS = 30 * 1000;\n/**\n * The minimum allowed executable timeout in milliseconds.\n */ const MINIMUM_EXECUTABLE_TIMEOUT_MILLIS = 5 * 1000;\n/**\n * The maximum allowed executable timeout in milliseconds.\n */ const MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS = 120 * 1000;\n/**\n * The environment variable to check to see if executable can be run.\n * Value must be set to '1' for the executable to run.\n */ const GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES = \"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\";\n/**\n * The maximum currently supported executable version.\n */ const MAXIMUM_EXECUTABLE_VERSION = 1;\n/**\n * PluggableAuthClient enables the exchange of workload identity pool external credentials for\n * Google access tokens by retrieving 3rd party tokens through a user supplied executable. These\n * scripts/executables are completely independent of the Google Cloud Auth libraries. These\n * credentials plug into ADC and will call the specified executable to retrieve the 3rd party token\n * to be exchanged for a Google access token.\n *\n * <p>To use these credentials, the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment variable\n * must be set to '1'. This is for security reasons.\n *\n * <p>Both OIDC and SAML are supported. The executable must adhere to a specific response format\n * defined below.\n *\n * <p>The executable must print out the 3rd party token to STDOUT in JSON format. When an\n * output_file is specified in the credential configuration, the executable must also handle writing the\n * JSON response to this file.\n *\n * <pre>\n * OIDC response sample:\n * {\n *   \"version\": 1,\n *   \"success\": true,\n *   \"token_type\": \"urn:ietf:params:oauth:token-type:id_token\",\n *   \"id_token\": \"HEADER.PAYLOAD.SIGNATURE\",\n *   \"expiration_time\": 1620433341\n * }\n *\n * SAML2 response sample:\n * {\n *   \"version\": 1,\n *   \"success\": true,\n *   \"token_type\": \"urn:ietf:params:oauth:token-type:saml2\",\n *   \"saml_response\": \"...\",\n *   \"expiration_time\": 1620433341\n * }\n *\n * Error response sample:\n * {\n *   \"version\": 1,\n *   \"success\": false,\n *   \"code\": \"401\",\n *   \"message\": \"Error message.\"\n * }\n * </pre>\n *\n * <p>The \"expiration_time\" field in the JSON response is only required for successful\n * responses when an output file was specified in the credential configuration\n *\n * <p>The auth libraries will populate certain environment variables that will be accessible by the\n * executable, such as: GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE, GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE,\n * GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE, GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL, and\n * GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE.\n *\n * <p>Please see this repositories README for a complete executable request/response specification.\n */ class PluggableAuthClient extends baseexternalclient_1.BaseExternalAccountClient {\n    /**\n     * Instantiates a PluggableAuthClient instance using the provided JSON\n     * object loaded from an external account credentials file.\n     * An error is thrown if the credential is not a valid pluggable auth credential.\n     * @param options The external account options object typically loaded from\n     *   the external account JSON credential file.\n     * @param additionalOptions **DEPRECATED, all options are available in the\n     *   `options` parameter.** Optional additional behavior customization options.\n     *   These currently customize expiration threshold time and whether to retry\n     *   on 401/403 API request errors.\n     */ constructor(options, additionalOptions){\n        super(options, additionalOptions);\n        if (!options.credential_source.executable) {\n            throw new Error('No valid Pluggable Auth \"credential_source\" provided.');\n        }\n        this.command = options.credential_source.executable.command;\n        if (!this.command) {\n            throw new Error('No valid Pluggable Auth \"credential_source\" provided.');\n        }\n        // Check if the provided timeout exists and if it is valid.\n        if (options.credential_source.executable.timeout_millis === undefined) {\n            this.timeoutMillis = DEFAULT_EXECUTABLE_TIMEOUT_MILLIS;\n        } else {\n            this.timeoutMillis = options.credential_source.executable.timeout_millis;\n            if (this.timeoutMillis < MINIMUM_EXECUTABLE_TIMEOUT_MILLIS || this.timeoutMillis > MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS) {\n                throw new Error(`Timeout must be between ${MINIMUM_EXECUTABLE_TIMEOUT_MILLIS} and ` + `${MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS} milliseconds.`);\n            }\n        }\n        this.outputFile = options.credential_source.executable.output_file;\n        this.handler = new pluggable_auth_handler_1.PluggableAuthHandler({\n            command: this.command,\n            timeoutMillis: this.timeoutMillis,\n            outputFile: this.outputFile\n        });\n        this.credentialSourceType = \"executable\";\n    }\n    /**\n     * Triggered when an external subject token is needed to be exchanged for a\n     * GCP access token via GCP STS endpoint.\n     * This uses the `options.credential_source` object to figure out how\n     * to retrieve the token using the current environment. In this case,\n     * this calls a user provided executable which returns the subject token.\n     * The logic is summarized as:\n     * 1. Validated that the executable is allowed to run. The\n     *    GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment must be set to\n     *    1 for security reasons.\n     * 2. If an output file is specified by the user, check the file location\n     *    for a response. If the file exists and contains a valid response,\n     *    return the subject token from the file.\n     * 3. Call the provided executable and return response.\n     * @return A promise that resolves with the external subject token.\n     */ async retrieveSubjectToken() {\n        // Check if the executable is allowed to run.\n        if (process.env[GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES] !== \"1\") {\n            throw new Error(\"Pluggable Auth executables need to be explicitly allowed to run by \" + \"setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment \" + \"Variable to 1.\");\n        }\n        let executableResponse = undefined;\n        // Try to get cached executable response from output file.\n        if (this.outputFile) {\n            executableResponse = await this.handler.retrieveCachedResponse();\n        }\n        // If no response from output file, call the executable.\n        if (!executableResponse) {\n            // Set up environment map with required values for the executable.\n            const envMap = new Map();\n            envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE\", this.audience);\n            envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE\", this.subjectTokenType);\n            // Always set to 0 because interactive mode is not supported.\n            envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE\", \"0\");\n            if (this.outputFile) {\n                envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE\", this.outputFile);\n            }\n            const serviceAccountEmail = this.getServiceAccountEmail();\n            if (serviceAccountEmail) {\n                envMap.set(\"GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL\", serviceAccountEmail);\n            }\n            executableResponse = await this.handler.retrieveResponseFromExecutable(envMap);\n        }\n        if (executableResponse.version > MAXIMUM_EXECUTABLE_VERSION) {\n            throw new Error(`Version of executable is not currently supported, maximum supported version is ${MAXIMUM_EXECUTABLE_VERSION}.`);\n        }\n        // Check that response was successful.\n        if (!executableResponse.success) {\n            throw new ExecutableError(executableResponse.errorMessage, executableResponse.errorCode);\n        }\n        // Check that response contains expiration time if output file was specified.\n        if (this.outputFile) {\n            if (!executableResponse.expirationTime) {\n                throw new executable_response_1.InvalidExpirationTimeFieldError(\"The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.\");\n            }\n        }\n        // Check that response is not expired.\n        if (executableResponse.isExpired()) {\n            throw new Error(\"Executable response is expired.\");\n        }\n        // Return subject token from response.\n        return executableResponse.subjectToken;\n    }\n}\nexports.PluggableAuthClient = PluggableAuthClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLGtFQUFrRTtBQUNsRSxtRUFBbUU7QUFDbkUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLHNFQUFzRTtBQUN0RSxvRUFBb0U7QUFDcEUsMkVBQTJFO0FBQzNFLHNFQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakNBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUM3RCxNQUFNSSx1QkFBdUJDLG1CQUFPQSxDQUFDLDJHQUFzQjtBQUMzRCxNQUFNQyx3QkFBd0JELG1CQUFPQSxDQUFDLDZHQUF1QjtBQUM3RCxNQUFNRSwyQkFBMkJGLG1CQUFPQSxDQUFDLG1IQUEwQjtBQUNuRTs7Q0FFQyxHQUNELE1BQU1GLHdCQUF3Qks7SUFDMUJDLFlBQVlDLE9BQU8sRUFBRUMsSUFBSSxDQUFFO1FBQ3ZCLEtBQUssQ0FBQyxDQUFDLHNDQUFzQyxFQUFFQSxLQUFLLG9CQUFvQixFQUFFRCxRQUFRLENBQUMsQ0FBQztRQUNwRixJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWmIsT0FBT2MsY0FBYyxDQUFDLElBQUksRUFBRSxXQUFXQyxTQUFTO0lBQ3BEO0FBQ0o7QUFDQWIsdUJBQXVCLEdBQUdHO0FBQzFCOztDQUVDLEdBQ0QsTUFBTVcsb0NBQW9DLEtBQUs7QUFDL0M7O0NBRUMsR0FDRCxNQUFNQyxvQ0FBb0MsSUFBSTtBQUM5Qzs7Q0FFQyxHQUNELE1BQU1DLG9DQUFvQyxNQUFNO0FBQ2hEOzs7Q0FHQyxHQUNELE1BQU1DLDRDQUE0QztBQUNsRDs7Q0FFQyxHQUNELE1BQU1DLDZCQUE2QjtBQUNuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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SUFBSTVDLGdCQUFnQmlDLG1CQUFtQlksWUFBWSxFQUFFWixtQkFBbUJhLFNBQVM7UUFDM0Y7UUFDQSw2RUFBNkU7UUFDN0UsSUFBSSxJQUFJLENBQUNyQixVQUFVLEVBQUU7WUFDakIsSUFBSSxDQUFDUSxtQkFBbUJjLGNBQWMsRUFBRTtnQkFDcEMsTUFBTSxJQUFJNUMsc0JBQXNCNkMsK0JBQStCLENBQUM7WUFDcEU7UUFDSjtRQUNBLHNDQUFzQztRQUN0QyxJQUFJZixtQkFBbUJnQixTQUFTLElBQUk7WUFDaEMsTUFBTSxJQUFJNUMsTUFBTTtRQUNwQjtRQUNBLHNDQUFzQztRQUN0QyxPQUFPNEIsbUJBQW1CaUIsWUFBWTtJQUMxQztBQUNKO0FBQ0FyRCwyQkFBMkIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWNvbW1lbnRlci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9hdXRoL3BsdWdnYWJsZS1hdXRoLWNsaWVudC5qcz9jMThlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBsdWdnYWJsZUF1dGhDbGllbnQgPSBleHBvcnRzLkV4ZWN1dGFibGVFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGJhc2VleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYmFzZWV4dGVybmFsY2xpZW50XCIpO1xuY29uc3QgZXhlY3V0YWJsZV9yZXNwb25zZV8xID0gcmVxdWlyZShcIi4vZXhlY3V0YWJsZS1yZXNwb25zZVwiKTtcbmNvbnN0IHBsdWdnYWJsZV9hdXRoX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL3BsdWdnYWJsZS1hdXRoLWhhbmRsZXJcIik7XG4vKipcbiAqIEVycm9yIHRocm93biBmcm9tIHRoZSBleGVjdXRhYmxlIHJ1biBieSBQbHVnZ2FibGVBdXRoQ2xpZW50LlxuICovXG5jbGFzcyBFeGVjdXRhYmxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICBzdXBlcihgVGhlIGV4ZWN1dGFibGUgZmFpbGVkIHdpdGggZXhpdCBjb2RlOiAke2NvZGV9IGFuZCBlcnJvciBtZXNzYWdlOiAke21lc3NhZ2V9LmApO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhlY3V0YWJsZUVycm9yID0gRXhlY3V0YWJsZUVycm9yO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBleGVjdXRhYmxlIHRpbWVvdXQgd2hlbiBub25lIGlzIHByb3ZpZGVkLCBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbmNvbnN0IERFRkFVTFRfRVhFQ1VUQUJMRV9USU1FT1VUX01JTExJUyA9IDMwICogMTAwMDtcbi8qKlxuICogVGhlIG1pbmltdW0gYWxsb3dlZCBleGVjdXRhYmxlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5jb25zdCBNSU5JTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMgPSA1ICogMTAwMDtcbi8qKlxuICogVGhlIG1heGltdW0gYWxsb3dlZCBleGVjdXRhYmxlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5jb25zdCBNQVhJTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMgPSAxMjAgKiAxMDAwO1xuLyoqXG4gKiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGUgdG8gY2hlY2sgdG8gc2VlIGlmIGV4ZWN1dGFibGUgY2FuIGJlIHJ1bi5cbiAqIFZhbHVlIG11c3QgYmUgc2V0IHRvICcxJyBmb3IgdGhlIGV4ZWN1dGFibGUgdG8gcnVuLlxuICovXG5jb25zdCBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyA9ICdHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyc7XG4vKipcbiAqIFRoZSBtYXhpbXVtIGN1cnJlbnRseSBzdXBwb3J0ZWQgZXhlY3V0YWJsZSB2ZXJzaW9uLlxuICovXG5jb25zdCBNQVhJTVVNX0VYRUNVVEFCTEVfVkVSU0lPTiA9IDE7XG4vKipcbiAqIFBsdWdnYWJsZUF1dGhDbGllbnQgZW5hYmxlcyB0aGUgZXhjaGFuZ2Ugb2Ygd29ya2xvYWQgaWRlbnRpdHkgcG9vbCBleHRlcm5hbCBjcmVkZW50aWFscyBmb3JcbiAqIEdvb2dsZSBhY2Nlc3MgdG9rZW5zIGJ5IHJldHJpZXZpbmcgM3JkIHBhcnR5IHRva2VucyB0aHJvdWdoIGEgdXNlciBzdXBwbGllZCBleGVjdXRhYmxlLiBUaGVzZVxuICogc2NyaXB0cy9leGVjdXRhYmxlcyBhcmUgY29tcGxldGVseSBpbmRlcGVuZGVudCBvZiB0aGUgR29vZ2xlIENsb3VkIEF1dGggbGlicmFyaWVzLiBUaGVzZVxuICogY3JlZGVudGlhbHMgcGx1ZyBpbnRvIEFEQyBhbmQgd2lsbCBjYWxsIHRoZSBzcGVjaWZpZWQgZXhlY3V0YWJsZSB0byByZXRyaWV2ZSB0aGUgM3JkIHBhcnR5IHRva2VuXG4gKiB0byBiZSBleGNoYW5nZWQgZm9yIGEgR29vZ2xlIGFjY2VzcyB0b2tlbi5cbiAqXG4gKiA8cD5UbyB1c2UgdGhlc2UgY3JlZGVudGlhbHMsIHRoZSBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogbXVzdCBiZSBzZXQgdG8gJzEnLiBUaGlzIGlzIGZvciBzZWN1cml0eSByZWFzb25zLlxuICpcbiAqIDxwPkJvdGggT0lEQyBhbmQgU0FNTCBhcmUgc3VwcG9ydGVkLiBUaGUgZXhlY3V0YWJsZSBtdXN0IGFkaGVyZSB0byBhIHNwZWNpZmljIHJlc3BvbnNlIGZvcm1hdFxuICogZGVmaW5lZCBiZWxvdy5cbiAqXG4gKiA8cD5UaGUgZXhlY3V0YWJsZSBtdXN0IHByaW50IG91dCB0aGUgM3JkIHBhcnR5IHRva2VuIHRvIFNURE9VVCBpbiBKU09OIGZvcm1hdC4gV2hlbiBhblxuICogb3V0cHV0X2ZpbGUgaXMgc3BlY2lmaWVkIGluIHRoZSBjcmVkZW50aWFsIGNvbmZpZ3VyYXRpb24sIHRoZSBleGVjdXRhYmxlIG11c3QgYWxzbyBoYW5kbGUgd3JpdGluZyB0aGVcbiAqIEpTT04gcmVzcG9uc2UgdG8gdGhpcyBmaWxlLlxuICpcbiAqIDxwcmU+XG4gKiBPSURDIHJlc3BvbnNlIHNhbXBsZTpcbiAqIHtcbiAqICAgXCJ2ZXJzaW9uXCI6IDEsXG4gKiAgIFwic3VjY2Vzc1wiOiB0cnVlLFxuICogICBcInRva2VuX3R5cGVcIjogXCJ1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTppZF90b2tlblwiLFxuICogICBcImlkX3Rva2VuXCI6IFwiSEVBREVSLlBBWUxPQUQuU0lHTkFUVVJFXCIsXG4gKiAgIFwiZXhwaXJhdGlvbl90aW1lXCI6IDE2MjA0MzMzNDFcbiAqIH1cbiAqXG4gKiBTQU1MMiByZXNwb25zZSBzYW1wbGU6XG4gKiB7XG4gKiAgIFwidmVyc2lvblwiOiAxLFxuICogICBcInN1Y2Nlc3NcIjogdHJ1ZSxcbiAqICAgXCJ0b2tlbl90eXBlXCI6IFwidXJuOmlldGY6cGFyYW1zOm9hdXRoOnRva2VuLXR5cGU6c2FtbDJcIixcbiAqICAgXCJzYW1sX3Jlc3BvbnNlXCI6IFwiLi4uXCIsXG4gKiAgIFwiZXhwaXJhdGlvbl90aW1lXCI6IDE2MjA0MzMzNDFcbiAqIH1cbiAqXG4gKiBFcnJvciByZXNwb25zZSBzYW1wbGU6XG4gKiB7XG4gKiAgIFwidmVyc2lvblwiOiAxLFxuICogICBcInN1Y2Nlc3NcIjogZmFsc2UsXG4gKiAgIFwiY29kZVwiOiBcIjQwMVwiLFxuICogICBcIm1lc3NhZ2VcIjogXCJFcnJvciBtZXNzYWdlLlwiXG4gKiB9XG4gKiA8L3ByZT5cbiAqXG4gKiA8cD5UaGUgXCJleHBpcmF0aW9uX3RpbWVcIiBmaWVsZCBpbiB0aGUgSlNPTiByZXNwb25zZSBpcyBvbmx5IHJlcXVpcmVkIGZvciBzdWNjZXNzZnVsXG4gKiByZXNwb25zZXMgd2hlbiBhbiBvdXRwdXQgZmlsZSB3YXMgc3BlY2lmaWVkIGluIHRoZSBjcmVkZW50aWFsIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiA8cD5UaGUgYXV0aCBsaWJyYXJpZXMgd2lsbCBwb3B1bGF0ZSBjZXJ0YWluIGVudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IHdpbGwgYmUgYWNjZXNzaWJsZSBieSB0aGVcbiAqIGV4ZWN1dGFibGUsIHN1Y2ggYXM6IEdPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0FVRElFTkNFLCBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9UT0tFTl9UWVBFLFxuICogR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfSU5URVJBQ1RJVkUsIEdPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0lNUEVSU09OQVRFRF9FTUFJTCwgYW5kXG4gKiBHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9PVVRQVVRfRklMRS5cbiAqXG4gKiA8cD5QbGVhc2Ugc2VlIHRoaXMgcmVwb3NpdG9yaWVzIFJFQURNRSBmb3IgYSBjb21wbGV0ZSBleGVjdXRhYmxlIHJlcXVlc3QvcmVzcG9uc2Ugc3BlY2lmaWNhdGlvbi5cbiAqL1xuY2xhc3MgUGx1Z2dhYmxlQXV0aENsaWVudCBleHRlbmRzIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIFBsdWdnYWJsZUF1dGhDbGllbnQgaW5zdGFuY2UgdXNpbmcgdGhlIHByb3ZpZGVkIEpTT05cbiAgICAgKiBvYmplY3QgbG9hZGVkIGZyb20gYW4gZXh0ZXJuYWwgYWNjb3VudCBjcmVkZW50aWFscyBmaWxlLlxuICAgICAqIEFuIGVycm9yIGlzIHRocm93biBpZiB0aGUgY3JlZGVudGlhbCBpcyBub3QgYSB2YWxpZCBwbHVnZ2FibGUgYXV0aCBjcmVkZW50aWFsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBleHRlcm5hbCBhY2NvdW50IG9wdGlvbnMgb2JqZWN0IHR5cGljYWxseSBsb2FkZWQgZnJvbVxuICAgICAqICAgdGhlIGV4dGVybmFsIGFjY291bnQgSlNPTiBjcmVkZW50aWFsIGZpbGUuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxPcHRpb25zICoqREVQUkVDQVRFRCwgYWxsIG9wdGlvbnMgYXJlIGF2YWlsYWJsZSBpbiB0aGVcbiAgICAgKiAgIGBvcHRpb25zYCBwYXJhbWV0ZXIuKiogT3B0aW9uYWwgYWRkaXRpb25hbCBiZWhhdmlvciBjdXN0b21pemF0aW9uIG9wdGlvbnMuXG4gICAgICogICBUaGVzZSBjdXJyZW50bHkgY3VzdG9taXplIGV4cGlyYXRpb24gdGhyZXNob2xkIHRpbWUgYW5kIHdoZXRoZXIgdG8gcmV0cnlcbiAgICAgKiAgIG9uIDQwMS80MDMgQVBJIHJlcXVlc3QgZXJyb3JzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIGFkZGl0aW9uYWxPcHRpb25zKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmV4ZWN1dGFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgUGx1Z2dhYmxlIEF1dGggXCJjcmVkZW50aWFsX3NvdXJjZVwiIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tbWFuZCA9IG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZXhlY3V0YWJsZS5jb21tYW5kO1xuICAgICAgICBpZiAoIXRoaXMuY29tbWFuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBQbHVnZ2FibGUgQXV0aCBcImNyZWRlbnRpYWxfc291cmNlXCIgcHJvdmlkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByb3ZpZGVkIHRpbWVvdXQgZXhpc3RzIGFuZCBpZiBpdCBpcyB2YWxpZC5cbiAgICAgICAgaWYgKG9wdGlvbnMuY3JlZGVudGlhbF9zb3VyY2UuZXhlY3V0YWJsZS50aW1lb3V0X21pbGxpcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRNaWxsaXMgPSBERUZBVUxUX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRNaWxsaXMgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmV4ZWN1dGFibGUudGltZW91dF9taWxsaXM7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lb3V0TWlsbGlzIDwgTUlOSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTIHx8XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0TWlsbGlzID4gTUFYSU1VTV9FWEVDVVRBQkxFX1RJTUVPVVRfTUlMTElTKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaW1lb3V0IG11c3QgYmUgYmV0d2VlbiAke01JTklNVU1fRVhFQ1VUQUJMRV9USU1FT1VUX01JTExJU30gYW5kIGAgK1xuICAgICAgICAgICAgICAgICAgICBgJHtNQVhJTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVN9IG1pbGxpc2Vjb25kcy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dEZpbGUgPSBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlLmV4ZWN1dGFibGUub3V0cHV0X2ZpbGU7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG5ldyBwbHVnZ2FibGVfYXV0aF9oYW5kbGVyXzEuUGx1Z2dhYmxlQXV0aEhhbmRsZXIoe1xuICAgICAgICAgICAgY29tbWFuZDogdGhpcy5jb21tYW5kLFxuICAgICAgICAgICAgdGltZW91dE1pbGxpczogdGhpcy50aW1lb3V0TWlsbGlzLFxuICAgICAgICAgICAgb3V0cHV0RmlsZTogdGhpcy5vdXRwdXRGaWxlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFsU291cmNlVHlwZSA9ICdleGVjdXRhYmxlJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYW4gZXh0ZXJuYWwgc3ViamVjdCB0b2tlbiBpcyBuZWVkZWQgdG8gYmUgZXhjaGFuZ2VkIGZvciBhXG4gICAgICogR0NQIGFjY2VzcyB0b2tlbiB2aWEgR0NQIFNUUyBlbmRwb2ludC5cbiAgICAgKiBUaGlzIHVzZXMgdGhlIGBvcHRpb25zLmNyZWRlbnRpYWxfc291cmNlYCBvYmplY3QgdG8gZmlndXJlIG91dCBob3dcbiAgICAgKiB0byByZXRyaWV2ZSB0aGUgdG9rZW4gdXNpbmcgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEluIHRoaXMgY2FzZSxcbiAgICAgKiB0aGlzIGNhbGxzIGEgdXNlciBwcm92aWRlZCBleGVjdXRhYmxlIHdoaWNoIHJldHVybnMgdGhlIHN1YmplY3QgdG9rZW4uXG4gICAgICogVGhlIGxvZ2ljIGlzIHN1bW1hcml6ZWQgYXM6XG4gICAgICogMS4gVmFsaWRhdGVkIHRoYXQgdGhlIGV4ZWN1dGFibGUgaXMgYWxsb3dlZCB0byBydW4uIFRoZVxuICAgICAqICAgIEdPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0FMTE9XX0VYRUNVVEFCTEVTIGVudmlyb25tZW50IG11c3QgYmUgc2V0IHRvXG4gICAgICogICAgMSBmb3Igc2VjdXJpdHkgcmVhc29ucy5cbiAgICAgKiAyLiBJZiBhbiBvdXRwdXQgZmlsZSBpcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXIsIGNoZWNrIHRoZSBmaWxlIGxvY2F0aW9uXG4gICAgICogICAgZm9yIGEgcmVzcG9uc2UuIElmIHRoZSBmaWxlIGV4aXN0cyBhbmQgY29udGFpbnMgYSB2YWxpZCByZXNwb25zZSxcbiAgICAgKiAgICByZXR1cm4gdGhlIHN1YmplY3QgdG9rZW4gZnJvbSB0aGUgZmlsZS5cbiAgICAgKiAzLiBDYWxsIHRoZSBwcm92aWRlZCBleGVjdXRhYmxlIGFuZCByZXR1cm4gcmVzcG9uc2UuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBleHRlcm5hbCBzdWJqZWN0IHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIHJldHJpZXZlU3ViamVjdFRva2VuKCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXhlY3V0YWJsZSBpcyBhbGxvd2VkIHRvIHJ1bi5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52W0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0FMTE9XX0VYRUNVVEFCTEVTXSAhPT0gJzEnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsdWdnYWJsZSBBdXRoIGV4ZWN1dGFibGVzIG5lZWQgdG8gYmUgZXhwbGljaXRseSBhbGxvd2VkIHRvIHJ1biBieSAnICtcbiAgICAgICAgICAgICAgICAnc2V0dGluZyB0aGUgR09PR0xFX0VYVEVSTkFMX0FDQ09VTlRfQUxMT1dfRVhFQ1VUQUJMRVMgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICAgICAgICAgJ1ZhcmlhYmxlIHRvIDEuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV4ZWN1dGFibGVSZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBjYWNoZWQgZXhlY3V0YWJsZSByZXNwb25zZSBmcm9tIG91dHB1dCBmaWxlLlxuICAgICAgICBpZiAodGhpcy5vdXRwdXRGaWxlKSB7XG4gICAgICAgICAgICBleGVjdXRhYmxlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmhhbmRsZXIucmV0cmlldmVDYWNoZWRSZXNwb25zZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHJlc3BvbnNlIGZyb20gb3V0cHV0IGZpbGUsIGNhbGwgdGhlIGV4ZWN1dGFibGUuXG4gICAgICAgIGlmICghZXhlY3V0YWJsZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBTZXQgdXAgZW52aXJvbm1lbnQgbWFwIHdpdGggcmVxdWlyZWQgdmFsdWVzIGZvciB0aGUgZXhlY3V0YWJsZS5cbiAgICAgICAgICAgIGNvbnN0IGVudk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGVudk1hcC5zZXQoJ0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0FVRElFTkNFJywgdGhpcy5hdWRpZW5jZSk7XG4gICAgICAgICAgICBlbnZNYXAuc2V0KCdHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9UT0tFTl9UWVBFJywgdGhpcy5zdWJqZWN0VG9rZW5UeXBlKTtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBzZXQgdG8gMCBiZWNhdXNlIGludGVyYWN0aXZlIG1vZGUgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgICAgIGVudk1hcC5zZXQoJ0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0lOVEVSQUNUSVZFJywgJzAnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dEZpbGUpIHtcbiAgICAgICAgICAgICAgICBlbnZNYXAuc2V0KCdHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9PVVRQVVRfRklMRScsIHRoaXMub3V0cHV0RmlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXJ2aWNlQWNjb3VudEVtYWlsID0gdGhpcy5nZXRTZXJ2aWNlQWNjb3VudEVtYWlsKCk7XG4gICAgICAgICAgICBpZiAoc2VydmljZUFjY291bnRFbWFpbCkge1xuICAgICAgICAgICAgICAgIGVudk1hcC5zZXQoJ0dPT0dMRV9FWFRFUk5BTF9BQ0NPVU5UX0lNUEVSU09OQVRFRF9FTUFJTCcsIHNlcnZpY2VBY2NvdW50RW1haWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhlY3V0YWJsZVJlc3BvbnNlID1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZXIucmV0cmlldmVSZXNwb25zZUZyb21FeGVjdXRhYmxlKGVudk1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4ZWN1dGFibGVSZXNwb25zZS52ZXJzaW9uID4gTUFYSU1VTV9FWEVDVVRBQkxFX1ZFUlNJT04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmVyc2lvbiBvZiBleGVjdXRhYmxlIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLCBtYXhpbXVtIHN1cHBvcnRlZCB2ZXJzaW9uIGlzICR7TUFYSU1VTV9FWEVDVVRBQkxFX1ZFUlNJT059LmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoYXQgcmVzcG9uc2Ugd2FzIHN1Y2Nlc3NmdWwuXG4gICAgICAgIGlmICghZXhlY3V0YWJsZVJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGVjdXRhYmxlRXJyb3IoZXhlY3V0YWJsZVJlc3BvbnNlLmVycm9yTWVzc2FnZSwgZXhlY3V0YWJsZVJlc3BvbnNlLmVycm9yQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhhdCByZXNwb25zZSBjb250YWlucyBleHBpcmF0aW9uIHRpbWUgaWYgb3V0cHV0IGZpbGUgd2FzIHNwZWNpZmllZC5cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsZSkge1xuICAgICAgICAgICAgaWYgKCFleGVjdXRhYmxlUmVzcG9uc2UuZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkludmFsaWRFeHBpcmF0aW9uVGltZUZpZWxkRXJyb3IoJ1RoZSBleGVjdXRhYmxlIHJlc3BvbnNlIG11c3QgY29udGFpbiB0aGUgYGV4cGlyYXRpb25fdGltZWAgZmllbGQgZm9yIHN1Y2Nlc3NmdWwgcmVzcG9uc2VzIHdoZW4gYW4gb3V0cHV0X2ZpbGUgaGFzIGJlZW4gc3BlY2lmaWVkIGluIHRoZSBjb25maWd1cmF0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHRoYXQgcmVzcG9uc2UgaXMgbm90IGV4cGlyZWQuXG4gICAgICAgIGlmIChleGVjdXRhYmxlUmVzcG9uc2UuaXNFeHBpcmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhlY3V0YWJsZSByZXNwb25zZSBpcyBleHBpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBzdWJqZWN0IHRva2VuIGZyb20gcmVzcG9uc2UuXG4gICAgICAgIHJldHVybiBleGVjdXRhYmxlUmVzcG9uc2Uuc3ViamVjdFRva2VuO1xuICAgIH1cbn1cbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aENsaWVudCA9IFBsdWdnYWJsZUF1dGhDbGllbnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQbHVnZ2FibGVBdXRoQ2xpZW50IiwiRXhlY3V0YWJsZUVycm9yIiwiYmFzZWV4dGVybmFsY2xpZW50XzEiLCJyZXF1aXJlIiwiZXhlY3V0YWJsZV9yZXNwb25zZV8xIiwicGx1Z2dhYmxlX2F1dGhfaGFuZGxlcl8xIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJjb2RlIiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJERUZBVUxUX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMiLCJNSU5JTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMiLCJNQVhJTVVNX0VYRUNVVEFCTEVfVElNRU9VVF9NSUxMSVMiLCJHT09HTEVfRVhURVJOQUxfQUNDT1VOVF9BTExPV19FWEVDVVRBQkxFUyIsIk1BWElNVU1fRVhFQ1VUQUJMRV9WRVJTSU9OIiwiQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCIsIm9wdGlvbnMiLCJhZGRpdGlvbmFsT3B0aW9ucyIsImNyZWRlbnRpYWxfc291cmNlIiwiZXhlY3V0YWJsZSIsImNvbW1hbmQiLCJ0aW1lb3V0X21pbGxpcyIsInVuZGVmaW5lZCIsInRpbWVvdXRNaWxsaXMiLCJvdXRwdXRGaWxlIiwib3V0cHV0X2ZpbGUiLCJoYW5kbGVyIiwiUGx1Z2dhYmxlQXV0aEhhbmRsZXIiLCJjcmVkZW50aWFsU291cmNlVHlwZSIsInJldHJpZXZlU3ViamVjdFRva2VuIiwicHJvY2VzcyIsImVudiIsImV4ZWN1dGFibGVSZXNwb25zZSIsInJldHJpZXZlQ2FjaGVkUmVzcG9uc2UiLCJlbnZNYXAiLCJNYXAiLCJzZXQiLCJhdWRpZW5jZSIsInN1YmplY3RUb2tlblR5cGUiLCJzZXJ2aWNlQWNjb3VudEVtYWlsIiwiZ2V0U2VydmljZUFjY291bnRFbWFpbCIsInJldHJpZXZlUmVzcG9uc2VGcm9tRXhlY3V0YWJsZSIsInZlcnNpb24iLCJzdWNjZXNzIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JDb2RlIiwiZXhwaXJhdGlvblRpbWUiLCJJbnZhbGlkRXhwaXJhdGlvblRpbWVGaWVsZEVycm9yIiwiaXNFeHBpcmVkIiwic3ViamVjdFRva2VuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PluggableAuthHandler = void 0;\nconst pluggable_auth_client_1 = __webpack_require__(/*! ./pluggable-auth-client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\nconst executable_response_1 = __webpack_require__(/*! ./executable-response */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/executable-response.js\");\nconst childProcess = __webpack_require__(/*! child_process */ \"child_process\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n/**\n * A handler used to retrieve 3rd party token responses from user defined\n * executables and cached file output for the PluggableAuthClient class.\n */ class PluggableAuthHandler {\n    /**\n     * Instantiates a PluggableAuthHandler instance using the provided\n     * PluggableAuthHandlerOptions object.\n     */ constructor(options){\n        if (!options.command) {\n            throw new Error(\"No command provided.\");\n        }\n        this.commandComponents = PluggableAuthHandler.parseCommand(options.command);\n        this.timeoutMillis = options.timeoutMillis;\n        if (!this.timeoutMillis) {\n            throw new Error(\"No timeoutMillis provided.\");\n        }\n        this.outputFile = options.outputFile;\n    }\n    /**\n     * Calls user provided executable to get a 3rd party subject token and\n     * returns the response.\n     * @param envMap a Map of additional Environment Variables required for\n     *   the executable.\n     * @return A promise that resolves with the executable response.\n     */ retrieveResponseFromExecutable(envMap) {\n        return new Promise((resolve, reject)=>{\n            // Spawn process to run executable using added environment variables.\n            const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {\n                env: {\n                    ...process.env,\n                    ...Object.fromEntries(envMap)\n                }\n            });\n            let output = \"\";\n            // Append stdout to output as executable runs.\n            child.stdout.on(\"data\", (data)=>{\n                output += data;\n            });\n            // Append stderr as executable runs.\n            child.stderr.on(\"data\", (err)=>{\n                output += err;\n            });\n            // Set up a timeout to end the child process and throw an error.\n            const timeout = setTimeout(()=>{\n                // Kill child process and remove listeners so 'close' event doesn't get\n                // read after child process is killed.\n                child.removeAllListeners();\n                child.kill();\n                return reject(new Error(\"The executable failed to finish within the timeout specified.\"));\n            }, this.timeoutMillis);\n            child.on(\"close\", (code)=>{\n                // Cancel timeout if executable closes before timeout is reached.\n                clearTimeout(timeout);\n                if (code === 0) {\n                    // If the executable completed successfully, try to return the parsed response.\n                    try {\n                        const responseJson = JSON.parse(output);\n                        const response = new executable_response_1.ExecutableResponse(responseJson);\n                        return resolve(response);\n                    } catch (error) {\n                        if (error instanceof executable_response_1.ExecutableResponseError) {\n                            return reject(error);\n                        }\n                        return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));\n                    }\n                } else {\n                    return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));\n                }\n            });\n        });\n    }\n    /**\n     * Checks user provided output file for response from previous run of\n     * executable and return the response if it exists, is formatted correctly, and is not expired.\n     */ async retrieveCachedResponse() {\n        if (!this.outputFile || this.outputFile.length === 0) {\n            return undefined;\n        }\n        let filePath;\n        try {\n            filePath = await fs.promises.realpath(this.outputFile);\n        } catch (_a) {\n            // If file path cannot be resolved, return undefined.\n            return undefined;\n        }\n        if (!(await fs.promises.lstat(filePath)).isFile()) {\n            // If path does not lead to file, return undefined.\n            return undefined;\n        }\n        const responseString = await fs.promises.readFile(filePath, {\n            encoding: \"utf8\"\n        });\n        if (responseString === \"\") {\n            return undefined;\n        }\n        try {\n            const responseJson = JSON.parse(responseString);\n            const response = new executable_response_1.ExecutableResponse(responseJson);\n            // Check if response is successful and unexpired.\n            if (response.isValid()) {\n                return new executable_response_1.ExecutableResponse(responseJson);\n            }\n            return undefined;\n        } catch (error) {\n            if (error instanceof executable_response_1.ExecutableResponseError) {\n                throw error;\n            }\n            throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);\n        }\n    }\n    /**\n     * Parses given command string into component array, splitting on spaces unless\n     * spaces are between quotation marks.\n     */ static parseCommand(command) {\n        // Split the command into components by splitting on spaces,\n        // unless spaces are contained in quotation marks.\n        const components = command.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n        if (!components) {\n            throw new Error(`Provided command: \"${command}\" could not be parsed.`);\n        }\n        // Remove quotation marks from the beginning and end of each component if they are present.\n        for(let i = 0; i < components.length; i++){\n            if (components[i][0] === '\"' && components[i].slice(-1) === '\"') {\n                components[i] = components[i].slice(1, -1);\n            }\n        }\n        return components;\n    }\n}\nexports.PluggableAuthHandler = PluggableAuthHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNEJBQTRCLEdBQUcsS0FBSztBQUNwQyxNQUFNRywwQkFBMEJDLG1CQUFPQSxDQUFDLGlIQUF5QjtBQUNqRSxNQUFNQyx3QkFBd0JELG1CQUFPQSxDQUFDLDZHQUF1QjtBQUM3RCxNQUFNRSxlQUFlRixtQkFBT0EsQ0FBQyxvQ0FBZTtBQUM1QyxNQUFNRyxLQUFLSCxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCOzs7Q0FHQyxHQUNELE1BQU1GO0lBQ0Y7OztLQUdDLEdBQ0RNLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixJQUFJLENBQUNBLFFBQVFDLE9BQU8sRUFBRTtZQUNsQixNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNDLGlCQUFpQixHQUFHVixxQkFBcUJXLFlBQVksQ0FBQ0osUUFBUUMsT0FBTztRQUMxRSxJQUFJLENBQUNJLGFBQWEsR0FBR0wsUUFBUUssYUFBYTtRQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDQSxhQUFhLEVBQUU7WUFDckIsTUFBTSxJQUFJSCxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDSSxVQUFVLEdBQUdOLFFBQVFNLFVBQVU7SUFDeEM7SUFDQTs7Ozs7O0tBTUMsR0FDREMsK0JBQStCQyxNQUFNLEVBQUU7UUFDbkMsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQ3pCLHFF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Q0FBK0MsRUFBRVksZUFBZSxDQUFDO1FBQzlIO0lBQ0o7SUFDQTs7O0tBR0MsR0FDRCxPQUFPNUMsYUFBYUgsT0FBTyxFQUFFO1FBQ3pCLDREQUE0RDtRQUM1RCxrREFBa0Q7UUFDbEQsTUFBTW1ELGFBQWFuRCxRQUFRb0QsS0FBSyxDQUFDO1FBQ2pDLElBQUksQ0FBQ0QsWUFBWTtZQUNiLE1BQU0sSUFBSWxELE1BQU0sQ0FBQyxtQkFBbUIsRUFBRUQsUUFBUSxzQkFBc0IsQ0FBQztRQUN6RTtRQUNBLDJGQUEyRjtRQUMzRixJQUFLLElBQUlxRCxJQUFJLEdBQUdBLElBQUlGLFdBQVdaLE1BQU0sRUFBRWMsSUFBSztZQUN4QyxJQUFJRixVQUFVLENBQUNFLEVBQUUsQ0FBQyxFQUFFLEtBQUssT0FBT0YsVUFBVSxDQUFDRSxFQUFFLENBQUN4QyxLQUFLLENBQUMsQ0FBQyxPQUFPLEtBQUs7Z0JBQzdEc0MsVUFBVSxDQUFDRSxFQUFFLEdBQUdGLFVBQVUsQ0FBQ0UsRUFBRSxDQUFDeEMsS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUM1QztRQUNKO1FBQ0EsT0FBT3NDO0lBQ1g7QUFDSjtBQUNBN0QsNEJBQTRCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9wbHVnZ2FibGUtYXV0aC1oYW5kbGVyLmpzPzBkNDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aEhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBwbHVnZ2FibGVfYXV0aF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3BsdWdnYWJsZS1hdXRoLWNsaWVudFwiKTtcbmNvbnN0IGV4ZWN1dGFibGVfcmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGFibGUtcmVzcG9uc2VcIik7XG5jb25zdCBjaGlsZFByb2Nlc3MgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuLyoqXG4gKiBBIGhhbmRsZXIgdXNlZCB0byByZXRyaWV2ZSAzcmQgcGFydHkgdG9rZW4gcmVzcG9uc2VzIGZyb20gdXNlciBkZWZpbmVkXG4gKiBleGVjdXRhYmxlcyBhbmQgY2FjaGVkIGZpbGUgb3V0cHV0IGZvciB0aGUgUGx1Z2dhYmxlQXV0aENsaWVudCBjbGFzcy5cbiAqL1xuY2xhc3MgUGx1Z2dhYmxlQXV0aEhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIFBsdWdnYWJsZUF1dGhIYW5kbGVyIGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZFxuICAgICAqIFBsdWdnYWJsZUF1dGhIYW5kbGVyT3B0aW9ucyBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuY29tbWFuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb21tYW5kIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tbWFuZENvbXBvbmVudHMgPSBQbHVnZ2FibGVBdXRoSGFuZGxlci5wYXJzZUNvbW1hbmQob3B0aW9ucy5jb21tYW5kKTtcbiAgICAgICAgdGhpcy50aW1lb3V0TWlsbGlzID0gb3B0aW9ucy50aW1lb3V0TWlsbGlzO1xuICAgICAgICBpZiAoIXRoaXMudGltZW91dE1pbGxpcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0aW1lb3V0TWlsbGlzIHByb3ZpZGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RmlsZSA9IG9wdGlvbnMub3V0cHV0RmlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdXNlciBwcm92aWRlZCBleGVjdXRhYmxlIHRvIGdldCBhIDNyZCBwYXJ0eSBzdWJqZWN0IHRva2VuIGFuZFxuICAgICAqIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBlbnZNYXAgYSBNYXAgb2YgYWRkaXRpb25hbCBFbnZpcm9ubWVudCBWYXJpYWJsZXMgcmVxdWlyZWQgZm9yXG4gICAgICogICB0aGUgZXhlY3V0YWJsZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGV4ZWN1dGFibGUgcmVzcG9uc2UuXG4gICAgICovXG4gICAgcmV0cmlldmVSZXNwb25zZUZyb21FeGVjdXRhYmxlKGVudk1hcCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gU3Bhd24gcHJvY2VzcyB0byBydW4gZXhlY3V0YWJsZSB1c2luZyBhZGRlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkUHJvY2Vzcy5zcGF3bih0aGlzLmNvbW1hbmRDb21wb25lbnRzWzBdLCB0aGlzLmNvbW1hbmRDb21wb25lbnRzLnNsaWNlKDEpLCB7XG4gICAgICAgICAgICAgICAgZW52OiB7IC4uLnByb2Nlc3MuZW52LCAuLi5PYmplY3QuZnJvbUVudHJpZXMoZW52TWFwKSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgICAgICAgICAvLyBBcHBlbmQgc3Rkb3V0IHRvIG91dHB1dCBhcyBleGVjdXRhYmxlIHJ1bnMuXG4gICAgICAgICAgICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBkYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBcHBlbmQgc3RkZXJyIGFzIGV4ZWN1dGFibGUgcnVucy5cbiAgICAgICAgICAgIGNoaWxkLnN0ZGVyci5vbignZGF0YScsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgYSB0aW1lb3V0IHRvIGVuZCB0aGUgY2hpbGQgcHJvY2VzcyBhbmQgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gS2lsbCBjaGlsZCBwcm9jZXNzIGFuZCByZW1vdmUgbGlzdGVuZXJzIHNvICdjbG9zZScgZXZlbnQgZG9lc24ndCBnZXRcbiAgICAgICAgICAgICAgICAvLyByZWFkIGFmdGVyIGNoaWxkIHByb2Nlc3MgaXMga2lsbGVkLlxuICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGNoaWxkLmtpbGwoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignVGhlIGV4ZWN1dGFibGUgZmFpbGVkIHRvIGZpbmlzaCB3aXRoaW4gdGhlIHRpbWVvdXQgc3BlY2lmaWVkLicpKTtcbiAgICAgICAgICAgIH0sIHRoaXMudGltZW91dE1pbGxpcyk7XG4gICAgICAgICAgICBjaGlsZC5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENhbmNlbCB0aW1lb3V0IGlmIGV4ZWN1dGFibGUgY2xvc2VzIGJlZm9yZSB0aW1lb3V0IGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBleGVjdXRhYmxlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIHRyeSB0byByZXR1cm4gdGhlIHBhcnNlZCByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IEpTT04ucGFyc2Uob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IGV4ZWN1dGFibGVfcmVzcG9uc2VfMS5FeGVjdXRhYmxlUmVzcG9uc2UocmVzcG9uc2VKc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGV4ZWN1dGFibGVfcmVzcG9uc2VfMS5FeGVjdXRhYmxlUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKGBUaGUgZXhlY3V0YWJsZSByZXR1cm5lZCBhbiBpbnZhbGlkIHJlc3BvbnNlOiAke291dHB1dH1gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IHBsdWdnYWJsZV9hdXRoX2NsaWVudF8xLkV4ZWN1dGFibGVFcnJvcihvdXRwdXQsIGNvZGUudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHVzZXIgcHJvdmlkZWQgb3V0cHV0IGZpbGUgZm9yIHJlc3BvbnNlIGZyb20gcHJldmlvdXMgcnVuIG9mXG4gICAgICogZXhlY3V0YWJsZSBhbmQgcmV0dXJuIHRoZSByZXNwb25zZSBpZiBpdCBleGlzdHMsIGlzIGZvcm1hdHRlZCBjb3JyZWN0bHksIGFuZCBpcyBub3QgZXhwaXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZUNhY2hlZFJlc3BvbnNlKCkge1xuICAgICAgICBpZiAoIXRoaXMub3V0cHV0RmlsZSB8fCB0aGlzLm91dHB1dEZpbGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWxlUGF0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbGVQYXRoID0gYXdhaXQgZnMucHJvbWlzZXMucmVhbHBhdGgodGhpcy5vdXRwdXRGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIElmIGZpbGUgcGF0aCBjYW5ub3QgYmUgcmVzb2x2ZWQsIHJldHVybiB1bmRlZmluZWQuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGF3YWl0IGZzLnByb21pc2VzLmxzdGF0KGZpbGVQYXRoKSkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgIC8vIElmIHBhdGggZG9lcyBub3QgbGVhZCB0byBmaWxlLCByZXR1cm4gdW5kZWZpbmVkLlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZVN0cmluZyA9IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKGZpbGVQYXRoLCB7XG4gICAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlU3RyaW5nID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VKc29uID0gSlNPTi5wYXJzZShyZXNwb25zZVN0cmluZyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuRXhlY3V0YWJsZVJlc3BvbnNlKHJlc3BvbnNlSnNvbik7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiByZXNwb25zZSBpcyBzdWNjZXNzZnVsIGFuZCB1bmV4cGlyZWQuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBleGVjdXRhYmxlX3Jlc3BvbnNlXzEuRXhlY3V0YWJsZVJlc3BvbnNlKHJlc3BvbnNlSnNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhlY3V0YWJsZV9yZXNwb25zZV8xLkV4ZWN1dGFibGVSZXNwb25zZUVycm9yKGBUaGUgb3V0cHV0IGZpbGUgY29udGFpbmVkIGFuIGludmFsaWQgcmVzcG9uc2U6ICR7cmVzcG9uc2VTdHJpbmd9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGdpdmVuIGNvbW1hbmQgc3RyaW5nIGludG8gY29tcG9uZW50IGFycmF5LCBzcGxpdHRpbmcgb24gc3BhY2VzIHVubGVzc1xuICAgICAqIHNwYWNlcyBhcmUgYmV0d2VlbiBxdW90YXRpb24gbWFya3MuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlQ29tbWFuZChjb21tYW5kKSB7XG4gICAgICAgIC8vIFNwbGl0IHRoZSBjb21tYW5kIGludG8gY29tcG9uZW50cyBieSBzcGxpdHRpbmcgb24gc3BhY2VzLFxuICAgICAgICAvLyB1bmxlc3Mgc3BhY2VzIGFyZSBjb250YWluZWQgaW4gcXVvdGF0aW9uIG1hcmtzLlxuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gY29tbWFuZC5tYXRjaCgvKD86W15cXHNcIl0rfFwiW15cIl0qXCIpKy9nKTtcbiAgICAgICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVkIGNvbW1hbmQ6IFwiJHtjb21tYW5kfVwiIGNvdWxkIG5vdCBiZSBwYXJzZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHF1b3RhdGlvbiBtYXJrcyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBlYWNoIGNvbXBvbmVudCBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzW2ldWzBdID09PSAnXCInICYmIGNvbXBvbmVudHNbaV0uc2xpY2UoLTEpID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpXSA9IGNvbXBvbmVudHNbaV0uc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn1cbmV4cG9ydHMuUGx1Z2dhYmxlQXV0aEhhbmRsZXIgPSBQbHVnZ2FibGVBdXRoSGFuZGxlcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBsdWdnYWJsZUF1dGhIYW5kbGVyIiwicGx1Z2dhYmxlX2F1dGhfY2xpZW50XzEiLCJyZXF1aXJlIiwiZXhlY3V0YWJsZV9yZXNwb25zZV8xIiwiY2hpbGRQcm9jZXNzIiwiZnMiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJjb21tYW5kIiwiRXJyb3IiLCJjb21tYW5kQ29tcG9uZW50cyIsInBhcnNlQ29tbWFuZCIsInRpbWVvdXRNaWxsaXMiLCJvdXRwdXRGaWxlIiwicmV0cmlldmVSZXNwb25zZUZyb21FeGVjdXRhYmxlIiwiZW52TWFwIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjaGlsZCIsInNwYXduIiwic2xpY2UiLCJlbnYiLCJwcm9jZXNzIiwiZnJvbUVudHJpZXMiLCJvdXRwdXQiLCJzdGRvdXQiLCJvbiIsImRhdGEiLCJzdGRlcnIiLCJlcnIiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsInJlbW92ZUFsbExpc3RlbmVycyIsImtpbGwiLCJjb2RlIiwiY2xlYXJUaW1lb3V0IiwicmVzcG9uc2VKc29uIiwiSlNPTiIsInBhcnNlIiwicmVzcG9uc2UiLCJFeGVjdXRhYmxlUmVzcG9uc2UiLCJlcnJvciIsIkV4ZWN1dGFibGVSZXNwb25zZUVycm9yIiwiRXhlY3V0YWJsZUVycm9yIiwidG9TdHJpbmciLCJyZXRyaWV2ZUNhY2hlZFJlc3BvbnNlIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiZmlsZVBhdGgiLCJwcm9taXNlcyIsInJlYWxwYXRoIiwiX2EiLCJsc3RhdCIsImlzRmlsZSIsInJlc3BvbnNlU3RyaW5nIiwicmVhZEZpbGUiLCJlbmNvZGluZyIsImlzVmFsaWQiLCJjb21wb25lbnRzIiwibWF0Y2giLCJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/refreshclient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2015 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.UserRefreshClient = exports.USER_REFRESH_ACCOUNT_TYPE = void 0;\nconst oauth2client_1 = __webpack_require__(/*! ./oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nconst querystring_1 = __webpack_require__(/*! querystring */ \"querystring\");\nexports.USER_REFRESH_ACCOUNT_TYPE = \"authorized_user\";\nclass UserRefreshClient extends oauth2client_1.OAuth2Client {\n    constructor(optionsOrClientId, clientSecret, refreshToken, eagerRefreshThresholdMillis, forceRefreshOnFailure){\n        const opts = optionsOrClientId && typeof optionsOrClientId === \"object\" ? optionsOrClientId : {\n            clientId: optionsOrClientId,\n            clientSecret,\n            refreshToken,\n            eagerRefreshThresholdMillis,\n            forceRefreshOnFailure\n        };\n        super(opts);\n        this._refreshToken = opts.refreshToken;\n        this.credentials.refresh_token = opts.refreshToken;\n    }\n    /**\n     * Refreshes the access token.\n     * @param refreshToken An ignored refreshToken..\n     * @param callback Optional callback.\n     */ async refreshTokenNoCache(// eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refreshToken) {\n        return super.refreshTokenNoCache(this._refreshToken);\n    }\n    async fetchIdToken(targetAudience) {\n        const res = await this.transporter.request({\n            ...UserRefreshClient.RETRY_CONFIG,\n            url: this.endpoints.oauth2TokenUrl,\n            headers: {\n                \"Content-Type\": \"application/x-www-form-urlencoded\"\n            },\n            method: \"POST\",\n            data: (0, querystring_1.stringify)({\n                client_id: this._clientId,\n                client_secret: this._clientSecret,\n                grant_type: \"refresh_token\",\n                refresh_token: this._refreshToken,\n                target_audience: targetAudience\n            })\n        });\n        return res.data.id_token;\n    }\n    /**\n     * Create a UserRefreshClient credentials instance using the given input\n     * options.\n     * @param json The input object.\n     */ fromJSON(json) {\n        if (!json) {\n            throw new Error(\"Must pass in a JSON object containing the user refresh token\");\n        }\n        if (json.type !== \"authorized_user\") {\n            throw new Error('The incoming JSON object does not have the \"authorized_user\" type');\n        }\n        if (!json.client_id) {\n            throw new Error(\"The incoming JSON object does not contain a client_id field\");\n        }\n        if (!json.client_secret) {\n            throw new Error(\"The incoming JSON object does not contain a client_secret field\");\n        }\n        if (!json.refresh_token) {\n            throw new Error(\"The incoming JSON object does not contain a refresh_token field\");\n        }\n        this._clientId = json.client_id;\n        this._clientSecret = json.client_secret;\n        this._refreshToken = json.refresh_token;\n        this.credentials.refresh_token = json.refresh_token;\n        this.quotaProjectId = json.quota_project_id;\n        this.universeDomain = json.universe_domain || this.universeDomain;\n    }\n    fromStream(inputStream, callback) {\n        if (callback) {\n            this.fromStreamAsync(inputStream).then(()=>callback(), callback);\n        } else {\n            return this.fromStreamAsync(inputStream);\n        }\n    }\n    async fromStreamAsync(inputStream) {\n        return new Promise((resolve, reject)=>{\n            if (!inputStream) {\n                return reject(new Error(\"Must pass in a stream containing the user refresh token.\"));\n            }\n            let s = \"\";\n            inputStream.setEncoding(\"utf8\").on(\"error\", reject).on(\"data\", (chunk)=>s += chunk).on(\"end\", ()=>{\n                try {\n                    const data = JSON.parse(s);\n                    this.fromJSON(data);\n                    return resolve();\n                } catch (err) {\n                    return reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Create a UserRefreshClient credentials instance using the given input\n     * options.\n     * @param json The input object.\n     */ static fromJSON(json) {\n        const client = new UserRefreshClient();\n        client.fromJSON(json);\n        return client;\n    }\n}\nexports.UserRefreshClient = UserRefreshClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9yZWZyZXNoY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQseUJBQXlCLEdBQUdBLGlDQUFpQyxHQUFHLEtBQUs7QUFDckUsTUFBTUksaUJBQWlCQyxtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDL0MsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxnQ0FBYTtBQUMzQ0wsaUNBQWlDLEdBQUc7QUFDcEMsTUFBTUUsMEJBQTBCRSxlQUFlRyxZQUFZO0lBQ3ZEQyxZQUFZQyxpQkFBaUIsRUFBRUMsWUFBWSxFQUFFQyxZQUFZLEVBQUVDLDJCQUEyQixFQUFFQyxxQkFBcUIsQ0FBRTtRQUMzRyxNQUFNQyxPQUFPTCxxQkFBcUIsT0FBT0Esc0JBQXNCLFdBQ3pEQSxvQkFDQTtZQUNFTSxVQUFVTjtZQUNWQztZQUNBQztZQUNBQztZQUNBQztRQUNKO1FBQ0osS0FBSyxDQUFDQztRQUNOLElBQUksQ0FBQ0UsYUFBYSxHQUFHRixLQUFLSCxZQUFZO1FBQ3RDLElBQUksQ0FBQ00sV0FBVyxDQUFDQyxhQUFhLEdBQUdKLEtBQUtILFlBQVk7SUFDdEQ7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTVEsb0JBQ04sNkRBQTZEO0lBQzdEUixZQUFZLEVBQUU7UUFDVixPQUFPLEtBQUssQ0FBQ1Esb0JBQW9CLElBQUksQ0FBQ0gsYUFBYTtJQUN2RDtJQUNBLE1BQU1JLGFBQWFDLGNBQWMsRUFBRTtRQUMvQixNQUFNQyxNQUFNLE1BQU0sSUFBSSxDQUFDQyxXQUFXLENBQUNDLE9BQU8sQ0FBQztZQUN2QyxHQUFHdEIsa0JBQWtCdUIsWUFBWTtZQUNqQ0MsS0FBSyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsY0FBYztZQUNsQ0MsU0FBUztnQkFDTCxnQkFBZ0I7WUFDcEI7WUFDQUMsUUFBUTtZQUNSQyxNQUFNLENBQUMsR0FBR3pCLGNBQWMwQixTQUFTLEVBQUU7Z0JBQy9CQyxXQUFXLElBQUksQ0FBQ0MsU0FBUztnQkFDekJDLGVBQWUsSUFBSSxDQUFDQyxhQUFhO2dCQUNqQ0MsWUFBWTtnQkFDWm5CLGVBQWUsSUFBSSxDQUFDRixhQUFhO2dCQUNqQ3NCLGlCQUFpQmpCO1lBQ3JCO1FBQ0o7UUFDQSxPQUFPQyxJQUFJUyxJQUFJLENBQUNRLFFBQVE7SUFDNUI7SUFDQTs7OztLQUlDLEdBQ0RDLFNBQVNDLElBQUksRUFBRTtRQUNYLElBQUksQ0FBQ0EsTUFBTTtZQUNQLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUlELEtBQUtFLElBQUksS0FBSyxtQkFBbUI7WUFDakMsTUFBTSxJQUFJRCxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDRCxLQUFLUixTQUFTLEVBQUU7WUFDakIsTUFBTSxJQUFJUyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDRCxLQUFLTixhQUFhLEVBQUU7WUFDckIsTUFBTSxJQUFJTyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDRCxLQUFLdkIsYUFBYSxFQUFFO1lBQ3JCLE1BQU0sSUFBSXdCLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNSLFNBQVMsR0FBR08sS0FBS1IsU0FBUztRQUMvQixJQUFJLENBQUNHLGFBQWEsR0FBR0ssS0FBS04sYUFBYTtRQUN2QyxJQUFJLENBQUNuQixhQUFhLEdBQUd5QixLQUFLdkIsYUFBYTtRQUN2QyxJQUFJLENBQUNELFdBQVcsQ0FBQ0MsYUFBYSxHQUFHdUIsS0FBS3ZCLGFBQWE7UUFDbkQsSUFBSSxDQUFDMEIsY0FBYyxHQUFHSCxLQUFLSSxnQkFBZ0I7UUFDM0MsSUFBSSxDQUFDQyxjQUFjLEdBQUdMLEtBQUtNLGVBQWUsSUFBSSxJQUFJLENBQUNELGNBQWM7SUFDckU7SUFDQUUsV0FBV0MsV0FBVyxFQUFFQyxRQUFRLEVBQUU7UUFDOUIsSUFBSUEsVUFBVTtZQUNWLElBQUksQ0FBQ0MsZUFBZSxDQUFDRixhQUFhRyxJQUFJLENBQUMsSUFBTUYsWUFBWUE7UUFDN0QsT0FDSztZQUNELE9BQU8sSUFBSSxDQUFDQyxlQUFlLENBQUNGO1FBQ2hDO0lBQ0o7SUFDQSxNQUFNRSxnQkFBZ0JGLFdBQVcsRUFBRTtRQUMvQixPQUFPLElBQUlJLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDekIsSUFBSSxDQUFDTixhQUFhO2dCQUNkLE9BQU9NLE9BQU8sSUFBSWIsTUFBTTtZQUM1QjtZQUNBLElBQUljLElBQUk7WUFDUlAsWUFDS1EsV0FBVyxDQUFDLFFBQ1pDLEVBQUUsQ0FBQyxTQUFTSCxRQUNaRyxFQUFFLENBQUMsUUFBUUMsQ0FBQUEsUUFBVUgsS0FBS0csT0FDMUJELEVBQUUsQ0FBQyxPQUFPO2dCQUNYLElBQUk7b0JBQ0EsTUFBTTNCLE9BQU82QixLQUFLQyxLQUFLLENBQUNMO29CQUN4QixJQUFJLENBQUNoQixRQUFRLENBQUNUO29CQUNkLE9BQU91QjtnQkFDWCxFQUNBLE9BQU9RLEtBQUs7b0JBQ1IsT0FBT1AsT0FBT087Z0JBQ2xCO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7S0FJQyxHQUNELE9BQU90QixTQUFTQyxJQUFJLEVBQUU7UUFDbEIsTUFBTXNCLFNBQVMsSUFBSTdEO1FBQ25CNkQsT0FBT3ZCLFFBQVEsQ0FBQ0M7UUFDaEIsT0FBT3NCO0lBQ1g7QUFDSjtBQUNBL0QseUJBQXlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9yZWZyZXNoY2xpZW50LmpzP2JlNjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVXNlclJlZnJlc2hDbGllbnQgPSBleHBvcnRzLlVTRVJfUkVGUkVTSF9BQ0NPVU5UX1RZUEUgPSB2b2lkIDA7XG5jb25zdCBvYXV0aDJjbGllbnRfMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNsaWVudFwiKTtcbmNvbnN0IHF1ZXJ5c3RyaW5nXzEgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5leHBvcnRzLlVTRVJfUkVGUkVTSF9BQ0NPVU5UX1RZUEUgPSAnYXV0aG9yaXplZF91c2VyJztcbmNsYXNzIFVzZXJSZWZyZXNoQ2xpZW50IGV4dGVuZHMgb2F1dGgyY2xpZW50XzEuT0F1dGgyQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zT3JDbGllbnRJZCwgY2xpZW50U2VjcmV0LCByZWZyZXNoVG9rZW4sIGVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcywgZm9yY2VSZWZyZXNoT25GYWlsdXJlKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zT3JDbGllbnRJZCAmJiB0eXBlb2Ygb3B0aW9uc09yQ2xpZW50SWQgPT09ICdvYmplY3QnXG4gICAgICAgICAgICA/IG9wdGlvbnNPckNsaWVudElkXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogb3B0aW9uc09yQ2xpZW50SWQsXG4gICAgICAgICAgICAgICAgY2xpZW50U2VjcmV0LFxuICAgICAgICAgICAgICAgIHJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgICAgICBlYWdlclJlZnJlc2hUaHJlc2hvbGRNaWxsaXMsXG4gICAgICAgICAgICAgICAgZm9yY2VSZWZyZXNoT25GYWlsdXJlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hUb2tlbiA9IG9wdHMucmVmcmVzaFRva2VuO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4gPSBvcHRzLnJlZnJlc2hUb2tlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHJlZnJlc2hUb2tlbiBBbiBpZ25vcmVkIHJlZnJlc2hUb2tlbi4uXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hUb2tlbk5vQ2FjaGUoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHJlZnJlc2hUb2tlbikge1xuICAgICAgICByZXR1cm4gc3VwZXIucmVmcmVzaFRva2VuTm9DYWNoZSh0aGlzLl9yZWZyZXNoVG9rZW4pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaElkVG9rZW4odGFyZ2V0QXVkaWVuY2UpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy50cmFuc3BvcnRlci5yZXF1ZXN0KHtcbiAgICAgICAgICAgIC4uLlVzZXJSZWZyZXNoQ2xpZW50LlJFVFJZX0NPTkZJRyxcbiAgICAgICAgICAgIHVybDogdGhpcy5lbmRwb2ludHMub2F1dGgyVG9rZW5VcmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgZGF0YTogKDAsIHF1ZXJ5c3RyaW5nXzEuc3RyaW5naWZ5KSh7XG4gICAgICAgICAgICAgICAgY2xpZW50X2lkOiB0aGlzLl9jbGllbnRJZCxcbiAgICAgICAgICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLl9jbGllbnRTZWNyZXQsXG4gICAgICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHRoaXMuX3JlZnJlc2hUb2tlbixcbiAgICAgICAgICAgICAgICB0YXJnZXRfYXVkaWVuY2U6IHRhcmdldEF1ZGllbmNlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzLmRhdGEuaWRfdG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIFVzZXJSZWZyZXNoQ2xpZW50IGNyZWRlbnRpYWxzIGluc3RhbmNlIHVzaW5nIHRoZSBnaXZlbiBpbnB1dFxuICAgICAqIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGpzb24gVGhlIGlucHV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHBhc3MgaW4gYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSB1c2VyIHJlZnJlc2ggdG9rZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi50eXBlICE9PSAnYXV0aG9yaXplZF91c2VyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgaGF2ZSB0aGUgXCJhdXRob3JpemVkX3VzZXJcIiB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFqc29uLmNsaWVudF9pZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jb21pbmcgSlNPTiBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhIGNsaWVudF9pZCBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanNvbi5jbGllbnRfc2VjcmV0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgY2xpZW50X3NlY3JldCBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanNvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNvbWluZyBKU09OIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgcmVmcmVzaF90b2tlbiBmaWVsZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsaWVudElkID0ganNvbi5jbGllbnRfaWQ7XG4gICAgICAgIHRoaXMuX2NsaWVudFNlY3JldCA9IGpzb24uY2xpZW50X3NlY3JldDtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFRva2VuID0ganNvbi5yZWZyZXNoX3Rva2VuO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzLnJlZnJlc2hfdG9rZW4gPSBqc29uLnJlZnJlc2hfdG9rZW47XG4gICAgICAgIHRoaXMucXVvdGFQcm9qZWN0SWQgPSBqc29uLnF1b3RhX3Byb2plY3RfaWQ7XG4gICAgICAgIHRoaXMudW5pdmVyc2VEb21haW4gPSBqc29uLnVuaXZlcnNlX2RvbWFpbiB8fCB0aGlzLnVuaXZlcnNlRG9tYWluO1xuICAgIH1cbiAgICBmcm9tU3RyZWFtKGlucHV0U3RyZWFtLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKS50aGVuKCgpID0+IGNhbGxiYWNrKCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21TdHJlYW1Bc3luYyhpbnB1dFN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnJvbVN0cmVhbUFzeW5jKGlucHV0U3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ011c3QgcGFzcyBpbiBhIHN0cmVhbSBjb250YWluaW5nIHRoZSB1c2VyIHJlZnJlc2ggdG9rZW4uJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgICAgIGlucHV0U3RyZWFtXG4gICAgICAgICAgICAgICAgLnNldEVuY29kaW5nKCd1dGY4JylcbiAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgICAgICAgICAgIC5vbignZGF0YScsIGNodW5rID0+IChzICs9IGNodW5rKSlcbiAgICAgICAgICAgICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm9tSlNPTihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBVc2VyUmVmcmVzaENsaWVudCBjcmVkZW50aWFscyBpbnN0YW5jZSB1c2luZyB0aGUgZ2l2ZW4gaW5wdXRcbiAgICAgKiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBqc29uIFRoZSBpbnB1dCBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IFVzZXJSZWZyZXNoQ2xpZW50KCk7XG4gICAgICAgIGNsaWVudC5mcm9tSlNPTihqc29uKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG59XG5leHBvcnRzLlVzZXJSZWZyZXNoQ2xpZW50ID0gVXNlclJlZnJlc2hDbGllbnQ7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJVc2VyUmVmcmVzaENsaWVudCIsIlVTRVJfUkVGUkVTSF9BQ0NPVU5UX1RZUEUiLCJvYXV0aDJjbGllbnRfMSIsInJlcXVpcmUiLCJxdWVyeXN0cmluZ18xIiwiT0F1dGgyQ2xpZW50IiwiY29uc3RydWN0b3IiLCJvcHRpb25zT3JDbGllbnRJZCIsImNsaWVudFNlY3JldCIsInJlZnJlc2hUb2tlbiIsImVhZ2VyUmVmcmVzaFRocmVzaG9sZE1pbGxpcyIsImZvcmNlUmVmcmVzaE9uRmFpbHVyZSIsIm9wdHMiLCJjbGllbnRJZCIsIl9yZWZyZXNoVG9rZW4iLCJjcmVkZW50aWFscyIsInJlZnJlc2hfdG9rZW4iLCJyZWZyZXNoVG9rZW5Ob0NhY2hlIiwiZmV0Y2hJZFRva2VuIiwidGFyZ2V0QXVkaWVuY2UiLCJyZXMiLCJ0cmFuc3BvcnRlciIsInJlcXVlc3QiLCJSRVRSWV9DT05GSUciLCJ1cmwiLCJlbmRwb2ludHMiLCJvYXV0aDJUb2tlblVybCIsImhlYWRlcnMiLCJtZXRob2QiLCJkYXRhIiwic3RyaW5naWZ5IiwiY2xpZW50X2lkIiwiX2NsaWVudElkIiwiY2xpZW50X3NlY3JldCIsIl9jbGllbnRTZWNyZXQiLCJncmFudF90eXBlIiwidGFyZ2V0X2F1ZGllbmNlIiwiaWRfdG9rZW4iLCJmcm9tSlNPTiIsImpzb24iLCJFcnJvciIsInR5cGUiLCJxdW90YVByb2plY3RJZCIsInF1b3RhX3Byb2plY3RfaWQiLCJ1bml2ZXJzZURvbWFpbiIsInVuaXZlcnNlX2RvbWFpbiIsImZyb21TdHJlYW0iLCJpbnB1dFN0cmVhbSIsImNhbGxiYWNrIiwiZnJvbVN0cmVhbUFzeW5jIiwidGhlbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicyIsInNldEVuY29kaW5nIiwib24iLCJjaHVuayIsIkpTT04iLCJwYXJzZSIsImVyciIsImNsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js":
/*!***************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/stscredentials.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StsCredentials = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst transporters_1 = __webpack_require__(/*! ../transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nconst oauth2common_1 = __webpack_require__(/*! ./oauth2common */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2common.js\");\n/**\n * Implements the OAuth 2.0 token exchange based on\n * https://tools.ietf.org/html/rfc8693\n */ class StsCredentials extends oauth2common_1.OAuthClientAuthHandler {\n    /**\n     * Initializes an STS credentials instance.\n     * @param tokenExchangeEndpoint The token exchange endpoint.\n     * @param clientAuthentication The client authentication credentials if\n     *   available.\n     */ constructor(tokenExchangeEndpoint, clientAuthentication){\n        super(clientAuthentication);\n        this.tokenExchangeEndpoint = tokenExchangeEndpoint;\n        this.transporter = new transporters_1.DefaultTransporter();\n    }\n    /**\n     * Exchanges the provided token for another type of token based on the\n     * rfc8693 spec.\n     * @param stsCredentialsOptions The token exchange options used to populate\n     *   the token exchange request.\n     * @param additionalHeaders Optional additional headers to pass along the\n     *   request.\n     * @param options Optional additional GCP-specific non-spec defined options\n     *   to send with the request.\n     *   Example: `&options=${encodeUriComponent(JSON.stringified(options))}`\n     * @return A promise that resolves with the token exchange response containing\n     *   the requested token and its expiration time.\n     */ async exchangeToken(stsCredentialsOptions, additionalHeaders, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    options) {\n        var _a, _b, _c;\n        const values = {\n            grant_type: stsCredentialsOptions.grantType,\n            resource: stsCredentialsOptions.resource,\n            audience: stsCredentialsOptions.audience,\n            scope: (_a = stsCredentialsOptions.scope) === null || _a === void 0 ? void 0 : _a.join(\" \"),\n            requested_token_type: stsCredentialsOptions.requestedTokenType,\n            subject_token: stsCredentialsOptions.subjectToken,\n            subject_token_type: stsCredentialsOptions.subjectTokenType,\n            actor_token: (_b = stsCredentialsOptions.actingParty) === null || _b === void 0 ? void 0 : _b.actorToken,\n            actor_token_type: (_c = stsCredentialsOptions.actingParty) === null || _c === void 0 ? void 0 : _c.actorTokenType,\n            // Non-standard GCP-specific options.\n            options: options && JSON.stringify(options)\n        };\n        // Remove undefined fields.\n        Object.keys(values).forEach((key)=>{\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (typeof values[key] === \"undefined\") {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                delete values[key];\n            }\n        });\n        const headers = {\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n        };\n        // Inject additional STS headers if available.\n        Object.assign(headers, additionalHeaders || {});\n        const opts = {\n            ...StsCredentials.RETRY_CONFIG,\n            url: this.tokenExchangeEndpoint.toString(),\n            method: \"POST\",\n            headers,\n            data: querystring.stringify(values),\n            responseType: \"json\"\n        };\n        // Apply OAuth client authentication.\n        this.applyClientAuthenticationOptions(opts);\n        try {\n            const response = await this.transporter.request(opts);\n            // Successful response.\n            const stsSuccessfulResponse = response.data;\n            stsSuccessfulResponse.res = response;\n            return stsSuccessfulResponse;\n        } catch (error) {\n            // Translate error to OAuthError.\n            if (error instanceof gaxios_1.GaxiosError && error.response) {\n                throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(error.response.data, // Preserve other fields from the original error.\n                error);\n            }\n            // Request could fail before the server responds.\n            throw error;\n        }\n    }\n}\nexports.StsCredentials = StsCredentials;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9zdHNjcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHLEtBQUs7QUFDOUIsTUFBTUcsV0FBV0MsbUJBQU9BLENBQUMsOERBQVE7QUFDakMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsZ0NBQWE7QUFDekMsTUFBTUUsaUJBQWlCRixtQkFBT0EsQ0FBQywyRkFBaUI7QUFDaEQsTUFBTUcsaUJBQWlCSCxtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDL0M7OztDQUdDLEdBQ0QsTUFBTUYsdUJBQXVCSyxlQUFlQyxzQkFBc0I7SUFDOUQ7Ozs7O0tBS0MsR0FDREMsWUFBWUMscUJBQXFCLEVBQUVDLG9CQUFvQixDQUFFO1FBQ3JELEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNELHFCQUFxQixHQUFHQTtRQUM3QixJQUFJLENBQUNFLFdBQVcsR0FBRyxJQUFJTixlQUFlTyxrQkFBa0I7SUFDNUQ7SUFDQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDRCxNQUFNQyxjQUFjQyxxQkFBcUIsRUFBRUMsaUJBQWlCLEVBQzVELDhEQUE4RDtJQUM5REMsT0FBTyxFQUFFO1FBQ0wsSUFBSUMsSUFBSUMsSUFBSUM7UUFDWixNQUFNQyxTQUFTO1lBQ1hDLFlBQVlQLHNCQUFzQlEsU0FBUztZQUMzQ0MsVUFBVVQsc0JBQXNCUyxRQUFRO1lBQ3hDQyxVQUFVVixzQkFBc0JVLFFBQVE7WUFDeENDLE9BQU8sQ0FBQ1IsS0FBS0gsc0JBQXNCVyxLQUFLLE1BQU0sUUFBUVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHUyxJQUFJLENBQUM7WUFDdkZDLHNCQUFzQmIsc0JBQXNCYyxrQkFBa0I7WUFDOURDLGVBQWVmLHNCQUFzQmdCLFlBQVk7WUFDakRDLG9CQUFvQmpCLHNCQUFzQmtCLGdCQUFnQjtZQUMxREMsYUFBYSxDQUFDZixLQUFLSixzQkFBc0JvQixXQUFXLE1BQU0sUUFBUWhCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2lCLFVBQVU7WUFDeEdDLGtCQUFrQixDQUFDakIsS0FBS0wsc0JBQXNCb0IsV0FBVyxNQUFNLFFBQVFmLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tCLGNBQWM7WUFDakgscUNBQXFDO1lBQ3JDckIsU0FBU0EsV0FBV3NCLEtBQUtDLFNBQVMsQ0FBQ3ZCO1FBQ3ZDO1FBQ0EsMkJBQTJCO1FBQzNCbkIsT0FBTzJDLElBQUksQ0FBQ3BCLFFBQVFxQixPQUFPLENBQUNDLENBQUFBO1lBQ3hCLDhEQUE4RDtZQUM5RCxJQUFJLE9BQU90QixNQUFNLENBQUNzQixJQUFJLEtBQUssYUFBYTtnQkFDcEMsOERBQThEO2dCQUM5RCxPQUFPdEIsTUFBTSxDQUFDc0IsSUFBSTtZQUN0QjtRQUNKO1FBQ0EsTUFBTUMsVUFBVTtZQUNaLGdCQUFnQjtRQUNwQjtRQUNBLDhDQUE4QztRQUM5QzlDLE9BQU8rQyxNQUFNLENBQUNELFNBQVM1QixxQkFBcUIsQ0FBQztRQUM3QyxNQUFNOEIsT0FBTztZQUNULEdBQUc1QyxlQUFlNkMsWUFBWTtZQUM5QkMsS0FBSyxJQUFJLENBQUN0QyxxQkFBcUIsQ0FBQ3VDLFFBQVE7WUFDeENDLFFBQVE7WUFDUk47WUFDQU8sTUFBTTlDLFlBQVltQyxTQUFTLENBQUNuQjtZQUM1QitCLGNBQWM7UUFDbEI7UUFDQSxxQ0FBcUM7UUFDckMsSUFBSSxDQUFDQyxnQ0FBZ0MsQ0FBQ1A7UUFDdEMsSUFBSTtZQUNBLE1BQU1RLFdBQVcsTUFBTSxJQUFJLENBQUMxQyxXQUFXLENBQUMyQyxPQUFPLENBQUNUO1lBQ2hELHVCQUF1QjtZQUN2QixNQUFNVSx3QkFBd0JGLFNBQVNILElBQUk7WUFDM0NLLHNCQUFzQkMsR0FBRyxHQUFHSDtZQUM1QixPQUFPRTtRQUNYLEVBQ0EsT0FBT0UsT0FBTztZQUNWLGlDQUFpQztZQUNqQyxJQUFJQSxpQkFBaUJ2RCxTQUFTd0QsV0FBVyxJQUFJRCxNQUFNSixRQUFRLEVBQUU7Z0JBQ3pELE1BQU0sQ0FBQyxHQUFHL0MsZUFBZXFELDhCQUE4QixFQUFFRixNQUFNSixRQUFRLENBQUNILElBQUksRUFDNUUsaURBQWlEO2dCQUNqRE87WUFDSjtZQUNBLGlEQUFpRDtZQUNqRCxNQUFNQTtRQUNWO0lBQ0o7QUFDSjtBQUNBMUQsc0JBQXNCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC9zdHNjcmVkZW50aWFscy5qcz9iN2U0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0c0NyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgZ2F4aW9zXzEgPSByZXF1aXJlKFwiZ2F4aW9zXCIpO1xuY29uc3QgcXVlcnlzdHJpbmcgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5jb25zdCB0cmFuc3BvcnRlcnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRlcnNcIik7XG5jb25zdCBvYXV0aDJjb21tb25fMSA9IHJlcXVpcmUoXCIuL29hdXRoMmNvbW1vblwiKTtcbi8qKlxuICogSW1wbGVtZW50cyB0aGUgT0F1dGggMi4wIHRva2VuIGV4Y2hhbmdlIGJhc2VkIG9uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjODY5M1xuICovXG5jbGFzcyBTdHNDcmVkZW50aWFscyBleHRlbmRzIG9hdXRoMmNvbW1vbl8xLk9BdXRoQ2xpZW50QXV0aEhhbmRsZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIFNUUyBjcmVkZW50aWFscyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gdG9rZW5FeGNoYW5nZUVuZHBvaW50IFRoZSB0b2tlbiBleGNoYW5nZSBlbmRwb2ludC5cbiAgICAgKiBAcGFyYW0gY2xpZW50QXV0aGVudGljYXRpb24gVGhlIGNsaWVudCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBpZlxuICAgICAqICAgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRva2VuRXhjaGFuZ2VFbmRwb2ludCwgY2xpZW50QXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgc3VwZXIoY2xpZW50QXV0aGVudGljYXRpb24pO1xuICAgICAgICB0aGlzLnRva2VuRXhjaGFuZ2VFbmRwb2ludCA9IHRva2VuRXhjaGFuZ2VFbmRwb2ludDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRlciA9IG5ldyB0cmFuc3BvcnRlcnNfMS5EZWZhdWx0VHJhbnNwb3J0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjaGFuZ2VzIHRoZSBwcm92aWRlZCB0b2tlbiBmb3IgYW5vdGhlciB0eXBlIG9mIHRva2VuIGJhc2VkIG9uIHRoZVxuICAgICAqIHJmYzg2OTMgc3BlYy5cbiAgICAgKiBAcGFyYW0gc3RzQ3JlZGVudGlhbHNPcHRpb25zIFRoZSB0b2tlbiBleGNoYW5nZSBvcHRpb25zIHVzZWQgdG8gcG9wdWxhdGVcbiAgICAgKiAgIHRoZSB0b2tlbiBleGNoYW5nZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsSGVhZGVycyBPcHRpb25hbCBhZGRpdGlvbmFsIGhlYWRlcnMgdG8gcGFzcyBhbG9uZyB0aGVcbiAgICAgKiAgIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgYWRkaXRpb25hbCBHQ1Atc3BlY2lmaWMgbm9uLXNwZWMgZGVmaW5lZCBvcHRpb25zXG4gICAgICogICB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3QuXG4gICAgICogICBFeGFtcGxlOiBgJm9wdGlvbnM9JHtlbmNvZGVVcmlDb21wb25lbnQoSlNPTi5zdHJpbmdpZmllZChvcHRpb25zKSl9YFxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdG9rZW4gZXhjaGFuZ2UgcmVzcG9uc2UgY29udGFpbmluZ1xuICAgICAqICAgdGhlIHJlcXVlc3RlZCB0b2tlbiBhbmQgaXRzIGV4cGlyYXRpb24gdGltZS5cbiAgICAgKi9cbiAgICBhc3luYyBleGNoYW5nZVRva2VuKHN0c0NyZWRlbnRpYWxzT3B0aW9ucywgYWRkaXRpb25hbEhlYWRlcnMsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgICAgICAgZ3JhbnRfdHlwZTogc3RzQ3JlZGVudGlhbHNPcHRpb25zLmdyYW50VHlwZSxcbiAgICAgICAgICAgIHJlc291cmNlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMucmVzb3VyY2UsXG4gICAgICAgICAgICBhdWRpZW5jZTogc3RzQ3JlZGVudGlhbHNPcHRpb25zLmF1ZGllbmNlLFxuICAgICAgICAgICAgc2NvcGU6IChfYSA9IHN0c0NyZWRlbnRpYWxzT3B0aW9ucy5zY29wZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHJlcXVlc3RlZF90b2tlbl90eXBlOiBzdHNDcmVkZW50aWFsc09wdGlvbnMucmVxdWVzdGVkVG9rZW5UeXBlLFxuICAgICAgICAgICAgc3ViamVjdF90b2tlbjogc3RzQ3JlZGVudGlhbHNPcHRpb25zLnN1YmplY3RUb2tlbixcbiAgICAgICAgICAgIHN1YmplY3RfdG9rZW5fdHlwZTogc3RzQ3JlZGVudGlhbHNPcHRpb25zLnN1YmplY3RUb2tlblR5cGUsXG4gICAgICAgICAgICBhY3Rvcl90b2tlbjogKF9iID0gc3RzQ3JlZGVudGlhbHNPcHRpb25zLmFjdGluZ1BhcnR5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWN0b3JUb2tlbixcbiAgICAgICAgICAgIGFjdG9yX3Rva2VuX3R5cGU6IChfYyA9IHN0c0NyZWRlbnRpYWxzT3B0aW9ucy5hY3RpbmdQYXJ0eSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjdG9yVG9rZW5UeXBlLFxuICAgICAgICAgICAgLy8gTm9uLXN0YW5kYXJkIEdDUC1zcGVjaWZpYyBvcHRpb25zLlxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyAmJiBKU09OLnN0cmluZ2lmeShvcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVtb3ZlIHVuZGVmaW5lZCBmaWVsZHMuXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICB9O1xuICAgICAgICAvLyBJbmplY3QgYWRkaXRpb25hbCBTVFMgaGVhZGVycyBpZiBhdmFpbGFibGUuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywgYWRkaXRpb25hbEhlYWRlcnMgfHwge30pO1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgLi4uU3RzQ3JlZGVudGlhbHMuUkVUUllfQ09ORklHLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnRva2VuRXhjaGFuZ2VFbmRwb2ludC50b1N0cmluZygpLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgZGF0YTogcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHZhbHVlcyksXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQXBwbHkgT0F1dGggY2xpZW50IGF1dGhlbnRpY2F0aW9uLlxuICAgICAgICB0aGlzLmFwcGx5Q2xpZW50QXV0aGVudGljYXRpb25PcHRpb25zKG9wdHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgICAgICAvLyBTdWNjZXNzZnVsIHJlc3BvbnNlLlxuICAgICAgICAgICAgY29uc3Qgc3RzU3VjY2Vzc2Z1bFJlc3BvbnNlID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIHN0c1N1Y2Nlc3NmdWxSZXNwb25zZS5yZXMgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiBzdHNTdWNjZXNzZnVsUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgZXJyb3IgdG8gT0F1dGhFcnJvci5cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGdheGlvc18xLkdheGlvc0Vycm9yICYmIGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIG9hdXRoMmNvbW1vbl8xLmdldEVycm9yRnJvbU9BdXRoRXJyb3JSZXNwb25zZSkoZXJyb3IucmVzcG9uc2UuZGF0YSwgXG4gICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgb3RoZXIgZmllbGRzIGZyb20gdGhlIG9yaWdpbmFsIGVycm9yLlxuICAgICAgICAgICAgICAgIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcXVlc3QgY291bGQgZmFpbCBiZWZvcmUgdGhlIHNlcnZlciByZXNwb25kcy5cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdHNDcmVkZW50aWFscyA9IFN0c0NyZWRlbnRpYWxzO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3RzQ3JlZGVudGlhbHMiLCJnYXhpb3NfMSIsInJlcXVpcmUiLCJxdWVyeXN0cmluZyIsInRyYW5zcG9ydGVyc18xIiwib2F1dGgyY29tbW9uXzEiLCJPQXV0aENsaWVudEF1dGhIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJ0b2tlbkV4Y2hhbmdlRW5kcG9pbnQiLCJjbGllbnRBdXRoZW50aWNhdGlvbiIsInRyYW5zcG9ydGVyIiwiRGVmYXVsdFRyYW5zcG9ydGVyIiwiZXhjaGFuZ2VUb2tlbiIsInN0c0NyZWRlbnRpYWxzT3B0aW9ucyIsImFkZGl0aW9uYWxIZWFkZXJzIiwib3B0aW9ucyIsIl9hIiwiX2IiLCJfYyIsInZhbHVlcyIsImdyYW50X3R5cGUiLCJncmFudFR5cGUiLCJyZXNvdXJjZSIsImF1ZGllbmNlIiwic2NvcGUiLCJqb2luIiwicmVxdWVzdGVkX3Rva2VuX3R5cGUiLCJyZXF1ZXN0ZWRUb2tlblR5cGUiLCJzdWJqZWN0X3Rva2VuIiwic3ViamVjdFRva2VuIiwic3ViamVjdF90b2tlbl90eXBlIiwic3ViamVjdFRva2VuVHlwZSIsImFjdG9yX3Rva2VuIiwiYWN0aW5nUGFydHkiLCJhY3RvclRva2VuIiwiYWN0b3JfdG9rZW5fdHlwZSIsImFjdG9yVG9rZW5UeXBlIiwiSlNPTiIsInN0cmluZ2lmeSIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiaGVhZGVycyIsImFzc2lnbiIsIm9wdHMiLCJSRVRSWV9DT05GSUciLCJ1cmwiLCJ0b1N0cmluZyIsIm1ldGhvZCIsImRhdGEiLCJyZXNwb25zZVR5cGUiLCJhcHBseUNsaWVudEF1dGhlbnRpY2F0aW9uT3B0aW9ucyIsInJlc3BvbnNlIiwicmVxdWVzdCIsInN0c1N1Y2Nlc3NmdWxSZXNwb25zZSIsInJlcyIsImVycm9yIiwiR2F4aW9zRXJyb3IiLCJnZXRFcnJvckZyb21PQXV0aEVycm9yUmVzcG9uc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/stscredentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js":
/*!************************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2024 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.UrlSubjectTokenSupplier = void 0;\n/**\n * Internal subject token supplier implementation used when a URL\n * is configured in the credential configuration used to build an {@link IdentityPoolClient}\n */ class UrlSubjectTokenSupplier {\n    /**\n     * Instantiates a URL subject token supplier.\n     * @param opts The URL subject token supplier options to build the supplier with.\n     */ constructor(opts){\n        this.url = opts.url;\n        this.formatType = opts.formatType;\n        this.subjectTokenFieldName = opts.subjectTokenFieldName;\n        this.headers = opts.headers;\n        this.additionalGaxiosOptions = opts.additionalGaxiosOptions;\n    }\n    /**\n     * Sends a GET request to the URL provided in the constructor and resolves\n     * with the returned external subject token.\n     * @param context {@link ExternalAccountSupplierContext} from the calling\n     *   {@link IdentityPoolClient}, contains the requested audience and subject\n     *   token type for the external account identity. Not used.\n     */ async getSubjectToken(context) {\n        const opts = {\n            ...this.additionalGaxiosOptions,\n            url: this.url,\n            method: \"GET\",\n            headers: this.headers,\n            responseType: this.formatType\n        };\n        let subjectToken;\n        if (this.formatType === \"text\") {\n            const response = await context.transporter.request(opts);\n            subjectToken = response.data;\n        } else if (this.formatType === \"json\" && this.subjectTokenFieldName) {\n            const response = await context.transporter.request(opts);\n            subjectToken = response.data[this.subjectTokenFieldName];\n        }\n        if (!subjectToken) {\n            throw new Error(\"Unable to parse the subject_token from the credential_source URL\");\n        }\n        return subjectToken;\n    }\n}\nexports.UrlSubjectTokenSupplier = UrlSubjectTokenSupplier;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvYXV0aC91cmxzdWJqZWN0dG9rZW5zdXBwbGllci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELCtCQUErQixHQUFHLEtBQUs7QUFDdkM7OztDQUdDLEdBQ0QsTUFBTUU7SUFDRjs7O0tBR0MsR0FDREMsWUFBWUMsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQyxHQUFHLEdBQUdELEtBQUtDLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxVQUFVLEdBQUdGLEtBQUtFLFVBQVU7UUFDakMsSUFBSSxDQUFDQyxxQkFBcUIsR0FBR0gsS0FBS0cscUJBQXFCO1FBQ3ZELElBQUksQ0FBQ0MsT0FBTyxHQUFHSixLQUFLSSxPQUFPO1FBQzNCLElBQUksQ0FBQ0MsdUJBQXVCLEdBQUdMLEtBQUtLLHVCQUF1QjtJQUMvRDtJQUNBOzs7Ozs7S0FNQyxHQUNELE1BQU1DLGdCQUFnQkMsT0FBTyxFQUFFO1FBQzNCLE1BQU1QLE9BQU87WUFDVCxHQUFHLElBQUksQ0FBQ0ssdUJBQXVCO1lBQy9CSixLQUFLLElBQUksQ0FBQ0EsR0FBRztZQUNiTyxRQUFRO1lBQ1JKLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCSyxjQUFjLElBQUksQ0FBQ1AsVUFBVTtRQUNqQztRQUNBLElBQUlRO1FBQ0osSUFBSSxJQUFJLENBQUNSLFVBQVUsS0FBSyxRQUFRO1lBQzVCLE1BQU1TLFdBQVcsTUFBTUosUUFBUUssV0FBVyxDQUFDQyxPQUFPLENBQUNiO1lBQ25EVSxlQUFlQyxTQUFTRyxJQUFJO1FBQ2hDLE9BQ0ssSUFBSSxJQUFJLENBQUNaLFVBQVUsS0FBSyxVQUFVLElBQUksQ0FBQ0MscUJBQXFCLEVBQUU7WUFDL0QsTUFBTVEsV0FBVyxNQUFNSixRQUFRSyxXQUFXLENBQUNDLE9BQU8sQ0FBQ2I7WUFDbkRVLGVBQWVDLFNBQVNHLElBQUksQ0FBQyxJQUFJLENBQUNYLHFCQUFxQixDQUFDO1FBQzVEO1FBQ0EsSUFBSSxDQUFDTyxjQUFjO1lBQ2YsTUFBTSxJQUFJSyxNQUFNO1FBQ3BCO1FBQ0EsT0FBT0w7SUFDWDtBQUNKO0FBQ0FkLCtCQUErQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2F1dGgvdXJsc3ViamVjdHRva2Vuc3VwcGxpZXIuanM/MjJkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDI0IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VcmxTdWJqZWN0VG9rZW5TdXBwbGllciA9IHZvaWQgMDtcbi8qKlxuICogSW50ZXJuYWwgc3ViamVjdCB0b2tlbiBzdXBwbGllciBpbXBsZW1lbnRhdGlvbiB1c2VkIHdoZW4gYSBVUkxcbiAqIGlzIGNvbmZpZ3VyZWQgaW4gdGhlIGNyZWRlbnRpYWwgY29uZmlndXJhdGlvbiB1c2VkIHRvIGJ1aWxkIGFuIHtAbGluayBJZGVudGl0eVBvb2xDbGllbnR9XG4gKi9cbmNsYXNzIFVybFN1YmplY3RUb2tlblN1cHBsaWVyIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYSBVUkwgc3ViamVjdCB0b2tlbiBzdXBwbGllci5cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgVVJMIHN1YmplY3QgdG9rZW4gc3VwcGxpZXIgb3B0aW9ucyB0byBidWlsZCB0aGUgc3VwcGxpZXIgd2l0aC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHRoaXMudXJsID0gb3B0cy51cmw7XG4gICAgICAgIHRoaXMuZm9ybWF0VHlwZSA9IG9wdHMuZm9ybWF0VHlwZTtcbiAgICAgICAgdGhpcy5zdWJqZWN0VG9rZW5GaWVsZE5hbWUgPSBvcHRzLnN1YmplY3RUb2tlbkZpZWxkTmFtZTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gb3B0cy5oZWFkZXJzO1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxHYXhpb3NPcHRpb25zID0gb3B0cy5hZGRpdGlvbmFsR2F4aW9zT3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBHRVQgcmVxdWVzdCB0byB0aGUgVVJMIHByb3ZpZGVkIGluIHRoZSBjb25zdHJ1Y3RvciBhbmQgcmVzb2x2ZXNcbiAgICAgKiB3aXRoIHRoZSByZXR1cm5lZCBleHRlcm5hbCBzdWJqZWN0IHRva2VuLlxuICAgICAqIEBwYXJhbSBjb250ZXh0IHtAbGluayBFeHRlcm5hbEFjY291bnRTdXBwbGllckNvbnRleHR9IGZyb20gdGhlIGNhbGxpbmdcbiAgICAgKiAgIHtAbGluayBJZGVudGl0eVBvb2xDbGllbnR9LCBjb250YWlucyB0aGUgcmVxdWVzdGVkIGF1ZGllbmNlIGFuZCBzdWJqZWN0XG4gICAgICogICB0b2tlbiB0eXBlIGZvciB0aGUgZXh0ZXJuYWwgYWNjb3VudCBpZGVudGl0eS4gTm90IHVzZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U3ViamVjdFRva2VuKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuYWRkaXRpb25hbEdheGlvc09wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogdGhpcy5mb3JtYXRUeXBlLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3ViamVjdFRva2VuO1xuICAgICAgICBpZiAodGhpcy5mb3JtYXRUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29udGV4dC50cmFuc3BvcnRlci5yZXF1ZXN0KG9wdHMpO1xuICAgICAgICAgICAgc3ViamVjdFRva2VuID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZvcm1hdFR5cGUgPT09ICdqc29uJyAmJiB0aGlzLnN1YmplY3RUb2tlbkZpZWxkTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb250ZXh0LnRyYW5zcG9ydGVyLnJlcXVlc3Qob3B0cyk7XG4gICAgICAgICAgICBzdWJqZWN0VG9rZW4gPSByZXNwb25zZS5kYXRhW3RoaXMuc3ViamVjdFRva2VuRmllbGROYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1YmplY3RUb2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgdGhlIHN1YmplY3RfdG9rZW4gZnJvbSB0aGUgY3JlZGVudGlhbF9zb3VyY2UgVVJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YmplY3RUb2tlbjtcbiAgICB9XG59XG5leHBvcnRzLlVybFN1YmplY3RUb2tlblN1cHBsaWVyID0gVXJsU3ViamVjdFRva2VuU3VwcGxpZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJVcmxTdWJqZWN0VG9rZW5TdXBwbGllciIsImNvbnN0cnVjdG9yIiwib3B0cyIsInVybCIsImZvcm1hdFR5cGUiLCJzdWJqZWN0VG9rZW5GaWVsZE5hbWUiLCJoZWFkZXJzIiwiYWRkaXRpb25hbEdheGlvc09wdGlvbnMiLCJnZXRTdWJqZWN0VG9rZW4iLCJjb250ZXh0IiwibWV0aG9kIiwicmVzcG9uc2VUeXBlIiwic3ViamVjdFRva2VuIiwicmVzcG9uc2UiLCJ0cmFuc3BvcnRlciIsInJlcXVlc3QiLCJkYXRhIiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/browser/crypto.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global window */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BrowserCrypto = void 0;\n// This file implements crypto functions we need using in-browser\n// SubtleCrypto interface `window.crypto.subtle`.\nconst base64js = __webpack_require__(/*! base64-js */ \"(rsc)/./node_modules/base64-js/index.js\");\nconst crypto_1 = __webpack_require__(/*! ../crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\");\nclass BrowserCrypto {\n    constructor(){\n        if (true) {\n            throw new Error(\"SubtleCrypto not found. Make sure it's an https:// website.\");\n        }\n    }\n    async sha256DigestBase64(str) {\n        // SubtleCrypto digest() method is async, so we must make\n        // this method async as well.\n        // To calculate SHA256 digest using SubtleCrypto, we first\n        // need to convert an input string to an ArrayBuffer:\n        const inputBuffer = new TextEncoder().encode(str);\n        // Result is ArrayBuffer as well.\n        const outputBuffer = await window.crypto.subtle.digest(\"SHA-256\", inputBuffer);\n        return base64js.fromByteArray(new Uint8Array(outputBuffer));\n    }\n    randomBytesBase64(count) {\n        const array = new Uint8Array(count);\n        window.crypto.getRandomValues(array);\n        return base64js.fromByteArray(array);\n    }\n    static padBase64(base64) {\n        // base64js requires padding, so let's add some '='\n        while(base64.length % 4 !== 0){\n            base64 += \"=\";\n        }\n        return base64;\n    }\n    async verify(pubkey, data, signature) {\n        const algo = {\n            name: \"RSASSA-PKCS1-v1_5\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        };\n        const dataArray = new TextEncoder().encode(data);\n        const signatureArray = base64js.toByteArray(BrowserCrypto.padBase64(signature));\n        const cryptoKey = await window.crypto.subtle.importKey(\"jwk\", pubkey, algo, true, [\n            \"verify\"\n        ]);\n        // SubtleCrypto's verify method is async so we must make\n        // this method async as well.\n        const result = await window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);\n        return result;\n    }\n    async sign(privateKey, data) {\n        const algo = {\n            name: \"RSASSA-PKCS1-v1_5\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        };\n        const dataArray = new TextEncoder().encode(data);\n        const cryptoKey = await window.crypto.subtle.importKey(\"jwk\", privateKey, algo, true, [\n            \"sign\"\n        ]);\n        // SubtleCrypto's sign method is async so we must make\n        // this method async as well.\n        const result = await window.crypto.subtle.sign(algo, cryptoKey, dataArray);\n        return base64js.fromByteArray(new Uint8Array(result));\n    }\n    decodeBase64StringUtf8(base64) {\n        const uint8array = base64js.toByteArray(BrowserCrypto.padBase64(base64));\n        const result = new TextDecoder().decode(uint8array);\n        return result;\n    }\n    encodeBase64StringUtf8(text) {\n        const uint8array = new TextEncoder().encode(text);\n        const result = base64js.fromByteArray(uint8array);\n        return result;\n    }\n    /**\n     * Computes the SHA-256 hash of the provided string.\n     * @param str The plain text string to hash.\n     * @return A promise that resolves with the SHA-256 hash of the provided\n     *   string in hexadecimal encoding.\n     */ async sha256DigestHex(str) {\n        // SubtleCrypto digest() method is async, so we must make\n        // this method async as well.\n        // To calculate SHA256 digest using SubtleCrypto, we first\n        // need to convert an input string to an ArrayBuffer:\n        const inputBuffer = new TextEncoder().encode(str);\n        // Result is ArrayBuffer as well.\n        const outputBuffer = await window.crypto.subtle.digest(\"SHA-256\", inputBuffer);\n        return (0, crypto_1.fromArrayBufferToHex)(outputBuffer);\n    }\n    /**\n     * Computes the HMAC hash of a message using the provided crypto key and the\n     * SHA-256 algorithm.\n     * @param key The secret crypto key in utf-8 or ArrayBuffer format.\n     * @param msg The plain text message.\n     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer\n     *   format.\n     */ async signWithHmacSha256(key, msg) {\n        // Convert key, if provided in ArrayBuffer format, to string.\n        const rawKey = typeof key === \"string\" ? key : String.fromCharCode(...new Uint16Array(key));\n        const enc = new TextEncoder();\n        const cryptoKey = await window.crypto.subtle.importKey(\"raw\", enc.encode(rawKey), {\n            name: \"HMAC\",\n            hash: {\n                name: \"SHA-256\"\n            }\n        }, false, [\n            \"sign\"\n        ]);\n        return window.crypto.subtle.sign(\"HMAC\", cryptoKey, enc.encode(msg));\n    }\n}\nexports.BrowserCrypto = BrowserCrypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL2Jyb3dzZXIvY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDLGlCQUFpQixHQUNqQkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsaUVBQWlFO0FBQ2pFLGlEQUFpRDtBQUNqRCxNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQywwREFBVztBQUNwQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxzRkFBVztBQUNwQyxNQUFNRjtJQUNGSSxhQUFjO1FBQ1YsSUFBSSxJQUVrQ0csRUFBRTtZQUNwQyxNQUFNLElBQUlFLE1BQU07UUFDcEI7SUFDSjtJQUNBLE1BQU1DLG1CQUFtQkMsR0FBRyxFQUFFO1FBQzFCLHlEQUF5RDtRQUN6RCw2QkFBNkI7UUFDN0IsMERBQTBEO1FBQzFELHFEQUFxRDtRQUNyRCxNQUFNQyxjQUFjLElBQUlDLGNBQWNDLE1BQU0sQ0FBQ0g7UUFDN0MsaUNBQWlDO1FBQ2pDLE1BQU1JLGVBQWUsTUFBTVYsT0FBT0MsTUFBTSxDQUFDRSxNQUFNLENBQUNRLE1BQU0sQ0FBQyxXQUFXSjtRQUNsRSxPQUFPWCxTQUFTZ0IsYUFBYSxDQUFDLElBQUlDLFdBQVdIO0lBQ2pEO0lBQ0FJLGtCQUFrQkMsS0FBSyxFQUFFO1FBQ3JCLE1BQU1DLFFBQVEsSUFBSUgsV0FBV0U7UUFDN0JmLE9BQU9DLE1BQU0sQ0FBQ2dCLGVBQWUsQ0FBQ0Q7UUFDOUIsT0FBT3BCLFNBQVNnQixhQUFhLENBQUNJO0lBQ2xD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TSxDQUFDRSxNQUFNLENBQUMrQixJQUFJLENBQUMsUUFBUUgsV0FBV29CLElBQUkxQyxNQUFNLENBQUNxQztJQUNuRTtBQUNKO0FBQ0FyRCxxQkFBcUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWNvbW1lbnRlci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9jcnlwdG8vYnJvd3Nlci9jcnlwdG8uanM/ZmQ2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ccm93c2VyQ3J5cHRvID0gdm9pZCAwO1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgY3J5cHRvIGZ1bmN0aW9ucyB3ZSBuZWVkIHVzaW5nIGluLWJyb3dzZXJcbi8vIFN1YnRsZUNyeXB0byBpbnRlcmZhY2UgYHdpbmRvdy5jcnlwdG8uc3VidGxlYC5cbmNvbnN0IGJhc2U2NGpzID0gcmVxdWlyZShcImJhc2U2NC1qc1wiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4uL2NyeXB0b1wiKTtcbmNsYXNzIEJyb3dzZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgIHdpbmRvdy5jcnlwdG8gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgd2luZG93LmNyeXB0by5zdWJ0bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VidGxlQ3J5cHRvIG5vdCBmb3VuZC4gTWFrZSBzdXJlIGl0J3MgYW4gaHR0cHM6Ly8gd2Vic2l0ZS5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2hhMjU2RGlnZXN0QmFzZTY0KHN0cikge1xuICAgICAgICAvLyBTdWJ0bGVDcnlwdG8gZGlnZXN0KCkgbWV0aG9kIGlzIGFzeW5jLCBzbyB3ZSBtdXN0IG1ha2VcbiAgICAgICAgLy8gdGhpcyBtZXRob2QgYXN5bmMgYXMgd2VsbC5cbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIFNIQTI1NiBkaWdlc3QgdXNpbmcgU3VidGxlQ3J5cHRvLCB3ZSBmaXJzdFxuICAgICAgICAvLyBuZWVkIHRvIGNvbnZlcnQgYW4gaW5wdXQgc3RyaW5nIHRvIGFuIEFycmF5QnVmZmVyOlxuICAgICAgICBjb25zdCBpbnB1dEJ1ZmZlciA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpO1xuICAgICAgICAvLyBSZXN1bHQgaXMgQXJyYXlCdWZmZXIgYXMgd2VsbC5cbiAgICAgICAgY29uc3Qgb3V0cHV0QnVmZmVyID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZGlnZXN0KCdTSEEtMjU2JywgaW5wdXRCdWZmZXIpO1xuICAgICAgICByZXR1cm4gYmFzZTY0anMuZnJvbUJ5dGVBcnJheShuZXcgVWludDhBcnJheShvdXRwdXRCdWZmZXIpKTtcbiAgICB9XG4gICAgcmFuZG9tQnl0ZXNCYXNlNjQoY291bnQpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShjb3VudCk7XG4gICAgICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGJhc2U2NGpzLmZyb21CeXRlQXJyYXkoYXJyYXkpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFkQmFzZTY0KGJhc2U2NCkge1xuICAgICAgICAvLyBiYXNlNjRqcyByZXF1aXJlcyBwYWRkaW5nLCBzbyBsZXQncyBhZGQgc29tZSAnPSdcbiAgICAgICAgd2hpbGUgKGJhc2U2NC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICBiYXNlNjQgKz0gJz0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeShwdWJrZXksIGRhdGEsIHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBhbGdvID0ge1xuICAgICAgICAgICAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRhdGFBcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlQXJyYXkgPSBiYXNlNjRqcy50b0J5dGVBcnJheShCcm93c2VyQ3J5cHRvLnBhZEJhc2U2NChzaWduYXR1cmUpKTtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdqd2snLCBwdWJrZXksIGFsZ28sIHRydWUsIFsndmVyaWZ5J10pO1xuICAgICAgICAvLyBTdWJ0bGVDcnlwdG8ncyB2ZXJpZnkgbWV0aG9kIGlzIGFzeW5jIHNvIHdlIG11c3QgbWFrZVxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBhc3luYyBhcyB3ZWxsLlxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS52ZXJpZnkoYWxnbywgY3J5cHRvS2V5LCBzaWduYXR1cmVBcnJheSwgZGF0YUFycmF5KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgc2lnbihwcml2YXRlS2V5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGFsZ28gPSB7XG4gICAgICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICAgICAgaGFzaDogeyBuYW1lOiAnU0hBLTI1NicgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGF0YUFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGEpO1xuICAgICAgICBjb25zdCBjcnlwdG9LZXkgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIHByaXZhdGVLZXksIGFsZ28sIHRydWUsIFsnc2lnbiddKTtcbiAgICAgICAgLy8gU3VidGxlQ3J5cHRvJ3Mgc2lnbiBtZXRob2QgaXMgYXN5bmMgc28gd2UgbXVzdCBtYWtlXG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGFzeW5jIGFzIHdlbGwuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLnNpZ24oYWxnbywgY3J5cHRvS2V5LCBkYXRhQXJyYXkpO1xuICAgICAgICByZXR1cm4gYmFzZTY0anMuZnJvbUJ5dGVBcnJheShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9XG4gICAgZGVjb2RlQmFzZTY0U3RyaW5nVXRmOChiYXNlNjQpIHtcbiAgICAgICAgY29uc3QgdWludDhhcnJheSA9IGJhc2U2NGpzLnRvQnl0ZUFycmF5KEJyb3dzZXJDcnlwdG8ucGFkQmFzZTY0KGJhc2U2NCkpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodWludDhhcnJheSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVuY29kZUJhc2U2NFN0cmluZ1V0ZjgodGV4dCkge1xuICAgICAgICBjb25zdCB1aW50OGFycmF5ID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRleHQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBiYXNlNjRqcy5mcm9tQnl0ZUFycmF5KHVpbnQ4YXJyYXkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgU0hBLTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHN0ciBUaGUgcGxhaW4gdGV4dCBzdHJpbmcgdG8gaGFzaC5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIFNIQS0yNTYgaGFzaCBvZiB0aGUgcHJvdmlkZWRcbiAgICAgKiAgIHN0cmluZyBpbiBoZXhhZGVjaW1hbCBlbmNvZGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBzaGEyNTZEaWdlc3RIZXgoc3RyKSB7XG4gICAgICAgIC8vIFN1YnRsZUNyeXB0byBkaWdlc3QoKSBtZXRob2QgaXMgYXN5bmMsIHNvIHdlIG11c3QgbWFrZVxuICAgICAgICAvLyB0aGlzIG1ldGhvZCBhc3luYyBhcyB3ZWxsLlxuICAgICAgICAvLyBUbyBjYWxjdWxhdGUgU0hBMjU2IGRpZ2VzdCB1c2luZyBTdWJ0bGVDcnlwdG8sIHdlIGZpcnN0XG4gICAgICAgIC8vIG5lZWQgdG8gY29udmVydCBhbiBpbnB1dCBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXI6XG4gICAgICAgIGNvbnN0IGlucHV0QnVmZmVyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG4gICAgICAgIC8vIFJlc3VsdCBpcyBBcnJheUJ1ZmZlciBhcyB3ZWxsLlxuICAgICAgICBjb25zdCBvdXRwdXRCdWZmZXIgPSBhd2FpdCB3aW5kb3cuY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBpbnB1dEJ1ZmZlcik7XG4gICAgICAgIHJldHVybiAoMCwgY3J5cHRvXzEuZnJvbUFycmF5QnVmZmVyVG9IZXgpKG91dHB1dEJ1ZmZlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBITUFDIGhhc2ggb2YgYSBtZXNzYWdlIHVzaW5nIHRoZSBwcm92aWRlZCBjcnlwdG8ga2V5IGFuZCB0aGVcbiAgICAgKiBTSEEtMjU2IGFsZ29yaXRobS5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBzZWNyZXQgY3J5cHRvIGtleSBpbiB1dGYtOCBvciBBcnJheUJ1ZmZlciBmb3JtYXQuXG4gICAgICogQHBhcmFtIG1zZyBUaGUgcGxhaW4gdGV4dCBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgSE1BQy1TSEEyNTYgaGFzaCBpbiBBcnJheUJ1ZmZlclxuICAgICAqICAgZm9ybWF0LlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25XaXRoSG1hY1NoYTI1NihrZXksIG1zZykge1xuICAgICAgICAvLyBDb252ZXJ0IGtleSwgaWYgcHJvdmlkZWQgaW4gQXJyYXlCdWZmZXIgZm9ybWF0LCB0byBzdHJpbmcuXG4gICAgICAgIGNvbnN0IHJhd0tleSA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50MTZBcnJheShrZXkpKTtcbiAgICAgICAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGNyeXB0b0tleSA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgZW5jLmVuY29kZShyYXdLZXkpLCB7XG4gICAgICAgICAgICBuYW1lOiAnSE1BQycsXG4gICAgICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ1NIQS0yNTYnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgZmFsc2UsIFsnc2lnbiddKTtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uc3VidGxlLnNpZ24oJ0hNQUMnLCBjcnlwdG9LZXksIGVuYy5lbmNvZGUobXNnKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyQ3J5cHRvID0gQnJvd3NlckNyeXB0bztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJyb3dzZXJDcnlwdG8iLCJiYXNlNjRqcyIsInJlcXVpcmUiLCJjcnlwdG9fMSIsImNvbnN0cnVjdG9yIiwid2luZG93IiwiY3J5cHRvIiwidW5kZWZpbmVkIiwic3VidGxlIiwiRXJyb3IiLCJzaGEyNTZEaWdlc3RCYXNlNjQiLCJzdHIiLCJpbnB1dEJ1ZmZlciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwib3V0cHV0QnVmZmVyIiwiZGlnZXN0IiwiZnJvbUJ5dGVBcnJheSIsIlVpbnQ4QXJyYXkiLCJyYW5kb21CeXRlc0Jhc2U2NCIsImNvdW50IiwiYXJyYXkiLCJnZXRSYW5kb21WYWx1ZXMiLCJwYWRCYXNlNjQiLCJiYXNlNjQiLCJsZW5ndGgiLCJ2ZXJpZnkiLCJwdWJrZXkiLCJkYXRhIiwic2lnbmF0dXJlIiwiYWxnbyIsIm5hbWUiLCJoYXNoIiwiZGF0YUFycmF5Iiwic2lnbmF0dXJlQXJyYXkiLCJ0b0J5dGVBcnJheSIsImNyeXB0b0tleSIsImltcG9ydEtleSIsInJlc3VsdCIsInNpZ24iLCJwcml2YXRlS2V5IiwiZGVjb2RlQmFzZTY0U3RyaW5nVXRmOCIsInVpbnQ4YXJyYXkiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsImVuY29kZUJhc2U2NFN0cmluZ1V0ZjgiLCJ0ZXh0Iiwic2hhMjU2RGlnZXN0SGV4IiwiZnJvbUFycmF5QnVmZmVyVG9IZXgiLCJzaWduV2l0aEhtYWNTaGEyNTYiLCJrZXkiLCJtc2ciLCJyYXdLZXkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJVaW50MTZBcnJheSIsImVuYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js":
/*!*********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/crypto.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global window */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createCrypto = createCrypto;\nexports.hasBrowserCrypto = hasBrowserCrypto;\nexports.fromArrayBufferToHex = fromArrayBufferToHex;\nconst crypto_1 = __webpack_require__(/*! ./browser/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/browser/crypto.js\");\nconst crypto_2 = __webpack_require__(/*! ./node/crypto */ \"(rsc)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js\");\nfunction createCrypto() {\n    if (hasBrowserCrypto()) {\n        return new crypto_1.BrowserCrypto();\n    }\n    return new crypto_2.NodeCrypto();\n}\nfunction hasBrowserCrypto() {\n    return  false && 0;\n}\n/**\n * Converts an ArrayBuffer to a hexadecimal string.\n * @param arrayBuffer The ArrayBuffer to convert to hexadecimal string.\n * @return The hexadecimal encoding of the ArrayBuffer.\n */ function fromArrayBufferToHex(arrayBuffer) {\n    // Convert buffer to byte array.\n    const byteArray = Array.from(new Uint8Array(arrayBuffer));\n    // Convert bytes to hex string.\n    return byteArray.map((byte)=>{\n        return byte.toString(16).padStart(2, \"0\");\n    }).join(\"\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQyxpQkFBaUIsR0FDakJBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0U7QUFDdkJGLHdCQUF3QixHQUFHRztBQUMzQkgsNEJBQTRCLEdBQUdJO0FBQy9CLE1BQU1DLFdBQVdDLG1CQUFPQSxDQUFDLHFHQUFrQjtBQUMzQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQywrRkFBZTtBQUN4QyxTQUFTSjtJQUNMLElBQUlDLG9CQUFvQjtRQUNwQixPQUFPLElBQUlFLFNBQVNHLGFBQWE7SUFDckM7SUFDQSxPQUFPLElBQUlELFNBQVNFLFVBQVU7QUFDbEM7QUFDQSxTQUFTTjtJQUNMLE9BQVEsTUFDcUIsSUFDekIsQ0FBZ0M7QUFDeEM7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0MscUJBQXFCUyxXQUFXO0lBQ3JDLGdDQUFnQztJQUNoQyxNQUFNQyxZQUFZQyxNQUFNQyxJQUFJLENBQUMsSUFBSUMsV0FBV0o7SUFDNUMsK0JBQStCO0lBQy9CLE9BQU9DLFVBQ0ZJLEdBQUcsQ0FBQ0MsQ0FBQUE7UUFDTCxPQUFPQSxLQUFLQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUc7SUFDekMsR0FDS0MsSUFBSSxDQUFDO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWNvbW1lbnRlci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9jcnlwdG8vY3J5cHRvLmpzPzQwOGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQ3J5cHRvID0gY3JlYXRlQ3J5cHRvO1xuZXhwb3J0cy5oYXNCcm93c2VyQ3J5cHRvID0gaGFzQnJvd3NlckNyeXB0bztcbmV4cG9ydHMuZnJvbUFycmF5QnVmZmVyVG9IZXggPSBmcm9tQXJyYXlCdWZmZXJUb0hleDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIi4vYnJvd3Nlci9jcnlwdG9cIik7XG5jb25zdCBjcnlwdG9fMiA9IHJlcXVpcmUoXCIuL25vZGUvY3J5cHRvXCIpO1xuZnVuY3Rpb24gY3JlYXRlQ3J5cHRvKCkge1xuICAgIGlmIChoYXNCcm93c2VyQ3J5cHRvKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjcnlwdG9fMS5Ccm93c2VyQ3J5cHRvKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgY3J5cHRvXzIuTm9kZUNyeXB0bygpO1xufVxuZnVuY3Rpb24gaGFzQnJvd3NlckNyeXB0bygpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiB3aW5kb3cuY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93LmNyeXB0by5zdWJ0bGUgIT09ICd1bmRlZmluZWQnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gQXJyYXlCdWZmZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcGFyYW0gYXJyYXlCdWZmZXIgVGhlIEFycmF5QnVmZmVyIHRvIGNvbnZlcnQgdG8gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybiBUaGUgaGV4YWRlY2ltYWwgZW5jb2Rpbmcgb2YgdGhlIEFycmF5QnVmZmVyLlxuICovXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXJUb0hleChhcnJheUJ1ZmZlcikge1xuICAgIC8vIENvbnZlcnQgYnVmZmVyIHRvIGJ5dGUgYXJyYXkuXG4gICAgY29uc3QgYnl0ZUFycmF5ID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgIC8vIENvbnZlcnQgYnl0ZXMgdG8gaGV4IHN0cmluZy5cbiAgICByZXR1cm4gYnl0ZUFycmF5XG4gICAgICAgIC5tYXAoYnl0ZSA9PiB7XG4gICAgICAgIHJldHVybiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUNyeXB0byIsImhhc0Jyb3dzZXJDcnlwdG8iLCJmcm9tQXJyYXlCdWZmZXJUb0hleCIsImNyeXB0b18xIiwicmVxdWlyZSIsImNyeXB0b18yIiwiQnJvd3NlckNyeXB0byIsIk5vZGVDcnlwdG8iLCJ3aW5kb3ciLCJjcnlwdG8iLCJzdWJ0bGUiLCJhcnJheUJ1ZmZlciIsImJ5dGVBcnJheSIsIkFycmF5IiwiZnJvbSIsIlVpbnQ4QXJyYXkiLCJtYXAiLCJieXRlIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/crypto/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js":
/*!**************************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/crypto/node/crypto.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.NodeCrypto = void 0;\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nclass NodeCrypto {\n    async sha256DigestBase64(str) {\n        return crypto.createHash(\"sha256\").update(str).digest(\"base64\");\n    }\n    randomBytesBase64(count) {\n        return crypto.randomBytes(count).toString(\"base64\");\n    }\n    async verify(pubkey, data, signature) {\n        const verifier = crypto.createVerify(\"RSA-SHA256\");\n        verifier.update(data);\n        verifier.end();\n        return verifier.verify(pubkey, signature, \"base64\");\n    }\n    async sign(privateKey, data) {\n        const signer = crypto.createSign(\"RSA-SHA256\");\n        signer.update(data);\n        signer.end();\n        return signer.sign(privateKey, \"base64\");\n    }\n    decodeBase64StringUtf8(base64) {\n        return Buffer.from(base64, \"base64\").toString(\"utf-8\");\n    }\n    encodeBase64StringUtf8(text) {\n        return Buffer.from(text, \"utf-8\").toString(\"base64\");\n    }\n    /**\n     * Computes the SHA-256 hash of the provided string.\n     * @param str The plain text string to hash.\n     * @return A promise that resolves with the SHA-256 hash of the provided\n     *   string in hexadecimal encoding.\n     */ async sha256DigestHex(str) {\n        return crypto.createHash(\"sha256\").update(str).digest(\"hex\");\n    }\n    /**\n     * Computes the HMAC hash of a message using the provided crypto key and the\n     * SHA-256 algorithm.\n     * @param key The secret crypto key in utf-8 or ArrayBuffer format.\n     * @param msg The plain text message.\n     * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer\n     *   format.\n     */ async signWithHmacSha256(key, msg) {\n        const cryptoKey = typeof key === \"string\" ? key : toBuffer(key);\n        return toArrayBuffer(crypto.createHmac(\"sha256\", cryptoKey).update(msg).digest());\n    }\n}\nexports.NodeCrypto = NodeCrypto;\n/**\n * Converts a Node.js Buffer to an ArrayBuffer.\n * https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer\n * @param buffer The Buffer input to covert.\n * @return The ArrayBuffer representation of the input.\n */ function toArrayBuffer(buffer) {\n    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n}\n/**\n * Converts an ArrayBuffer to a Node.js Buffer.\n * @param arrayBuffer The ArrayBuffer input to covert.\n * @return The Buffer representation of the input.\n */ function toBuffer(arrayBuffer) {\n    return Buffer.from(arrayBuffer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvY3J5cHRvL25vZGUvY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUMvQixNQUFNRjtJQUNGLE1BQU1HLG1CQUFtQkMsR0FBRyxFQUFFO1FBQzFCLE9BQU9ILE9BQU9JLFVBQVUsQ0FBQyxVQUFVQyxNQUFNLENBQUNGLEtBQUtHLE1BQU0sQ0FBQztJQUMxRDtJQUNBQyxrQkFBa0JDLEtBQUssRUFBRTtRQUNyQixPQUFPUixPQUFPUyxXQUFXLENBQUNELE9BQU9FLFFBQVEsQ0FBQztJQUM5QztJQUNBLE1BQU1DLE9BQU9DLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxTQUFTLEVBQUU7UUFDbEMsTUFBTUMsV0FBV2YsT0FBT2dCLFlBQVksQ0FBQztRQUNyQ0QsU0FBU1YsTUFBTSxDQUFDUTtRQUNoQkUsU0FBU0UsR0FBRztRQUNaLE9BQU9GLFNBQVNKLE1BQU0sQ0FBQ0MsUUFBUUUsV0FBVztJQUM5QztJQUNBLE1BQU1JLEtBQUtDLFVBQVUsRUFBRU4sSUFBSSxFQUFFO1FBQ3pCLE1BQU1PLFNBQVNwQixPQUFPcUIsVUFBVSxDQUFDO1FBQ2pDRCxPQUFPZixNQUFNLENBQUNRO1FBQ2RPLE9BQU9ILEdBQUc7UUFDVixPQUFPRyxPQUFPRixJQUFJLENBQUNDLFlBQVk7SUFDbkM7SUFDQUcsdUJBQXVCQyxNQUFNLEVBQUU7UUFDM0IsT0FBT0MsT0FBT0MsSUFBSSxDQUFDRixRQUFRLFVBQVViLFFBQVEsQ0FBQztJQUNsRDtJQUNBZ0IsdUJBQXVCQyxJQUFJLEVBQUU7UUFDekIsT0FBT0gsT0FBT0MsSUFBSSxDQUFDRSxNQUFNLFNBQVNqQixRQUFRLENBQUM7SUFDL0M7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU1rQixnQkFBZ0J6QixHQUFHLEVBQUU7UUFDdkIsT0FBT0gsT0FBT0ksVUFBVSxDQUFDLFVBQVVDLE1BQU0sQ0FBQ0YsS0FBS0csTUFBTSxDQUFDO0lBQzFEO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNELE1BQU11QixtQkFBbUJDLEdBQUcsRUFBRUMsR0FBRyxFQUFFO1FBQy9CLE1BQU1DLFlBQVksT0FBT0YsUUFBUSxXQUFXQSxNQUFNRyxTQUFTSDtRQUMzRCxPQUFPSSxjQUFjbEMsT0FBT21DLFVBQVUsQ0FBQyxVQUFVSCxXQUFXM0IsTUFBTSxDQUFDMEIsS0FBS3pCLE1BQU07SUFDbEY7QUFDSjtBQUNBVCxrQkFBa0IsR0FBR0U7QUFDckI7Ozs7O0NBS0MsR0FDRCxTQUFTbUMsY0FBY0UsTUFBTTtJQUN6QixPQUFPQSxPQUFPQSxNQUFNLENBQUNDLEtBQUssQ0FBQ0QsT0FBT0UsVUFBVSxFQUFFRixPQUFPRSxVQUFVLEdBQUdGLE9BQU9HLFVBQVU7QUFDdkY7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU04sU0FBU08sV0FBVztJQUN6QixPQUFPaEIsT0FBT0MsSUFBSSxDQUFDZTtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL2NyeXB0by9ub2RlL2NyeXB0by5qcz9lMmUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vZGVDcnlwdG8gPSB2b2lkIDA7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY2xhc3MgTm9kZUNyeXB0byB7XG4gICAgYXN5bmMgc2hhMjU2RGlnZXN0QmFzZTY0KHN0cikge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShzdHIpLmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgfVxuICAgIHJhbmRvbUJ5dGVzQmFzZTY0KGNvdW50KSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoY291bnQpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5KHB1YmtleSwgZGF0YSwgc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHZlcmlmaWVyID0gY3J5cHRvLmNyZWF0ZVZlcmlmeSgnUlNBLVNIQTI1NicpO1xuICAgICAgICB2ZXJpZmllci51cGRhdGUoZGF0YSk7XG4gICAgICAgIHZlcmlmaWVyLmVuZCgpO1xuICAgICAgICByZXR1cm4gdmVyaWZpZXIudmVyaWZ5KHB1YmtleSwgc2lnbmF0dXJlLCAnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ24ocHJpdmF0ZUtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbignUlNBLVNIQTI1NicpO1xuICAgICAgICBzaWduZXIudXBkYXRlKGRhdGEpO1xuICAgICAgICBzaWduZXIuZW5kKCk7XG4gICAgICAgIHJldHVybiBzaWduZXIuc2lnbihwcml2YXRlS2V5LCAnYmFzZTY0Jyk7XG4gICAgfVxuICAgIGRlY29kZUJhc2U2NFN0cmluZ1V0ZjgoYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShiYXNlNjQsICdiYXNlNjQnKS50b1N0cmluZygndXRmLTgnKTtcbiAgICB9XG4gICAgZW5jb2RlQmFzZTY0U3RyaW5nVXRmOCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0ZXh0LCAndXRmLTgnKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBTSEEtMjU2IGhhc2ggb2YgdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gc3RyIFRoZSBwbGFpbiB0ZXh0IHN0cmluZyB0byBoYXNoLlxuICAgICAqIEByZXR1cm4gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgU0hBLTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZFxuICAgICAqICAgc3RyaW5nIGluIGhleGFkZWNpbWFsIGVuY29kaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHNoYTI1NkRpZ2VzdEhleChzdHIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc3RyKS5kaWdlc3QoJ2hleCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgSE1BQyBoYXNoIG9mIGEgbWVzc2FnZSB1c2luZyB0aGUgcHJvdmlkZWQgY3J5cHRvIGtleSBhbmQgdGhlXG4gICAgICogU0hBLTI1NiBhbGdvcml0aG0uXG4gICAgICogQHBhcmFtIGtleSBUaGUgc2VjcmV0IGNyeXB0byBrZXkgaW4gdXRmLTggb3IgQXJyYXlCdWZmZXIgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBtc2cgVGhlIHBsYWluIHRleHQgbWVzc2FnZS5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIEhNQUMtU0hBMjU2IGhhc2ggaW4gQXJyYXlCdWZmZXJcbiAgICAgKiAgIGZvcm1hdC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduV2l0aEhtYWNTaGEyNTYoa2V5LCBtc2cpIHtcbiAgICAgICAgY29uc3QgY3J5cHRvS2V5ID0gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgPyBrZXkgOiB0b0J1ZmZlcihrZXkpO1xuICAgICAgICByZXR1cm4gdG9BcnJheUJ1ZmZlcihjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2JywgY3J5cHRvS2V5KS51cGRhdGUobXNnKS5kaWdlc3QoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob2RlQ3J5cHRvID0gTm9kZUNyeXB0bztcbi8qKlxuICogQ29udmVydHMgYSBOb2RlLmpzIEJ1ZmZlciB0byBhbiBBcnJheUJ1ZmZlci5cbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg2MDkyODkvY29udmVydC1hLWJpbmFyeS1ub2RlanMtYnVmZmVyLXRvLWphdmFzY3JpcHQtYXJyYXlidWZmZXJcbiAqIEBwYXJhbSBidWZmZXIgVGhlIEJ1ZmZlciBpbnB1dCB0byBjb3ZlcnQuXG4gKiBAcmV0dXJuIFRoZSBBcnJheUJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXIuc2xpY2UoYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlT2Zmc2V0ICsgYnVmZmVyLmJ5dGVMZW5ndGgpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBBcnJheUJ1ZmZlciB0byBhIE5vZGUuanMgQnVmZmVyLlxuICogQHBhcmFtIGFycmF5QnVmZmVyIFRoZSBBcnJheUJ1ZmZlciBpbnB1dCB0byBjb3ZlcnQuXG4gKiBAcmV0dXJuIFRoZSBCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlucHV0LlxuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcik7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJOb2RlQ3J5cHRvIiwiY3J5cHRvIiwicmVxdWlyZSIsInNoYTI1NkRpZ2VzdEJhc2U2NCIsInN0ciIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJkaWdlc3QiLCJyYW5kb21CeXRlc0Jhc2U2NCIsImNvdW50IiwicmFuZG9tQnl0ZXMiLCJ0b1N0cmluZyIsInZlcmlmeSIsInB1YmtleSIsImRhdGEiLCJzaWduYXR1cmUiLCJ2ZXJpZmllciIsImNyZWF0ZVZlcmlmeSIsImVuZCIsInNpZ24iLCJwcml2YXRlS2V5Iiwic2lnbmVyIiwiY3JlYXRlU2lnbiIsImRlY29kZUJhc2U2NFN0cmluZ1V0ZjgiLCJiYXNlNjQiLCJCdWZmZXIiLCJmcm9tIiwiZW5jb2RlQmFzZTY0U3RyaW5nVXRmOCIsInRleHQiLCJzaGEyNTZEaWdlc3RIZXgiLCJzaWduV2l0aEhtYWNTaGEyNTYiLCJrZXkiLCJtc2ciLCJjcnlwdG9LZXkiLCJ0b0J1ZmZlciIsInRvQXJyYXlCdWZmZXIiLCJjcmVhdGVIbWFjIiwiYnVmZmVyIiwic2xpY2UiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImFycmF5QnVmZmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/crypto/node/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.GoogleAuth = exports.auth = exports.DefaultTransporter = exports.PassThroughClient = exports.ExecutableError = exports.PluggableAuthClient = exports.DownscopedClient = exports.BaseExternalAccountClient = exports.ExternalAccountClient = exports.IdentityPoolClient = exports.AwsRequestSigner = exports.AwsClient = exports.UserRefreshClient = exports.LoginTicket = exports.ClientAuthentication = exports.OAuth2Client = exports.CodeChallengeMethod = exports.Impersonated = exports.JWT = exports.JWTAccess = exports.IdTokenClient = exports.IAMAuth = exports.GCPEnv = exports.Compute = exports.DEFAULT_UNIVERSE = exports.AuthClient = exports.gaxios = exports.gcpMetadata = void 0;\n// Copyright 2017 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst googleauth_1 = __webpack_require__(/*! ./auth/googleauth */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/googleauth.js\");\nObject.defineProperty(exports, \"GoogleAuth\", ({\n    enumerable: true,\n    get: function() {\n        return googleauth_1.GoogleAuth;\n    }\n}));\n// Export common deps to ensure types/instances are the exact match. Useful\n// for consistently configuring the library across versions.\nexports.gcpMetadata = __webpack_require__(/*! gcp-metadata */ \"(rsc)/./node_modules/gcp-metadata/build/src/index.js\");\nexports.gaxios = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nvar authclient_1 = __webpack_require__(/*! ./auth/authclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/authclient.js\");\nObject.defineProperty(exports, \"AuthClient\", ({\n    enumerable: true,\n    get: function() {\n        return authclient_1.AuthClient;\n    }\n}));\nObject.defineProperty(exports, \"DEFAULT_UNIVERSE\", ({\n    enumerable: true,\n    get: function() {\n        return authclient_1.DEFAULT_UNIVERSE;\n    }\n}));\nvar computeclient_1 = __webpack_require__(/*! ./auth/computeclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/computeclient.js\");\nObject.defineProperty(exports, \"Compute\", ({\n    enumerable: true,\n    get: function() {\n        return computeclient_1.Compute;\n    }\n}));\nvar envDetect_1 = __webpack_require__(/*! ./auth/envDetect */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/envDetect.js\");\nObject.defineProperty(exports, \"GCPEnv\", ({\n    enumerable: true,\n    get: function() {\n        return envDetect_1.GCPEnv;\n    }\n}));\nvar iam_1 = __webpack_require__(/*! ./auth/iam */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/iam.js\");\nObject.defineProperty(exports, \"IAMAuth\", ({\n    enumerable: true,\n    get: function() {\n        return iam_1.IAMAuth;\n    }\n}));\nvar idtokenclient_1 = __webpack_require__(/*! ./auth/idtokenclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/idtokenclient.js\");\nObject.defineProperty(exports, \"IdTokenClient\", ({\n    enumerable: true,\n    get: function() {\n        return idtokenclient_1.IdTokenClient;\n    }\n}));\nvar jwtaccess_1 = __webpack_require__(/*! ./auth/jwtaccess */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtaccess.js\");\nObject.defineProperty(exports, \"JWTAccess\", ({\n    enumerable: true,\n    get: function() {\n        return jwtaccess_1.JWTAccess;\n    }\n}));\nvar jwtclient_1 = __webpack_require__(/*! ./auth/jwtclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/jwtclient.js\");\nObject.defineProperty(exports, \"JWT\", ({\n    enumerable: true,\n    get: function() {\n        return jwtclient_1.JWT;\n    }\n}));\nvar impersonated_1 = __webpack_require__(/*! ./auth/impersonated */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/impersonated.js\");\nObject.defineProperty(exports, \"Impersonated\", ({\n    enumerable: true,\n    get: function() {\n        return impersonated_1.Impersonated;\n    }\n}));\nvar oauth2client_1 = __webpack_require__(/*! ./auth/oauth2client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/oauth2client.js\");\nObject.defineProperty(exports, \"CodeChallengeMethod\", ({\n    enumerable: true,\n    get: function() {\n        return oauth2client_1.CodeChallengeMethod;\n    }\n}));\nObject.defineProperty(exports, \"OAuth2Client\", ({\n    enumerable: true,\n    get: function() {\n        return oauth2client_1.OAuth2Client;\n    }\n}));\nObject.defineProperty(exports, \"ClientAuthentication\", ({\n    enumerable: true,\n    get: function() {\n        return oauth2client_1.ClientAuthentication;\n    }\n}));\nvar loginticket_1 = __webpack_require__(/*! ./auth/loginticket */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/loginticket.js\");\nObject.defineProperty(exports, \"LoginTicket\", ({\n    enumerable: true,\n    get: function() {\n        return loginticket_1.LoginTicket;\n    }\n}));\nvar refreshclient_1 = __webpack_require__(/*! ./auth/refreshclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/refreshclient.js\");\nObject.defineProperty(exports, \"UserRefreshClient\", ({\n    enumerable: true,\n    get: function() {\n        return refreshclient_1.UserRefreshClient;\n    }\n}));\nvar awsclient_1 = __webpack_require__(/*! ./auth/awsclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/awsclient.js\");\nObject.defineProperty(exports, \"AwsClient\", ({\n    enumerable: true,\n    get: function() {\n        return awsclient_1.AwsClient;\n    }\n}));\nvar awsrequestsigner_1 = __webpack_require__(/*! ./auth/awsrequestsigner */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/awsrequestsigner.js\");\nObject.defineProperty(exports, \"AwsRequestSigner\", ({\n    enumerable: true,\n    get: function() {\n        return awsrequestsigner_1.AwsRequestSigner;\n    }\n}));\nvar identitypoolclient_1 = __webpack_require__(/*! ./auth/identitypoolclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/identitypoolclient.js\");\nObject.defineProperty(exports, \"IdentityPoolClient\", ({\n    enumerable: true,\n    get: function() {\n        return identitypoolclient_1.IdentityPoolClient;\n    }\n}));\nvar externalclient_1 = __webpack_require__(/*! ./auth/externalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/externalclient.js\");\nObject.defineProperty(exports, \"ExternalAccountClient\", ({\n    enumerable: true,\n    get: function() {\n        return externalclient_1.ExternalAccountClient;\n    }\n}));\nvar baseexternalclient_1 = __webpack_require__(/*! ./auth/baseexternalclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/baseexternalclient.js\");\nObject.defineProperty(exports, \"BaseExternalAccountClient\", ({\n    enumerable: true,\n    get: function() {\n        return baseexternalclient_1.BaseExternalAccountClient;\n    }\n}));\nvar downscopedclient_1 = __webpack_require__(/*! ./auth/downscopedclient */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/downscopedclient.js\");\nObject.defineProperty(exports, \"DownscopedClient\", ({\n    enumerable: true,\n    get: function() {\n        return downscopedclient_1.DownscopedClient;\n    }\n}));\nvar pluggable_auth_client_1 = __webpack_require__(/*! ./auth/pluggable-auth-client */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js\");\nObject.defineProperty(exports, \"PluggableAuthClient\", ({\n    enumerable: true,\n    get: function() {\n        return pluggable_auth_client_1.PluggableAuthClient;\n    }\n}));\nObject.defineProperty(exports, \"ExecutableError\", ({\n    enumerable: true,\n    get: function() {\n        return pluggable_auth_client_1.ExecutableError;\n    }\n}));\nvar passthrough_1 = __webpack_require__(/*! ./auth/passthrough */ \"(rsc)/./node_modules/google-auth-library/build/src/auth/passthrough.js\");\nObject.defineProperty(exports, \"PassThroughClient\", ({\n    enumerable: true,\n    get: function() {\n        return passthrough_1.PassThroughClient;\n    }\n}));\nvar transporters_1 = __webpack_require__(/*! ./transporters */ \"(rsc)/./node_modules/google-auth-library/build/src/transporters.js\");\nObject.defineProperty(exports, \"DefaultTransporter\", ({\n    enumerable: true,\n    get: function() {\n        return transporters_1.DefaultTransporter;\n    }\n}));\nconst auth = new googleauth_1.GoogleAuth();\nexports.auth = auth;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxZQUFZLEdBQUdBLDBCQUEwQixHQUFHQSx5QkFBeUIsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSx3QkFBd0IsR0FBR0EsaUNBQWlDLEdBQUdBLDZCQUE2QixHQUFHQSwwQkFBMEIsR0FBR0Esd0JBQXdCLEdBQUdBLGlCQUFpQixHQUFHQSx5QkFBeUIsR0FBR0EsbUJBQW1CLEdBQUdBLDRCQUE0QixHQUFHQSxvQkFBb0IsR0FBR0EsMkJBQTJCLEdBQUdBLG9CQUFvQixHQUFHQSxXQUFXLEdBQUdBLGlCQUFpQixHQUFHQSxxQkFBcUIsR0FBR0EsZUFBZSxHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBR0Esd0JBQXdCLEdBQUdBLGtCQUFrQixHQUFHQSxjQUFjLEdBQUdBLG1CQUFtQixHQUFHLEtBQUs7QUFDeHFCLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQyxNQUFNOEIsZUFBZUMsbUJBQU9BLENBQUMsZ0dBQW1CO0FBQ2hEakMsOENBQTZDO0lBQUVrQyxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxhQUFhNUIsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hILDJFQUEyRTtBQUMzRSw0REFBNEQ7QUFDNURGLHFIQUE2QztBQUM3Q0Esb0dBQWtDO0FBQ2xDLElBQUlrQyxlQUFlSCxtQkFBT0EsQ0FBQyxnR0FBbUI7QUFDOUNqQyw4Q0FBNkM7SUFBRWtDLFlBQVk7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QUUsQ0FBQyxFQUFDO0FBQzFJLE1BQU1ELE9BQU8sSUFBSTJCLGFBQWE1QixVQUFVO0FBQ3hDRixZQUFZLEdBQUdHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1jb21tZW50ZXIvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvaW5kZXguanM/MDk2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR29vZ2xlQXV0aCA9IGV4cG9ydHMuYXV0aCA9IGV4cG9ydHMuRGVmYXVsdFRyYW5zcG9ydGVyID0gZXhwb3J0cy5QYXNzVGhyb3VnaENsaWVudCA9IGV4cG9ydHMuRXhlY3V0YWJsZUVycm9yID0gZXhwb3J0cy5QbHVnZ2FibGVBdXRoQ2xpZW50ID0gZXhwb3J0cy5Eb3duc2NvcGVkQ2xpZW50ID0gZXhwb3J0cy5CYXNlRXh0ZXJuYWxBY2NvdW50Q2xpZW50ID0gZXhwb3J0cy5FeHRlcm5hbEFjY291bnRDbGllbnQgPSBleHBvcnRzLklkZW50aXR5UG9vbENsaWVudCA9IGV4cG9ydHMuQXdzUmVxdWVzdFNpZ25lciA9IGV4cG9ydHMuQXdzQ2xpZW50ID0gZXhwb3J0cy5Vc2VyUmVmcmVzaENsaWVudCA9IGV4cG9ydHMuTG9naW5UaWNrZXQgPSBleHBvcnRzLkNsaWVudEF1dGhlbnRpY2F0aW9uID0gZXhwb3J0cy5PQXV0aDJDbGllbnQgPSBleHBvcnRzLkNvZGVDaGFsbGVuZ2VNZXRob2QgPSBleHBvcnRzLkltcGVyc29uYXRlZCA9IGV4cG9ydHMuSldUID0gZXhwb3J0cy5KV1RBY2Nlc3MgPSBleHBvcnRzLklkVG9rZW5DbGllbnQgPSBleHBvcnRzLklBTUF1dGggPSBleHBvcnRzLkdDUEVudiA9IGV4cG9ydHMuQ29tcHV0ZSA9IGV4cG9ydHMuREVGQVVMVF9VTklWRVJTRSA9IGV4cG9ydHMuQXV0aENsaWVudCA9IGV4cG9ydHMuZ2F4aW9zID0gZXhwb3J0cy5nY3BNZXRhZGF0YSA9IHZvaWQgMDtcbi8vIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY29uc3QgZ29vZ2xlYXV0aF8xID0gcmVxdWlyZShcIi4vYXV0aC9nb29nbGVhdXRoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR29vZ2xlQXV0aFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ29vZ2xlYXV0aF8xLkdvb2dsZUF1dGg7IH0gfSk7XG4vLyBFeHBvcnQgY29tbW9uIGRlcHMgdG8gZW5zdXJlIHR5cGVzL2luc3RhbmNlcyBhcmUgdGhlIGV4YWN0IG1hdGNoLiBVc2VmdWxcbi8vIGZvciBjb25zaXN0ZW50bHkgY29uZmlndXJpbmcgdGhlIGxpYnJhcnkgYWNyb3NzIHZlcnNpb25zLlxuZXhwb3J0cy5nY3BNZXRhZGF0YSA9IHJlcXVpcmUoXCJnY3AtbWV0YWRhdGFcIik7XG5leHBvcnRzLmdheGlvcyA9IHJlcXVpcmUoXCJnYXhpb3NcIik7XG52YXIgYXV0aGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9hdXRoY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXV0aENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXV0aGNsaWVudF8xLkF1dGhDbGllbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJERUZBVUxUX1VOSVZFUlNFXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhdXRoY2xpZW50XzEuREVGQVVMVF9VTklWRVJTRTsgfSB9KTtcbnZhciBjb21wdXRlY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2NvbXB1dGVjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb21wdXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wdXRlY2xpZW50XzEuQ29tcHV0ZTsgfSB9KTtcbnZhciBlbnZEZXRlY3RfMSA9IHJlcXVpcmUoXCIuL2F1dGgvZW52RGV0ZWN0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR0NQRW52XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnZEZXRlY3RfMS5HQ1BFbnY7IH0gfSk7XG52YXIgaWFtXzEgPSByZXF1aXJlKFwiLi9hdXRoL2lhbVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklBTUF1dGhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlhbV8xLklBTUF1dGg7IH0gfSk7XG52YXIgaWR0b2tlbmNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9pZHRva2VuY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSWRUb2tlbkNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaWR0b2tlbmNsaWVudF8xLklkVG9rZW5DbGllbnQ7IH0gfSk7XG52YXIgand0YWNjZXNzXzEgPSByZXF1aXJlKFwiLi9hdXRoL2p3dGFjY2Vzc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpXVEFjY2Vzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gand0YWNjZXNzXzEuSldUQWNjZXNzOyB9IH0pO1xudmFyIGp3dGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9qd3RjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKV1RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGp3dGNsaWVudF8xLkpXVDsgfSB9KTtcbnZhciBpbXBlcnNvbmF0ZWRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvaW1wZXJzb25hdGVkXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1wZXJzb25hdGVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbXBlcnNvbmF0ZWRfMS5JbXBlcnNvbmF0ZWQ7IH0gfSk7XG52YXIgb2F1dGgyY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL29hdXRoMmNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvZGVDaGFsbGVuZ2VNZXRob2RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9hdXRoMmNsaWVudF8xLkNvZGVDaGFsbGVuZ2VNZXRob2Q7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPQXV0aDJDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9hdXRoMmNsaWVudF8xLk9BdXRoMkNsaWVudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsaWVudEF1dGhlbnRpY2F0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvYXV0aDJjbGllbnRfMS5DbGllbnRBdXRoZW50aWNhdGlvbjsgfSB9KTtcbnZhciBsb2dpbnRpY2tldF8xID0gcmVxdWlyZShcIi4vYXV0aC9sb2dpbnRpY2tldFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ2luVGlja2V0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2dpbnRpY2tldF8xLkxvZ2luVGlja2V0OyB9IH0pO1xudmFyIHJlZnJlc2hjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2F1dGgvcmVmcmVzaGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVzZXJSZWZyZXNoQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZWZyZXNoY2xpZW50XzEuVXNlclJlZnJlc2hDbGllbnQ7IH0gfSk7XG52YXIgYXdzY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2F3c2NsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkF3c0NsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXdzY2xpZW50XzEuQXdzQ2xpZW50OyB9IH0pO1xudmFyIGF3c3JlcXVlc3RzaWduZXJfMSA9IHJlcXVpcmUoXCIuL2F1dGgvYXdzcmVxdWVzdHNpZ25lclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkF3c1JlcXVlc3RTaWduZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF3c3JlcXVlc3RzaWduZXJfMS5Bd3NSZXF1ZXN0U2lnbmVyOyB9IH0pO1xudmFyIGlkZW50aXR5cG9vbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9pZGVudGl0eXBvb2xjbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJZGVudGl0eVBvb2xDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlkZW50aXR5cG9vbGNsaWVudF8xLklkZW50aXR5UG9vbENsaWVudDsgfSB9KTtcbnZhciBleHRlcm5hbGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9leHRlcm5hbGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV4dGVybmFsQWNjb3VudENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXh0ZXJuYWxjbGllbnRfMS5FeHRlcm5hbEFjY291bnRDbGllbnQ7IH0gfSk7XG52YXIgYmFzZWV4dGVybmFsY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL2Jhc2VleHRlcm5hbGNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2VleHRlcm5hbGNsaWVudF8xLkJhc2VFeHRlcm5hbEFjY291bnRDbGllbnQ7IH0gfSk7XG52YXIgZG93bnNjb3BlZGNsaWVudF8xID0gcmVxdWlyZShcIi4vYXV0aC9kb3duc2NvcGVkY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG93bnNjb3BlZENsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG93bnNjb3BlZGNsaWVudF8xLkRvd25zY29wZWRDbGllbnQ7IH0gfSk7XG52YXIgcGx1Z2dhYmxlX2F1dGhfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hdXRoL3BsdWdnYWJsZS1hdXRoLWNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBsdWdnYWJsZUF1dGhDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBsdWdnYWJsZV9hdXRoX2NsaWVudF8xLlBsdWdnYWJsZUF1dGhDbGllbnQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeGVjdXRhYmxlRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBsdWdnYWJsZV9hdXRoX2NsaWVudF8xLkV4ZWN1dGFibGVFcnJvcjsgfSB9KTtcbnZhciBwYXNzdGhyb3VnaF8xID0gcmVxdWlyZShcIi4vYXV0aC9wYXNzdGhyb3VnaFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhc3NUaHJvdWdoQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXNzdGhyb3VnaF8xLlBhc3NUaHJvdWdoQ2xpZW50OyB9IH0pO1xudmFyIHRyYW5zcG9ydGVyc18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0ZXJzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVmYXVsdFRyYW5zcG9ydGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuc3BvcnRlcnNfMS5EZWZhdWx0VHJhbnNwb3J0ZXI7IH0gfSk7XG5jb25zdCBhdXRoID0gbmV3IGdvb2dsZWF1dGhfMS5Hb29nbGVBdXRoKCk7XG5leHBvcnRzLmF1dGggPSBhdXRoO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiR29vZ2xlQXV0aCIsImF1dGgiLCJEZWZhdWx0VHJhbnNwb3J0ZXIiLCJQYXNzVGhyb3VnaENsaWVudCIsIkV4ZWN1dGFibGVFcnJvciIsIlBsdWdnYWJsZUF1dGhDbGllbnQiLCJEb3duc2NvcGVkQ2xpZW50IiwiQmFzZUV4dGVybmFsQWNjb3VudENsaWVudCIsIkV4dGVybmFsQWNjb3VudENsaWVudCIsIklkZW50aXR5UG9vbENsaWVudCIsIkF3c1JlcXVlc3RTaWduZXIiLCJBd3NDbGllbnQiLCJVc2VyUmVmcmVzaENsaWVudCIsIkxvZ2luVGlja2V0IiwiQ2xpZW50QXV0aGVudGljYXRpb24iLCJPQXV0aDJDbGllbnQiLCJDb2RlQ2hhbGxlbmdlTWV0aG9kIiwiSW1wZXJzb25hdGVkIiwiSldUIiwiSldUQWNjZXNzIiwiSWRUb2tlbkNsaWVudCIsIklBTUF1dGgiLCJHQ1BFbnYiLCJDb21wdXRlIiwiREVGQVVMVF9VTklWRVJTRSIsIkF1dGhDbGllbnQiLCJnYXhpb3MiLCJnY3BNZXRhZGF0YSIsImdvb2dsZWF1dGhfMSIsInJlcXVpcmUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYXV0aGNsaWVudF8xIiwiY29tcHV0ZWNsaWVudF8xIiwiZW52RGV0ZWN0XzEiLCJpYW1fMSIsImlkdG9rZW5jbGllbnRfMSIsImp3dGFjY2Vzc18xIiwiand0Y2xpZW50XzEiLCJpbXBlcnNvbmF0ZWRfMSIsIm9hdXRoMmNsaWVudF8xIiwibG9naW50aWNrZXRfMSIsInJlZnJlc2hjbGllbnRfMSIsImF3c2NsaWVudF8xIiwiYXdzcmVxdWVzdHNpZ25lcl8xIiwiaWRlbnRpdHlwb29sY2xpZW50XzEiLCJleHRlcm5hbGNsaWVudF8xIiwiYmFzZWV4dGVybmFsY2xpZW50XzEiLCJkb3duc2NvcGVkY2xpZW50XzEiLCJwbHVnZ2FibGVfYXV0aF9jbGllbnRfMSIsInBhc3N0aHJvdWdoXzEiLCJ0cmFuc3BvcnRlcnNfMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/options.js":
/*!***************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/options.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Copyright 2017 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validate = validate;\n// Accepts an options object passed from the user to the API.  In the\n// previous version of the API, it referred to a `Request` options object.\n// Now it refers to an Axiox Request Config object.  This is here to help\n// ensure users don't pass invalid options when they upgrade from 0.x to 1.x.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validate(options) {\n    const vpairs = [\n        {\n            invalid: \"uri\",\n            expected: \"url\"\n        },\n        {\n            invalid: \"json\",\n            expected: \"data\"\n        },\n        {\n            invalid: \"qs\",\n            expected: \"params\"\n        }\n    ];\n    for (const pair of vpairs){\n        if (options[pair.invalid]) {\n            const e = `'${pair.invalid}' is not a valid configuration option. Please use '${pair.expected}' instead. This library is using Axios for requests. Please see https://github.com/axios/axios to learn more about the valid request options.`;\n            throw new Error(e);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQ0EsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHRTtBQUNuQixxRUFBcUU7QUFDckUsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSw2RUFBNkU7QUFDN0UsOERBQThEO0FBQzlELFNBQVNBLFNBQVNDLE9BQU87SUFDckIsTUFBTUMsU0FBUztRQUNYO1lBQUVDLFNBQVM7WUFBT0MsVUFBVTtRQUFNO1FBQ2xDO1lBQUVELFNBQVM7WUFBUUMsVUFBVTtRQUFPO1FBQ3BDO1lBQUVELFNBQVM7WUFBTUMsVUFBVTtRQUFTO0tBQ3ZDO0lBQ0QsS0FBSyxNQUFNQyxRQUFRSCxPQUFRO1FBQ3ZCLElBQUlELE9BQU8sQ0FBQ0ksS0FBS0YsT0FBTyxDQUFDLEVBQUU7WUFDdkIsTUFBTUcsSUFBSSxDQUFDLENBQUMsRUFBRUQsS0FBS0YsT0FBTyxDQUFDLG1EQUFtRCxFQUFFRSxLQUFLRCxRQUFRLENBQUMsNklBQTZJLENBQUM7WUFDNU8sTUFBTSxJQUFJRyxNQUFNRDtRQUNwQjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWNvbW1lbnRlci8uL25vZGVfbW9kdWxlcy9nb29nbGUtYXV0aC1saWJyYXJ5L2J1aWxkL3NyYy9vcHRpb25zLmpzPzUzNzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbi8vIEFjY2VwdHMgYW4gb3B0aW9ucyBvYmplY3QgcGFzc2VkIGZyb20gdGhlIHVzZXIgdG8gdGhlIEFQSS4gIEluIHRoZVxuLy8gcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgQVBJLCBpdCByZWZlcnJlZCB0byBhIGBSZXF1ZXN0YCBvcHRpb25zIG9iamVjdC5cbi8vIE5vdyBpdCByZWZlcnMgdG8gYW4gQXhpb3ggUmVxdWVzdCBDb25maWcgb2JqZWN0LiAgVGhpcyBpcyBoZXJlIHRvIGhlbHBcbi8vIGVuc3VyZSB1c2VycyBkb24ndCBwYXNzIGludmFsaWQgb3B0aW9ucyB3aGVuIHRoZXkgdXBncmFkZSBmcm9tIDAueCB0byAxLnguXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHZwYWlycyA9IFtcbiAgICAgICAgeyBpbnZhbGlkOiAndXJpJywgZXhwZWN0ZWQ6ICd1cmwnIH0sXG4gICAgICAgIHsgaW52YWxpZDogJ2pzb24nLCBleHBlY3RlZDogJ2RhdGEnIH0sXG4gICAgICAgIHsgaW52YWxpZDogJ3FzJywgZXhwZWN0ZWQ6ICdwYXJhbXMnIH0sXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IHBhaXIgb2YgdnBhaXJzKSB7XG4gICAgICAgIGlmIChvcHRpb25zW3BhaXIuaW52YWxpZF0pIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBgJyR7cGFpci5pbnZhbGlkfScgaXMgbm90IGEgdmFsaWQgY29uZmlndXJhdGlvbiBvcHRpb24uIFBsZWFzZSB1c2UgJyR7cGFpci5leHBlY3RlZH0nIGluc3RlYWQuIFRoaXMgbGlicmFyeSBpcyB1c2luZyBBeGlvcyBmb3IgcmVxdWVzdHMuIFBsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zIHRvIGxlYXJuIG1vcmUgYWJvdXQgdGhlIHZhbGlkIHJlcXVlc3Qgb3B0aW9ucy5gO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidmFsaWRhdGUiLCJvcHRpb25zIiwidnBhaXJzIiwiaW52YWxpZCIsImV4cGVjdGVkIiwicGFpciIsImUiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/transporters.js":
/*!********************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/transporters.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DefaultTransporter = void 0;\nconst gaxios_1 = __webpack_require__(/*! gaxios */ \"(rsc)/./node_modules/gaxios/build/src/index.js\");\nconst options_1 = __webpack_require__(/*! ./options */ \"(rsc)/./node_modules/google-auth-library/build/src/options.js\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst pkg = __webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/google-auth-library/package.json\");\nconst PRODUCT_NAME = \"google-api-nodejs-client\";\nclass DefaultTransporter {\n    constructor(){\n        /**\n         * A configurable, replacable `Gaxios` instance.\n         */ this.instance = new gaxios_1.Gaxios();\n    }\n    /**\n     * Configures request options before making a request.\n     * @param opts GaxiosOptions options.\n     * @return Configured options.\n     */ configure(opts = {}) {\n        opts.headers = opts.headers || {};\n        if (true) {\n            // set transporter user agent if not in browser\n            const uaValue = opts.headers[\"User-Agent\"];\n            if (!uaValue) {\n                opts.headers[\"User-Agent\"] = DefaultTransporter.USER_AGENT;\n            } else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {\n                opts.headers[\"User-Agent\"] = `${uaValue} ${DefaultTransporter.USER_AGENT}`;\n            }\n            // track google-auth-library-nodejs version:\n            if (!opts.headers[\"x-goog-api-client\"]) {\n                const nodeVersion = process.version.replace(/^v/, \"\");\n                opts.headers[\"x-goog-api-client\"] = `gl-node/${nodeVersion}`;\n            }\n        }\n        return opts;\n    }\n    /**\n     * Makes a request using Gaxios with given options.\n     * @param opts GaxiosOptions options.\n     * @param callback optional callback that contains GaxiosResponse object.\n     * @return GaxiosPromise, assuming no callback is passed.\n     */ request(opts) {\n        // ensure the user isn't passing in request-style options\n        opts = this.configure(opts);\n        (0, options_1.validate)(opts);\n        return this.instance.request(opts).catch((e)=>{\n            throw this.processError(e);\n        });\n    }\n    get defaults() {\n        return this.instance.defaults;\n    }\n    set defaults(opts) {\n        this.instance.defaults = opts;\n    }\n    /**\n     * Changes the error to include details from the body.\n     */ processError(e) {\n        const res = e.response;\n        const err = e;\n        const body = res ? res.data : null;\n        if (res && body && body.error && res.status !== 200) {\n            if (typeof body.error === \"string\") {\n                err.message = body.error;\n                err.status = res.status;\n            } else if (Array.isArray(body.error.errors)) {\n                err.message = body.error.errors.map((err2)=>err2.message).join(\"\\n\");\n                err.code = body.error.code;\n                err.errors = body.error.errors;\n            } else {\n                err.message = body.error.message;\n                err.code = body.error.code;\n            }\n        } else if (res && res.status >= 400) {\n            // Consider all 4xx and 5xx responses errors.\n            err.message = body;\n            err.status = res.status;\n        }\n        return err;\n    }\n}\nexports.DefaultTransporter = DefaultTransporter;\n/**\n * Default user agent.\n */ DefaultTransporter.USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvdHJhbnNwb3J0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsNEJBQTRCO0FBQzVCLEVBQUU7QUFDRixrRUFBa0U7QUFDbEUsbUVBQW1FO0FBQ25FLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Ysa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLDJFQUEyRTtBQUMzRSxzRUFBc0U7QUFDdEUsaUNBQWlDO0FBQ2pDQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMEJBQTBCLEdBQUcsS0FBSztBQUNsQyxNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyw4REFBUTtBQUNqQyxNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQyxnRkFBVztBQUNyQyw4REFBOEQ7QUFDOUQsTUFBTUUsTUFBTUYsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUcsZUFBZTtBQUNyQixNQUFNTDtJQUNGTSxhQUFjO1FBQ1Y7O1NBRUMsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJTixTQUFTTyxNQUFNO0lBQ3ZDO0lBQ0E7Ozs7S0FJQyxHQUNEQyxVQUFVQyxPQUFPLENBQUMsQ0FBQyxFQUFFO1FBQ2pCQSxLQUFLQyxPQUFPLEdBQUdELEtBQUtDLE9BQU8sSUFBSSxDQUFDO1FBQ2hDLElBQUksSUFBa0IsRUFBYTtZQUMvQiwrQ0FBK0M7WUFDL0MsTUFBTUMsVUFBVUYsS0FBS0MsT0FBTyxDQUFDLGFBQWE7WUFDMUMsSUFBSSxDQUFDQyxTQUFTO2dCQUNWRixLQUFLQyxPQUFPLENBQUMsYUFBYSxHQUFHWCxtQkFBbUJhLFVBQVU7WUFDOUQsT0FDSyxJQUFJLENBQUNELFFBQVFFLFFBQVEsQ0FBQyxDQUFDLEVBQUVULGFBQWEsQ0FBQyxDQUFDLEdBQUc7Z0JBQzVDSyxLQUFLQyxPQUFPLENBQUMsYUFBYSxHQUN0QixDQUFDLEVBQUVDLFFBQVEsQ0FBQyxFQUFFWixtQkFBbUJhLFVBQVUsQ0FBQyxDQUFDO1lBQ3JEO1lBQ0EsNENBQTRDO1lBQzVDLElBQUksQ0FBQ0gsS0FBS0MsT0FBTyxDQUFDLG9CQUFvQixFQUFFO2dCQUNwQyxNQUFNSSxjQUFjQyxRQUFRQyxPQUFPLENBQUNDLE9BQU8sQ0FBQyxNQUFNO2dCQUNsRFIsS0FBS0MsT0FBTyxDQUFDLG9CQUFvQixHQUFHLENBQUMsUUFBUSxFQUFFSSxZQUFZLENBQUM7WUFDaEU7UUFDSjtRQUNBLE9BQU9MO0lBQ1g7SUFDQTs7Ozs7S0FLQyxHQUNEUyxRQUFRVCxJQUFJLEVBQUU7UUFDVix5REFBeUQ7UUFDekRBLE9BQU8sSUFBSSxDQUFDRCxTQUFTLENBQUNDO1FBQ3JCLElBQUdQLFVBQVVpQixRQUFRLEVBQUVWO1FBQ3hCLE9BQU8sSUFBSSxDQUFDSCxRQUFRLENBQUNZLE9BQU8sQ0FBQ1QsTUFBTVcsS0FBSyxDQUFDQyxDQUFBQTtZQUNyQyxNQUFNLElBQUksQ0FBQ0MsWUFBWSxDQUFDRDtRQUM1QjtJQUNKO0lBQ0EsSUFBSUUsV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDakIsUUFBUSxDQUFDaUIsUUFBUTtJQUNqQztJQUNBLElBQUlBLFNBQVNkLElBQUksRUFBRTtRQUNmLElBQUksQ0FBQ0gsUUFBUSxDQUFDaUIsUUFBUSxHQUFHZDtJQUM3QjtJQUNBOztLQUVDLEdBQ0RhLGFBQWFELENBQUMsRUFBRTtRQUNaLE1BQU1HLE1BQU1ILEVBQUVJLFFBQVE7UUFDdEIsTUFBTUMsTUFBTUw7UUFDWixNQUFNTSxPQUFPSCxNQUFNQSxJQUFJSSxJQUFJLEdBQUc7UUFDOUIsSUFBSUosT0FBT0csUUFBUUEsS0FBS0UsS0FBSyxJQUFJTCxJQUFJTSxNQUFNLEtBQUssS0FBSztZQUNqRCxJQUFJLE9BQU9ILEtBQUtFLEtBQUssS0FBSyxVQUFVO2dCQUNoQ0gsSUFBSUssT0FBTyxHQUFHSixLQUFLRSxLQUFLO2dCQUN4QkgsSUFBSUksTUFBTSxHQUFHTixJQUFJTSxNQUFNO1lBQzNCLE9BQ0ssSUFBSUUsTUFBTUMsT0FBTyxDQUFDTixLQUFLRSxLQUFLLENBQUNLLE1BQU0sR0FBRztnQkFDdkNSLElBQUlLLE9BQU8sR0FBR0osS0FBS0UsS0FBSyxDQUFDSyxNQUFNLENBQzFCQyxHQUFHLENBQUMsQ0FBQ0MsT0FBU0EsS0FBS0wsT0FBTyxFQUMxQk0sSUFBSSxDQUFDO2dCQUNWWCxJQUFJWSxJQUFJLEdBQUdYLEtBQUtFLEtBQUssQ0FBQ1MsSUFBSTtnQkFDMUJaLElBQUlRLE1BQU0sR0FBR1AsS0FBS0UsS0FBSyxDQUFDSyxNQUFNO1lBQ2xDLE9BQ0s7Z0JBQ0RSLElBQUlLLE9BQU8sR0FBR0osS0FBS0UsS0FBSyxDQUFDRSxPQUFPO2dCQUNoQ0wsSUFBSVksSUFBSSxHQUFHWCxLQUFLRSxLQUFLLENBQUNTLElBQUk7WUFDOUI7UUFDSixPQUNLLElBQUlkLE9BQU9BLElBQUlNLE1BQU0sSUFBSSxLQUFLO1lBQy9CLDZDQUE2QztZQUM3Q0osSUFBSUssT0FBTyxHQUFHSjtZQUNkRCxJQUFJSSxNQUFNLEdBQUdOLElBQUlNLE1BQU07UUFDM0I7UUFDQSxPQUFPSjtJQUNYO0FBQ0o7QUFDQTdCLDBCQUEwQixHQUFHRTtBQUM3Qjs7Q0FFQyxHQUNEQSxtQkFBbUJhLFVBQVUsR0FBRyxDQUFDLEVBQUVSLGFBQWEsQ0FBQyxFQUFFRCxJQUFJYSxPQUFPLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL3RyYW5zcG9ydGVycy5qcz83Nzk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlZmF1bHRUcmFuc3BvcnRlciA9IHZvaWQgMDtcbmNvbnN0IGdheGlvc18xID0gcmVxdWlyZShcImdheGlvc1wiKTtcbmNvbnN0IG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL29wdGlvbnNcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuY29uc3QgcGtnID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBQUk9EVUNUX05BTUUgPSAnZ29vZ2xlLWFwaS1ub2RlanMtY2xpZW50JztcbmNsYXNzIERlZmF1bHRUcmFuc3BvcnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvbmZpZ3VyYWJsZSwgcmVwbGFjYWJsZSBgR2F4aW9zYCBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgZ2F4aW9zXzEuR2F4aW9zKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgcmVxdWVzdCBvcHRpb25zIGJlZm9yZSBtYWtpbmcgYSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzIEdheGlvc09wdGlvbnMgb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJuIENvbmZpZ3VyZWQgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb25maWd1cmUob3B0cyA9IHt9KSB7XG4gICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBzZXQgdHJhbnNwb3J0ZXIgdXNlciBhZ2VudCBpZiBub3QgaW4gYnJvd3NlclxuICAgICAgICAgICAgY29uc3QgdWFWYWx1ZSA9IG9wdHMuaGVhZGVyc1snVXNlci1BZ2VudCddO1xuICAgICAgICAgICAgaWYgKCF1YVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzWydVc2VyLUFnZW50J10gPSBEZWZhdWx0VHJhbnNwb3J0ZXIuVVNFUl9BR0VOVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF1YVZhbHVlLmluY2x1ZGVzKGAke1BST0RVQ1RfTkFNRX0vYCkpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnNbJ1VzZXItQWdlbnQnXSA9XG4gICAgICAgICAgICAgICAgICAgIGAke3VhVmFsdWV9ICR7RGVmYXVsdFRyYW5zcG9ydGVyLlVTRVJfQUdFTlR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyYWNrIGdvb2dsZS1hdXRoLWxpYnJhcnktbm9kZWpzIHZlcnNpb246XG4gICAgICAgICAgICBpZiAoIW9wdHMuaGVhZGVyc1sneC1nb29nLWFwaS1jbGllbnQnXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9uLnJlcGxhY2UoL152LywgJycpO1xuICAgICAgICAgICAgICAgIG9wdHMuaGVhZGVyc1sneC1nb29nLWFwaS1jbGllbnQnXSA9IGBnbC1ub2RlLyR7bm9kZVZlcnNpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgYSByZXF1ZXN0IHVzaW5nIEdheGlvcyB3aXRoIGdpdmVuIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdHMgR2F4aW9zT3B0aW9ucyBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBvcHRpb25hbCBjYWxsYmFjayB0aGF0IGNvbnRhaW5zIEdheGlvc1Jlc3BvbnNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIEdheGlvc1Byb21pc2UsIGFzc3VtaW5nIG5vIGNhbGxiYWNrIGlzIHBhc3NlZC5cbiAgICAgKi9cbiAgICByZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgLy8gZW5zdXJlIHRoZSB1c2VyIGlzbid0IHBhc3NpbmcgaW4gcmVxdWVzdC1zdHlsZSBvcHRpb25zXG4gICAgICAgIG9wdHMgPSB0aGlzLmNvbmZpZ3VyZShvcHRzKTtcbiAgICAgICAgKDAsIG9wdGlvbnNfMS52YWxpZGF0ZSkob3B0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlLnJlcXVlc3Qob3B0cykuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnByb2Nlc3NFcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBkZWZhdWx0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UuZGVmYXVsdHM7XG4gICAgfVxuICAgIHNldCBkZWZhdWx0cyhvcHRzKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UuZGVmYXVsdHMgPSBvcHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBlcnJvciB0byBpbmNsdWRlIGRldGFpbHMgZnJvbSB0aGUgYm9keS5cbiAgICAgKi9cbiAgICBwcm9jZXNzRXJyb3IoZSkge1xuICAgICAgICBjb25zdCByZXMgPSBlLnJlc3BvbnNlO1xuICAgICAgICBjb25zdCBlcnIgPSBlO1xuICAgICAgICBjb25zdCBib2R5ID0gcmVzID8gcmVzLmRhdGEgOiBudWxsO1xuICAgICAgICBpZiAocmVzICYmIGJvZHkgJiYgYm9keS5lcnJvciAmJiByZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYm9keS5lcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGJvZHkuZXJyb3I7XG4gICAgICAgICAgICAgICAgZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJvZHkuZXJyb3IuZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYm9keS5lcnJvci5lcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoZXJyMikgPT4gZXJyMi5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBib2R5LmVycm9yLmNvZGU7XG4gICAgICAgICAgICAgICAgZXJyLmVycm9ycyA9IGJvZHkuZXJyb3IuZXJyb3JzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBib2R5LmVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBib2R5LmVycm9yLmNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzICYmIHJlcy5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBhbGwgNHh4IGFuZCA1eHggcmVzcG9uc2VzIGVycm9ycy5cbiAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYm9keTtcbiAgICAgICAgICAgIGVyci5zdGF0dXMgPSByZXMuc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufVxuZXhwb3J0cy5EZWZhdWx0VHJhbnNwb3J0ZXIgPSBEZWZhdWx0VHJhbnNwb3J0ZXI7XG4vKipcbiAqIERlZmF1bHQgdXNlciBhZ2VudC5cbiAqL1xuRGVmYXVsdFRyYW5zcG9ydGVyLlVTRVJfQUdFTlQgPSBgJHtQUk9EVUNUX05BTUV9LyR7cGtnLnZlcnNpb259YDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRlZmF1bHRUcmFuc3BvcnRlciIsImdheGlvc18xIiwicmVxdWlyZSIsIm9wdGlvbnNfMSIsInBrZyIsIlBST0RVQ1RfTkFNRSIsImNvbnN0cnVjdG9yIiwiaW5zdGFuY2UiLCJHYXhpb3MiLCJjb25maWd1cmUiLCJvcHRzIiwiaGVhZGVycyIsInVhVmFsdWUiLCJVU0VSX0FHRU5UIiwiaW5jbHVkZXMiLCJub2RlVmVyc2lvbiIsInByb2Nlc3MiLCJ2ZXJzaW9uIiwicmVwbGFjZSIsInJlcXVlc3QiLCJ2YWxpZGF0ZSIsImNhdGNoIiwiZSIsInByb2Nlc3NFcnJvciIsImRlZmF1bHRzIiwicmVzIiwicmVzcG9uc2UiLCJlcnIiLCJib2R5IiwiZGF0YSIsImVycm9yIiwic3RhdHVzIiwibWVzc2FnZSIsIkFycmF5IiwiaXNBcnJheSIsImVycm9ycyIsIm1hcCIsImVycjIiLCJqb2luIiwiY29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/transporters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/build/src/util.js":
/*!************************************************************!*\
  !*** ./node_modules/google-auth-library/build/src/util.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _LRUCache_instances, _LRUCache_cache, _LRUCache_moveToEnd, _LRUCache_evict;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LRUCache = void 0;\nexports.snakeToCamel = snakeToCamel;\nexports.originalOrCamelOptions = originalOrCamelOptions;\n/**\n * Returns the camel case of a provided string.\n *\n * @remarks\n *\n * Match any `_` and not `_` pair, then return the uppercase of the not `_`\n * character.\n *\n * @internal\n *\n * @param str the string to convert\n * @returns the camelCase'd string\n */ function snakeToCamel(str) {\n    return str.replace(/([_][^_])/g, (match)=>match.slice(1).toUpperCase());\n}\n/**\n * Get the value of `obj[key]` or `obj[camelCaseKey]`, with a preference\n * for original, non-camelCase key.\n *\n * @param obj object to lookup a value in\n * @returns a `get` function for getting `obj[key || snakeKey]`, if available\n */ function originalOrCamelOptions(obj) {\n    /**\n     *\n     * @param key an index of object, preferably snake_case\n     * @returns the value `obj[key || snakeKey]`, if available\n     */ function get(key) {\n        var _a;\n        const o = obj || {};\n        return (_a = o[key]) !== null && _a !== void 0 ? _a : o[snakeToCamel(key)];\n    }\n    return {\n        get\n    };\n}\n/**\n * A simple LRU cache utility.\n * Not meant for external usage.\n *\n * @experimental\n * @internal\n */ class LRUCache {\n    constructor(options){\n        _LRUCache_instances.add(this);\n        /**\n         * Maps are in order. Thus, the older item is the first item.\n         *\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map}\n         */ _LRUCache_cache.set(this, new Map());\n        this.capacity = options.capacity;\n        this.maxAge = options.maxAge;\n    }\n    /**\n     * Add an item to the cache.\n     *\n     * @param key the key to upsert\n     * @param value the value of the key\n     */ set(key, value) {\n        __classPrivateFieldGet(this, _LRUCache_instances, \"m\", _LRUCache_moveToEnd).call(this, key, value);\n        __classPrivateFieldGet(this, _LRUCache_instances, \"m\", _LRUCache_evict).call(this);\n    }\n    /**\n     * Get an item from the cache.\n     *\n     * @param key the key to retrieve\n     */ get(key) {\n        const item = __classPrivateFieldGet(this, _LRUCache_cache, \"f\").get(key);\n        if (!item) return;\n        __classPrivateFieldGet(this, _LRUCache_instances, \"m\", _LRUCache_moveToEnd).call(this, key, item.value);\n        __classPrivateFieldGet(this, _LRUCache_instances, \"m\", _LRUCache_evict).call(this);\n        return item.value;\n    }\n}\nexports.LRUCache = LRUCache;\n_LRUCache_cache = new WeakMap(), _LRUCache_instances = new WeakSet(), _LRUCache_moveToEnd = function _LRUCache_moveToEnd(key, value) {\n    __classPrivateFieldGet(this, _LRUCache_cache, \"f\").delete(key);\n    __classPrivateFieldGet(this, _LRUCache_cache, \"f\").set(key, {\n        value,\n        lastAccessed: Date.now()\n    });\n}, _LRUCache_evict = function _LRUCache_evict() {\n    const cutoffDate = this.maxAge ? Date.now() - this.maxAge : 0;\n    /**\n     * Because we know Maps are in order, this item is both the\n     * last item in the list (capacity) and oldest (maxAge).\n     */ let oldestItem = __classPrivateFieldGet(this, _LRUCache_cache, \"f\").entries().next();\n    while(!oldestItem.done && (__classPrivateFieldGet(this, _LRUCache_cache, \"f\").size > this.capacity || // too many\n    oldestItem.value[1].lastAccessed < cutoffDate // too old\n    )){\n        __classPrivateFieldGet(this, _LRUCache_cache, \"f\").delete(oldestItem.value[0]);\n        oldestItem = __classPrivateFieldGet(this, _LRUCache_cache, \"f\").entries().next();\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWF1dGgtbGlicmFyeS9idWlsZC9zcmMvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG1FQUFtRTtBQUNuRSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGLGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwyRUFBMkU7QUFDM0Usc0VBQXNFO0FBQ3RFLGlDQUFpQztBQUNqQyxJQUFJQSx5QkFBeUIsSUFBSyxJQUFJLElBQUksQ0FBQ0Esc0JBQXNCLElBQUssU0FBVUMsUUFBUSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsQ0FBQztJQUNwRyxJQUFJRCxTQUFTLE9BQU8sQ0FBQ0MsR0FBRyxNQUFNLElBQUlDLFVBQVU7SUFDNUMsSUFBSSxPQUFPSCxVQUFVLGFBQWFELGFBQWFDLFNBQVMsQ0FBQ0UsSUFBSSxDQUFDRixNQUFNSSxHQUFHLENBQUNMLFdBQVcsTUFBTSxJQUFJSSxVQUFVO0lBQ3ZHLE9BQU9GLFNBQVMsTUFBTUMsSUFBSUQsU0FBUyxNQUFNQyxFQUFFRyxJQUFJLENBQUNOLFlBQVlHLElBQUlBLEVBQUVJLEtBQUssR0FBR04sTUFBTU8sR0FBRyxDQUFDUjtBQUN4RjtBQUNBLElBQUlTLHFCQUFxQkMsaUJBQWlCQyxxQkFBcUJDO0FBQy9EQyw4Q0FBNkM7SUFBRU4sT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RFEsZ0JBQWdCLEdBQUcsS0FBSztBQUN4QkEsb0JBQW9CLEdBQUdFO0FBQ3ZCRiw4QkFBOEIsR0FBR0c7QUFDakM7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsU0FBU0QsYUFBYUUsR0FBRztJQUNyQixPQUFPQSxJQUFJQyxPQUFPLENBQUMsY0FBY0MsQ0FBQUEsUUFBU0EsTUFBTUMsS0FBSyxDQUFDLEdBQUdDLFdBQVc7QUFDeEU7QUFDQTs7Ozs7O0NBTUMsR0FDRCxTQUFTTCx1QkFBdUJNLEdBQUc7SUFDL0I7Ozs7S0FJQyxHQUNELFNBQVNoQixJQUFJaUIsR0FBRztRQUNaLElBQUlDO1FBQ0osTUFBTUMsSUFBS0gsT0FBTyxDQUFDO1FBQ25CLE9BQU8sQ0FBQ0UsS0FBS0MsQ0FBQyxDQUFDRixJQUFJLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUlBLEtBQUtDLENBQUMsQ0FBQ1YsYUFBYVEsS0FBSztJQUM5RTtJQUNBLE9BQU87UUFBRWpCO0lBQUk7QUFDakI7QUFDQTs7Ozs7O0NBTUMsR0FDRCxNQUFNUTtJQUNGWSxZQUFZQyxPQUFPLENBQUU7UUFDakJwQixvQkFBb0JxQixHQUFHLENBQUMsSUFBSTtRQUM1Qjs7OztTQUlDLEdBQ0RwQixnQkFBZ0JxQixHQUFHLENBQUMsSUFBSSxFQUFFLElBQUlDO1FBQzlCLElBQUksQ0FBQ0MsUUFBUSxHQUFHSixRQUFRSSxRQUFRO1FBQ2hDLElBQUksQ0FBQ0MsTUFBTSxHQUFHTCxRQUFRSyxNQUFNO0lBQ2hDO0lBQ0E7Ozs7O0tBS0MsR0FDREgsSUFBSU4sR0FBRyxFQUFFbEIsS0FBSyxFQUFFO1FBQ1pSLHVCQUF1QixJQUFJLEVBQUVVLHFCQUFxQixLQUFLRSxxQkFBcUJMLElBQUksQ0FBQyxJQUFJLEVBQUVtQixLQUFLbEI7UUFDNUZSLHVCQUF1QixJQUFJLEVBQUVVLHFCQUFxQixLQUFLRyxpQkFBaUJOLElBQUksQ0FBQyxJQUFJO0lBQ3JGO0lBQ0E7Ozs7S0FJQyxHQUNERSxJQUFJaUIsR0FBRyxFQUFFO1FBQ0wsTUFBTVUsT0FBT3BDLHVCQUF1QixJQUFJLEVBQUVXLGlCQUFpQixLQUFLRixHQUFHLENBQUNpQjtRQUNwRSxJQUFJLENBQUNVLE1BQ0Q7UUFDSnBDLHVCQUF1QixJQUFJLEVBQUVVLHFCQUFxQixLQUFLRSxxQkFBcUJMLElBQUksQ0FBQyxJQUFJLEVBQUVtQixLQUFLVSxLQUFLNUIsS0FBSztRQUN0R1IsdUJBQXVCLElBQUksRUFBRVUscUJBQXFCLEtBQUtHLGlCQUFpQk4sSUFBSSxDQUFDLElBQUk7UUFDakYsT0FBTzZCLEtBQUs1QixLQUFLO0lBQ3JCO0FBQ0o7QUFDQVEsZ0JBQWdCLEdBQUdDO0FBQ25CTixrQkFBa0IsSUFBSTBCLFdBQVczQixzQkFBc0IsSUFBSTRCLFdBQVcxQixzQkFBc0IsU0FBU0Esb0JBQW9CYyxHQUFHLEVBQUVsQixLQUFLO0lBQy9IUix1QkFBdUIsSUFBSSxFQUFFVyxpQkFBaUIsS0FBSzRCLE1BQU0sQ0FBQ2I7SUFDMUQxQix1QkFBdUIsSUFBSSxFQUFFVyxpQkFBaUIsS0FBS3FCLEdBQUcsQ0FBQ04sS0FBSztRQUN4RGxCO1FBQ0FnQyxjQUFjQyxLQUFLQyxHQUFHO0lBQzFCO0FBQ0osR0FBRzdCLGtCQUFrQixTQUFTQTtJQUMxQixNQUFNOEIsYUFBYSxJQUFJLENBQUNSLE1BQU0sR0FBR00sS0FBS0MsR0FBRyxLQUFLLElBQUksQ0FBQ1AsTUFBTSxHQUFHO0lBQzVEOzs7S0FHQyxHQUNELElBQUlTLGFBQWE1Qyx1QkFBdUIsSUFBSSxFQUFFVyxpQkFBaUIsS0FBS2tDLE9BQU8sR0FBR0MsSUFBSTtJQUNsRixNQUFPLENBQUNGLFdBQVdHLElBQUksSUFDbEIvQyxDQUFBQSx1QkFBdUIsSUFBSSxFQUFFVyxpQkFBaUIsS0FBS3FDLElBQUksR0FBRyxJQUFJLENBQUNkLFFBQVEsSUFBSSxXQUFXO0lBQ25GVSxXQUFXcEMsS0FBSyxDQUFDLEVBQUUsQ0FBQ2dDLFlBQVksR0FBR0csV0FBWSxVQUFVO0lBQWIsRUFDbEQ7UUFDRTNDLHVCQUF1QixJQUFJLEVBQUVXLGlCQUFpQixLQUFLNEIsTUFBTSxDQUFDSyxXQUFXcEMsS0FBSyxDQUFDLEVBQUU7UUFDN0VvQyxhQUFhNUMsdUJBQXVCLElBQUksRUFBRVcsaUJBQWlCLEtBQUtrQyxPQUFPLEdBQUdDLElBQUk7SUFDbEY7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL2dvb2dsZS1hdXRoLWxpYnJhcnkvYnVpbGQvc3JjL3V0aWwuanM/YWYyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0xSVUNhY2hlX2luc3RhbmNlcywgX0xSVUNhY2hlX2NhY2hlLCBfTFJVQ2FjaGVfbW92ZVRvRW5kLCBfTFJVQ2FjaGVfZXZpY3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxSVUNhY2hlID0gdm9pZCAwO1xuZXhwb3J0cy5zbmFrZVRvQ2FtZWwgPSBzbmFrZVRvQ2FtZWw7XG5leHBvcnRzLm9yaWdpbmFsT3JDYW1lbE9wdGlvbnMgPSBvcmlnaW5hbE9yQ2FtZWxPcHRpb25zO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlIG9mIGEgcHJvdmlkZWQgc3RyaW5nLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogTWF0Y2ggYW55IGBfYCBhbmQgbm90IGBfYCBwYWlyLCB0aGVuIHJldHVybiB0aGUgdXBwZXJjYXNlIG9mIHRoZSBub3QgYF9gXG4gKiBjaGFyYWN0ZXIuXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHRoZSBjYW1lbENhc2UnZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gc25ha2VUb0NhbWVsKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFtfXVteX10pL2csIG1hdGNoID0+IG1hdGNoLnNsaWNlKDEpLnRvVXBwZXJDYXNlKCkpO1xufVxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBvYmpba2V5XWAgb3IgYG9ialtjYW1lbENhc2VLZXldYCwgd2l0aCBhIHByZWZlcmVuY2VcbiAqIGZvciBvcmlnaW5hbCwgbm9uLWNhbWVsQ2FzZSBrZXkuXG4gKlxuICogQHBhcmFtIG9iaiBvYmplY3QgdG8gbG9va3VwIGEgdmFsdWUgaW5cbiAqIEByZXR1cm5zIGEgYGdldGAgZnVuY3Rpb24gZm9yIGdldHRpbmcgYG9ialtrZXkgfHwgc25ha2VLZXldYCwgaWYgYXZhaWxhYmxlXG4gKi9cbmZ1bmN0aW9uIG9yaWdpbmFsT3JDYW1lbE9wdGlvbnMob2JqKSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IGFuIGluZGV4IG9mIG9iamVjdCwgcHJlZmVyYWJseSBzbmFrZV9jYXNlXG4gICAgICogQHJldHVybnMgdGhlIHZhbHVlIGBvYmpba2V5IHx8IHNuYWtlS2V5XWAsIGlmIGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvID0gKG9iaiB8fCB7fSk7XG4gICAgICAgIHJldHVybiAoX2EgPSBvW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9bc25ha2VUb0NhbWVsKGtleSldO1xuICAgIH1cbiAgICByZXR1cm4geyBnZXQgfTtcbn1cbi8qKlxuICogQSBzaW1wbGUgTFJVIGNhY2hlIHV0aWxpdHkuXG4gKiBOb3QgbWVhbnQgZm9yIGV4dGVybmFsIHVzYWdlLlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBMUlVDYWNoZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBfTFJVQ2FjaGVfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHMgYXJlIGluIG9yZGVyLiBUaHVzLCB0aGUgb2xkZXIgaXRlbSBpcyB0aGUgZmlyc3QgaXRlbS5cbiAgICAgICAgICpcbiAgICAgICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hcH1cbiAgICAgICAgICovXG4gICAgICAgIF9MUlVDYWNoZV9jYWNoZS5zZXQodGhpcywgbmV3IE1hcCgpKTtcbiAgICAgICAgdGhpcy5jYXBhY2l0eSA9IG9wdGlvbnMuY2FwYWNpdHk7XG4gICAgICAgIHRoaXMubWF4QWdlID0gb3B0aW9ucy5tYXhBZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBpdGVtIHRvIHRoZSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgdGhlIGtleSB0byB1cHNlcnRcbiAgICAgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIG9mIHRoZSBrZXlcbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9pbnN0YW5jZXMsIFwibVwiLCBfTFJVQ2FjaGVfbW92ZVRvRW5kKS5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9pbnN0YW5jZXMsIFwibVwiLCBfTFJVQ2FjaGVfZXZpY3QpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbiBpdGVtIGZyb20gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSB0aGUga2V5IHRvIHJldHJpZXZlXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBpdGVtID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTFJVQ2FjaGVfY2FjaGUsIFwiZlwiKS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFpdGVtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9pbnN0YW5jZXMsIFwibVwiLCBfTFJVQ2FjaGVfbW92ZVRvRW5kKS5jYWxsKHRoaXMsIGtleSwgaXRlbS52YWx1ZSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0xSVUNhY2hlX2luc3RhbmNlcywgXCJtXCIsIF9MUlVDYWNoZV9ldmljdCkuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5MUlVDYWNoZSA9IExSVUNhY2hlO1xuX0xSVUNhY2hlX2NhY2hlID0gbmV3IFdlYWtNYXAoKSwgX0xSVUNhY2hlX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9MUlVDYWNoZV9tb3ZlVG9FbmQgPSBmdW5jdGlvbiBfTFJVQ2FjaGVfbW92ZVRvRW5kKGtleSwgdmFsdWUpIHtcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9jYWNoZSwgXCJmXCIpLmRlbGV0ZShrZXkpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0xSVUNhY2hlX2NhY2hlLCBcImZcIikuc2V0KGtleSwge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbGFzdEFjY2Vzc2VkOiBEYXRlLm5vdygpLFxuICAgIH0pO1xufSwgX0xSVUNhY2hlX2V2aWN0ID0gZnVuY3Rpb24gX0xSVUNhY2hlX2V2aWN0KCkge1xuICAgIGNvbnN0IGN1dG9mZkRhdGUgPSB0aGlzLm1heEFnZSA/IERhdGUubm93KCkgLSB0aGlzLm1heEFnZSA6IDA7XG4gICAgLyoqXG4gICAgICogQmVjYXVzZSB3ZSBrbm93IE1hcHMgYXJlIGluIG9yZGVyLCB0aGlzIGl0ZW0gaXMgYm90aCB0aGVcbiAgICAgKiBsYXN0IGl0ZW0gaW4gdGhlIGxpc3QgKGNhcGFjaXR5KSBhbmQgb2xkZXN0IChtYXhBZ2UpLlxuICAgICAqL1xuICAgIGxldCBvbGRlc3RJdGVtID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTFJVQ2FjaGVfY2FjaGUsIFwiZlwiKS5lbnRyaWVzKCkubmV4dCgpO1xuICAgIHdoaWxlICghb2xkZXN0SXRlbS5kb25lICYmXG4gICAgICAgIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9jYWNoZSwgXCJmXCIpLnNpemUgPiB0aGlzLmNhcGFjaXR5IHx8IC8vIHRvbyBtYW55XG4gICAgICAgICAgICBvbGRlc3RJdGVtLnZhbHVlWzFdLmxhc3RBY2Nlc3NlZCA8IGN1dG9mZkRhdGUpIC8vIHRvbyBvbGRcbiAgICApIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTFJVQ2FjaGVfY2FjaGUsIFwiZlwiKS5kZWxldGUob2xkZXN0SXRlbS52YWx1ZVswXSk7XG4gICAgICAgIG9sZGVzdEl0ZW0gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MUlVDYWNoZV9jYWNoZSwgXCJmXCIpLmVudHJpZXMoKS5uZXh0KCk7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwicmVjZWl2ZXIiLCJzdGF0ZSIsImtpbmQiLCJmIiwiVHlwZUVycm9yIiwiaGFzIiwiY2FsbCIsInZhbHVlIiwiZ2V0IiwiX0xSVUNhY2hlX2luc3RhbmNlcyIsIl9MUlVDYWNoZV9jYWNoZSIsIl9MUlVDYWNoZV9tb3ZlVG9FbmQiLCJfTFJVQ2FjaGVfZXZpY3QiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJMUlVDYWNoZSIsInNuYWtlVG9DYW1lbCIsIm9yaWdpbmFsT3JDYW1lbE9wdGlvbnMiLCJzdHIiLCJyZXBsYWNlIiwibWF0Y2giLCJzbGljZSIsInRvVXBwZXJDYXNlIiwib2JqIiwia2V5IiwiX2EiLCJvIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiYWRkIiwic2V0IiwiTWFwIiwiY2FwYWNpdHkiLCJtYXhBZ2UiLCJpdGVtIiwiV2Vha01hcCIsIldlYWtTZXQiLCJkZWxldGUiLCJsYXN0QWNjZXNzZWQiLCJEYXRlIiwibm93IiwiY3V0b2ZmRGF0ZSIsIm9sZGVzdEl0ZW0iLCJlbnRyaWVzIiwibmV4dCIsImRvbmUiLCJzaXplIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-auth-library/build/src/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/google-auth-library/package.json":
/*!*******************************************************!*\
  !*** ./node_modules/google-auth-library/package.json ***!
  \*******************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"google-auth-library","version":"9.15.0","author":"Google Inc.","description":"Google APIs Authentication Client Library for Node.js","engines":{"node":">=14"},"main":"./build/src/index.js","types":"./build/src/index.d.ts","repository":"googleapis/google-auth-library-nodejs.git","keywords":["google","api","google apis","client","client library"],"dependencies":{"base64-js":"^1.3.0","ecdsa-sig-formatter":"^1.0.11","gaxios":"^6.1.1","gcp-metadata":"^6.1.0","gtoken":"^7.0.0","jws":"^4.0.0"},"devDependencies":{"@types/base64-js":"^1.2.5","@types/chai":"^4.1.7","@types/jws":"^3.1.0","@types/mocha":"^9.0.0","@types/mv":"^2.1.0","@types/ncp":"^2.0.1","@types/node":"^20.4.2","@types/sinon":"^17.0.0","assert-rejects":"^1.0.0","c8":"^8.0.0","chai":"^4.2.0","cheerio":"1.0.0-rc.12","codecov":"^3.0.2","execa":"^5.0.0","gts":"^5.0.0","is-docker":"^2.0.0","jsdoc":"^4.0.0","jsdoc-fresh":"^3.0.0","jsdoc-region-tag":"^3.0.0","karma":"^6.0.0","karma-chrome-launcher":"^3.0.0","karma-coverage":"^2.0.0","karma-firefox-launcher":"^2.0.0","karma-mocha":"^2.0.0","karma-sourcemap-loader":"^0.4.0","karma-webpack":"5.0.0","keypair":"^1.0.4","linkinator":"^4.0.0","mocha":"^9.2.2","mv":"^2.1.1","ncp":"^2.0.0","nock":"^13.0.0","null-loader":"^4.0.0","pdfmake":"0.2.12","puppeteer":"^21.0.0","sinon":"^18.0.0","ts-loader":"^8.0.0","typescript":"^5.1.6","webpack":"^5.21.2","webpack-cli":"^4.0.0"},"files":["build/src","!build/src/**/*.map"],"scripts":{"test":"c8 mocha build/test","clean":"gts clean","prepare":"npm run compile","lint":"gts check","compile":"tsc -p .","fix":"gts fix","pretest":"npm run compile -- --sourceMap","docs":"jsdoc -c .jsdoc.json","samples-setup":"cd samples/ && npm link ../ && npm run setup && cd ../","samples-test":"cd samples/ && npm link ../ && npm test && cd ../","system-test":"mocha build/system-test --timeout 60000","presystem-test":"npm run compile -- --sourceMap","webpack":"webpack","browser-test":"karma start","docs-test":"linkinator docs","predocs-test":"npm run docs","prelint":"cd samples; npm link ../; npm install","precompile":"gts clean"},"license":"Apache-2.0"}');

/***/ })

};
;
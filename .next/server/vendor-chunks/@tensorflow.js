"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tensorflow";
exports.ids = ["vendor-chunks/@tensorflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GraphModel: () => (/* binding */ GraphModel),\n/* harmony export */   deregisterOp: () => (/* binding */ deregisterOp),\n/* harmony export */   loadGraphModel: () => (/* binding */ loadGraphModel),\n/* harmony export */   registerOp: () => (/* binding */ registerOp),\n/* harmony export */   version_converter: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tensorflow/tfjs-core */ \"(ssr)/./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js\");\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */ \nvar DataType, SaverDef, __assign = function() {\n    return (__assign = Object.assign || function(e) {\n        for(var t, a = 1, r = arguments.length; a < r; a++)for(var n in t = arguments[a])Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n        return e;\n    }).apply(this, arguments);\n};\nfunction __awaiter(e, t, a, r) {\n    return new (a || (a = Promise))(function(n, s) {\n        function o(e) {\n            try {\n                u(r.next(e));\n            } catch (e) {\n                s(e);\n            }\n        }\n        function p(e) {\n            try {\n                u(r.throw(e));\n            } catch (e) {\n                s(e);\n            }\n        }\n        function u(e) {\n            e.done ? n(e.value) : new a(function(t) {\n                t(e.value);\n            }).then(o, p);\n        }\n        u((r = r.apply(e, t || [])).next());\n    });\n}\nfunction __generator(e, t) {\n    var a, r, n, s, o = {\n        label: 0,\n        sent: function() {\n            if (1 & n[0]) throw n[1];\n            return n[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return s = {\n        next: p(0),\n        throw: p(1),\n        return: p(2)\n    }, \"function\" == typeof Symbol && (s[Symbol.iterator] = function() {\n        return this;\n    }), s;\n    function p(s) {\n        return function(p) {\n            return function(s) {\n                if (a) throw new TypeError(\"Generator is already executing.\");\n                for(; o;)try {\n                    if (a = 1, r && (n = 2 & s[0] ? r.return : s[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, s[1])).done) return n;\n                    switch(r = 0, n && (s = [\n                        2 & s[0],\n                        n.value\n                    ]), s[0]){\n                        case 0:\n                        case 1:\n                            n = s;\n                            break;\n                        case 4:\n                            return o.label++, {\n                                value: s[1],\n                                done: !1\n                            };\n                        case 5:\n                            o.label++, r = s[1], s = [\n                                0\n                            ];\n                            continue;\n                        case 7:\n                            s = o.ops.pop(), o.trys.pop();\n                            continue;\n                        default:\n                            if (!(n = (n = o.trys).length > 0 && n[n.length - 1]) && (6 === s[0] || 2 === s[0])) {\n                                o = 0;\n                                continue;\n                            }\n                            if (3 === s[0] && (!n || s[1] > n[0] && s[1] < n[3])) {\n                                o.label = s[1];\n                                break;\n                            }\n                            if (6 === s[0] && o.label < n[1]) {\n                                o.label = n[1], n = s;\n                                break;\n                            }\n                            if (n && o.label < n[2]) {\n                                o.label = n[2], o.ops.push(s);\n                                break;\n                            }\n                            n[2] && o.ops.pop(), o.trys.pop();\n                            continue;\n                    }\n                    s = t.call(e, o);\n                } catch (e) {\n                    s = [\n                        6,\n                        e\n                    ], r = 0;\n                } finally{\n                    a = n = 0;\n                }\n                if (5 & s[0]) throw s[1];\n                return {\n                    value: s[0] ? s[1] : void 0,\n                    done: !0\n                };\n            }([\n                s,\n                p\n            ]);\n        };\n    }\n}\n!function(e) {\n    e[e.DT_INVALID = 0] = \"DT_INVALID\", e[e.DT_FLOAT = 1] = \"DT_FLOAT\", e[e.DT_DOUBLE = 2] = \"DT_DOUBLE\", e[e.DT_INT32 = 3] = \"DT_INT32\", e[e.DT_UINT8 = 4] = \"DT_UINT8\", e[e.DT_INT16 = 5] = \"DT_INT16\", e[e.DT_INT8 = 6] = \"DT_INT8\", e[e.DT_STRING = 7] = \"DT_STRING\", e[e.DT_COMPLEX64 = 8] = \"DT_COMPLEX64\", e[e.DT_INT64 = 9] = \"DT_INT64\", e[e.DT_BOOL = 10] = \"DT_BOOL\", e[e.DT_QINT8 = 11] = \"DT_QINT8\", e[e.DT_QUINT8 = 12] = \"DT_QUINT8\", e[e.DT_QINT32 = 13] = \"DT_QINT32\", e[e.DT_BFLOAT16 = 14] = \"DT_BFLOAT16\", e[e.DT_FLOAT_REF = 101] = \"DT_FLOAT_REF\", e[e.DT_DOUBLE_REF = 102] = \"DT_DOUBLE_REF\", e[e.DT_INT32_REF = 103] = \"DT_INT32_REF\", e[e.DT_UINT8_REF = 104] = \"DT_UINT8_REF\", e[e.DT_INT16_REF = 105] = \"DT_INT16_REF\", e[e.DT_INT8_REF = 106] = \"DT_INT8_REF\", e[e.DT_STRING_REF = 107] = \"DT_STRING_REF\", e[e.DT_COMPLEX64_REF = 108] = \"DT_COMPLEX64_REF\", e[e.DT_INT64_REF = 109] = \"DT_INT64_REF\", e[e.DT_BOOL_REF = 110] = \"DT_BOOL_REF\", e[e.DT_QINT8_REF = 111] = \"DT_QINT8_REF\", e[e.DT_QUINT8_REF = 112] = \"DT_QUINT8_REF\", e[e.DT_QINT32_REF = 113] = \"DT_QINT32_REF\", e[e.DT_BFLOAT16_REF = 114] = \"DT_BFLOAT16_REF\";\n}(DataType || (DataType = {})), function(e) {\n    !function(e) {\n        e[e.LEGACY = 0] = \"LEGACY\", e[e.V1 = 1] = \"V1\", e[e.V2 = 2] = \"V2\";\n    }(e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}));\n}(SaverDef || (SaverDef = {}));\nvar CUSTOM_OPS = {};\nfunction registerOp(e, t) {\n    var a = {\n        tfOpName: e,\n        category: \"custom\",\n        inputs: [],\n        attrs: [],\n        customExecutor: t\n    };\n    CUSTOM_OPS[e] = a;\n}\nfunction getRegisteredOp(e) {\n    return CUSTOM_OPS[e];\n}\nfunction deregisterOp(e) {\n    delete CUSTOM_OPS[e];\n}\nfunction getParamValue(e, t, a, r) {\n    var n = t.inputParams[e];\n    if (n && void 0 !== n.inputIndexStart) {\n        var s = n.inputIndexStart, o = 0 === n.inputIndexEnd ? void 0 : void 0 === n.inputIndexEnd ? s + 1 : n.inputIndexEnd;\n        if (\"tensor\" === n.type) return getTensor(t.inputNames[n.inputIndexStart], a, r);\n        if (\"tensors\" === n.type) return t.inputNames.slice(s, o).map(function(e) {\n            return getTensor(e, a, r);\n        });\n        var p = Array.prototype.slice.call(getTensor(t.inputNames.slice(s)[0], a, r).dataSync());\n        return \"number\" === n.type ? p[0] : p;\n    }\n    var u = t.attrParams[e];\n    return u && u.value;\n}\nfunction getTensor(e, t, a) {\n    var r = parseNodeName(e), n = r[0], s = r[1], o = a.currentContextIds.find(function(e) {\n        return !!t[getNodeNameWithContextId(n, e)];\n    });\n    return void 0 !== o ? t[getNodeNameWithContextId(n, o)][s] : void 0;\n}\nfunction getTensorsForCurrentContenxt(e, t, a) {\n    return t[getNodeNameWithContextId(e, a.currentContextId)];\n}\nfunction getNodeNameAndIndex(e, t) {\n    var a = parseNodeName(e), r = a[0], n = a[1];\n    return [\n        getNodeNameWithContextId(r, t && t.currentContextId),\n        n\n    ];\n}\nfunction getNodeNameWithContextId(e, t) {\n    return t ? e + \"-\" + t : e;\n}\nfunction parseNodeName(e) {\n    var t = e.lastIndexOf(\":\");\n    return -1 === t ? [\n        e,\n        0\n    ] : [\n        e.substring(0, t),\n        Number(e.substring(t + 1))\n    ];\n}\nfunction split$1(e, t) {\n    for(var a = [], r = 0; r < e.length; r += t)a.push(e.slice(r, r + t));\n    return a;\n}\nvar json = [\n    {\n        tfOpName: \"Add\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"AddV2\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"AddN\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                end: 0,\n                name: \"tensors\",\n                type: \"tensors\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"BiasAdd\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Sub\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"RealDiv\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Div\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"DivNoNan\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"FloorDiv\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Mul\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Maximum\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Minimum\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Pow\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"SquaredDifference\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Mod\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"FloorMod\",\n        category: \"arithmetic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    }\n], arithmetic = Object.freeze({\n    json: json\n}), json$1 = [\n    {\n        tfOpName: \"Abs\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Acos\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Asin\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Atan\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Atan2\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"y\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Ceil\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"ClipByValue\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"clip_value_min\",\n                name: \"clipValueMin\",\n                type: \"number\"\n            },\n            {\n                tfName: \"clip_value_max\",\n                name: \"clipValueMax\",\n                type: \"number\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Complex\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"real\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"imag\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"ComplexAbs\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Cos\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Cosh\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Elu\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Exp\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Floor\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Log\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Imag\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            },\n            {\n                tfName: \"Tout\",\n                name: \"outputType\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Neg\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Real\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            },\n            {\n                tfName: \"Tout\",\n                name: \"outputType\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Prelu\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"alpha\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Relu\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Relu6\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            },\n            {\n                tfName: \"clipValueMin\",\n                name: \"clipValueMin\",\n                type: \"number\",\n                defaultValue: 0\n            },\n            {\n                tfName: \"clipValueMax\",\n                name: \"clipValueMax\",\n                type: \"number\",\n                defaultValue: 6\n            }\n        ]\n    },\n    {\n        tfOpName: \"Selu\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Sigmoid\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Sin\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Sinh\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Sqrt\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Rsqrt\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Square\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Tan\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Tanh\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Sign\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Round\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Expm1\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Log1p\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Reciprocal\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Softplus\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Asinh\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Acosh\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Atanh\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Erf\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Prod\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axes\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"keep_dims\",\n                name: \"keepDims\",\n                type: \"bool\",\n                notSupported: !0\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"LeakyRelu\",\n        category: \"basic_math\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"alpha\",\n                name: \"alpha\",\n                type: \"number\",\n                defaultValue: .2\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    }\n], basicMath = Object.freeze({\n    json: json$1\n}), json$2 = [\n    {\n        tfOpName: \"LoopCond\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"pred\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Switch\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"data\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"pred\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Merge\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                end: 0,\n                name: \"tensors\",\n                type: \"tensors\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Enter\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensor\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            },\n            {\n                tfName: \"frame_name\",\n                name: \"frameName\",\n                type: \"string\"\n            },\n            {\n                tfName: \"is_constant\",\n                name: \"isConstant\",\n                type: \"bool\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Exit\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensor\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"NextIteration\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensor\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"TensorArrayV3\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"size\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"dtype\",\n                name: \"dtype\",\n                type: \"dtype\"\n            },\n            {\n                tfName: \"element_shape\",\n                name: \"elementShape\",\n                type: \"shape\"\n            },\n            {\n                tfName: \"dynamic_size\",\n                name: \"dynamicSize\",\n                type: \"bool\"\n            },\n            {\n                tfName: \"clear_after_read\",\n                name: \"clearAfterRead\",\n                type: \"bool\"\n            },\n            {\n                tfName: \"identical_element_shapes\",\n                name: \"identicalElementShapes\",\n                type: \"bool\"\n            },\n            {\n                tfName: \"tensor_array_name\",\n                name: \"name\",\n                type: \"string\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"TensorArrayWriteV3\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensorArrayId\",\n                type: \"number\"\n            },\n            {\n                start: 1,\n                name: \"index\",\n                type: \"number\"\n            },\n            {\n                start: 2,\n                name: \"tensor\",\n                type: \"tensor\"\n            },\n            {\n                start: 3,\n                name: \"flowIn\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"TensorArrayReadV3\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensorArrayId\",\n                type: \"number\"\n            },\n            {\n                start: 1,\n                name: \"index\",\n                type: \"number\"\n            },\n            {\n                start: 2,\n                name: \"flowIn\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"dtype\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"TensorArrayGatherV3\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensorArrayId\",\n                type: \"number\"\n            },\n            {\n                start: 1,\n                name: \"indices\",\n                type: \"number[]\"\n            },\n            {\n                start: 2,\n                name: \"flowIn\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"dtype\",\n                name: \"dtype\",\n                type: \"dtype\"\n            },\n            {\n                tfName: \"element_shape\",\n                name: \"elementShape\",\n                type: \"shape\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"TensorArrayScatterV3\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensorArrayId\",\n                type: \"number\"\n            },\n            {\n                start: 1,\n                name: \"indices\",\n                type: \"number[]\"\n            },\n            {\n                start: 2,\n                name: \"tensor\",\n                type: \"tensor\"\n            },\n            {\n                start: 3,\n                name: \"flowIn\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"TensorArrayConcatV3\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensorArrayId\",\n                type: \"number\"\n            },\n            {\n                start: 1,\n                name: \"flowIn\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"dtype\",\n                name: \"dtype\",\n                type: \"dtype\"\n            },\n            {\n                tfName: \"element_shape_except0\",\n                name: \"elementShapeExcept0\",\n                type: \"shape\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"TensorArraySplitV3\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensorArrayId\",\n                type: \"number\"\n            },\n            {\n                start: 1,\n                name: \"tensor\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"lengths\",\n                type: \"number[]\"\n            },\n            {\n                start: 3,\n                name: \"flowIn\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"TensorArraySizeV3\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensorArrayId\",\n                type: \"number\"\n            },\n            {\n                start: 1,\n                name: \"flowIn\",\n                type: \"number\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"TensorArrayCloseV3\",\n        category: \"control\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensorArrayId\",\n                type: \"number\"\n            }\n        ]\n    }\n], control = Object.freeze({\n    json: json$2\n}), json$3 = [\n    {\n        tfOpName: \"AvgPool\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                notSupported: !0\n            },\n            {\n                tfName: \"ksize\",\n                name: \"kernelSize\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"MaxPool\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                notSupported: !0\n            },\n            {\n                tfName: \"ksize\",\n                name: \"kernelSize\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"MaxPoolWithArgmax\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"ksize\",\n                name: \"kernelSize\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"include_batch_in_index\",\n                name: \"includeBatchInIndex\",\n                type: \"bool\"\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"AvgPool3D\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                notSupported: !0\n            },\n            {\n                tfName: \"ksize\",\n                name: \"kernelSize\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"MaxPool3D\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                notSupported: !0\n            },\n            {\n                tfName: \"ksize\",\n                name: \"kernelSize\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Conv1D\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"filter\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"stride\",\n                name: \"stride\",\n                type: \"number\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                defaultValue: \"NWC\"\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            },\n            {\n                tfName: \"dilation\",\n                name: \"dilation\",\n                type: \"number\",\n                defaultValue: 1\n            }\n        ]\n    },\n    {\n        tfOpName: \"Conv2D\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"filter\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            },\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"useCudnnOnGpu\",\n                name: \"useCudnnOnGpu\",\n                type: \"bool\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                defaultValue: \"NHWC\"\n            },\n            {\n                tfName: \"dilations\",\n                name: \"dilations\",\n                type: \"number[]\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"_FusedConv2D\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"filter\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                end: 0,\n                name: \"args\",\n                type: \"tensors\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"num_args\",\n                name: \"numArgs\",\n                type: \"number\"\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            },\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"explicit_paddings\",\n                name: \"explicitPaddings\",\n                type: \"number[]\",\n                defaultValue: []\n            },\n            {\n                tfName: \"use_cudnn_on_gpu\",\n                name: \"useCudnnOnGpu\",\n                type: \"bool\",\n                defaultValue: !0\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                defaultValue: \"NHWC\"\n            },\n            {\n                tfName: \"dilations\",\n                name: \"dilations\",\n                type: \"number[]\",\n                defaultValue: [\n                    1,\n                    1,\n                    1,\n                    1\n                ]\n            },\n            {\n                tfName: \"fused_ops\",\n                name: \"fusedOps\",\n                type: \"string[]\",\n                defaultValue: []\n            },\n            {\n                tfName: \"epsilon\",\n                name: \"epsilon\",\n                type: \"number\",\n                defaultValue: 1e-4\n            }\n        ]\n    },\n    {\n        tfOpName: \"Conv2DBackpropInput\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 2,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"filter\",\n                type: \"tensor\"\n            },\n            {\n                start: 0,\n                name: \"outputShape\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"DepthwiseConv2d\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"input\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"filter\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                defaultValue: \"NHWC\"\n            },\n            {\n                tfName: \"dilations\",\n                name: \"dilations\",\n                type: \"number[]\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"DepthwiseConv2dNative\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"input\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"filter\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                defaultValue: \"NHWC\"\n            },\n            {\n                tfName: \"dilations\",\n                name: \"dilations\",\n                type: \"number[]\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"FusedDepthwiseConv2dNative\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"filter\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                end: 0,\n                name: \"args\",\n                type: \"tensors\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"num_args\",\n                name: \"numArgs\",\n                type: \"number\"\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            },\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                defaultValue: \"NHWC\"\n            },\n            {\n                tfName: \"dilations\",\n                name: \"dilations\",\n                type: \"number[]\",\n                defaultValue: [\n                    1,\n                    1,\n                    1,\n                    1\n                ]\n            },\n            {\n                tfName: \"fused_ops\",\n                name: \"fusedOps\",\n                type: \"string[]\",\n                defaultValue: []\n            }\n        ]\n    },\n    {\n        tfOpName: \"Conv3D\",\n        category: \"convolution\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"filter\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"strides\",\n                name: \"strides\",\n                type: \"number[]\"\n            },\n            {\n                tfName: \"padding\",\n                name: \"pad\",\n                type: \"string\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                defaultValue: \"NHWC\"\n            },\n            {\n                tfName: \"dilations\",\n                name: \"dilations\",\n                type: \"number[]\"\n            }\n        ]\n    }\n], convolution = Object.freeze({\n    json: json$3\n}), json$4 = [\n    {\n        tfOpName: \"Fill\",\n        category: \"creation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"shape\",\n                type: \"number[]\"\n            },\n            {\n                start: 1,\n                name: \"value\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"LinSpace\",\n        category: \"creation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"start\",\n                type: \"number\"\n            },\n            {\n                start: 1,\n                name: \"stop\",\n                type: \"number\"\n            },\n            {\n                start: 2,\n                name: \"num\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"OneHot\",\n        category: \"creation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"indices\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"depth\",\n                type: \"number\"\n            },\n            {\n                start: 2,\n                name: \"onValue\",\n                type: \"number\",\n                defaultValue: 1\n            },\n            {\n                start: 3,\n                name: \"offValue\",\n                type: \"number\",\n                defaultValue: 0\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"axis\",\n                name: \"axis\",\n                type: \"number\",\n                notSupported: !0\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Ones\",\n        category: \"creation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"shape\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"OnesLike\",\n        category: \"creation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"dtype\",\n                name: \"dtype\",\n                type: \"dtype\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"RandomUniform\",\n        category: \"creation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"shape\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"minval\",\n                name: \"minval\",\n                type: \"number\",\n                defaultValue: 0\n            },\n            {\n                tfName: \"maxval\",\n                name: \"maxval\",\n                type: \"number\",\n                defaultValue: 1\n            },\n            {\n                tfName: \"dtype\",\n                name: \"dtype\",\n                type: \"dtype\"\n            },\n            {\n                tfName: \"seed\",\n                name: \"seed\",\n                type: \"number\",\n                defaultValue: 0\n            },\n            {\n                tfName: \"seed2\",\n                name: \"seed2\",\n                type: \"number\",\n                defaultValue: 0,\n                notSupported: !0\n            },\n            {\n                tfName: \"T\",\n                name: \"T\",\n                type: \"number\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Range\",\n        category: \"creation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"start\",\n                type: \"number\"\n            },\n            {\n                start: 1,\n                name: \"stop\",\n                type: \"number\"\n            },\n            {\n                start: 2,\n                name: \"step\",\n                type: \"number\",\n                defaultValue: 0\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"Tidx\",\n                name: \"dtype\",\n                type: \"dtype\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"TruncatedNormal\",\n        category: \"creation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"shape\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"means\",\n                name: \"mean\",\n                type: \"number\",\n                defaultValue: 0\n            },\n            {\n                tfName: \"stddev\",\n                name: \"stdDev\",\n                type: \"number\",\n                defaultValue: 1\n            },\n            {\n                tfName: \"seed\",\n                name: \"seed\",\n                type: \"number\"\n            },\n            {\n                tfName: \"seed2\",\n                name: \"seed2\",\n                type: \"number\",\n                defaultValue: 0,\n                notSupported: !0\n            },\n            {\n                tfName: \"dtype\",\n                name: \"dtype\",\n                type: \"dtype\"\n            },\n            {\n                tfName: \"T\",\n                name: \"T\",\n                type: \"number\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Zeros\",\n        category: \"creation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"shape\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"ZerosLike\",\n        category: \"creation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Multinomial\",\n        category: \"creation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"logits\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"numSamples\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"seed\",\n                name: \"seed\",\n                type: \"number\"\n            },\n            {\n                tfName: \"seed2\",\n                name: \"seed2\",\n                type: \"number\"\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\"\n            },\n            {\n                tfName: \"output_dtype\",\n                name: \"output_dtype\",\n                type: \"dtype\"\n            }\n        ]\n    }\n], creation = Object.freeze({\n    json: json$4\n}), json$5 = [\n    {\n        tfOpName: \"NonMaxSuppressionV2\",\n        category: \"dynamic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"boxes\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"scores\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"maxOutputSize\",\n                type: \"number\"\n            },\n            {\n                start: 3,\n                name: \"iouThreshold\",\n                type: \"number\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"NonMaxSuppressionV3\",\n        category: \"dynamic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"boxes\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"scores\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"maxOutputSize\",\n                type: \"number\"\n            },\n            {\n                start: 3,\n                name: \"iouThreshold\",\n                type: \"number\"\n            },\n            {\n                start: 4,\n                name: \"scoreThreshold\",\n                type: \"number\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"NonMaxSuppressionV5\",\n        category: \"dynamic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"boxes\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"scores\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"maxOutputSize\",\n                type: \"number\"\n            },\n            {\n                start: 3,\n                name: \"iouThreshold\",\n                type: \"number\"\n            },\n            {\n                start: 4,\n                name: \"scoreThreshold\",\n                type: \"number\"\n            },\n            {\n                start: 5,\n                name: \"softNmsSigma\",\n                type: \"number\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Where\",\n        category: \"dynamic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"condition\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"ListDiff\",\n        category: \"dynamic\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"y\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    }\n], dynamic = Object.freeze({\n    json: json$5\n}), json$6 = [\n    {\n        tfOpName: \"TopKV2\",\n        category: \"evaluation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"k\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"sorted\",\n                name: \"sorted\",\n                type: \"bool\"\n            }\n        ]\n    }\n], evaluation = Object.freeze({\n    json: json$6\n}), json$7 = [\n    {\n        tfOpName: \"PlaceholderWithDefault\",\n        category: \"graph\",\n        inputs: [\n            {\n                start: 0,\n                name: \"default\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"shape\",\n                name: \"shape\",\n                type: \"shape\"\n            },\n            {\n                tfName: \"dtype\",\n                name: \"dtype\",\n                type: \"dtype\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Placeholder\",\n        category: \"graph\",\n        attrs: [\n            {\n                tfName: \"shape\",\n                name: \"shape\",\n                type: \"shape\"\n            },\n            {\n                tfName: \"dtype\",\n                name: \"dtype\",\n                type: \"dtype\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Const\",\n        category: \"graph\"\n    },\n    {\n        tfOpName: \"Identity\",\n        category: \"graph\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"IdentityN\",\n        category: \"graph\",\n        inputs: [\n            {\n                start: 0,\n                end: 0,\n                name: \"x\",\n                type: \"tensors\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Snapshot\",\n        category: \"graph\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Rank\",\n        category: \"graph\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Size\",\n        category: \"graph\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Shape\",\n        category: \"graph\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"ShapeN\",\n        category: \"graph\",\n        inputs: [\n            {\n                start: 0,\n                end: 0,\n                name: \"x\",\n                type: \"tensors\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Print\",\n        category: \"graph\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"data\",\n                type: \"tensors\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"message\",\n                name: \"message\",\n                type: \"string\"\n            },\n            {\n                tfName: \"first_n\",\n                name: \"firstN\",\n                type: \"number\",\n                notSupported: !0\n            },\n            {\n                tfName: \"summarize\",\n                name: \"summarize\",\n                type: \"number\",\n                defaultValue: 3\n            }\n        ]\n    },\n    {\n        tfOpName: \"NoOp\",\n        category: \"graph\",\n        inputs: []\n    },\n    {\n        tfOpName: \"StopGradient\",\n        category: \"graph\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"FakeQuantWithMinMaxVars\",\n        category: \"graph\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"min\",\n                name: \"min\",\n                type: \"number\"\n            },\n            {\n                tfName: \"max\",\n                name: \"max\",\n                type: \"number\"\n            }\n        ]\n    }\n], graph = Object.freeze({\n    json: json$7\n}), json$8 = [\n    {\n        tfOpName: \"ResizeBilinear\",\n        category: \"image\",\n        inputs: [\n            {\n                start: 0,\n                name: \"images\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"size\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"align_corners\",\n                name: \"alignCorners\",\n                type: \"bool\"\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"ResizeNearestNeighbor\",\n        category: \"image\",\n        inputs: [\n            {\n                start: 0,\n                name: \"images\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"size\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"align_corners\",\n                name: \"alignCorners\",\n                type: \"bool\"\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"CropAndResize\",\n        category: \"image\",\n        inputs: [\n            {\n                start: 0,\n                name: \"image\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"boxes\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"boxInd\",\n                type: \"tensor\"\n            },\n            {\n                start: 3,\n                name: \"cropSize\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"method\",\n                name: \"method\",\n                type: \"string\"\n            },\n            {\n                tfName: \"extrapolation_value\",\n                name: \"extrapolationValue\",\n                type: \"number\"\n            }\n        ]\n    }\n], image$1 = Object.freeze({\n    json: json$8\n}), json$9 = [\n    {\n        tfOpName: \"Equal\",\n        category: \"logical\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"NotEqual\",\n        category: \"logical\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Greater\",\n        category: \"logical\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"GreaterEqual\",\n        category: \"logical\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Less\",\n        category: \"logical\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"LessEqual\",\n        category: \"logical\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"LogicalAnd\",\n        category: \"logical\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"LogicalNot\",\n        category: \"logical\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"LogicalOr\",\n        category: \"logical\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Select\",\n        category: \"logical\",\n        inputs: [\n            {\n                start: 0,\n                name: \"condition\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"SelectV2\",\n        category: \"logical\",\n        inputs: [\n            {\n                start: 0,\n                name: \"condition\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    }\n], logical = Object.freeze({\n    json: json$9\n}), json$10 = [\n    {\n        tfOpName: \"_FusedMatMul\",\n        category: \"matrices\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                end: 0,\n                name: \"args\",\n                type: \"tensors\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"num_args\",\n                name: \"numArgs\",\n                type: \"number\"\n            },\n            {\n                tfName: \"fused_ops\",\n                name: \"fusedOps\",\n                type: \"string[]\",\n                defaultValue: []\n            },\n            {\n                tfName: \"epsilon\",\n                name: \"epsilon\",\n                type: \"number\",\n                defaultValue: 1e-4\n            },\n            {\n                tfName: \"transpose_a\",\n                name: \"transposeA\",\n                type: \"bool\",\n                defaultValue: !1\n            },\n            {\n                tfName: \"transpose_b\",\n                name: \"transposeB\",\n                type: \"bool\",\n                defaultValue: !1\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"MatMul\",\n        category: \"matrices\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"transpose_a\",\n                name: \"transposeA\",\n                type: \"bool\",\n                defaultValue: !1\n            },\n            {\n                tfName: \"transpose_b\",\n                name: \"transposeB\",\n                type: \"bool\",\n                defaultValue: !1\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"BatchMatMul\",\n        category: \"matrices\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"adj_x\",\n                name: \"transposeA\",\n                type: \"bool\",\n                defaultValue: !1\n            },\n            {\n                tfName: \"adj_y\",\n                name: \"transposeB\",\n                type: \"bool\",\n                defaultValue: !1\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"BatchMatMulV2\",\n        category: \"matrices\",\n        inputs: [\n            {\n                start: 0,\n                name: \"a\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"b\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"adj_x\",\n                name: \"transposeA\",\n                type: \"bool\",\n                defaultValue: !1\n            },\n            {\n                tfName: \"adj_y\",\n                name: \"transposeB\",\n                type: \"bool\",\n                defaultValue: !1\n            },\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Transpose\",\n        category: \"matrices\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"perm\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"T\",\n                name: \"dtype\",\n                type: \"dtype\",\n                notSupported: !0\n            }\n        ]\n    }\n], matrices = Object.freeze({\n    json: json$10\n}), json$11 = [\n    {\n        tfOpName: \"FusedBatchNorm\",\n        category: \"normalization\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"scale\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"offset\",\n                type: \"tensor\"\n            },\n            {\n                start: 3,\n                name: \"mean\",\n                type: \"tensor\"\n            },\n            {\n                start: 4,\n                name: \"variance\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"epsilon\",\n                name: \"epsilon\",\n                type: \"number\",\n                defaultValue: .001\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"FusedBatchNormV2\",\n        category: \"normalization\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"scale\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"offset\",\n                type: \"tensor\"\n            },\n            {\n                start: 3,\n                name: \"mean\",\n                type: \"tensor\"\n            },\n            {\n                start: 4,\n                name: \"variance\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"epsilon\",\n                name: \"epsilon\",\n                type: \"number\",\n                defaultValue: .001\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"FusedBatchNormV3\",\n        category: \"normalization\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"scale\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"offset\",\n                type: \"tensor\"\n            },\n            {\n                start: 3,\n                name: \"mean\",\n                type: \"tensor\"\n            },\n            {\n                start: 4,\n                name: \"variance\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"epsilon\",\n                name: \"epsilon\",\n                type: \"number\",\n                defaultValue: .001\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"LRN\",\n        category: \"normalization\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"depth_radius\",\n                name: \"radius\",\n                type: \"number\",\n                defaultValue: 5\n            },\n            {\n                tfName: \"bias\",\n                name: \"bias\",\n                type: \"number\",\n                defaultValue: 1\n            },\n            {\n                tfName: \"alpha\",\n                name: \"alpha\",\n                type: \"number\",\n                defaultValue: 1\n            },\n            {\n                tfName: \"beta\",\n                name: \"beta\",\n                type: \"number\",\n                defaultValue: .5\n            }\n        ]\n    },\n    {\n        tfOpName: \"Softmax\",\n        category: \"normalization\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"LogSoftmax\",\n        category: \"normalization\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"SparseToDense\",\n        category: \"normalization\",\n        inputs: [\n            {\n                start: 0,\n                name: \"sparseIndices\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"outputShape\",\n                type: \"number[]\"\n            },\n            {\n                start: 2,\n                name: \"sparseValues\",\n                type: \"tensor\"\n            },\n            {\n                start: 3,\n                name: \"defaultValue\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"validate_indices\",\n                name: \"validateIndices\",\n                type: \"bool\",\n                defaultValue: !0,\n                notSupported: !0\n            }\n        ]\n    }\n], normalization = Object.freeze({\n    json: json$11\n}), json$12 = [\n    {\n        tfOpName: \"Max\",\n        category: \"reduction\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axis\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"keep_dims\",\n                name: \"keepDims\",\n                type: \"bool\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Mean\",\n        category: \"reduction\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axis\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"keep_dims\",\n                name: \"keepDims\",\n                type: \"bool\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Min\",\n        category: \"reduction\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axis\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"keep_dims\",\n                name: \"keepDims\",\n                type: \"bool\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Sum\",\n        category: \"reduction\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axis\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"keep_dims\",\n                name: \"keepDims\",\n                type: \"bool\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"All\",\n        category: \"reduction\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axis\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"keep_dims\",\n                name: \"keepDims\",\n                type: \"bool\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Any\",\n        category: \"reduction\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axis\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"keep_dims\",\n                name: \"keepDims\",\n                type: \"bool\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"ArgMax\",\n        category: \"reduction\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axis\",\n                type: \"number\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"ArgMin\",\n        category: \"reduction\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axis\",\n                type: \"number\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Prod\",\n        category: \"reduction\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axis\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"keep_dims\",\n                name: \"keepDims\",\n                type: \"bool\"\n            }\n        ]\n    }\n], reduction = Object.freeze({\n    json: json$12\n}), json$13 = [\n    {\n        tfOpName: \"ConcatV2\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                end: -1,\n                name: \"tensors\",\n                type: \"tensors\"\n            },\n            {\n                start: -1,\n                name: \"axis\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"N\",\n                name: \"n\",\n                type: \"number\",\n                defaultValue: 2\n            }\n        ]\n    },\n    {\n        tfOpName: \"Concat\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 1,\n                end: 0,\n                name: \"tensors\",\n                type: \"tensors\"\n            },\n            {\n                start: 0,\n                name: \"axis\",\n                type: \"number\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"N\",\n                name: \"n\",\n                type: \"number\",\n                defaultValue: 2\n            }\n        ]\n    },\n    {\n        tfOpName: \"GatherV2\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"indices\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"axis\",\n                type: \"number\",\n                defaultValue: 0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Gather\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"indices\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"axis\",\n                name: \"axis\",\n                type: \"number\",\n                defaultValue: 0\n            },\n            {\n                tfName: \"validate_indices\",\n                name: \"validateIndices\",\n                type: \"bool\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Reverse\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"dims\",\n                type: \"bool\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"ReverseV2\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axis\",\n                type: \"number[]\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Slice\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"begin\",\n                type: \"number[]\"\n            },\n            {\n                start: 2,\n                name: \"size\",\n                type: \"number[]\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"StridedSlice\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"begin\",\n                type: \"number[]\"\n            },\n            {\n                start: 2,\n                name: \"end\",\n                type: \"number[]\"\n            },\n            {\n                start: 3,\n                name: \"strides\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"begin_mask\",\n                name: \"beginMask\",\n                type: \"number\",\n                defaultValue: 0\n            },\n            {\n                tfName: \"end_mask\",\n                name: \"endMask\",\n                type: \"number\",\n                defaultValue: 0\n            },\n            {\n                tfName: \"new_axis_mask\",\n                name: \"newAxisMask\",\n                type: \"number\",\n                defaultValue: 0\n            },\n            {\n                tfName: \"ellipsis_mask\",\n                name: \"ellipsisMask\",\n                type: \"number\",\n                defaultValue: 0\n            },\n            {\n                tfName: \"shrink_axis_mask\",\n                name: \"shrinkAxisMask\",\n                type: \"number\",\n                defaultValue: 0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Pack\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                end: 0,\n                name: \"tensors\",\n                type: \"tensors\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"axis\",\n                name: \"axis\",\n                type: \"number\",\n                defaultValue: 0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Unpack\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"tensor\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"axis\",\n                name: \"axis\",\n                type: \"number\",\n                defaultValue: 0\n            },\n            {\n                tfName: \"num\",\n                name: \"num\",\n                type: \"number\",\n                defaultValue: 0,\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Tile\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"reps\",\n                type: \"number[]\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Split\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"axis\",\n                type: \"number\",\n                defaultValue: 0\n            },\n            {\n                start: 1,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"num_split\",\n                name: \"numOrSizeSplits\",\n                type: \"number\",\n                defaultValue: 1\n            }\n        ]\n    },\n    {\n        tfOpName: \"SplitV\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"numOrSizeSplits\",\n                type: \"number[]\"\n            },\n            {\n                start: 2,\n                name: \"axis\",\n                type: \"number\",\n                defaultValue: 0\n            }\n        ]\n    },\n    {\n        tfOpName: \"ScatterNd\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"indices\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"values\",\n                type: \"tensor\"\n            },\n            {\n                start: 2,\n                name: \"shape\",\n                type: \"number[]\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"GatherNd\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"indices\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"SparseToDense\",\n        category: \"slice_join\",\n        inputs: [\n            {\n                start: 0,\n                name: \"sparseIndices\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"outputShape\",\n                type: \"number[]\"\n            },\n            {\n                start: 2,\n                name: \"sparseValues\",\n                type: \"tensor\"\n            },\n            {\n                start: 3,\n                name: \"defaultValue\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"validate_indices\",\n                name: \"validateIndices\",\n                type: \"bool\",\n                defaultValue: !1,\n                notSupported: !0\n            }\n        ]\n    }\n], sliceJoin = Object.freeze({\n    json: json$13\n}), json$14 = [\n    {\n        tfOpName: \"FFT\",\n        category: \"spectral\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"IFFT\",\n        category: \"spectral\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"RFFT\",\n        category: \"spectral\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"fft_length\",\n                type: \"number\",\n                notSupported: !0\n            }\n        ]\n    },\n    {\n        tfOpName: \"IRFFT\",\n        category: \"spectral\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"fft_length\",\n                type: \"number\",\n                notSupported: !0\n            }\n        ]\n    }\n], spectral = Object.freeze({\n    json: json$14\n}), json$15 = [\n    {\n        tfOpName: \"Cast\",\n        category: \"transformation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"SrcT\",\n                name: \"sdtype\",\n                type: \"dtype\",\n                notSupported: !0\n            },\n            {\n                tfName: \"DstT\",\n                name: \"dtype\",\n                type: \"dtype\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"ExpandDims\",\n        category: \"transformation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"axis\",\n                type: \"number\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Pad\",\n        category: \"transformation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"padding\",\n                type: \"number[]\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"constant_value\",\n                name: \"constantValue\",\n                type: \"number\",\n                defaultValue: 0\n            }\n        ]\n    },\n    {\n        tfOpName: \"PadV2\",\n        category: \"transformation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"padding\",\n                type: \"number[]\"\n            },\n            {\n                start: 2,\n                name: \"constantValue\",\n                type: \"number\",\n                defaultValue: 0\n            }\n        ]\n    },\n    {\n        tfOpName: \"Reshape\",\n        category: \"transformation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"shape\",\n                type: \"number[]\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"Squeeze\",\n        category: \"transformation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"axis\",\n                tfDeprecatedName: \"squeeze_dims\",\n                name: \"axis\",\n                type: \"number[]\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"SpaceToBatchND\",\n        category: \"transformation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"blockShape\",\n                type: \"number[]\"\n            },\n            {\n                start: 2,\n                name: \"paddings\",\n                type: \"number[]\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"BatchToSpaceND\",\n        category: \"transformation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            },\n            {\n                start: 1,\n                name: \"blockShape\",\n                type: \"number[]\"\n            },\n            {\n                start: 2,\n                name: \"crops\",\n                type: \"number[]\"\n            }\n        ]\n    },\n    {\n        tfOpName: \"DepthToSpace\",\n        category: \"transformation\",\n        inputs: [\n            {\n                start: 0,\n                name: \"x\",\n                type: \"tensor\"\n            }\n        ],\n        attrs: [\n            {\n                tfName: \"block_size\",\n                name: \"blockSize\",\n                type: \"number\"\n            },\n            {\n                tfName: \"data_format\",\n                name: \"dataFormat\",\n                type: \"string\"\n            }\n        ]\n    }\n], transformation = Object.freeze({\n    json: json$15\n}), OperationMapper = function() {\n    function e() {\n        var e = [\n            arithmetic,\n            basicMath,\n            control,\n            convolution,\n            creation,\n            dynamic,\n            evaluation,\n            logical,\n            image$1,\n            graph,\n            matrices,\n            normalization,\n            reduction,\n            sliceJoin,\n            spectral,\n            transformation\n        ], t = [].concat.apply([], e.map(function(e) {\n            return e.json;\n        }));\n        this.opMappers = t.reduce(function(e, t) {\n            return e[t.tfOpName] = t, e;\n        }, {});\n    }\n    return Object.defineProperty(e, \"Instance\", {\n        get: function() {\n            return this._instance || (this._instance = new this);\n        },\n        enumerable: !0,\n        configurable: !0\n    }), e.prototype.transformGraph = function(e, t) {\n        var a = this;\n        void 0 === t && (t = {});\n        var r = [], n = [], s = e.node.reduce(function(e, t) {\n            return e[t.name] = a.mapNode(t), t.op.startsWith(\"Placeholder\") && r.push(e[t.name]), \"Const\" === t.op && n.push(e[t.name]), e;\n        }, {}), o = [], p = [], u = {}, i = {};\n        null != t && (u = this.mapSignatureEntries(t.inputs), i = this.mapSignatureEntries(t.outputs));\n        var m = Object.keys(s);\n        return m.forEach(function(e) {\n            var t = s[e];\n            t.inputNames.forEach(function(e) {\n                var a = getNodeNameAndIndex(e)[0];\n                t.inputs.push(s[a]), s[a].children.push(t);\n            });\n        }), 0 === Object.keys(i).length ? m.forEach(function(e) {\n            var t = s[e];\n            0 === t.children.length && p.push(t);\n        }) : Object.keys(i).forEach(function(e) {\n            var t = getNodeNameAndIndex(e)[0], a = s[t];\n            null != a && (a.signatureKey = i[e], p.push(a));\n        }), Object.keys(u).length > 0 ? Object.keys(u).forEach(function(e) {\n            var t = getNodeNameAndIndex(e)[0], a = s[t];\n            a && (a.signatureKey = u[e], o.push(a));\n        }) : o = r, {\n            nodes: s,\n            inputs: o,\n            outputs: p,\n            weights: n,\n            placeholders: r,\n            signature: t\n        };\n    }, e.prototype.mapSignatureEntries = function(e) {\n        return Object.keys(e || {}).reduce(function(t, a) {\n            return t[e[a].name] = a, t;\n        }, {});\n    }, e.prototype.mapNode = function(e) {\n        var t = getRegisteredOp(e.op) || this.opMappers[e.op] || {};\n        null == e.attr && (e.attr = {});\n        var a = {\n            name: e.name,\n            op: e.op,\n            category: t.category,\n            inputNames: (e.input || []).map(function(e) {\n                return e.startsWith(\"^\") ? e.substr(1) : e;\n            }),\n            inputs: [],\n            children: [],\n            inputParams: {},\n            attrParams: {},\n            rawAttrs: e.attr\n        };\n        return null != t.inputs && (a.inputParams = t.inputs.reduce(function(e, t) {\n            return e[t.name] = {\n                type: t.type,\n                inputIndexStart: t.start,\n                inputIndexEnd: t.end\n            }, e;\n        }, {})), null != t.attrs && (a.attrParams = t.attrs.reduce(function(t, a) {\n            var r = a.type, n = void 0;\n            switch(a.type){\n                case \"string\":\n                    void 0 === (n = getStringParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getStringParam(e.attr, a.tfDeprecatedName, a.defaultValue));\n                    break;\n                case \"string[]\":\n                    void 0 === (n = getStringArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getStringArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));\n                    break;\n                case \"number\":\n                    void 0 === (n = getNumberParam(e.attr, a.tfName, a.defaultValue || 0)) && a.tfDeprecatedName && (n = getNumberParam(e.attr, a.tfDeprecatedName, a.defaultValue));\n                    break;\n                case \"number[]\":\n                    void 0 === (n = getNumericArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getNumericArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));\n                    break;\n                case \"bool\":\n                    void 0 === (n = getBoolParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getBoolParam(e.attr, a.tfDeprecatedName, a.defaultValue));\n                    break;\n                case \"bool[]\":\n                    void 0 === (n = getBoolArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getBoolArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));\n                    break;\n                case \"shape\":\n                    void 0 === (n = getTensorShapeParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getTensorShapeParam(e.attr, a.tfDeprecatedName, a.defaultValue));\n                    break;\n                case \"shape[]\":\n                    void 0 === (n = getTensorShapeArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getTensorShapeArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));\n                    break;\n                case \"dtype\":\n                    void 0 === (n = getDtypeParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getDtypeParam(e.attr, a.tfDeprecatedName, a.defaultValue));\n                    break;\n                case \"dtype[]\":\n                    void 0 === (n = getDtypeArrayParam(e.attr, a.tfName, a.defaultValue)) && a.tfDeprecatedName && (n = getDtypeArrayParam(e.attr, a.tfDeprecatedName, a.defaultValue));\n                    break;\n                case \"tensor\":\n                case \"tensors\":\n                    break;\n                default:\n                    throw new Error(\"Unsupported param type: \" + a.type + \" for op: \" + e.op);\n            }\n            return t[a.name] = {\n                value: n,\n                type: r\n            }, t;\n        }, {})), a;\n    }, e;\n}();\nfunction decodeBase64(e) {\n    var t = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.env)().global;\n    if (void 0 !== t.atob) return t.atob(e);\n    if (\"undefined\" != typeof Buffer) return new Buffer(e, \"base64\").toString();\n    throw new Error(\"Unable to decode base64 in this environment. Missing built-in atob() or Buffer()\");\n}\nfunction parseStringParam(e, t) {\n    var a = Array.isArray(e) ? String.fromCharCode.apply(null, e) : decodeBase64(e);\n    return t ? a : a.toLowerCase();\n}\nfunction getStringParam(e, t, a, r) {\n    void 0 === r && (r = !1);\n    var n = e[t];\n    return null != n ? parseStringParam(n.s, r) : a;\n}\nfunction getBoolParam(e, t, a) {\n    var r = e[t];\n    return r ? r.b : a;\n}\nfunction getNumberParam(e, t, a) {\n    var r = e[t] || {}, n = null != r.i ? r.i : null != r.f ? r.f : a;\n    return \"number\" == typeof n ? n : parseInt(n, 10);\n}\nfunction parseDtypeParam(e) {\n    switch(\"string\" == typeof e && (e = DataType[e]), e){\n        case DataType.DT_FLOAT:\n            return \"float32\";\n        case DataType.DT_INT32:\n        case DataType.DT_INT64:\n        case DataType.DT_INT8:\n        case DataType.DT_UINT8:\n            return \"int32\";\n        case DataType.DT_BOOL:\n            return \"bool\";\n        case DataType.DT_DOUBLE:\n            return \"float32\";\n        case DataType.DT_STRING:\n            return \"string\";\n        default:\n            return null;\n    }\n}\nfunction getDtypeParam(e, t, a) {\n    var r = e[t];\n    return r && r.type ? parseDtypeParam(r.type) : a;\n}\nfunction getDtypeArrayParam(e, t, a) {\n    var r = e[t];\n    return r && r.list && r.list.type ? r.list.type.map(function(e) {\n        return parseDtypeParam(e);\n    }) : a;\n}\nfunction parseTensorShapeParam(e) {\n    if (!e.unknownRank) return null != e.dim ? e.dim.map(function(e) {\n        return \"number\" == typeof e.size ? e.size : parseInt(e.size, 10);\n    }) : [];\n}\nfunction getTensorShapeParam(e, t, a) {\n    var r = e[t];\n    return r && r.shape ? parseTensorShapeParam(r.shape) : a;\n}\nfunction getNumericArrayParam(e, t, a) {\n    var r = e[t];\n    return r ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map(function(e) {\n        return \"number\" == typeof e ? e : parseInt(e, 10);\n    }) : a;\n}\nfunction getStringArrayParam(e, t, a, r) {\n    void 0 === r && (r = !1);\n    var n = e[t];\n    return n && n.list && n.list.s ? n.list.s.map(function(e) {\n        return parseStringParam(e, r);\n    }) : a;\n}\nfunction getTensorShapeArrayParam(e, t, a) {\n    var r = e[t];\n    return r && r.list && r.list.shape ? r.list.shape.map(function(e) {\n        return parseTensorShapeParam(e);\n    }) : a;\n}\nfunction getBoolArrayParam(e, t, a) {\n    var r = e[t];\n    return r && r.list && r.list.b ? r.list.b : a;\n}\nvar NodeValueImpl = function() {\n    function e(e, t, a) {\n        var r = this;\n        this.node = e, this.tensorMap = t, this.context = a, this.inputs = [], this.attrs = {}, this.inputs = e.inputNames.map(function(e) {\n            return r.getInput(e);\n        }), null != e.rawAttrs && (this.attrs = Object.keys(e.rawAttrs).reduce(function(e, t) {\n            return e[t] = r.getAttr(t), e;\n        }, {}));\n    }\n    return e.prototype.getInput = function(e) {\n        return getTensor(e, this.tensorMap, this.context);\n    }, e.prototype.getAttr = function(e, t) {\n        var a = this.node.rawAttrs[e];\n        if (null != a.tensor) return getTensor(e, this.tensorMap, this.context);\n        if (null != a.i || null != a.f) return getNumberParam(this.node.rawAttrs, e, t);\n        if (null != a.s) return getStringParam(this.node.rawAttrs, e, t);\n        if (null != a.b) return getBoolParam(this.node.rawAttrs, e, t);\n        if (null != a.shape) return getTensorShapeParam(this.node.rawAttrs, e, t);\n        if (null != a.type) return getDtypeParam(this.node.rawAttrs, e, t);\n        if (null != a.list) {\n            if (null != a.list.i || null != a.list.f) return getNumericArrayParam(this.node.rawAttrs, e, t);\n            if (null != a.list.s) return getStringArrayParam(this.node.rawAttrs, e, t);\n            if (null != a.list.shape) return getTensorShapeArrayParam(this.node.rawAttrs, e, t);\n            if (null != a.list.b) return getBoolArrayParam(this.node.rawAttrs, e, t);\n            if (null != a.list.type) return getDtypeArrayParam(this.node.rawAttrs, e, t);\n        }\n        return t;\n    }, e;\n}(), executeOp = function(e, t, a) {\n    switch(e.op){\n        case \"BiasAdd\":\n        case \"AddV2\":\n        case \"Add\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.add)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"AddN\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.addN)(getParamValue(\"tensors\", e, t, a))\n            ];\n        case \"FloorMod\":\n        case \"Mod\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.mod)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"Mul\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.mul)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"RealDiv\":\n        case \"Div\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.div)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"DivNoNan\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.divNoNan)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"FloorDiv\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.floorDiv)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"Sub\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sub)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"Minimum\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.minimum)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"Maximum\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.maximum)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"Pow\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.pow)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"SquaredDifference\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.squaredDifference)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, executeOp$1 = function(e, t, a) {\n    switch(e.op){\n        case \"Abs\":\n        case \"ComplexAbs\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.abs)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Acos\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.acos)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Acosh\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.acosh)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Asin\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.asin)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Asinh\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.asinh)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Atan\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.atan)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Atan2\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.atan2)(getParamValue(\"x\", e, t, a), getParamValue(\"y\", e, t, a))\n            ];\n        case \"Atanh\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.atanh)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Ceil\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ceil)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Complex\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.complex)(getParamValue(\"real\", e, t, a), getParamValue(\"imag\", e, t, a))\n            ];\n        case \"Cos\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.cos)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Cosh\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.cosh)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Elu\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.elu)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Erf\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.erf)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Exp\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.exp)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Expm1\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.expm1)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Floor\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.floor)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Log\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.log)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Log1p\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.log1p)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Imag\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.imag)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Neg\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.neg)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Reciprocal\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.reciprocal)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Real\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.real)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Relu\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.relu)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Round\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.round)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Selu\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.selu)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Sigmoid\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sigmoid)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Sin\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sin)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Sign\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sign)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Sinh\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sinh)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Softplus\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.softplus)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Sqrt\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sqrt)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Square\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.square)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Tanh\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tanh)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Tan\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tan)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"Relu6\":\n        case \"ClipByValue\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.clipByValue)(getParamValue(\"x\", e, t, a), getParamValue(\"clipValueMin\", e, t, a), getParamValue(\"clipValueMax\", e, t, a))\n            ];\n        case \"Rsqrt\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.rsqrt)(getTensor(e.inputNames[0], t, a))\n            ];\n        case \"Prod\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.prod)(getParamValue(\"x\", e, t, a), getParamValue(\"axes\", e, t, a))\n            ];\n        case \"LeakyRelu\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.leakyRelu)(getParamValue(\"x\", e, t, a), getParamValue(\"alpha\", e, t, a))\n            ];\n        case \"Prelu\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.prelu)(getParamValue(\"x\", e, t, a), getParamValue(\"alpha\", e, t, a))\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, TensorArray = function() {\n    function e(t, a, r, n, s, o, p) {\n        this.name = t, this.dtype = a, this.maxSize = r, this.elementShape = n, this.identicalElementShapes = s, this.dynamicSize = o, this.clearAfterRead = p, this.tensors = [], this.closed_ = !1, this.id = e.nextId++;\n    }\n    return Object.defineProperty(e.prototype, \"closed\", {\n        get: function() {\n            return this.closed_;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), e.prototype.clearAndClose = function() {\n        this.tensors.forEach(function(e) {\n            return e.tensor.dispose();\n        }), this.tensors = [], this.closed_ = !0;\n    }, e.prototype.size = function() {\n        return this.tensors.length;\n    }, e.prototype.read = function(e) {\n        if (this.closed_) throw new Error(\"TensorArray \" + this.name + \" has already been closed.\");\n        if (e < 0 || e >= this.tensors.length) throw new Error(\"Tried to read from index \" + e + \", but array size is: \" + this.tensors.length);\n        var t = this.tensors[e];\n        if (t.cleared) throw new Error(\"TensorArray \" + this.name + \": Could not read index \" + e + \" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).\");\n        return this.clearAfterRead && (t.cleared = !0), t.read = !0, t.tensor;\n    }, e.prototype.readMany = function(e) {\n        var t = this;\n        return e.map(function(e) {\n            return t.read(e);\n        });\n    }, e.prototype.write = function(e, t) {\n        if (this.closed_) throw new Error(\"TensorArray \" + this.name + \" has already been closed.\");\n        if (e < 0 || !this.dynamicSize && e >= this.maxSize) throw new Error(\"Tried to write to index \" + e + \", but array is not resizeable and size is: \" + this.maxSize);\n        var a = this.tensors[e] || {};\n        if (t.dtype !== this.dtype) throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + e + \",\\n          because the value dtype is \" + t.dtype + \", but TensorArray dtype is \" + this.dtype + \".\");\n        if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = t.shape), this.assertShapesMatchAllowUndefinedSize(this.elementShape, t.shape, \"TensorArray \" + this.name + \": Could not write to TensorArray index \" + e + \".\"), a && a.read) throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + e + \", because it has already been read.\");\n        if (a && a.written) throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + e + \", because it has already been written.\");\n        a.tensor = t, a.written = !0, this.tensors[e] = a;\n    }, e.prototype.writeMany = function(e, t) {\n        var a = this;\n        if (e.length !== t.length) throw new Error(\"TensorArray \" + this.name + \": could not write multiple tensors,because the index size: \" + e.length + \" is not the same as tensors size: \" + t.length + \".\");\n        e.forEach(function(e, r) {\n            return a.write(e, t[r]);\n        });\n    }, e.prototype.gather = function(e, t) {\n        if (t && t !== this.dtype) throw new Error(\"TensorArray dtype is \" + this.dtype + \" but gather requested dtype \" + t);\n        if (!e) {\n            e = [];\n            for(var a = 0; a < this.size(); a++)e.push(a);\n        }\n        if (0 === e.length) return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tensor)([], [\n            0\n        ].concat(this.elementShape));\n        var r = this.readMany(e);\n        return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, \"TensorArray shape mismatch: \"), (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.stack)(r, 0);\n    }, e.prototype.concat = function(e) {\n        if (e && e !== this.dtype) throw new Error(\"TensorArray dtype is \" + this.dtype + \" but concat requested dtype \" + e);\n        if (0 === this.size()) return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tensor)([], [\n            0\n        ].concat(this.elementShape));\n        for(var t = [], a = 0; a < this.size(); a++)t.push(a);\n        var r = this.readMany(t);\n        return this.assertShapesMatchAllowUndefinedSize(this.elementShape, r[0].shape, \"TensorArray shape mismatch: tensor array shape (\" + this.elementShape + \") vs first tensor shape (\" + r[0].shape + \")\"), (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.concat)(r, 0);\n    }, e.prototype.scatter = function(e, t) {\n        if (t.dtype !== this.dtype) throw new Error(\"TensorArray dtype is \" + this.dtype + \" but tensor has dtype \" + t.dtype);\n        if (e.length !== t.shape[0]) throw new Error(\"Expected len(indices) == tensor.shape[0], but saw: \" + e.length + \" vs. \" + t.shape[0]);\n        var a = Math.max.apply(Math, e);\n        if (!this.dynamicSize && a >= this.maxSize) throw new Error(\"Max index must be < array size (\" + a + \"  vs. \" + this.maxSize + \")\");\n        this.writeMany(e, (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.unstack)(t, 0));\n    }, e.prototype.split = function(e, t) {\n        var a = this;\n        if (t.dtype !== this.dtype) throw new Error(\"TensorArray dtype is \" + this.dtype + \" but tensor has dtype \" + t.dtype);\n        var r = 0, n = e.map(function(e) {\n            return r += e;\n        });\n        if (r !== t.shape[0]) throw new Error(\"Expected sum of lengths to be equal to\\n          tensor.shape[0], but sum of lengths is\\n        \" + r + \", and tensor's shape is: \" + t.shape);\n        if (!this.dynamicSize && e.length !== this.maxSize) throw new Error(\"TensorArray's size is not equal to the size of lengths (\" + this.maxSize + \" vs. \" + e.length + \"), and the TensorArray is not marked as dynamically resizeable\");\n        var s = 0 === r ? 0 : t.size / r, o = [];\n        (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n            t = t.reshape([\n                1,\n                r,\n                s\n            ]);\n            for(var p = 0; p < e.length; ++p){\n                var u = [\n                    0,\n                    0 === p ? 0 : n[p - 1],\n                    0\n                ], i = [\n                    1,\n                    e[p],\n                    s\n                ];\n                o[p] = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.slice)(t, u, i).reshape(a.elementShape);\n            }\n            return o;\n        });\n        for(var p = [], u = 0; u < e.length; u++)p[u] = u;\n        this.writeMany(p, o);\n    }, e.prototype.assertShapesMatchAllowUndefinedSize = function(e, t, a) {\n        void 0 === a && (a = \"\"), _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(this.shapesEqualAllowUndefinedSize(e, t), function() {\n            return a + \" Shapes \" + e + \" and \" + t + \" must match\";\n        });\n    }, e.prototype.shapesEqualAllowUndefinedSize = function(e, t) {\n        if (e.length !== t.length) return !1;\n        for(var a = 0; a < e.length; a++)if (-1 !== e[a] && -1 !== t[a] && e[a] !== t[a]) return !1;\n        return !0;\n    }, e.nextId = 0, e;\n}(), _this = void 0, executeOp$2 = function(e, t, a) {\n    return __awaiter(_this, void 0, void 0, function() {\n        var r, n, s, o, p, u, i, m, l, c, d, y, f, g, h, N, x, V, b, P, T, v, O, S, _, w, A, D, E, I, M, C, k, z, F;\n        return __generator(this, function(j) {\n            switch(j.label){\n                case 0:\n                    switch(e.op){\n                        case \"LoopCond\":\n                            return [\n                                3,\n                                1\n                            ];\n                        case \"Switch\":\n                            return [\n                                3,\n                                2\n                            ];\n                        case \"Merge\":\n                            return [\n                                3,\n                                4\n                            ];\n                        case \"Enter\":\n                            return [\n                                3,\n                                5\n                            ];\n                        case \"Exit\":\n                            return [\n                                3,\n                                6\n                            ];\n                        case \"NextIteration\":\n                            return [\n                                3,\n                                7\n                            ];\n                        case \"TensorArrayV3\":\n                            return [\n                                3,\n                                8\n                            ];\n                        case \"TensorArrayWriteV3\":\n                            return [\n                                3,\n                                9\n                            ];\n                        case \"TensorArrayReadV3\":\n                            return [\n                                3,\n                                10\n                            ];\n                        case \"TensorArrayGatherV3\":\n                            return [\n                                3,\n                                11\n                            ];\n                        case \"TensorArrayScatterV3\":\n                            return [\n                                3,\n                                12\n                            ];\n                        case \"TensorArrayConcatV3\":\n                            return [\n                                3,\n                                13\n                            ];\n                        case \"TensorArraySplitV3\":\n                            return [\n                                3,\n                                14\n                            ];\n                        case \"TensorArraySizeV3\":\n                            return [\n                                3,\n                                15\n                            ];\n                        case \"TensorArrayCloseV3\":\n                            return [\n                                3,\n                                16\n                            ];\n                    }\n                    return [\n                        3,\n                        17\n                    ];\n                case 1:\n                    return [\n                        2,\n                        [\n                            getParamValue(\"pred\", e, t, a).clone()\n                        ]\n                    ];\n                case 2:\n                    return r = getParamValue(\"pred\", e, t, a), n = getParamValue(\"data\", e, t, a), [\n                        4,\n                        r.data()\n                    ];\n                case 3:\n                    return [\n                        2,\n                        j.sent()[0] ? [\n                            void 0,\n                            n.clone()\n                        ] : [\n                            n.clone(),\n                            void 0\n                        ]\n                    ];\n                case 4:\n                    return [\n                        2,\n                        (s = e.inputNames.find(function(e) {\n                            return void 0 !== getTensor(e, t, a);\n                        })) ? [\n                            getTensor(s, t, a).clone()\n                        ] : void 0\n                    ];\n                case 5:\n                    return o = getParamValue(\"frameName\", e, t, a), p = getParamValue(\"tensor\", e, t, a), a.enterFrame(o), [\n                        2,\n                        [\n                            p.clone()\n                        ]\n                    ];\n                case 6:\n                    return u = getParamValue(\"tensor\", e, t, a), a.exitFrame(), [\n                        2,\n                        [\n                            u.clone()\n                        ]\n                    ];\n                case 7:\n                    return i = getParamValue(\"tensor\", e, t, a), a.nextIteration(), [\n                        2,\n                        [\n                            i.clone()\n                        ]\n                    ];\n                case 8:\n                    return m = getParamValue(\"size\", e, t, a), l = getParamValue(\"dtype\", e, t, a), c = getParamValue(\"elementShape\", e, t, a), d = getParamValue(\"dynamicSize\", e, t, a), y = getParamValue(\"clearAfterRead\", e, t, a), f = getParamValue(\"identicalElementShapes\", e, t, a), g = getParamValue(\"name\", e, t, a), h = new TensorArray(g, l, m, c, f, d, y), a.addTensorArray(h), [\n                        2,\n                        [\n                            (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.scalar)(h.id),\n                            (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.scalar)(1)\n                        ]\n                    ];\n                case 9:\n                    return N = getParamValue(\"tensorArrayId\", e, t, a), x = getParamValue(\"index\", e, t, a), V = getParamValue(\"tensor\", e, t, a), a.getTensorArray(N).write(x, V), [\n                        2,\n                        [\n                            (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.scalar)(1)\n                        ]\n                    ];\n                case 10:\n                    return b = getParamValue(\"tensorArrayId\", e, t, a), P = getParamValue(\"index\", e, t, a), [\n                        2,\n                        [\n                            a.getTensorArray(b).read(P)\n                        ]\n                    ];\n                case 11:\n                    return T = getParamValue(\"tensorArrayId\", e, t, a), v = getParamValue(\"indices\", e, t, a), O = getParamValue(\"dtype\", e, t, a), [\n                        2,\n                        [\n                            a.getTensorArray(T).gather(v, O)\n                        ]\n                    ];\n                case 12:\n                    return S = getParamValue(\"tensorArrayId\", e, t, a), _ = getParamValue(\"indices\", e, t, a), w = getParamValue(\"tensor\", e, t, a), a.getTensorArray(S).scatter(_, w), [\n                        2,\n                        [\n                            (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.scalar)(1)\n                        ]\n                    ];\n                case 13:\n                    return A = getParamValue(\"tensorArrayId\", e, t, a), D = a.getTensorArray(A), E = getParamValue(\"dtype\", e, t, a), [\n                        2,\n                        [\n                            D.concat(E)\n                        ]\n                    ];\n                case 14:\n                    return I = getParamValue(\"tensorArrayId\", e, t, a), M = getParamValue(\"tensor\", e, t, a), C = getParamValue(\"lengths\", e, t, a), a.getTensorArray(I).split(C, M), [\n                        2,\n                        [\n                            (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.scalar)(1)\n                        ]\n                    ];\n                case 15:\n                    return k = getParamValue(\"tensorArrayId\", e, t, a), z = a.getTensorArray(k), [\n                        2,\n                        [\n                            (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.scalar)(z.size(), \"int32\")\n                        ]\n                    ];\n                case 16:\n                    return F = getParamValue(\"tensorArrayId\", e, t, a), a.getTensorArray(F).clearAndClose(), [\n                        2,\n                        [\n                            (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.scalar)(0)\n                        ]\n                    ];\n                case 17:\n                    throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n            }\n        });\n    });\n}, executeOp$3 = function(e, t, a) {\n    switch(e.op){\n        case \"Conv1D\":\n            var r = getParamValue(\"stride\", e, t, a), n = getParamValue(\"pad\", e, t, a), s = getParamValue(\"dataFormat\", e, t, a).toUpperCase(), o = getParamValue(\"dilation\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.conv1d)(getParamValue(\"x\", e, t, a), getParamValue(\"filter\", e, t, a), r, n, s, o)\n            ];\n        case \"Conv2D\":\n            r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a), s = getParamValue(\"dataFormat\", e, t, a).toUpperCase();\n            var p = getParamValue(\"dilations\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.conv2d)(getParamValue(\"x\", e, t, a), getParamValue(\"filter\", e, t, a), [\n                    r[1],\n                    r[2]\n                ], n, s, [\n                    p[1],\n                    p[2]\n                ])\n            ];\n        case \"_FusedConv2D\":\n        case \"FusedDepthwiseConv2dNative\":\n            var u = getParamValue(\"fusedOps\", e, t, a), i = u[0], m = u[1], l = \"biasadd\" === i, c = \"prelu\" === m, d = \"fusedbatchnorm\" === i, y = getParamValue(\"numArgs\", e, t, a);\n            if (l) {\n                if (c && 2 !== y) throw new Error(\"FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.\");\n                if (!c && 1 !== y) throw new Error(\"FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.\");\n            }\n            if (d) throw new Error(\"FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.\");\n            r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a), s = getParamValue(\"dataFormat\", e, t, a).toUpperCase(), p = getParamValue(\"dilations\", e, t, a);\n            var f = getParamValue(\"args\", e, t, a), g = f[0], h = f[1];\n            return [\n                (\"_FusedConv2D\" === e.op ? _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.fused.conv2d : _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.fused.depthwiseConv2d)({\n                    x: getParamValue(\"x\", e, t, a),\n                    filter: getParamValue(\"filter\", e, t, a),\n                    strides: [\n                        r[1],\n                        r[2]\n                    ],\n                    pad: n,\n                    dataFormat: s,\n                    dilations: [\n                        p[1],\n                        p[2]\n                    ],\n                    bias: g,\n                    activation: m,\n                    preluActivationWeights: h\n                })\n            ];\n        case \"Conv2DBackpropInput\":\n        case \"Conv2dTranspose\":\n            var N = getParamValue(\"outputShape\", e, t, a);\n            r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.conv2dTranspose)(getParamValue(\"x\", e, t, a), getParamValue(\"filter\", e, t, a), N, [\n                    r[1],\n                    r[2]\n                ], n)\n            ];\n        case \"DepthwiseConv2dNative\":\n        case \"DepthwiseConv2d\":\n            r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a), p = getParamValue(\"dilations\", e, t, a), s = getParamValue(\"dataFormat\", e, t, a).toUpperCase();\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.depthwiseConv2d)(getParamValue(\"input\", e, t, a), getParamValue(\"filter\", e, t, a), [\n                    r[1],\n                    r[2]\n                ], n, s, [\n                    p[1],\n                    p[2]\n                ])\n            ];\n        case \"Conv3D\":\n            r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a), s = getParamValue(\"dataFormat\", e, t, a).toUpperCase(), p = getParamValue(\"dilations\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.conv3d)(getParamValue(\"x\", e, t, a), getParamValue(\"filter\", e, t, a), [\n                    r[1],\n                    r[2],\n                    r[3]\n                ], n, s, [\n                    p[1],\n                    p[2],\n                    p[3]\n                ])\n            ];\n        case \"AvgPool\":\n            r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a);\n            var x = getParamValue(\"kernelSize\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.avgPool)(getParamValue(\"x\", e, t, a), [\n                    x[1],\n                    x[2]\n                ], [\n                    r[1],\n                    r[2]\n                ], n)\n            ];\n        case \"MaxPool\":\n            r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a), x = getParamValue(\"kernelSize\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.maxPool)(getParamValue(\"x\", e, t, a), [\n                    x[1],\n                    x[2]\n                ], [\n                    r[1],\n                    r[2]\n                ], n)\n            ];\n        case \"MaxPoolWithArgmax\":\n            r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a), x = getParamValue(\"kernelSize\", e, t, a);\n            var V = getParamValue(\"includeBatchInIndex\", e, t, a), b = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.maxPoolWithArgmax)(getParamValue(\"x\", e, t, a), [\n                x[1],\n                x[2]\n            ], [\n                r[1],\n                r[2]\n            ], n, V);\n            return [\n                b.result,\n                b.indexes\n            ];\n        case \"AvgPool3D\":\n            r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a), x = getParamValue(\"kernelSize\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.avgPool3d)(getParamValue(\"x\", e, t, a), [\n                    x[1],\n                    x[2],\n                    x[3]\n                ], [\n                    r[1],\n                    r[2],\n                    r[3]\n                ], n)\n            ];\n        case \"MaxPool3D\":\n            r = getParamValue(\"strides\", e, t, a), n = getParamValue(\"pad\", e, t, a), x = getParamValue(\"kernelSize\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.maxPool3d)(getParamValue(\"x\", e, t, a), [\n                    x[1],\n                    x[2],\n                    x[3]\n                ], [\n                    r[1],\n                    r[2],\n                    r[3]\n                ], n)\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, executeOp$4 = function(e, t, a) {\n    switch(e.op){\n        case \"Fill\":\n            var r = getParamValue(\"shape\", e, t, a), n = getParamValue(\"dtype\", e, t, a), s = getParamValue(\"value\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.fill)(r, s, n)\n            ];\n        case \"LinSpace\":\n            var o = getParamValue(\"start\", e, t, a), p = getParamValue(\"stop\", e, t, a), u = getParamValue(\"num\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.linspace)(o, p, u)\n            ];\n        case \"Multinomial\":\n            var i = getParamValue(\"logits\", e, t, a), m = getParamValue(\"numSamples\", e, t, a), l = getParamValue(\"seed\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.multinomial)(i, m, l)\n            ];\n        case \"OneHot\":\n            var c = getParamValue(\"indices\", e, t, a), d = getParamValue(\"depth\", e, t, a), y = getParamValue(\"onValue\", e, t, a), f = getParamValue(\"offValue\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.oneHot)(c, d, y, f)\n            ];\n        case \"Ones\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ones)(getParamValue(\"shape\", e, t, a), getParamValue(\"dtype\", e, t, a))\n            ];\n        case \"OnesLike\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.onesLike)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"RandomUniform\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.randomUniform)(getParamValue(\"shape\", e, t, a), getParamValue(\"minval\", e, t, a), getParamValue(\"maxval\", e, t, a), getParamValue(\"dtype\", e, t, a))\n            ];\n        case \"Range\":\n            o = getParamValue(\"start\", e, t, a);\n            var g = getParamValue(\"stop\", e, t, a), h = getParamValue(\"step\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.range)(o, g, h, getParamValue(\"dtype\", e, t, a))\n            ];\n        case \"TruncatedNormal\":\n            r = getParamValue(\"shape\", e, t, a);\n            var N = getParamValue(\"mean\", e, t, a), x = getParamValue(\"stdDev\", e, t, a);\n            l = getParamValue(\"seed\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.truncatedNormal)(r, N, x, getParamValue(\"dtype\", e, t, a), l)\n            ];\n        case \"Zeros\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.zeros)(getParamValue(\"shape\", e, t, a), getParamValue(\"dtype\", e, t, a))\n            ];\n        case \"ZerosLike\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.zerosLike)(getParamValue(\"x\", e, t, a))\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, _this$1 = void 0, executeOp$5 = function(e, t, a) {\n    return __awaiter(_this$1, void 0, void 0, function() {\n        var r, n, s, o, p, u, i, m;\n        return __generator(this, function(l) {\n            switch(l.label){\n                case 0:\n                    switch(e.op){\n                        case \"NonMaxSuppressionV5\":\n                        case \"NonMaxSuppressionV3\":\n                        case \"NonMaxSuppressionV2\":\n                            return [\n                                3,\n                                1\n                            ];\n                        case \"Where\":\n                            return [\n                                3,\n                                5\n                            ];\n                        case \"ListDiff\":\n                            return [\n                                3,\n                                7\n                            ];\n                    }\n                    return [\n                        3,\n                        8\n                    ];\n                case 1:\n                    return r = getParamValue(\"boxes\", e, t, a), n = getParamValue(\"scores\", e, t, a), s = getParamValue(\"maxOutputSize\", e, t, a), o = getParamValue(\"iouThreshold\", e, t, a), p = getParamValue(\"scoreThreshold\", e, t, a), \"NonMaxSuppressionV5\" !== e.op ? [\n                        3,\n                        3\n                    ] : (u = getParamValue(\"softNmsSigma\", e, t, a), [\n                        4,\n                        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.image.nonMaxSuppressionWithScoreAsync(r, n, s, o, p, u)\n                    ]);\n                case 2:\n                    return [\n                        2,\n                        [\n                            (m = l.sent()).selectedIndices,\n                            m.selectedScores\n                        ]\n                    ];\n                case 3:\n                    return [\n                        4,\n                        _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.image.nonMaxSuppressionAsync(r, n, s, o, p)\n                    ];\n                case 4:\n                    return [\n                        2,\n                        [\n                            l.sent()\n                        ]\n                    ];\n                case 5:\n                    return i = getParamValue(\"condition\", e, t, a).asType(\"bool\"), [\n                        4,\n                        (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.whereAsync)(i)\n                    ];\n                case 6:\n                    return m = [\n                        l.sent()\n                    ], i.dispose(), [\n                        2,\n                        m\n                    ];\n                case 7:\n                    return [\n                        2,\n                        (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.setdiff1dAsync)(getParamValue(\"x\", e, t, a), getParamValue(\"y\", e, t, a))\n                    ];\n                case 8:\n                    throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n            }\n        });\n    });\n}, executeOp$6 = function(e, t, a) {\n    switch(e.op){\n        case \"TopKV2\":\n            var r = getParamValue(\"x\", e, t, a), n = getParamValue(\"k\", e, t, a), s = getParamValue(\"sorted\", e, t, a), o = (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.topk)(r, n, s);\n            return [\n                o.values,\n                o.indices\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, executeOp$7 = function(e, t, a) {\n    switch(e.op){\n        case \"Const\":\n            return t[e.name];\n        case \"PlaceholderWithDefault\":\n            var r = getParamValue(\"default\", e, t, a);\n            return [\n                getTensor(e.name, t, a) || r\n            ];\n        case \"Placeholder\":\n            return [\n                getTensor(e.name, t, a)\n            ];\n        case \"Identity\":\n        case \"StopGradient\":\n        case \"FakeQuantWithMinMaxVars\":\n            return [\n                getParamValue(\"x\", e, t, a).clone()\n            ];\n        case \"IdentityN\":\n            return getParamValue(\"x\", e, t, a).map(function(e) {\n                return e.clone();\n            });\n        case \"Snapshot\":\n            return [\n                getParamValue(\"x\", e, t, a).clone()\n            ];\n        case \"Shape\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tensor1d)(getParamValue(\"x\", e, t, a).shape, \"int32\")\n            ];\n        case \"ShapeN\":\n            return getParamValue(\"x\", e, t, a).map(function(e) {\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tensor1d)(e.shape);\n            });\n        case \"Size\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.scalar)(getParamValue(\"x\", e, t, a).size, \"int32\")\n            ];\n        case \"Rank\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.scalar)(getParamValue(\"x\", e, t, a).rank, \"int32\")\n            ];\n        case \"NoOp\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.scalar)(1)\n            ];\n        case \"Print\":\n            var n = getParamValue(\"x\", e, t, a), s = getParamValue(\"data\", e, t, a), o = getParamValue(\"message\", e, t, a), p = getParamValue(\"summarize\", e, t, a);\n            console.warn(\"The graph has a tf.print() operation,usually used for debugging, which slows down performance.\"), console.log(o);\n            for(var u = 0; u < s.length; u++)console.log(Array.prototype.slice.call(s[u].dataSync()).slice(0, p));\n            return [\n                n\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, executeOp$8 = function(e, t, a) {\n    switch(e.op){\n        case \"ResizeBilinear\":\n            var r = getParamValue(\"images\", e, t, a), n = getParamValue(\"size\", e, t, a), s = getParamValue(\"alignCorners\", e, t, a);\n            return [\n                _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.image.resizeBilinear(r, [\n                    n[0],\n                    n[1]\n                ], s)\n            ];\n        case \"ResizeNearestNeighbor\":\n            r = getParamValue(\"images\", e, t, a), n = getParamValue(\"size\", e, t, a), s = getParamValue(\"alignCorners\", e, t, a);\n            return [\n                _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.image.resizeNearestNeighbor(r, [\n                    n[0],\n                    n[1]\n                ], s)\n            ];\n        case \"CropAndResize\":\n            var o = getParamValue(\"image\", e, t, a), p = getParamValue(\"boxes\", e, t, a), u = getParamValue(\"boxInd\", e, t, a), i = getParamValue(\"cropSize\", e, t, a), m = getParamValue(\"method\", e, t, a), l = getParamValue(\"extrapolationValue\", e, t, a);\n            return [\n                _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.image.cropAndResize(o, p, u, i, m, l)\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, executeOp$9 = function(e, t, a) {\n    switch(e.op){\n        case \"Equal\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.equal)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"NotEqual\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.notEqual)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"Greater\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.greater)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"GreaterEqual\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.greaterEqual)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"Less\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.less)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"LessEqual\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.lessEqual)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"LogicalAnd\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.logicalAnd)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"LogicalNot\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.logicalNot)(getParamValue(\"a\", e, t, a))\n            ];\n        case \"LogicalOr\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.logicalOr)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        case \"Select\":\n        case \"SelectV2\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.where)(getParamValue(\"condition\", e, t, a), getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a))\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, executeOp$10 = function(e, t, a) {\n    switch(e.op){\n        case \"BatchMatMul\":\n        case \"BatchMatMulV2\":\n        case \"MatMul\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.matMul)(getParamValue(\"a\", e, t, a), getParamValue(\"b\", e, t, a), getParamValue(\"transposeA\", e, t, a), getParamValue(\"transposeB\", e, t, a))\n            ];\n        case \"Transpose\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.transpose)(getParamValue(\"x\", e, t, a), getParamValue(\"perm\", e, t, a))\n            ];\n        case \"_FusedMatMul\":\n            var r = getParamValue(\"fusedOps\", e, t, a), n = r[0], s = r[1], o = \"biasadd\" === n, p = \"prelu\" === s, u = getParamValue(\"numArgs\", e, t, a);\n            if (o) {\n                if (p && 2 !== u) throw new Error(\"Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.\");\n                if (!p && 1 !== u) throw new Error(\"Fused MatMul with BiasAdd must have one extra argument: bias.\");\n            }\n            var i = getParamValue(\"args\", e, t, a), m = i[0], l = i[1];\n            return [\n                _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.fused.matMul({\n                    a: getParamValue(\"a\", e, t, a),\n                    b: getParamValue(\"b\", e, t, a),\n                    transposeA: getParamValue(\"transposeA\", e, t, a),\n                    transposeB: getParamValue(\"transposeB\", e, t, a),\n                    bias: m,\n                    activation: s,\n                    preluActivationWeights: l\n                })\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, executeOp$11 = function(e, t, a) {\n    switch(e.op){\n        case \"FusedBatchNorm\":\n        case \"FusedBatchNormV2\":\n        case \"FusedBatchNormV3\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.batchNorm)(getParamValue(\"x\", e, t, a), getParamValue(\"mean\", e, t, a), getParamValue(\"variance\", e, t, a), getParamValue(\"offset\", e, t, a), getParamValue(\"scale\", e, t, a), getParamValue(\"epsilon\", e, t, a))\n            ];\n        case \"LRN\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.localResponseNormalization)(getParamValue(\"x\", e, t, a), getParamValue(\"radius\", e, t, a), getParamValue(\"bias\", e, t, a), getParamValue(\"alpha\", e, t, a), getParamValue(\"beta\", e, t, a))\n            ];\n        case \"Softmax\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.softmax)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"LogSoftmax\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.logSoftmax)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"SparseToDense\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sparseToDense)(getParamValue(\"sparseIndices\", e, t, a), getParamValue(\"outputShape\", e, t, a), getParamValue(\"sparseValues\", e, t, a), getParamValue(\"defaultValue\", e, t, a))\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, executeOp$12 = function(e, t, a) {\n    switch(e.op){\n        case \"Max\":\n            var r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.max)(getParamValue(\"x\", e, t, a), r, n)\n            ];\n        case \"Mean\":\n            r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.mean)(getParamValue(\"x\", e, t, a), r, n)\n            ];\n        case \"Min\":\n            r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.min)(getParamValue(\"x\", e, t, a), r, n)\n            ];\n        case \"Sum\":\n            r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sum)(getParamValue(\"x\", e, t, a), r, n)\n            ];\n        case \"All\":\n            r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.all)(getParamValue(\"x\", e, t, a), r, n)\n            ];\n        case \"Any\":\n            r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.any)(getParamValue(\"x\", e, t, a), r, n)\n            ];\n        case \"ArgMax\":\n            r = getParamValue(\"axis\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.argMax)(getParamValue(\"x\", e, t, a), r)\n            ];\n        case \"ArgMin\":\n            r = getParamValue(\"axis\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.argMin)(getParamValue(\"x\", e, t, a), r)\n            ];\n        case \"Prod\":\n            r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"keepDims\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.prod)(getParamValue(\"x\", e, t, a), r, n)\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, executeOp$13 = function(e, t, a) {\n    switch(e.op){\n        case \"ConcatV2\":\n        case \"Concat\":\n            var r = getParamValue(\"n\", e, t, a), n = getParamValue(\"axis\", e, t, a), s = getParamValue(\"tensors\", e, t, a);\n            return s = s.slice(0, r), [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.concat)(s, n)\n            ];\n        case \"GatherV2\":\n        case \"Gather\":\n            n = getParamValue(\"axis\", e, t, a);\n            var o = getParamValue(\"x\", e, t, a), p = getParamValue(\"indices\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.gather)(o, p.asType(\"int32\"), n)\n            ];\n        case \"ReverseV2\":\n        case \"Reverse\":\n            n = getParamValue(\"axis\", e, t, a), o = getParamValue(\"x\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.reverse)(o, n)\n            ];\n        case \"Slice\":\n            var u = getParamValue(\"begin\", e, t, a), i = getParamValue(\"size\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.slice)(getParamValue(\"x\", e, t, a), u, i)\n            ];\n        case \"StridedSlice\":\n            u = getParamValue(\"begin\", e, t, a);\n            var m = getParamValue(\"end\", e, t, a), l = getParamValue(\"strides\", e, t, a), c = getParamValue(\"beginMask\", e, t, a), d = getParamValue(\"endMask\", e, t, a), y = getParamValue(\"ellipsisMask\", e, t, a), f = getParamValue(\"newAxisMask\", e, t, a), g = getParamValue(\"shrinkAxisMask\", e, t, a), h = getParamValue(\"x\", e, t, a);\n            if (1 === u.length && h.shape.length > 1) for(var N = 1; N < h.shape.length; N++)u.push(0), m.push(h.shape[N]), l.push(l[0]);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.stridedSlice)(h, u, m, l, c, d, y, f, g)\n            ];\n        case \"Pack\":\n            return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                var r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"tensors\", e, t, a), s = n[0].shape, o = n[0].squeeze().shape, p = n.map(function(e) {\n                    var t = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(e.shape, s);\n                    if (!t && !_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.arraysEqual(e.squeeze().shape, o)) throw new Error(\"the input tensors shape does not match\");\n                    return t ? e : e.reshape(s);\n                });\n                return [\n                    (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.stack)(p, r)\n                ];\n            });\n        case \"Unpack\":\n            return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                var r = getParamValue(\"axis\", e, t, a), n = getParamValue(\"tensor\", e, t, a);\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.unstack)(n, r);\n            });\n        case \"Tile\":\n            var x = getParamValue(\"reps\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tile)(getParamValue(\"x\", e, t, a), x)\n            ];\n        case \"Split\":\n        case \"SplitV\":\n            n = getParamValue(\"axis\", e, t, a);\n            var V = getParamValue(\"numOrSizeSplits\", e, t, a);\n            return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.split)(getParamValue(\"x\", e, t, a), V, n);\n        case \"ScatterNd\":\n            p = getParamValue(\"indices\", e, t, a);\n            var b = getParamValue(\"values\", e, t, a), P = getParamValue(\"shape\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.scatterND)(p, b, P)\n            ];\n        case \"GatherNd\":\n            var T = getParamValue(\"x\", e, t, a);\n            p = getParamValue(\"indices\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.gatherND)(T, p)\n            ];\n        case \"SparseToDense\":\n            p = getParamValue(\"sparseIndices\", e, t, a), P = getParamValue(\"outputShape\", e, t, a);\n            var v = getParamValue(\"sparseValues\", e, t, a), O = getParamValue(\"defaultValue\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.sparseToDense)(p, v, P, v.dtype === O.dtype ? O : O.asType(v.dtype))\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, executeOp$14 = function(e, t, a) {\n    switch(e.op){\n        case \"FFT\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.fft)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"IFFT\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.ifft)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"RFFT\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.rfft)(getParamValue(\"x\", e, t, a))\n            ];\n        case \"IRFFT\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.irfft)(getParamValue(\"x\", e, t, a))\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n}, executeOp$15 = function(e, t, a) {\n    switch(e.op){\n        case \"Cast\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.cast)(getParamValue(\"x\", e, t, a), getParamValue(\"dtype\", e, t, a))\n            ];\n        case \"ExpandDims\":\n            var r = getParamValue(\"axis\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.expandDims)(getParamValue(\"x\", e, t, a), r)\n            ];\n        case \"Squeeze\":\n            r = getParamValue(\"axis\", e, t, a);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.squeeze)(getParamValue(\"x\", e, t, a), r)\n            ];\n        case \"Reshape\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.reshape)(getParamValue(\"x\", e, t, a), getParamValue(\"shape\", e, t, a))\n            ];\n        case \"PadV2\":\n        case \"Pad\":\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.pad)(getParamValue(\"x\", e, t, a), split$1(getParamValue(\"padding\", e, t, a), 2), getParamValue(\"constantValue\", e, t, a))\n            ];\n        case \"SpaceToBatchND\":\n            var n = getParamValue(\"blockShape\", e, t, a), s = split$1(getParamValue(\"paddings\", e, t, a), 2);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.spaceToBatchND)(getParamValue(\"x\", e, t, a), n, s)\n            ];\n        case \"BatchToSpaceND\":\n            n = getParamValue(\"blockShape\", e, t, a);\n            var o = split$1(getParamValue(\"crops\", e, t, a), 2);\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.batchToSpaceND)(getParamValue(\"x\", e, t, a), n, o)\n            ];\n        case \"DepthToSpace\":\n            var p = getParamValue(\"blockSize\", e, t, a), u = getParamValue(\"dataFormat\", e, t, a).toUpperCase();\n            return [\n                (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.depthToSpace)(getParamValue(\"x\", e, t, a), p, u)\n            ];\n        default:\n            throw TypeError(\"Node type \" + e.op + \" is not implemented\");\n    }\n};\nfunction executeOp$16(e, t, a) {\n    var r = function(e, t, a) {\n        switch(e.category){\n            case \"arithmetic\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp(e, t, a);\n                });\n            case \"basic_math\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$1(e, t, a);\n                });\n            case \"control\":\n                return executeOp$2(e, t, a);\n            case \"convolution\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$3(e, t, a);\n                });\n            case \"creation\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$4(e, t, a);\n                });\n            case \"dynamic\":\n                return executeOp$5(e, t, a);\n            case \"evaluation\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$6(e, t, a);\n                });\n            case \"image\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$8(e, t, a);\n                });\n            case \"graph\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$7(e, t, a);\n                });\n            case \"logical\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$9(e, t, a);\n                });\n            case \"matrices\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$10(e, t, a);\n                });\n            case \"normalization\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$11(e, t, a);\n                });\n            case \"reduction\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$12(e, t, a);\n                });\n            case \"slice_join\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$13(e, t, a);\n                });\n            case \"spectral\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$14(e, t, a);\n                });\n            case \"transformation\":\n                return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n                    return executeOp$15(e, t, a);\n                });\n            case \"custom\":\n                var r = getRegisteredOp(e.op);\n                if (r && r.customExecutor) return r.customExecutor(new NodeValueImpl(e, t, a));\n                throw TypeError(\"Custom op \" + e.op + \" is not registered.\");\n            default:\n                throw TypeError(\"Unknown op '\" + e.op + \"'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()\");\n        }\n    }(e, t, a);\n    return r instanceof Promise ? r.then(function(e) {\n        return [].concat(e);\n    }) : [].concat(r);\n}\nvar ExecutionContext = function() {\n    function e(e, t) {\n        this.weightMap = e, this.tensorArrayMap = t, this.rootContext = {\n            id: 0,\n            frameName: \"\",\n            iterationId: 0\n        }, this.contexts = [\n            this.rootContext\n        ], this.lastId = 0, this.generateCurrentContextIds();\n    }\n    return e.prototype.newFrame = function(e, t) {\n        return {\n            id: e,\n            frameName: t,\n            iterationId: 0\n        };\n    }, Object.defineProperty(e.prototype, \"currentContext\", {\n        get: function() {\n            return this.contexts;\n        },\n        set: function(e) {\n            this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds());\n        },\n        enumerable: !0,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"currentContextId\", {\n        get: function() {\n            return this._currentContextIds[0];\n        },\n        enumerable: !0,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"currentContextIds\", {\n        get: function() {\n            return this._currentContextIds;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), e.prototype.generateCurrentContextIds = function() {\n        for(var e = [], t = 0; t < this.contexts.length - 1; t++){\n            var a = this.contexts.slice(0, this.contexts.length - t);\n            e.push(this.contextIdforContexts(a));\n        }\n        e.push(\"\"), this._currentContextIds = e;\n    }, e.prototype.contextIdforContexts = function(e) {\n        return e ? e.map(function(e) {\n            return 0 === e.id && 0 === e.iterationId ? \"\" : e.frameName + \"-\" + e.iterationId;\n        }).join(\"/\") : \"\";\n    }, e.prototype.enterFrame = function(e) {\n        this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));\n    }, e.prototype.exitFrame = function() {\n        if (!(this.contexts && this.contexts.length > 1)) throw new Error(\"Cannot exit frame, the context is empty\");\n        this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();\n    }, e.prototype.nextIteration = function() {\n        if (!(this.contexts && this.contexts.length > 0)) throw new Error(\"Cannot increase frame iteration, the context is empty\");\n        this.contexts = this.contexts.slice(), this.lastId++;\n        var e = Object.assign({}, this.contexts[this.contexts.length - 1]);\n        e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n    }, e.prototype.getWeight = function(e) {\n        return this.weightMap[e];\n    }, e.prototype.addTensorArray = function(e) {\n        this.tensorArrayMap[e.id] = e;\n    }, e.prototype.getTensorArray = function(e) {\n        return this.tensorArrayMap[e];\n    }, e;\n}();\nfunction getExecutionSubgraph(e, t, a) {\n    for(var r = new Set, n = [], s = null, o = null, p = new Set, u = Object.keys(e).map(function(e) {\n        return parseNodeName(e)[0];\n    }), i = t.slice(); i.length > 0;){\n        var m = i.pop();\n        (isControlFlow(m) || isDynamicShape(m)) && null == s && (o = (s = m).children.map(function(e) {\n            return e.name;\n        }).filter(function(e) {\n            return r.has(e);\n        })), r.add(m.name), null == a[m.name] && -1 === u.indexOf(m.name) && (0 !== m.inputs.length ? m.inputs.forEach(function(e) {\n            p.has(e.name) || (p.add(e.name), i.push(e));\n        }) : n.push(m.name));\n    }\n    return {\n        inputs: e,\n        outputs: t,\n        usedNodes: r,\n        missingInputs: n,\n        dynamicNode: s,\n        syncInputs: o\n    };\n}\nfunction getNodesInTopologicalOrder(e, t, a) {\n    var r = a.usedNodes, n = a.inputs, s = [];\n    Object.keys(n).map(function(e) {\n        return parseNodeName(e)[0];\n    }).map(function(t) {\n        return e.nodes[t];\n    }).forEach(function(e) {\n        r.has(e.name) && s.push(e);\n    }), e.weights.forEach(function(e) {\n        r.has(e.name) && s.push(e);\n    });\n    for(var o = new Set, p = []; s.length > 0;){\n        var u = s.pop();\n        o.add(u.name), t[u.name] || p.push(u), u.children.forEach(function(e) {\n            !o.has(e.name) && r.has(e.name) && e.inputs.every(function(e) {\n                return o.has(e.name);\n            }) && s.push(e);\n        });\n    }\n    return p;\n}\nvar CONTROL_FLOW_OPS = [\n    \"Switch\",\n    \"Merge\",\n    \"Enter\",\n    \"Exit\",\n    \"NextIteration\"\n], DYNAMIC_SHAPE_OPS = [\n    \"NonMaxSuppressionV2\",\n    \"NonMaxSuppressionV3\",\n    \"NonMaxSuppressionV5\",\n    \"Where\"\n];\nfunction isControlFlow(e) {\n    return CONTROL_FLOW_OPS.indexOf(e.op) >= 0;\n}\nfunction isDynamicShape(e) {\n    return DYNAMIC_SHAPE_OPS.indexOf(e.op) >= 0;\n}\nvar GraphExecutor = function() {\n    function e(e) {\n        this.graph = e, this.compiledMap = new Map, this._weightMap = {}, this.SEPERATOR = \",\", this._outputs = e.outputs, this._inputs = e.inputs, this._signature = e.signature;\n    }\n    return Object.defineProperty(e.prototype, \"weightMap\", {\n        get: function() {\n            return this._weightMap;\n        },\n        set: function(e) {\n            var t = Object.keys(e).map(function(t) {\n                return e[t].map(function(e) {\n                    return e.id;\n                });\n            });\n            this.weightIds = [].concat.apply([], t), this._weightMap = e;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"inputs\", {\n        get: function() {\n            return this._inputs.map(function(e) {\n                return {\n                    name: e.name,\n                    shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,\n                    dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0\n                };\n            });\n        },\n        enumerable: !0,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"outputs\", {\n        get: function() {\n            return this._outputs.map(function(e) {\n                return {\n                    name: e.name,\n                    shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,\n                    dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0\n                };\n            });\n        },\n        enumerable: !0,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"inputNodes\", {\n        get: function() {\n            return this._inputs.map(function(e) {\n                return e.signatureKey || e.name;\n            });\n        },\n        enumerable: !0,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"outputNodes\", {\n        get: function() {\n            return this._outputs.map(function(e) {\n                return e.signatureKey || e.name;\n            });\n        },\n        enumerable: !0,\n        configurable: !0\n    }), e.prototype.getCompilationKey = function(e, t) {\n        var a = e.map(function(e) {\n            return e.name;\n        }).sort(), r = t.map(function(e) {\n            return e.name;\n        }).sort();\n        return a.join(this.SEPERATOR) + \"--\" + r.join(this.SEPERATOR);\n    }, e.prototype.compile = function(e, t) {\n        var a = getExecutionSubgraph(e, t, this.weightMap), r = a.missingInputs, n = a.dynamicNode, s = a.syncInputs;\n        if (null != n) throw new Error(\"This execution contains the node '\" + n.name + \"', which has the dynamic op '\" + n.op + \"'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [\" + s + \"]\");\n        if (r.length > 0) {\n            var o = t.map(function(e) {\n                return e.name;\n            }), p = Object.keys(e);\n            throw new Error(\"Cannot compute the outputs [\" + o + \"] from the provided inputs [\" + p + \"]. Missing the following inputs: [\" + r + \"]\");\n        }\n        return getNodesInTopologicalOrder(this.graph, this.weightMap, a);\n    }, e.prototype.execute = function(e, t) {\n        var a = this;\n        e = this.mapInputs(e);\n        var r = Object.keys(e).sort();\n        this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t);\n        var n = r.map(function(e) {\n            return a.graph.nodes[parseNodeName(e)[0]];\n        }), s = t.map(function(e) {\n            return a.graph.nodes[parseNodeName(e)[0]];\n        }), o = this.getCompilationKey(n, s), p = this.compiledMap.get(o);\n        null == p && (p = this.compile(e, s), this.compiledMap.set(o, p));\n        var u = {};\n        return (0,_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.tidy)(function() {\n            var r = new ExecutionContext(a._weightMap, u), n = __assign({}, a.weightMap);\n            Object.keys(e).forEach(function(t) {\n                var a = parseNodeName(t), r = a[0], s = [];\n                s[a[1]] = e[t], n[r] = s;\n            });\n            for(var s = a.getFrozenTensorIds(n), o = {}, i = 0; i < p.length; i++){\n                var m = p[i];\n                if (!n[m.name]) {\n                    var l = executeOp$16(m, n, r);\n                    if (l instanceof Promise) throw new Error(\"The execution of the op '\" + m.op + \"' returned a promise. Please use model.executeAsync() instead.\");\n                    n[m.name] = l, a.checkTensorForDisposal(m.name, m, n, r, s, t, o);\n                }\n            }\n            return t.map(function(e) {\n                return getTensor(e, n, r);\n            });\n        });\n    }, e.prototype.getFrozenTensorIds = function(e) {\n        var t = [].concat.apply([], Object.keys(e).map(function(t) {\n            return e[t];\n        }).map(function(e) {\n            return e.map(function(e) {\n                return e.id;\n            });\n        }));\n        return new Set(t);\n    }, e.prototype.checkTensorForDisposal = function(e, t, a, r, n, s, o) {\n        \"control\" !== t.category && -1 === s.indexOf(e) && (a[e].forEach(function(e) {\n            null != e && (o[e.id] = (o[e.id] || 0) + t.children.length);\n        }), t.inputs.forEach(function(e) {\n            if (\"control\" !== e.category) {\n                var t = getTensorsForCurrentContenxt(e.name, a, r);\n                null != t && t.forEach(function(e) {\n                    if (e && !n.has(e.id)) {\n                        var t = o[e.id];\n                        1 === t ? (e.dispose(), delete o[e.id]) : null != t && o[e.id]--;\n                    }\n                });\n            }\n        }));\n    }, e.prototype.executeAsync = function(e, t) {\n        return __awaiter(this, void 0, void 0, function() {\n            var a, r, n, s, o, p, u = this;\n            return __generator(this, function(i) {\n                switch(i.label){\n                    case 0:\n                        return e = this.mapInputs(e), this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t), a = {}, r = new ExecutionContext(this._weightMap, a), [\n                            4,\n                            this.executeWithControlFlow(e, r, t)\n                        ];\n                    case 1:\n                        return n = i.sent(), s = t.map(function(e) {\n                            return getTensor(e, n, r);\n                        }), o = new Set(s.map(function(e) {\n                            return e.id;\n                        })), p = new Set(Object.keys(e).map(function(t) {\n                            return e[t].id;\n                        })), Object.keys(n).forEach(function(e) {\n                            n[e].forEach(function(e) {\n                                !e || e.isDisposed || o.has(e.id) || p.has(e.id) || -1 !== u.weightIds.indexOf(e.id) || e.dispose();\n                            });\n                        }), [\n                            2,\n                            s\n                        ];\n                }\n            });\n        });\n    }, e.prototype.executeWithControlFlow = function(e, t, a) {\n        return __awaiter(this, void 0, void 0, function() {\n            var r, n, s, o, p, u, i, m, l, c, d, y, f, g, h, N, x = this;\n            return __generator(this, function(V) {\n                switch(V.label){\n                    case 0:\n                        r = Object.keys(e), n = r.map(function(e) {\n                            return x.graph.nodes[parseNodeName(e)[0]];\n                        }), s = a.map(function(e) {\n                            return x.graph.nodes[parseNodeName(e)[0]];\n                        }), o = getExecutionSubgraph(e, s, this.weightMap), p = o.usedNodes, u = o.missingInputs, i = o.dynamicNode, m = o.syncInputs, l = n.concat(this.graph.weights).map(function(e) {\n                            return {\n                                node: e,\n                                contexts: t.currentContext\n                            };\n                        }), c = __assign({}, this.weightMap), Object.keys(e).forEach(function(t) {\n                            var a = parseNodeName(t), r = a[0], n = [];\n                            n[a[1]] = e[t], c[r] = n;\n                        }), d = {}, y = this.getFrozenTensorIds(c), f = {}, V.label = 1;\n                    case 1:\n                        return l.length > 0 ? (g = this.processStack(n, l, t, c, f, y, a, d, p), [\n                            4,\n                            Promise.all(g)\n                        ]) : [\n                            3,\n                            3\n                        ];\n                    case 2:\n                        return V.sent(), [\n                            3,\n                            1\n                        ];\n                    case 3:\n                        if (null == i && console.warn(\"This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.\"), (h = s.filter(function(e) {\n                            return !isControlFlow(e) && !getTensor(e.name, c, t);\n                        }).map(function(e) {\n                            return e.name;\n                        })).length > 0) throw N = \"\", null != i && (N = \"Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [\" + m + \"]\"), new Error(\"Cannot compute the outputs [\" + h + \"] from the provided inputs [\" + r + \"]. Consider providing the following inputs: [\" + u + \"]. \" + N);\n                        return [\n                            2,\n                            c\n                        ];\n                }\n            });\n        });\n    }, e.prototype.processStack = function(e, t, a, r, n, s, o, p, u) {\n        for(var i = this, m = [], l = function() {\n            var l = t.pop();\n            a.currentContext = l.contexts;\n            var d = \"\";\n            if (\"Enter\" === l.node.op && getParamValue(\"isConstant\", l.node, r, a) && (d = getNodeNameAndIndex(l.node.name, a)[0]), -1 === e.indexOf(l.node)) {\n                var y = executeOp$16(l.node, r, a);\n                d || (d = getNodeNameAndIndex(l.node.name, a)[0]);\n                var f = a.currentContext;\n                y instanceof Promise ? m.push(y.then(function(e) {\n                    return r[d] = e, a.currentContext = f, i.checkTensorForDisposal(d, l.node, r, a, s, o, p), i.processChildNodes(l.node, t, a, r, n, u), e;\n                })) : (r[d] = y, c.checkTensorForDisposal(d, l.node, r, a, s, o, p), c.processChildNodes(l.node, t, a, r, n, u));\n            } else c.processChildNodes(l.node, t, a, r, n, u);\n        }, c = this; t.length > 0;)l();\n        return m;\n    }, e.prototype.processChildNodes = function(e, t, a, r, n, s) {\n        e.children.forEach(function(e) {\n            var o = getNodeNameAndIndex(e.name, a)[0];\n            !n[o] && s.has(e.name) && (\"Merge\" === e.op ? e.inputNames.some(function(e) {\n                return !!getTensor(e, r, a);\n            }) && (n[o] = !0, t.push({\n                contexts: a.currentContext,\n                node: e\n            })) : e.inputNames.every(function(e) {\n                return !!getTensor(e, r, a);\n            }) && (n[o] = !0, t.push({\n                contexts: a.currentContext,\n                node: e\n            })));\n        });\n    }, e.prototype.dispose = function() {\n        var e = this;\n        Object.keys(this.weightMap).forEach(function(t) {\n            return e.weightMap[t].forEach(function(e) {\n                return e.dispose();\n            });\n        });\n    }, e.prototype.checkInputShapeAndType = function(e) {\n        var t = this;\n        Object.keys(e).forEach(function(a) {\n            var r = e[a], n = parseNodeName(a)[0], s = t.graph.nodes[n];\n            if (s.attrParams.shape && s.attrParams.shape.value) {\n                var o = s.attrParams.shape.value, p = o.length === r.shape.length && r.shape.every(function(e, t) {\n                    return -1 === o[t] || o[t] === e;\n                });\n                _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(p, function() {\n                    return \"The shape of dict['\" + s.name + \"'] provided in model.execute(dict) must be [\" + o + \"], but was [\" + r.shape + \"]\";\n                });\n            }\n            s.attrParams.dtype && s.attrParams.dtype.value && _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.util.assert(r.dtype === s.attrParams.dtype.value, function() {\n                return \"The dtype of dict['\" + s.name + \"'] provided in model.execute(dict) must be \" + s.attrParams.dtype.value + \", but was \" + r.dtype;\n            });\n        });\n    }, e.prototype.mapInputs = function(e) {\n        var t = {};\n        for(var a in e){\n            if (null != this._signature && null != this._signature.inputs && null != this._signature.inputs[a]) t[this._signature.inputs[a].name] = e[a];\n            else t[a] = e[a];\n        }\n        return t;\n    }, e.prototype.checkInputs = function(e) {\n        var t = this, a = Object.keys(e).filter(function(e) {\n            var a = parseNodeName(e)[0];\n            return null == t.graph.nodes[a];\n        });\n        if (a.length > 0) throw new Error(\"The dict provided in model.execute(dict) has keys: [\" + a + \"] that are not part of graph\");\n    }, e.prototype.mapOutputs = function(e) {\n        var t = this;\n        return e.map(function(e) {\n            return null != t._signature && null != t._signature.outputs && null != t._signature.outputs[e] ? t._signature.outputs[e].name : e;\n        }, {});\n    }, e.prototype.checkOutputs = function(e) {\n        var t = this;\n        e.forEach(function(e) {\n            var a = parseNodeName(e)[0];\n            if (!t.graph.nodes[a]) throw new Error(\"The output '\" + e + \"' is not found in the graph\");\n        });\n    }, e;\n}(), TFHUB_SEARCH_PARAM = \"?tfjs-format=file\", DEFAULT_MODEL_NAME = \"model.json\", GraphModel = function() {\n    function e(e, t) {\n        void 0 === t && (t = {}), this.modelUrl = e, this.loadOptions = t, this.version = \"n/a\", null == t && (this.loadOptions = {});\n    }\n    return Object.defineProperty(e.prototype, \"modelVersion\", {\n        get: function() {\n            return this.version;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"inputNodes\", {\n        get: function() {\n            return this.executor.inputNodes;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"outputNodes\", {\n        get: function() {\n            return this.executor.outputNodes;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"inputs\", {\n        get: function() {\n            return this.executor.inputs;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"outputs\", {\n        get: function() {\n            return this.executor.outputs;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"weights\", {\n        get: function() {\n            return this.executor.weightMap;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), e.prototype.findIOHandler = function() {\n        var e = this.modelUrl;\n        if (null != e.load) this.handler = e;\n        else if (null != this.loadOptions.requestInit) this.handler = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.io.browserHTTPRequest(e, this.loadOptions);\n        else {\n            var t = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.io.getLoadHandlers(e, this.loadOptions.onProgress);\n            if (0 === t.length) t.push(_tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.io.browserHTTPRequest(e, this.loadOptions));\n            else if (t.length > 1) throw new Error(\"Found more than one (\" + t.length + \") load handlers for URL '\" + [\n                e\n            ] + \"'\");\n            this.handler = t[0];\n        }\n    }, e.prototype.load = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var e, t, a, r;\n            return __generator(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        if (this.findIOHandler(), null == this.handler.load) throw new Error(\"Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.\");\n                        return e = this, [\n                            4,\n                            this.handler.load()\n                        ];\n                    case 1:\n                        return e.artifacts = n.sent(), t = this.artifacts.modelTopology, a = {}, null != this.artifacts.userDefinedMetadata && (a = this.artifacts.userDefinedMetadata.signature), this.version = t.versions.producer + \".\" + t.versions.minConsumer, r = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs), this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(t, a)), this.executor.weightMap = this.convertTensorMapToTensorsMap(r), [\n                            2,\n                            !0\n                        ];\n                }\n            });\n        });\n    }, e.prototype.save = function(e, t) {\n        return __awaiter(this, void 0, void 0, function() {\n            var t;\n            return __generator(this, function(a) {\n                if (\"string\" == typeof e) {\n                    if (0 === (t = _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.io.getSaveHandlers(e)).length) throw new Error(\"Cannot find any save handlers for URL '\" + e + \"'\");\n                    if (t.length > 1) throw new Error(\"Found more than one (\" + t.length + \") save handlers for URL '\" + e + \"'\");\n                    e = t[0];\n                }\n                if (null == e.save) throw new Error(\"GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.\");\n                return [\n                    2,\n                    e.save(this.artifacts)\n                ];\n            });\n        });\n    }, e.prototype.predict = function(e, t) {\n        return this.execute(e, this.outputNodes);\n    }, e.prototype.normalizeInputs = function(e) {\n        if (!(e instanceof _tensorflow_tfjs_core__WEBPACK_IMPORTED_MODULE_0__.Tensor || Array.isArray(e))) return e;\n        if ((e = Array.isArray(e) ? e : [\n            e\n        ]).length !== this.inputNodes.length) throw new Error(\"Input tensor count mismatch,the graph model has \" + this.inputNodes.length + \" placeholders, while there are \" + e.length + \" input tensors.\");\n        return this.inputNodes.reduce(function(t, a, r) {\n            return t[a] = e[r], t;\n        }, {});\n    }, e.prototype.normalizeOutputs = function(e) {\n        return e = e || this.outputNodes, Array.isArray(e) ? e : [\n            e\n        ];\n    }, e.prototype.execute = function(e, t) {\n        e = this.normalizeInputs(e), t = this.normalizeOutputs(t);\n        var a = this.executor.execute(e, t);\n        return a.length > 1 ? a : a[0];\n    }, e.prototype.executeAsync = function(e, t) {\n        return __awaiter(this, void 0, void 0, function() {\n            var a;\n            return __generator(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        return e = this.normalizeInputs(e), t = this.normalizeOutputs(t), [\n                            4,\n                            this.executor.executeAsync(e, t)\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            (a = r.sent()).length > 1 ? a : a[0]\n                        ];\n                }\n            });\n        });\n    }, e.prototype.convertTensorMapToTensorsMap = function(e) {\n        return Object.keys(e).reduce(function(t, a) {\n            return t[a] = [\n                e[a]\n            ], t;\n        }, {});\n    }, e.prototype.dispose = function() {\n        this.executor.dispose();\n    }, e;\n}();\nfunction loadGraphModel(e, t) {\n    return void 0 === t && (t = {}), __awaiter(this, void 0, void 0, function() {\n        var a;\n        return __generator(this, function(r) {\n            switch(r.label){\n                case 0:\n                    if (null == e) throw new Error(\"modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model\");\n                    return null == t && (t = {}), t.fromTFHub && null == e.load && (e.endsWith(\"/\") || (e += \"/\"), e = \"\" + e + DEFAULT_MODEL_NAME + TFHUB_SEARCH_PARAM), [\n                        4,\n                        (a = new GraphModel(e, t)).load()\n                    ];\n                case 1:\n                    return r.sent(), [\n                        2,\n                        a\n                    ];\n            }\n        });\n    });\n}\nvar version = \"1.7.4\";\n //# sourceMappingURL=tf-converter.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb252ZXJ0ZXIvZGlzdC90Zi1jb252ZXJ0ZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNpaEM7QUFBQSxJQUFJc0ksVUFBU0MsVUFBU0MsV0FBUztJQUFXLE9BQU0sQ0FBQ0EsV0FBU0MsT0FBT0MsTUFBTSxJQUFFLFNBQVNDLENBQUM7UUFBRSxJQUFJLElBQUlDLEdBQUVDLElBQUUsR0FBRUMsSUFBRUMsVUFBVUMsTUFBTSxFQUFDSCxJQUFFQyxHQUFFRCxJQUFJLElBQUksSUFBSUksS0FBS0wsSUFBRUcsU0FBUyxDQUFDRixFQUFFLENBQUNKLE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUVLLE1BQUtOLENBQUFBLENBQUMsQ0FBQ00sRUFBRSxHQUFDTCxDQUFDLENBQUNLLEVBQUU7UUFBRSxPQUFPTjtJQUFDLEdBQUdVLEtBQUssQ0FBQyxJQUFJLEVBQUNOO0FBQVU7QUFBRSxTQUFTTyxVQUFVWCxDQUFDLEVBQUNDLENBQUMsRUFBQ0MsQ0FBQyxFQUFDQyxDQUFDO0lBQUUsT0FBTyxJQUFJRCxDQUFBQSxLQUFJQSxDQUFBQSxJQUFFVSxPQUFNLENBQUMsRUFBRyxTQUFTTixDQUFDLEVBQUNPLENBQUM7UUFBRSxTQUFTQyxFQUFFZCxDQUFDO1lBQUUsSUFBRztnQkFBQ2UsRUFBRVosRUFBRWEsSUFBSSxDQUFDaEI7WUFBRyxFQUFDLE9BQU1BLEdBQUU7Z0JBQUNhLEVBQUViO1lBQUU7UUFBQztRQUFDLFNBQVNpQixFQUFFakIsQ0FBQztZQUFFLElBQUc7Z0JBQUNlLEVBQUVaLEVBQUVlLEtBQUssQ0FBQ2xCO1lBQUcsRUFBQyxPQUFNQSxHQUFFO2dCQUFDYSxFQUFFYjtZQUFFO1FBQUM7UUFBQyxTQUFTZSxFQUFFZixDQUFDO1lBQUVBLEVBQUVtQixJQUFJLEdBQUNiLEVBQUVOLEVBQUVvQixLQUFLLElB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QUFRQyxRQUFPO1lBQUM7Z0JBQUM0QixPQUFNO2dCQUFFQyxNQUFLO2dCQUFJcEIsTUFBSztZQUFRO1NBQUU7SUFBQTtJQUFFO1FBQUNYLFVBQVM7UUFBWUMsVUFBUztRQUFRQyxRQUFPO1lBQUM7Z0JBQUM0QixPQUFNO2dCQUFFSSxLQUFJO2dCQUFFSCxNQUFLO2dCQUFJcEIsTUFBSztZQUFTO1NBQUU7SUFBQTtJQUFFO1FBQUNYLFVBQVM7UUFBV0MsVUFBUztRQUFRQyxRQUFPO1lBQUM7Z0JBQUM0QixPQUFNO2dCQUFFQyxNQUFLO2dCQUFJcEIsTUFBSztZQUFRO1NBQUU7SUFBQTtJQUFFO1FBQUNYLFVBQVM7UUFBT0MsVUFBUztRQUFRQyxRQUFPO1lBQUM7Z0JBQUM0QixPQUFNO2dCQUFFQyxNQUFLO2dCQUFJcEIsTUFBSztZQUFRO1NBQUU7SUFBQTtJQUFFO1FBQUNYLFVBQVM7UUFBT0MsVUFBUztRQUFRQyxRQUFPO1lBQUM7Z0JBQUM0QixPQUFNO2dCQUFFQyxNQUFLO2dCQUFJcEIsTUFBSztZQUFRO1NBQUU7SUFBQTtJQUFFO1FBQUNYLFVBQVM7UUFBUUMsVUFBUztRQUFRQyxRQUFPO1lBQUM7Z0JBQUM0QixPQUFNO2dCQUFFQyxNQUFLO2dCQUFJcEIsTUFBSztZQUFRO1NBQUU7SUFBQTtJQUFFO1FBQUNYLFVBQVM7UUFBU0MsVUFBUztRQUFRQyxRQUFPO1lBQUM7Z0JBQUM0QixPQUFNO2dCQUFFSSxLQUFJO2dCQUFFSCxNQUFLO2dCQUFJcEIsTUFBSztZQUFTO1NBQUU7SUFBQTtJQUFFO1FBQUNYLFVBQVM7UUFBUUMsVUFBUztRQUFRQyxRQUFPO1lBQUM7Z0JBQUM0QixPQUFNO2dCQUFFQyxNQUFLO2dCQUFJcEIsTUFBSztZQUFRO1lBQUU7Z0JBQUNtQixPQUFNO2dCQUFFQyxNQUFLO2dCQUFPcEIsTUFBSztZQUFTO1NBQUU7UUFBQ1IsT0FBTTtZQUFDO2dCQUFDNkIsUUFBTztnQkFBVUQsTUFBSztnQkFBVXBCLE1BQUs7WUFBUTtZQUFFO2dCQUFDcUIsUUFBTztnQkFBVUQsTUFBSztnQkFB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QUErRixDQUNqbjdGLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtY29tbWVudGVyLy4vbm9kZV9tb2R1bGVzL0B0ZW5zb3JmbG93L3RmanMtY29udmVydGVyL2Rpc3QvdGYtY29udmVydGVyLmVzbS5qcz81MTBkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmltcG9ydHtlbnYsY29uY2F0LHNsaWNlLHN0YWNrLHRlbnNvcix0aWR5LHVuc3RhY2ssdXRpbCxpbyxUZW5zb3IsYWRkLGFkZE4sbW9kLG11bCxkaXYsZGl2Tm9OYW4sZmxvb3JEaXYsc3ViLG1pbmltdW0sbWF4aW11bSxwb3csc3F1YXJlZERpZmZlcmVuY2UsYWJzLGFjb3MsYWNvc2gsYXNpbixhc2luaCxhdGFuLGF0YW4yLGF0YW5oLGNlaWwsY29tcGxleCxjb3MsY29zaCxlbHUsZXJmLGV4cCxleHBtMSxmbG9vcixsb2csbG9nMXAsaW1hZyxuZWcscmVjaXByb2NhbCxyZWFsLHJlbHUscm91bmQsc2VsdSxzaWdtb2lkLHNpbixzaWduLHNpbmgsc29mdHBsdXMsc3FydCxzcXVhcmUsdGFuaCx0YW4sY2xpcEJ5VmFsdWUscnNxcnQscHJvZCxsZWFreVJlbHUscHJlbHUsc2NhbGFyLGNvbnYxZCxjb252MmQsZnVzZWQsY29udjJkVHJhbnNwb3NlLGRlcHRod2lzZUNvbnYyZCxjb252M2QsYXZnUG9vbCxtYXhQb29sLG1heFBvb2xXaXRoQXJnbWF4LGF2Z1Bvb2wzZCxtYXhQb29sM2QsZmlsbCxsaW5zcGFjZSxtdWx0aW5vbWlhbCxvbmVIb3Qsb25lcyxvbmVzTGlrZSxyYW5kb21Vbmlmb3JtLHJhbmdlLHRydW5jYXRlZE5vcm1hbCx6ZXJvcyx6ZXJvc0xpa2UsaW1hZ2Usd2hlcmVBc3luYyxzZXRkaWZmMWRBc3luYyx0b3BrLHRlbnNvcjFkLGVxdWFsLG5vdEVxdWFsLGdyZWF0ZXIsZ3JlYXRlckVxdWFsLGxlc3MsbGVzc0VxdWFsLGxvZ2ljYWxBbmQsbG9naWNhbE5vdCxsb2dpY2FsT3Isd2hlcmUsbWF0TXVsLHRyYW5zcG9zZSxiYXRjaE5vcm0sbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24sc29mdG1heCxsb2dTb2Z0bWF4LHNwYXJzZVRvRGVuc2UsbWF4LG1lYW4sbWluLHN1bSxhbGwsYW55LGFyZ01heCxhcmdNaW4sZ2F0aGVyLHJldmVyc2Usc3RyaWRlZFNsaWNlLHRpbGUsc3BsaXQsc2NhdHRlck5ELGdhdGhlck5ELGZmdCxpZmZ0LHJmZnQsaXJmZnQsY2FzdCxleHBhbmREaW1zLHNxdWVlemUscmVzaGFwZSxwYWQsc3BhY2VUb0JhdGNoTkQsYmF0Y2hUb1NwYWNlTkQsZGVwdGhUb1NwYWNlfWZyb21cIkB0ZW5zb3JmbG93L3RmanMtY29yZVwiO3ZhciBEYXRhVHlwZSxTYXZlckRlZixfX2Fzc2lnbj1mdW5jdGlvbigpe3JldHVybihfX2Fzc2lnbj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHQsYT0xLHI9YXJndW1lbnRzLmxlbmd0aDthPHI7YSsrKWZvcih2YXIgbiBpbiB0PWFyZ3VtZW50c1thXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSk7cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIF9fYXdhaXRlcihlLHQsYSxyKXtyZXR1cm4gbmV3KGF8fChhPVByb21pc2UpKShmdW5jdGlvbihuLHMpe2Z1bmN0aW9uIG8oZSl7dHJ5e3Uoci5uZXh0KGUpKX1jYXRjaChlKXtzKGUpfX1mdW5jdGlvbiBwKGUpe3RyeXt1KHIudGhyb3coZSkpfWNhdGNoKGUpe3MoZSl9fWZ1bmN0aW9uIHUoZSl7ZS5kb25lP24oZS52YWx1ZSk6bmV3IGEoZnVuY3Rpb24odCl7dChlLnZhbHVlKX0pLnRoZW4obyxwKX11KChyPXIuYXBwbHkoZSx0fHxbXSkpLm5leHQoKSl9KX1mdW5jdGlvbiBfX2dlbmVyYXRvcihlLHQpe3ZhciBhLHIsbixzLG89e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmblswXSl0aHJvdyBuWzFdO3JldHVybiBuWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIHM9e25leHQ6cCgwKSx0aHJvdzpwKDEpLHJldHVybjpwKDIpfSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihzW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLHM7ZnVuY3Rpb24gcChzKXtyZXR1cm4gZnVuY3Rpb24ocCl7cmV0dXJuIGZ1bmN0aW9uKHMpe2lmKGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDtvOyl0cnl7aWYoYT0xLHImJihuPTImc1swXT9yLnJldHVybjpzWzBdP3IudGhyb3d8fCgobj1yLnJldHVybikmJm4uY2FsbChyKSwwKTpyLm5leHQpJiYhKG49bi5jYWxsKHIsc1sxXSkpLmRvbmUpcmV0dXJuIG47c3dpdGNoKHI9MCxuJiYocz1bMiZzWzBdLG4udmFsdWVdKSxzWzBdKXtjYXNlIDA6Y2FzZSAxOm49czticmVhaztjYXNlIDQ6cmV0dXJuIG8ubGFiZWwrKyx7dmFsdWU6c1sxXSxkb25lOiExfTtjYXNlIDU6by5sYWJlbCsrLHI9c1sxXSxzPVswXTtjb250aW51ZTtjYXNlIDc6cz1vLm9wcy5wb3AoKSxvLnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZighKG49KG49by50cnlzKS5sZW5ndGg+MCYmbltuLmxlbmd0aC0xXSkmJig2PT09c1swXXx8Mj09PXNbMF0pKXtvPTA7Y29udGludWV9aWYoMz09PXNbMF0mJighbnx8c1sxXT5uWzBdJiZzWzFdPG5bM10pKXtvLmxhYmVsPXNbMV07YnJlYWt9aWYoNj09PXNbMF0mJm8ubGFiZWw8blsxXSl7by5sYWJlbD1uWzFdLG49czticmVha31pZihuJiZvLmxhYmVsPG5bMl0pe28ubGFiZWw9blsyXSxvLm9wcy5wdXNoKHMpO2JyZWFrfW5bMl0mJm8ub3BzLnBvcCgpLG8udHJ5cy5wb3AoKTtjb250aW51ZX1zPXQuY2FsbChlLG8pfWNhdGNoKGUpe3M9WzYsZV0scj0wfWZpbmFsbHl7YT1uPTB9aWYoNSZzWzBdKXRocm93IHNbMV07cmV0dXJue3ZhbHVlOnNbMF0/c1sxXTp2b2lkIDAsZG9uZTohMH19KFtzLHBdKX19fSFmdW5jdGlvbihlKXtlW2UuRFRfSU5WQUxJRD0wXT1cIkRUX0lOVkFMSURcIixlW2UuRFRfRkxPQVQ9MV09XCJEVF9GTE9BVFwiLGVbZS5EVF9ET1VCTEU9Ml09XCJEVF9ET1VCTEVcIixlW2UuRFRfSU5UMzI9M109XCJEVF9JTlQzMlwiLGVbZS5EVF9VSU5UOD00XT1cIkRUX1VJTlQ4XCIsZVtlLkRUX0lOVDE2PTVdPVwiRFRfSU5UMTZcIixlW2UuRFRfSU5UOD02XT1cIkRUX0lOVDhcIixlW2UuRFRfU1RSSU5HPTddPVwiRFRfU1RSSU5HXCIsZVtlLkRUX0NPTVBMRVg2ND04XT1cIkRUX0NPTVBMRVg2NFwiLGVbZS5EVF9JTlQ2ND05XT1cIkRUX0lOVDY0XCIsZVtlLkRUX0JPT0w9MTBdPVwiRFRfQk9PTFwiLGVbZS5EVF9RSU5UOD0xMV09XCJEVF9RSU5UOFwiLGVbZS5EVF9RVUlOVDg9MTJdPVwiRFRfUVVJTlQ4XCIsZVtlLkRUX1FJTlQzMj0xM109XCJEVF9RSU5UMzJcIixlW2UuRFRfQkZMT0FUMTY9MTRdPVwiRFRfQkZMT0FUMTZcIixlW2UuRFRfRkxPQVRfUkVGPTEwMV09XCJEVF9GTE9BVF9SRUZcIixlW2UuRFRfRE9VQkxFX1JFRj0xMDJdPVwiRFRfRE9VQkxFX1JFRlwiLGVbZS5EVF9JTlQzMl9SRUY9MTAzXT1cIkRUX0lOVDMyX1JFRlwiLGVbZS5EVF9VSU5UOF9SRUY9MTA0XT1cIkRUX1VJTlQ4X1JFRlwiLGVbZS5EVF9JTlQxNl9SRUY9MTA1XT1cIkRUX0lOVDE2X1JFRlwiLGVbZS5EVF9JTlQ4X1JFRj0xMDZdPVwiRFRfSU5UOF9SRUZcIixlW2UuRFRfU1RSSU5HX1JFRj0xMDddPVwiRFRfU1RSSU5HX1JFRlwiLGVbZS5EVF9DT01QTEVYNjRfUkVGPTEwOF09XCJEVF9DT01QTEVYNjRfUkVGXCIsZVtlLkRUX0lOVDY0X1JFRj0xMDldPVwiRFRfSU5UNjRfUkVGXCIsZVtlLkRUX0JPT0xfUkVGPTExMF09XCJEVF9CT09MX1JFRlwiLGVbZS5EVF9RSU5UOF9SRUY9MTExXT1cIkRUX1FJTlQ4X1JFRlwiLGVbZS5EVF9RVUlOVDhfUkVGPTExMl09XCJEVF9RVUlOVDhfUkVGXCIsZVtlLkRUX1FJTlQzMl9SRUY9MTEzXT1cIkRUX1FJTlQzMl9SRUZcIixlW2UuRFRfQkZMT0FUMTZfUkVGPTExNF09XCJEVF9CRkxPQVQxNl9SRUZcIn0oRGF0YVR5cGV8fChEYXRhVHlwZT17fSkpLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXtlW2UuTEVHQUNZPTBdPVwiTEVHQUNZXCIsZVtlLlYxPTFdPVwiVjFcIixlW2UuVjI9Ml09XCJWMlwifShlLkNoZWNrcG9pbnRGb3JtYXRWZXJzaW9ufHwoZS5DaGVja3BvaW50Rm9ybWF0VmVyc2lvbj17fSkpfShTYXZlckRlZnx8KFNhdmVyRGVmPXt9KSk7dmFyIENVU1RPTV9PUFM9e307ZnVuY3Rpb24gcmVnaXN0ZXJPcChlLHQpe3ZhciBhPXt0Zk9wTmFtZTplLGNhdGVnb3J5OlwiY3VzdG9tXCIsaW5wdXRzOltdLGF0dHJzOltdLGN1c3RvbUV4ZWN1dG9yOnR9O0NVU1RPTV9PUFNbZV09YX1mdW5jdGlvbiBnZXRSZWdpc3RlcmVkT3AoZSl7cmV0dXJuIENVU1RPTV9PUFNbZV19ZnVuY3Rpb24gZGVyZWdpc3Rlck9wKGUpe2RlbGV0ZSBDVVNUT01fT1BTW2VdfWZ1bmN0aW9uIGdldFBhcmFtVmFsdWUoZSx0LGEscil7dmFyIG49dC5pbnB1dFBhcmFtc1tlXTtpZihuJiZ2b2lkIDAhPT1uLmlucHV0SW5kZXhTdGFydCl7dmFyIHM9bi5pbnB1dEluZGV4U3RhcnQsbz0wPT09bi5pbnB1dEluZGV4RW5kP3ZvaWQgMDp2b2lkIDA9PT1uLmlucHV0SW5kZXhFbmQ/cysxOm4uaW5wdXRJbmRleEVuZDtpZihcInRlbnNvclwiPT09bi50eXBlKXJldHVybiBnZXRUZW5zb3IodC5pbnB1dE5hbWVzW24uaW5wdXRJbmRleFN0YXJ0XSxhLHIpO2lmKFwidGVuc29yc1wiPT09bi50eXBlKXJldHVybiB0LmlucHV0TmFtZXMuc2xpY2UocyxvKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGdldFRlbnNvcihlLGEscil9KTt2YXIgcD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChnZXRUZW5zb3IodC5pbnB1dE5hbWVzLnNsaWNlKHMpWzBdLGEscikuZGF0YVN5bmMoKSk7cmV0dXJuXCJudW1iZXJcIj09PW4udHlwZT9wWzBdOnB9dmFyIHU9dC5hdHRyUGFyYW1zW2VdO3JldHVybiB1JiZ1LnZhbHVlfWZ1bmN0aW9uIGdldFRlbnNvcihlLHQsYSl7dmFyIHI9cGFyc2VOb2RlTmFtZShlKSxuPXJbMF0scz1yWzFdLG89YS5jdXJyZW50Q29udGV4dElkcy5maW5kKGZ1bmN0aW9uKGUpe3JldHVybiEhdFtnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQobixlKV19KTtyZXR1cm4gdm9pZCAwIT09bz90W2dldE5vZGVOYW1lV2l0aENvbnRleHRJZChuLG8pXVtzXTp2b2lkIDB9ZnVuY3Rpb24gZ2V0VGVuc29yc0ZvckN1cnJlbnRDb250ZW54dChlLHQsYSl7cmV0dXJuIHRbZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKGUsYS5jdXJyZW50Q29udGV4dElkKV19ZnVuY3Rpb24gZ2V0Tm9kZU5hbWVBbmRJbmRleChlLHQpe3ZhciBhPXBhcnNlTm9kZU5hbWUoZSkscj1hWzBdLG49YVsxXTtyZXR1cm5bZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkKHIsdCYmdC5jdXJyZW50Q29udGV4dElkKSxuXX1mdW5jdGlvbiBnZXROb2RlTmFtZVdpdGhDb250ZXh0SWQoZSx0KXtyZXR1cm4gdD9lK1wiLVwiK3Q6ZX1mdW5jdGlvbiBwYXJzZU5vZGVOYW1lKGUpe3ZhciB0PWUubGFzdEluZGV4T2YoXCI6XCIpO3JldHVybi0xPT09dD9bZSwwXTpbZS5zdWJzdHJpbmcoMCx0KSxOdW1iZXIoZS5zdWJzdHJpbmcodCsxKSldfWZ1bmN0aW9uIHNwbGl0JDEoZSx0KXtmb3IodmFyIGE9W10scj0wO3I8ZS5sZW5ndGg7cis9dClhLnB1c2goZS5zbGljZShyLHIrdCkpO3JldHVybiBhfXZhciBqc29uPVt7dGZPcE5hbWU6XCJBZGRcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBZGRWMlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFkZE5cIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn1dfSx7dGZPcE5hbWU6XCJCaWFzQWRkXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU3ViXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVhbERpdlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkRpdlwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkRpdk5vTmFuXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JEaXZcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNdWxcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNYXhpbXVtXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiTWluaW11bVwiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlBvd1wiLGNhdGVnb3J5OlwiYXJpdGhtZXRpY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNxdWFyZWREaWZmZXJlbmNlXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTW9kXCIsY2F0ZWdvcnk6XCJhcml0aG1ldGljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JNb2RcIixjYXRlZ29yeTpcImFyaXRobWV0aWNcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfV0sYXJpdGhtZXRpYz1PYmplY3QuZnJlZXplKHtqc29uOmpzb259KSxqc29uJDE9W3t0Zk9wTmFtZTpcIkFic1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQWNvc1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXNpblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXRhblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXRhbjJcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwieVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDZWlsXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDbGlwQnlWYWx1ZVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImNsaXBfdmFsdWVfbWluXCIsbmFtZTpcImNsaXBWYWx1ZU1pblwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcImNsaXBfdmFsdWVfbWF4XCIsbmFtZTpcImNsaXBWYWx1ZU1heFwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJDb21wbGV4XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwicmVhbFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImltYWdcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ29tcGxleEFic1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ29zXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJDb3NoXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJFbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkV4cFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiRmxvb3JcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiSW1hZ1wiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJUb3V0XCIsbmFtZTpcIm91dHB1dFR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTmVnXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWFsXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRvdXRcIixuYW1lOlwib3V0cHV0VHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJQcmVsdVwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJhbHBoYVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZWx1NlwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJjbGlwVmFsdWVNaW5cIixuYW1lOlwiY2xpcFZhbHVlTWluXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwiY2xpcFZhbHVlTWF4XCIsbmFtZTpcImNsaXBWYWx1ZU1heFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6Nn1dfSx7dGZPcE5hbWU6XCJTZWx1XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTaWdtb2lkXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTaW5cIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNpbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNxcnRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJzcXJ0XCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJTcXVhcmVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRhblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGFuaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU2lnblwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUm91bmRcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkV4cG0xXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMb2cxcFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmVjaXByb2NhbFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiU29mdHBsdXNcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkFzaW5oXCIsY2F0ZWdvcnk6XCJiYXNpY19tYXRoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJBY29zaFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXRhbmhcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkVyZlwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUHJvZFwiLGNhdGVnb3J5OlwiYmFzaWNfbWF0aFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMZWFreVJlbHVcIixjYXRlZ29yeTpcImJhc2ljX21hdGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJhbHBoYVwiLG5hbWU6XCJhbHBoYVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6LjJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19XSxiYXNpY01hdGg9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDF9KSxqc29uJDI9W3t0Zk9wTmFtZTpcIkxvb3BDb25kXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwicHJlZFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTd2l0Y2hcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJkYXRhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwicHJlZFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJNZXJnZVwiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsZW5kOjAsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifV19LHt0Zk9wTmFtZTpcIkVudGVyXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiZnJhbWVfbmFtZVwiLG5hbWU6XCJmcmFtZU5hbWVcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJpc19jb25zdGFudFwiLG5hbWU6XCJpc0NvbnN0YW50XCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJFeGl0XCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk5leHRJdGVyYXRpb25cIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJlbGVtZW50X3NoYXBlXCIsbmFtZTpcImVsZW1lbnRTaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7dGZOYW1lOlwiZHluYW1pY19zaXplXCIsbmFtZTpcImR5bmFtaWNTaXplXCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcImNsZWFyX2FmdGVyX3JlYWRcIixuYW1lOlwiY2xlYXJBZnRlclJlYWRcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiaWRlbnRpY2FsX2VsZW1lbnRfc2hhcGVzXCIsbmFtZTpcImlkZW50aWNhbEVsZW1lbnRTaGFwZXNcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwidGVuc29yX2FycmF5X25hbWVcIixuYW1lOlwibmFtZVwiLHR5cGU6XCJzdHJpbmdcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVdyaXRlVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kZXhcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlSZWFkVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kZXhcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5R2F0aGVyVjNcIixjYXRlZ29yeTpcImNvbnRyb2xcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ0ZW5zb3JBcnJheUlkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MSxuYW1lOlwiaW5kaWNlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiZmxvd0luXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwiZWxlbWVudF9zaGFwZVwiLG5hbWU6XCJlbGVtZW50U2hhcGVcIix0eXBlOlwic2hhcGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVNjYXR0ZXJWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDozLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheUNvbmNhdFYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcImZsb3dJblwiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcImVsZW1lbnRfc2hhcGVfZXhjZXB0MFwiLG5hbWU6XCJlbGVtZW50U2hhcGVFeGNlcHQwXCIsdHlwZTpcInNoYXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlRlbnNvckFycmF5U3BsaXRWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJ0ZW5zb3JcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJsZW5ndGhzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDozLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJUZW5zb3JBcnJheVNpemVWM1wiLGNhdGVnb3J5OlwiY29udHJvbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvckFycmF5SWRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJmbG93SW5cIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiVGVuc29yQXJyYXlDbG9zZVYzXCIsY2F0ZWdvcnk6XCJjb250cm9sXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwidGVuc29yQXJyYXlJZFwiLHR5cGU6XCJudW1iZXJcIn1dfV0sY29udHJvbD1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kMn0pLGpzb24kMz1be3RmT3BOYW1lOlwiQXZnUG9vbFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJrc2l6ZVwiLG5hbWU6XCJrZXJuZWxTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIk1heFBvb2xcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwia3NpemVcIixuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJNYXhQb29sV2l0aEFyZ21heFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwia3NpemVcIixuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwiaW5jbHVkZV9iYXRjaF9pbl9pbmRleFwiLG5hbWU6XCJpbmNsdWRlQmF0Y2hJbkluZGV4XCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQXZnUG9vbDNEXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImtzaXplXCIsbmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTWF4UG9vbDNEXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZXNcIixuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifSx7dGZOYW1lOlwicGFkZGluZ1wiLG5hbWU6XCJwYWRcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImtzaXplXCIsbmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiQ29udjFEXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcInN0cmlkZVwiLG5hbWU6XCJzdHJpZGVcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTldDXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwiZGlsYXRpb25cIixuYW1lOlwiZGlsYXRpb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9XX0se3RmT3BOYW1lOlwiQ29udjJEXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwidXNlQ3Vkbm5PbkdwdVwiLG5hbWU6XCJ1c2VDdWRubk9uR3B1XCIsdHlwZTpcImJvb2xcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIl9GdXNlZENvbnYyRFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixlbmQ6MCxuYW1lOlwiYXJnc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm51bV9hcmdzXCIsbmFtZTpcIm51bUFyZ3NcIix0eXBlOlwibnVtYmVyXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfSx7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImV4cGxpY2l0X3BhZGRpbmdzXCIsbmFtZTpcImV4cGxpY2l0UGFkZGluZ3NcIix0eXBlOlwibnVtYmVyW11cIixkZWZhdWx0VmFsdWU6W119LHt0Zk5hbWU6XCJ1c2VfY3Vkbm5fb25fZ3B1XCIsbmFtZTpcInVzZUN1ZG5uT25HcHVcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMH0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwiLGRlZmF1bHRWYWx1ZTpbMSwxLDEsMV19LHt0Zk5hbWU6XCJmdXNlZF9vcHNcIixuYW1lOlwiZnVzZWRPcHNcIix0eXBlOlwic3RyaW5nW11cIixkZWZhdWx0VmFsdWU6W119LHt0Zk5hbWU6XCJlcHNpbG9uXCIsbmFtZTpcImVwc2lsb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjFlLTR9XX0se3RmT3BOYW1lOlwiQ29udjJEQmFja3Byb3BJbnB1dFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDoyLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmlsdGVyXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MCxuYW1lOlwib3V0cHV0U2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkRlcHRod2lzZUNvbnYyZFwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbnB1dFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkRlcHRod2lzZUNvbnYyZE5hdGl2ZVwiLGNhdGVnb3J5OlwiY29udm9sdXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJpbnB1dFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkZ1c2VkRGVwdGh3aXNlQ29udjJkTmF0aXZlXCIsY2F0ZWdvcnk6XCJjb252b2x1dGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmaWx0ZXJcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLGVuZDowLG5hbWU6XCJhcmdzXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwibnVtX2FyZ3NcIixuYW1lOlwibnVtQXJnc1wiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJzdHJpZGVzXCIsbmFtZTpcInN0cmlkZXNcIix0eXBlOlwibnVtYmVyW11cIn0se3RmTmFtZTpcInBhZGRpbmdcIixuYW1lOlwicGFkXCIsdHlwZTpcInN0cmluZ1wifSx7dGZOYW1lOlwiZGF0YV9mb3JtYXRcIixuYW1lOlwiZGF0YUZvcm1hdFwiLHR5cGU6XCJzdHJpbmdcIixkZWZhdWx0VmFsdWU6XCJOSFdDXCJ9LHt0Zk5hbWU6XCJkaWxhdGlvbnNcIixuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcIm51bWJlcltdXCIsZGVmYXVsdFZhbHVlOlsxLDEsMSwxXX0se3RmTmFtZTpcImZ1c2VkX29wc1wiLG5hbWU6XCJmdXNlZE9wc1wiLHR5cGU6XCJzdHJpbmdbXVwiLGRlZmF1bHRWYWx1ZTpbXX1dfSx7dGZPcE5hbWU6XCJDb252M0RcIixjYXRlZ29yeTpcImNvbnZvbHV0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImZpbHRlclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwic3RyaWRlc1wiLG5hbWU6XCJzdHJpZGVzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHt0Zk5hbWU6XCJwYWRkaW5nXCIsbmFtZTpcInBhZFwiLHR5cGU6XCJzdHJpbmdcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCIsZGVmYXVsdFZhbHVlOlwiTkhXQ1wifSx7dGZOYW1lOlwiZGlsYXRpb25zXCIsbmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJudW1iZXJbXVwifV19XSxjb252b2x1dGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kM30pLGpzb24kND1be3RmT3BOYW1lOlwiRmlsbFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MSxuYW1lOlwidmFsdWVcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJMaW5TcGFjZVwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzdGFydFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjEsbmFtZTpcInN0b3BcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoyLG5hbWU6XCJudW1cIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiT25lSG90XCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJkZXB0aFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjIsbmFtZTpcIm9uVmFsdWVcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHtzdGFydDozLG5hbWU6XCJvZmZWYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiT25lc1wiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiT25lc0xpa2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJSYW5kb21Vbmlmb3JtXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1pbnZhbFwiLG5hbWU6XCJtaW52YWxcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJtYXh2YWxcIixuYW1lOlwibWF4dmFsXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn0se3RmTmFtZTpcInNlZWRcIixuYW1lOlwic2VlZFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcInNlZWQyXCIsbmFtZTpcInNlZWQyXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcIlRcIixuYW1lOlwiVFwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiUmFuZ2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwic3RhcnRcIix0eXBlOlwibnVtYmVyXCJ9LHtzdGFydDoxLG5hbWU6XCJzdG9wXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MixuYW1lOlwic3RlcFwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dLGF0dHJzOlt7dGZOYW1lOlwiVGlkeFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIlRydW5jYXRlZE5vcm1hbFwiLGNhdGVnb3J5OlwiY3JlYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJtZWFuc1wiLG5hbWU6XCJtZWFuXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwic3RkZGV2XCIsbmFtZTpcInN0ZERldlwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX0se3RmTmFtZTpcInNlZWRcIixuYW1lOlwic2VlZFwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcInNlZWQyXCIsbmFtZTpcInNlZWQyXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowLG5vdFN1cHBvcnRlZDohMH0se3RmTmFtZTpcImR0eXBlXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcIlRcIix0eXBlOlwibnVtYmVyXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlplcm9zXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJaZXJvc0xpa2VcIixjYXRlZ29yeTpcImNyZWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIk11bHRpbm9taWFsXCIsY2F0ZWdvcnk6XCJjcmVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImxvZ2l0c1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcIm51bVNhbXBsZXNcIix0eXBlOlwibnVtYmVyXCJ9XSxhdHRyczpbe3RmTmFtZTpcInNlZWRcIixuYW1lOlwic2VlZFwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcInNlZWQyXCIsbmFtZTpcInNlZWQyXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifSx7dGZOYW1lOlwib3V0cHV0X2R0eXBlXCIsbmFtZTpcIm91dHB1dF9kdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19XSxjcmVhdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kNH0pLGpzb24kNT1be3RmT3BOYW1lOlwiTm9uTWF4U3VwcHJlc3Npb25WMlwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImJveGVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NvcmVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwibWF4T3V0cHV0U2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjMsbmFtZTpcImlvdVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJOb25NYXhTdXBwcmVzc2lvblYzXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYm94ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzY29yZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJtYXhPdXRwdXRTaXplXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6MyxuYW1lOlwiaW91VGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6NCxuYW1lOlwic2NvcmVUaHJlc2hvbGRcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiTm9uTWF4U3VwcHJlc3Npb25WNVwiLGNhdGVnb3J5OlwiZHluYW1pY1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImJveGVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2NvcmVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwibWF4T3V0cHV0U2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjMsbmFtZTpcImlvdVRocmVzaG9sZFwiLHR5cGU6XCJudW1iZXJcIn0se3N0YXJ0OjQsbmFtZTpcInNjb3JlVGhyZXNob2xkXCIsdHlwZTpcIm51bWJlclwifSx7c3RhcnQ6NSxuYW1lOlwic29mdE5tc1NpZ21hXCIsdHlwZTpcIm51bWJlclwifV19LHt0Zk9wTmFtZTpcIldoZXJlXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiY29uZGl0aW9uXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxpc3REaWZmXCIsY2F0ZWdvcnk6XCJkeW5hbWljXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInlcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLGR5bmFtaWM9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDV9KSxqc29uJDY9W3t0Zk9wTmFtZTpcIlRvcEtWMlwiLGNhdGVnb3J5OlwiZXZhbHVhdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJrXCIsdHlwZTpcIm51bWJlclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzb3J0ZWRcIixuYW1lOlwic29ydGVkXCIsdHlwZTpcImJvb2xcIn1dfV0sZXZhbHVhdGlvbj1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kNn0pLGpzb24kNz1be3RmT3BOYW1lOlwiUGxhY2Vob2xkZXJXaXRoRGVmYXVsdFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJkZWZhdWx0XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJzaGFwZVwiLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJzaGFwZVwifSx7dGZOYW1lOlwiZHR5cGVcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIn1dfSx7dGZPcE5hbWU6XCJQbGFjZWhvbGRlclwiLGNhdGVnb3J5OlwiZ3JhcGhcIixhdHRyczpbe3RmTmFtZTpcInNoYXBlXCIsbmFtZTpcInNoYXBlXCIsdHlwZTpcInNoYXBlXCJ9LHt0Zk5hbWU6XCJkdHlwZVwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwifV19LHt0Zk9wTmFtZTpcIkNvbnN0XCIsY2F0ZWdvcnk6XCJncmFwaFwifSx7dGZPcE5hbWU6XCJJZGVudGl0eVwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIklkZW50aXR5TlwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvcnNcIn1dfSx7dGZPcE5hbWU6XCJTbmFwc2hvdFwiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlJhbmtcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTaXplXCIsY2F0ZWdvcnk6XCJncmFwaFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU2hhcGVcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJTaGFwZU5cIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxlbmQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JzXCJ9XX0se3RmT3BOYW1lOlwiUHJpbnRcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImRhdGFcIix0eXBlOlwidGVuc29yc1wifV0sYXR0cnM6W3t0Zk5hbWU6XCJtZXNzYWdlXCIsbmFtZTpcIm1lc3NhZ2VcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJmaXJzdF9uXCIsbmFtZTpcImZpcnN0TlwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJzdW1tYXJpemVcIixuYW1lOlwic3VtbWFyaXplXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTozfV19LHt0Zk9wTmFtZTpcIk5vT3BcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOltdfSx7dGZPcE5hbWU6XCJTdG9wR3JhZGllbnRcIixjYXRlZ29yeTpcImdyYXBoXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJGYWtlUXVhbnRXaXRoTWluTWF4VmFyc1wiLGNhdGVnb3J5OlwiZ3JhcGhcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJtaW5cIixuYW1lOlwibWluXCIsdHlwZTpcIm51bWJlclwifSx7dGZOYW1lOlwibWF4XCIsbmFtZTpcIm1heFwiLHR5cGU6XCJudW1iZXJcIn1dfV0sZ3JhcGg9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDd9KSxqc29uJDg9W3t0Zk9wTmFtZTpcIlJlc2l6ZUJpbGluZWFyXCIsY2F0ZWdvcnk6XCJpbWFnZVwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImltYWdlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiYWxpZ25fY29ybmVyc1wiLG5hbWU6XCJhbGlnbkNvcm5lcnNcIix0eXBlOlwiYm9vbFwifSx7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJSZXNpemVOZWFyZXN0TmVpZ2hib3JcIixjYXRlZ29yeTpcImltYWdlXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW1hZ2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwic2l6ZVwiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJhbGlnbl9jb3JuZXJzXCIsbmFtZTpcImFsaWduQ29ybmVyc1wiLHR5cGU6XCJib29sXCJ9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkNyb3BBbmRSZXNpemVcIixjYXRlZ29yeTpcImltYWdlXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiaW1hZ2VcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJib3hlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcImJveEluZFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcImNyb3BTaXplXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIm1ldGhvZFwiLG5hbWU6XCJtZXRob2RcIix0eXBlOlwic3RyaW5nXCJ9LHt0Zk5hbWU6XCJleHRyYXBvbGF0aW9uX3ZhbHVlXCIsbmFtZTpcImV4dHJhcG9sYXRpb25WYWx1ZVwiLHR5cGU6XCJudW1iZXJcIn1dfV0saW1hZ2UkMT1PYmplY3QuZnJlZXplKHtqc29uOmpzb24kOH0pLGpzb24kOT1be3RmT3BOYW1lOlwiRXF1YWxcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJOb3RFcXVhbFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkdyZWF0ZXJcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJHcmVhdGVyRXF1YWxcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYlwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiVFwiLG5hbWU6XCJkdHlwZVwiLHR5cGU6XCJkdHlwZVwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMZXNzXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTGVzc0VxdWFsXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTG9naWNhbEFuZFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ2ljYWxOb3RcIixjYXRlZ29yeTpcImxvZ2ljYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJhXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkxvZ2ljYWxPclwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNlbGVjdFwiLGNhdGVnb3J5OlwibG9naWNhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImNvbmRpdGlvblwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlNlbGVjdFYyXCIsY2F0ZWdvcnk6XCJsb2dpY2FsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiY29uZGl0aW9uXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjIsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLGxvZ2ljYWw9T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDl9KSxqc29uJDEwPVt7dGZPcE5hbWU6XCJfRnVzZWRNYXRNdWxcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLGVuZDowLG5hbWU6XCJhcmdzXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwibnVtX2FyZ3NcIixuYW1lOlwibnVtQXJnc1wiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcImZ1c2VkX29wc1wiLG5hbWU6XCJmdXNlZE9wc1wiLHR5cGU6XCJzdHJpbmdbXVwiLGRlZmF1bHRWYWx1ZTpbXX0se3RmTmFtZTpcImVwc2lsb25cIixuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MWUtNH0se3RmTmFtZTpcInRyYW5zcG9zZV9hXCIsbmFtZTpcInRyYW5zcG9zZUFcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcInRyYW5zcG9zZV9iXCIsbmFtZTpcInRyYW5zcG9zZUJcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiTWF0TXVsXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJ0cmFuc3Bvc2VfYVwiLG5hbWU6XCJ0cmFuc3Bvc2VBXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJ0cmFuc3Bvc2VfYlwiLG5hbWU6XCJ0cmFuc3Bvc2VCXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkJhdGNoTWF0TXVsXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImFcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJiXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJhZGpfeFwiLG5hbWU6XCJ0cmFuc3Bvc2VBXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJhZGpfeVwiLG5hbWU6XCJ0cmFuc3Bvc2VCXCIsdHlwZTpcImJvb2xcIixkZWZhdWx0VmFsdWU6ITF9LHt0Zk5hbWU6XCJUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIkJhdGNoTWF0TXVsVjJcIixjYXRlZ29yeTpcIm1hdHJpY2VzXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwiYVwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImJcIix0eXBlOlwidGVuc29yXCJ9XSxhdHRyczpbe3RmTmFtZTpcImFkal94XCIsbmFtZTpcInRyYW5zcG9zZUFcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcImFkal95XCIsbmFtZTpcInRyYW5zcG9zZUJcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMX0se3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVHJhbnNwb3NlXCIsY2F0ZWdvcnk6XCJtYXRyaWNlc1wiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJwZXJtXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcIlRcIixuYW1lOlwiZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLG1hdHJpY2VzPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxMH0pLGpzb24kMTE9W3t0Zk9wTmFtZTpcIkZ1c2VkQmF0Y2hOb3JtXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNjYWxlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwib2Zmc2V0XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwibWVhblwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjQsbmFtZTpcInZhcmlhbmNlXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlcHNpbG9uXCIsbmFtZTpcImVwc2lsb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi4wMDF9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJGdXNlZEJhdGNoTm9ybVYyXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNjYWxlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwib2Zmc2V0XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwibWVhblwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjQsbmFtZTpcInZhcmlhbmNlXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlcHNpbG9uXCIsbmFtZTpcImVwc2lsb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi4wMDF9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJGdXNlZEJhdGNoTm9ybVYzXCIsY2F0ZWdvcnk6XCJub3JtYWxpemF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInNjYWxlXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MixuYW1lOlwib2Zmc2V0XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwibWVhblwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjQsbmFtZTpcInZhcmlhbmNlXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJlcHNpbG9uXCIsbmFtZTpcImVwc2lsb25cIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi4wMDF9LHt0Zk5hbWU6XCJkYXRhX2Zvcm1hdFwiLG5hbWU6XCJkYXRhRm9ybWF0XCIsdHlwZTpcInN0cmluZ1wiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJMUk5cIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJkZXB0aF9yYWRpdXNcIixuYW1lOlwicmFkaXVzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTo1fSx7dGZOYW1lOlwiYmlhc1wiLG5hbWU6XCJiaWFzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToxfSx7dGZOYW1lOlwiYWxwaGFcIixuYW1lOlwiYWxwaGFcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjF9LHt0Zk5hbWU6XCJiZXRhXCIsbmFtZTpcImJldGFcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOi41fV19LHt0Zk9wTmFtZTpcIlNvZnRtYXhcIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIkxvZ1NvZnRtYXhcIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIlNwYXJzZVRvRGVuc2VcIixjYXRlZ29yeTpcIm5vcm1hbGl6YXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJzcGFyc2VJbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwib3V0cHV0U2hhcGVcIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcInNwYXJzZVZhbHVlc1wiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjMsbmFtZTpcImRlZmF1bHRWYWx1ZVwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwidmFsaWRhdGVfaW5kaWNlc1wiLG5hbWU6XCJ2YWxpZGF0ZUluZGljZXNcIix0eXBlOlwiYm9vbFwiLGRlZmF1bHRWYWx1ZTohMCxub3RTdXBwb3J0ZWQ6ITB9XX1dLG5vcm1hbGl6YXRpb249T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDExfSksanNvbiQxMj1be3RmT3BOYW1lOlwiTWF4XCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIk1lYW5cIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiTWluXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIlN1bVwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwia2VlcF9kaW1zXCIsbmFtZTpcImtlZXBEaW1zXCIsdHlwZTpcImJvb2xcIn1dfSx7dGZPcE5hbWU6XCJBbGxcIixjYXRlZ29yeTpcInJlZHVjdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XSxhdHRyczpbe3RmTmFtZTpcImtlZXBfZGltc1wiLG5hbWU6XCJrZWVwRGltc1wiLHR5cGU6XCJib29sXCJ9XX0se3RmT3BOYW1lOlwiQW55XCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19LHt0Zk9wTmFtZTpcIkFyZ01heFwiLGNhdGVnb3J5OlwicmVkdWN0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCJ9XX0se3RmT3BOYW1lOlwiQXJnTWluXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJQcm9kXCIsY2F0ZWdvcnk6XCJyZWR1Y3Rpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJrZWVwX2RpbXNcIixuYW1lOlwia2VlcERpbXNcIix0eXBlOlwiYm9vbFwifV19XSxyZWR1Y3Rpb249T2JqZWN0LmZyZWV6ZSh7anNvbjpqc29uJDEyfSksanNvbiQxMz1be3RmT3BOYW1lOlwiQ29uY2F0VjJcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLGVuZDotMSxuYW1lOlwidGVuc29yc1wiLHR5cGU6XCJ0ZW5zb3JzXCJ9LHtzdGFydDotMSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiTlwiLG5hbWU6XCJuXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToyfV19LHt0Zk9wTmFtZTpcIkNvbmNhdFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjEsZW5kOjAsbmFtZTpcInRlbnNvcnNcIix0eXBlOlwidGVuc29yc1wifSx7c3RhcnQ6MCxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dLGF0dHJzOlt7dGZOYW1lOlwiTlwiLG5hbWU6XCJuXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZToyfV19LHt0Zk9wTmFtZTpcIkdhdGhlclYyXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIkdhdGhlclwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJpbmRpY2VzXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJheGlzXCIsbmFtZTpcImF4aXNcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJ2YWxpZGF0ZV9pbmRpY2VzXCIsbmFtZTpcInZhbGlkYXRlSW5kaWNlc1wiLHR5cGU6XCJib29sXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJldmVyc2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZGltc1wiLHR5cGU6XCJib29sXCIsbm90U3VwcG9ydGVkOiEwfV19LHt0Zk9wTmFtZTpcIlJldmVyc2VWMlwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU2xpY2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYmVnaW5cIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcInNpemVcIix0eXBlOlwibnVtYmVyW11cIn1dfSx7dGZPcE5hbWU6XCJTdHJpZGVkU2xpY2VcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYmVnaW5cIix0eXBlOlwibnVtYmVyW11cIn0se3N0YXJ0OjIsbmFtZTpcImVuZFwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MyxuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJudW1iZXJbXVwifV0sYXR0cnM6W3t0Zk5hbWU6XCJiZWdpbl9tYXNrXCIsbmFtZTpcImJlZ2luTWFza1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH0se3RmTmFtZTpcImVuZF9tYXNrXCIsbmFtZTpcImVuZE1hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJuZXdfYXhpc19tYXNrXCIsbmFtZTpcIm5ld0F4aXNNYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwiZWxsaXBzaXNfbWFza1wiLG5hbWU6XCJlbGxpcHNpc01hc2tcIix0eXBlOlwibnVtYmVyXCIsZGVmYXVsdFZhbHVlOjB9LHt0Zk5hbWU6XCJzaHJpbmtfYXhpc19tYXNrXCIsbmFtZTpcInNocmlua0F4aXNNYXNrXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlBhY2tcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLGVuZDowLG5hbWU6XCJ0ZW5zb3JzXCIsdHlwZTpcInRlbnNvcnNcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlVucGFja1wiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInRlbnNvclwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7dGZOYW1lOlwibnVtXCIsbmFtZTpcIm51bVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MCxub3RTdXBwb3J0ZWQ6ITB9XX0se3RmT3BOYW1lOlwiVGlsZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJyZXBzXCIsdHlwZTpcIm51bWJlcltdXCJ9XX0se3RmT3BOYW1lOlwiU3BsaXRcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfSx7c3RhcnQ6MSxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwibnVtX3NwbGl0XCIsbmFtZTpcIm51bU9yU2l6ZVNwbGl0c1wiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MX1dfSx7dGZPcE5hbWU6XCJTcGxpdFZcIixjYXRlZ29yeTpcInNsaWNlX2pvaW5cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwibnVtT3JTaXplU3BsaXRzXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJheGlzXCIsdHlwZTpcIm51bWJlclwiLGRlZmF1bHRWYWx1ZTowfV19LHt0Zk9wTmFtZTpcIlNjYXR0ZXJOZFwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJ2YWx1ZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoyLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkdhdGhlck5kXCIsY2F0ZWdvcnk6XCJzbGljZV9qb2luXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcImluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9XX0se3RmT3BOYW1lOlwiU3BhcnNlVG9EZW5zZVwiLGNhdGVnb3J5Olwic2xpY2Vfam9pblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInNwYXJzZUluZGljZXNcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJvdXRwdXRTaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwic3BhcnNlVmFsdWVzXCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MyxuYW1lOlwiZGVmYXVsdFZhbHVlXCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJ2YWxpZGF0ZV9pbmRpY2VzXCIsbmFtZTpcInZhbGlkYXRlSW5kaWNlc1wiLHR5cGU6XCJib29sXCIsZGVmYXVsdFZhbHVlOiExLG5vdFN1cHBvcnRlZDohMH1dfV0sc2xpY2VKb2luPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxM30pLGpzb24kMTQ9W3t0Zk9wTmFtZTpcIkZGVFwiLGNhdGVnb3J5Olwic3BlY3RyYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV19LHt0Zk9wTmFtZTpcIklGRlRcIixjYXRlZ29yeTpcInNwZWN0cmFsXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dfSx7dGZPcE5hbWU6XCJSRkZUXCIsY2F0ZWdvcnk6XCJzcGVjdHJhbFwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJmZnRfbGVuZ3RoXCIsdHlwZTpcIm51bWJlclwiLG5vdFN1cHBvcnRlZDohMH1dfSx7dGZPcE5hbWU6XCJJUkZGVFwiLGNhdGVnb3J5Olwic3BlY3RyYWxcIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiZmZ0X2xlbmd0aFwiLHR5cGU6XCJudW1iZXJcIixub3RTdXBwb3J0ZWQ6ITB9XX1dLHNwZWN0cmFsPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxNH0pLGpzb24kMTU9W3t0Zk9wTmFtZTpcIkNhc3RcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiU3JjVFwiLG5hbWU6XCJzZHR5cGVcIix0eXBlOlwiZHR5cGVcIixub3RTdXBwb3J0ZWQ6ITB9LHt0Zk5hbWU6XCJEc3RUXCIsbmFtZTpcImR0eXBlXCIsdHlwZTpcImR0eXBlXCJ9XX0se3RmT3BOYW1lOlwiRXhwYW5kRGltc1wiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJcIn1dfSx7dGZPcE5hbWU6XCJQYWRcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn0se3N0YXJ0OjEsbmFtZTpcInBhZGRpbmdcIix0eXBlOlwibnVtYmVyW11cIn1dLGF0dHJzOlt7dGZOYW1lOlwiY29uc3RhbnRfdmFsdWVcIixuYW1lOlwiY29uc3RhbnRWYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJQYWRWMlwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifSx7c3RhcnQ6MSxuYW1lOlwicGFkZGluZ1wiLHR5cGU6XCJudW1iZXJbXVwifSx7c3RhcnQ6MixuYW1lOlwiY29uc3RhbnRWYWx1ZVwiLHR5cGU6XCJudW1iZXJcIixkZWZhdWx0VmFsdWU6MH1dfSx7dGZPcE5hbWU6XCJSZXNoYXBlXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJzaGFwZVwiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlNxdWVlemVcIixjYXRlZ29yeTpcInRyYW5zZm9ybWF0aW9uXCIsaW5wdXRzOlt7c3RhcnQ6MCxuYW1lOlwieFwiLHR5cGU6XCJ0ZW5zb3JcIn1dLGF0dHJzOlt7dGZOYW1lOlwiYXhpc1wiLHRmRGVwcmVjYXRlZE5hbWU6XCJzcXVlZXplX2RpbXNcIixuYW1lOlwiYXhpc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIlNwYWNlVG9CYXRjaE5EXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJibG9ja1NoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJwYWRkaW5nc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkJhdGNoVG9TcGFjZU5EXCIsY2F0ZWdvcnk6XCJ0cmFuc2Zvcm1hdGlvblwiLGlucHV0czpbe3N0YXJ0OjAsbmFtZTpcInhcIix0eXBlOlwidGVuc29yXCJ9LHtzdGFydDoxLG5hbWU6XCJibG9ja1NoYXBlXCIsdHlwZTpcIm51bWJlcltdXCJ9LHtzdGFydDoyLG5hbWU6XCJjcm9wc1wiLHR5cGU6XCJudW1iZXJbXVwifV19LHt0Zk9wTmFtZTpcIkRlcHRoVG9TcGFjZVwiLGNhdGVnb3J5OlwidHJhbnNmb3JtYXRpb25cIixpbnB1dHM6W3tzdGFydDowLG5hbWU6XCJ4XCIsdHlwZTpcInRlbnNvclwifV0sYXR0cnM6W3t0Zk5hbWU6XCJibG9ja19zaXplXCIsbmFtZTpcImJsb2NrU2l6ZVwiLHR5cGU6XCJudW1iZXJcIn0se3RmTmFtZTpcImRhdGFfZm9ybWF0XCIsbmFtZTpcImRhdGFGb3JtYXRcIix0eXBlOlwic3RyaW5nXCJ9XX1dLHRyYW5zZm9ybWF0aW9uPU9iamVjdC5mcmVlemUoe2pzb246anNvbiQxNX0pLE9wZXJhdGlvbk1hcHBlcj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt2YXIgZT1bYXJpdGhtZXRpYyxiYXNpY01hdGgsY29udHJvbCxjb252b2x1dGlvbixjcmVhdGlvbixkeW5hbWljLGV2YWx1YXRpb24sbG9naWNhbCxpbWFnZSQxLGdyYXBoLG1hdHJpY2VzLG5vcm1hbGl6YXRpb24scmVkdWN0aW9uLHNsaWNlSm9pbixzcGVjdHJhbCx0cmFuc2Zvcm1hdGlvbl0sdD1bXS5jb25jYXQuYXBwbHkoW10sZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuanNvbn0pKTt0aGlzLm9wTWFwcGVycz10LnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlW3QudGZPcE5hbWVdPXQsZX0se30pfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIkluc3RhbmNlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnN0YW5jZXx8KHRoaXMuX2luc3RhbmNlPW5ldyB0aGlzKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS50cmFuc2Zvcm1HcmFwaD1mdW5jdGlvbihlLHQpe3ZhciBhPXRoaXM7dm9pZCAwPT09dCYmKHQ9e30pO3ZhciByPVtdLG49W10scz1lLm5vZGUucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbdC5uYW1lXT1hLm1hcE5vZGUodCksdC5vcC5zdGFydHNXaXRoKFwiUGxhY2Vob2xkZXJcIikmJnIucHVzaChlW3QubmFtZV0pLFwiQ29uc3RcIj09PXQub3AmJm4ucHVzaChlW3QubmFtZV0pLGV9LHt9KSxvPVtdLHA9W10sdT17fSxpPXt9O251bGwhPXQmJih1PXRoaXMubWFwU2lnbmF0dXJlRW50cmllcyh0LmlucHV0cyksaT10aGlzLm1hcFNpZ25hdHVyZUVudHJpZXModC5vdXRwdXRzKSk7dmFyIG09T2JqZWN0LmtleXMocyk7cmV0dXJuIG0uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1zW2VdO3QuaW5wdXROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciBhPWdldE5vZGVOYW1lQW5kSW5kZXgoZSlbMF07dC5pbnB1dHMucHVzaChzW2FdKSxzW2FdLmNoaWxkcmVuLnB1c2godCl9KX0pLDA9PT1PYmplY3Qua2V5cyhpKS5sZW5ndGg/bS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXNbZV07MD09PXQuY2hpbGRyZW4ubGVuZ3RoJiZwLnB1c2godCl9KTpPYmplY3Qua2V5cyhpKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWdldE5vZGVOYW1lQW5kSW5kZXgoZSlbMF0sYT1zW3RdO251bGwhPWEmJihhLnNpZ25hdHVyZUtleT1pW2VdLHAucHVzaChhKSl9KSxPYmplY3Qua2V5cyh1KS5sZW5ndGg+MD9PYmplY3Qua2V5cyh1KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PWdldE5vZGVOYW1lQW5kSW5kZXgoZSlbMF0sYT1zW3RdO2EmJihhLnNpZ25hdHVyZUtleT11W2VdLG8ucHVzaChhKSl9KTpvPXIse25vZGVzOnMsaW5wdXRzOm8sb3V0cHV0czpwLHdlaWdodHM6bixwbGFjZWhvbGRlcnM6cixzaWduYXR1cmU6dH19LGUucHJvdG90eXBlLm1hcFNpZ25hdHVyZUVudHJpZXM9ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5rZXlzKGV8fHt9KS5yZWR1Y2UoZnVuY3Rpb24odCxhKXtyZXR1cm4gdFtlW2FdLm5hbWVdPWEsdH0se30pfSxlLnByb3RvdHlwZS5tYXBOb2RlPWZ1bmN0aW9uKGUpe3ZhciB0PWdldFJlZ2lzdGVyZWRPcChlLm9wKXx8dGhpcy5vcE1hcHBlcnNbZS5vcF18fHt9O251bGw9PWUuYXR0ciYmKGUuYXR0cj17fSk7dmFyIGE9e25hbWU6ZS5uYW1lLG9wOmUub3AsY2F0ZWdvcnk6dC5jYXRlZ29yeSxpbnB1dE5hbWVzOihlLmlucHV0fHxbXSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnN0YXJ0c1dpdGgoXCJeXCIpP2Uuc3Vic3RyKDEpOmV9KSxpbnB1dHM6W10sY2hpbGRyZW46W10saW5wdXRQYXJhbXM6e30sYXR0clBhcmFtczp7fSxyYXdBdHRyczplLmF0dHJ9O3JldHVybiBudWxsIT10LmlucHV0cyYmKGEuaW5wdXRQYXJhbXM9dC5pbnB1dHMucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbdC5uYW1lXT17dHlwZTp0LnR5cGUsaW5wdXRJbmRleFN0YXJ0OnQuc3RhcnQsaW5wdXRJbmRleEVuZDp0LmVuZH0sZX0se30pKSxudWxsIT10LmF0dHJzJiYoYS5hdHRyUGFyYW1zPXQuYXR0cnMucmVkdWNlKGZ1bmN0aW9uKHQsYSl7dmFyIHI9YS50eXBlLG49dm9pZCAwO3N3aXRjaChhLnR5cGUpe2Nhc2VcInN0cmluZ1wiOnZvaWQgMD09PShuPWdldFN0cmluZ1BhcmFtKGUuYXR0cixhLnRmTmFtZSxhLmRlZmF1bHRWYWx1ZSkpJiZhLnRmRGVwcmVjYXRlZE5hbWUmJihuPWdldFN0cmluZ1BhcmFtKGUuYXR0cixhLnRmRGVwcmVjYXRlZE5hbWUsYS5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJzdHJpbmdbXVwiOnZvaWQgMD09PShuPWdldFN0cmluZ0FycmF5UGFyYW0oZS5hdHRyLGEudGZOYW1lLGEuZGVmYXVsdFZhbHVlKSkmJmEudGZEZXByZWNhdGVkTmFtZSYmKG49Z2V0U3RyaW5nQXJyYXlQYXJhbShlLmF0dHIsYS50ZkRlcHJlY2F0ZWROYW1lLGEuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwibnVtYmVyXCI6dm9pZCAwPT09KG49Z2V0TnVtYmVyUGFyYW0oZS5hdHRyLGEudGZOYW1lLGEuZGVmYXVsdFZhbHVlfHwwKSkmJmEudGZEZXByZWNhdGVkTmFtZSYmKG49Z2V0TnVtYmVyUGFyYW0oZS5hdHRyLGEudGZEZXByZWNhdGVkTmFtZSxhLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcIm51bWJlcltdXCI6dm9pZCAwPT09KG49Z2V0TnVtZXJpY0FycmF5UGFyYW0oZS5hdHRyLGEudGZOYW1lLGEuZGVmYXVsdFZhbHVlKSkmJmEudGZEZXByZWNhdGVkTmFtZSYmKG49Z2V0TnVtZXJpY0FycmF5UGFyYW0oZS5hdHRyLGEudGZEZXByZWNhdGVkTmFtZSxhLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcImJvb2xcIjp2b2lkIDA9PT0obj1nZXRCb29sUGFyYW0oZS5hdHRyLGEudGZOYW1lLGEuZGVmYXVsdFZhbHVlKSkmJmEudGZEZXByZWNhdGVkTmFtZSYmKG49Z2V0Qm9vbFBhcmFtKGUuYXR0cixhLnRmRGVwcmVjYXRlZE5hbWUsYS5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJib29sW11cIjp2b2lkIDA9PT0obj1nZXRCb29sQXJyYXlQYXJhbShlLmF0dHIsYS50Zk5hbWUsYS5kZWZhdWx0VmFsdWUpKSYmYS50ZkRlcHJlY2F0ZWROYW1lJiYobj1nZXRCb29sQXJyYXlQYXJhbShlLmF0dHIsYS50ZkRlcHJlY2F0ZWROYW1lLGEuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwic2hhcGVcIjp2b2lkIDA9PT0obj1nZXRUZW5zb3JTaGFwZVBhcmFtKGUuYXR0cixhLnRmTmFtZSxhLmRlZmF1bHRWYWx1ZSkpJiZhLnRmRGVwcmVjYXRlZE5hbWUmJihuPWdldFRlbnNvclNoYXBlUGFyYW0oZS5hdHRyLGEudGZEZXByZWNhdGVkTmFtZSxhLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcInNoYXBlW11cIjp2b2lkIDA9PT0obj1nZXRUZW5zb3JTaGFwZUFycmF5UGFyYW0oZS5hdHRyLGEudGZOYW1lLGEuZGVmYXVsdFZhbHVlKSkmJmEudGZEZXByZWNhdGVkTmFtZSYmKG49Z2V0VGVuc29yU2hhcGVBcnJheVBhcmFtKGUuYXR0cixhLnRmRGVwcmVjYXRlZE5hbWUsYS5kZWZhdWx0VmFsdWUpKTticmVhaztjYXNlXCJkdHlwZVwiOnZvaWQgMD09PShuPWdldER0eXBlUGFyYW0oZS5hdHRyLGEudGZOYW1lLGEuZGVmYXVsdFZhbHVlKSkmJmEudGZEZXByZWNhdGVkTmFtZSYmKG49Z2V0RHR5cGVQYXJhbShlLmF0dHIsYS50ZkRlcHJlY2F0ZWROYW1lLGEuZGVmYXVsdFZhbHVlKSk7YnJlYWs7Y2FzZVwiZHR5cGVbXVwiOnZvaWQgMD09PShuPWdldER0eXBlQXJyYXlQYXJhbShlLmF0dHIsYS50Zk5hbWUsYS5kZWZhdWx0VmFsdWUpKSYmYS50ZkRlcHJlY2F0ZWROYW1lJiYobj1nZXREdHlwZUFycmF5UGFyYW0oZS5hdHRyLGEudGZEZXByZWNhdGVkTmFtZSxhLmRlZmF1bHRWYWx1ZSkpO2JyZWFrO2Nhc2VcInRlbnNvclwiOmNhc2VcInRlbnNvcnNcIjpicmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHBhcmFtIHR5cGU6IFwiK2EudHlwZStcIiBmb3Igb3A6IFwiK2Uub3ApfXJldHVybiB0W2EubmFtZV09e3ZhbHVlOm4sdHlwZTpyfSx0fSx7fSkpLGF9LGV9KCk7ZnVuY3Rpb24gZGVjb2RlQmFzZTY0KGUpe3ZhciB0PWVudigpLmdsb2JhbDtpZih2b2lkIDAhPT10LmF0b2IpcmV0dXJuIHQuYXRvYihlKTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgQnVmZmVyKXJldHVybiBuZXcgQnVmZmVyKGUsXCJiYXNlNjRcIikudG9TdHJpbmcoKTt0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIGJhc2U2NCBpbiB0aGlzIGVudmlyb25tZW50LiBNaXNzaW5nIGJ1aWx0LWluIGF0b2IoKSBvciBCdWZmZXIoKVwiKX1mdW5jdGlvbiBwYXJzZVN0cmluZ1BhcmFtKGUsdCl7dmFyIGE9QXJyYXkuaXNBcnJheShlKT9TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsZSk6ZGVjb2RlQmFzZTY0KGUpO3JldHVybiB0P2E6YS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIGdldFN0cmluZ1BhcmFtKGUsdCxhLHIpe3ZvaWQgMD09PXImJihyPSExKTt2YXIgbj1lW3RdO3JldHVybiBudWxsIT1uP3BhcnNlU3RyaW5nUGFyYW0obi5zLHIpOmF9ZnVuY3Rpb24gZ2V0Qm9vbFBhcmFtKGUsdCxhKXt2YXIgcj1lW3RdO3JldHVybiByP3IuYjphfWZ1bmN0aW9uIGdldE51bWJlclBhcmFtKGUsdCxhKXt2YXIgcj1lW3RdfHx7fSxuPW51bGwhPXIuaT9yLmk6bnVsbCE9ci5mP3IuZjphO3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBuP246cGFyc2VJbnQobiwxMCl9ZnVuY3Rpb24gcGFyc2VEdHlwZVBhcmFtKGUpe3N3aXRjaChcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9RGF0YVR5cGVbZV0pLGUpe2Nhc2UgRGF0YVR5cGUuRFRfRkxPQVQ6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSBEYXRhVHlwZS5EVF9JTlQzMjpjYXNlIERhdGFUeXBlLkRUX0lOVDY0OmNhc2UgRGF0YVR5cGUuRFRfSU5UODpjYXNlIERhdGFUeXBlLkRUX1VJTlQ4OnJldHVyblwiaW50MzJcIjtjYXNlIERhdGFUeXBlLkRUX0JPT0w6cmV0dXJuXCJib29sXCI7Y2FzZSBEYXRhVHlwZS5EVF9ET1VCTEU6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSBEYXRhVHlwZS5EVF9TVFJJTkc6cmV0dXJuXCJzdHJpbmdcIjtkZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiBnZXREdHlwZVBhcmFtKGUsdCxhKXt2YXIgcj1lW3RdO3JldHVybiByJiZyLnR5cGU/cGFyc2VEdHlwZVBhcmFtKHIudHlwZSk6YX1mdW5jdGlvbiBnZXREdHlwZUFycmF5UGFyYW0oZSx0LGEpe3ZhciByPWVbdF07cmV0dXJuIHImJnIubGlzdCYmci5saXN0LnR5cGU/ci5saXN0LnR5cGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUR0eXBlUGFyYW0oZSl9KTphfWZ1bmN0aW9uIHBhcnNlVGVuc29yU2hhcGVQYXJhbShlKXtpZighZS51bmtub3duUmFuaylyZXR1cm4gbnVsbCE9ZS5kaW0/ZS5kaW0ubWFwKGZ1bmN0aW9uKGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlLnNpemU/ZS5zaXplOnBhcnNlSW50KGUuc2l6ZSwxMCl9KTpbXX1mdW5jdGlvbiBnZXRUZW5zb3JTaGFwZVBhcmFtKGUsdCxhKXt2YXIgcj1lW3RdO3JldHVybiByJiZyLnNoYXBlP3BhcnNlVGVuc29yU2hhcGVQYXJhbShyLnNoYXBlKTphfWZ1bmN0aW9uIGdldE51bWVyaWNBcnJheVBhcmFtKGUsdCxhKXt2YXIgcj1lW3RdO3JldHVybiByPygoci5saXN0LmYmJnIubGlzdC5mLmxlbmd0aD9yLmxpc3QuZjpyLmxpc3QuaSl8fFtdKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGU/ZTpwYXJzZUludChlLDEwKX0pOmF9ZnVuY3Rpb24gZ2V0U3RyaW5nQXJyYXlQYXJhbShlLHQsYSxyKXt2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG49ZVt0XTtyZXR1cm4gbiYmbi5saXN0JiZuLmxpc3Qucz9uLmxpc3Qucy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlU3RyaW5nUGFyYW0oZSxyKX0pOmF9ZnVuY3Rpb24gZ2V0VGVuc29yU2hhcGVBcnJheVBhcmFtKGUsdCxhKXt2YXIgcj1lW3RdO3JldHVybiByJiZyLmxpc3QmJnIubGlzdC5zaGFwZT9yLmxpc3Quc2hhcGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZVRlbnNvclNoYXBlUGFyYW0oZSl9KTphfWZ1bmN0aW9uIGdldEJvb2xBcnJheVBhcmFtKGUsdCxhKXt2YXIgcj1lW3RdO3JldHVybiByJiZyLmxpc3QmJnIubGlzdC5iP3IubGlzdC5iOmF9dmFyIE5vZGVWYWx1ZUltcGw9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCxhKXt2YXIgcj10aGlzO3RoaXMubm9kZT1lLHRoaXMudGVuc29yTWFwPXQsdGhpcy5jb250ZXh0PWEsdGhpcy5pbnB1dHM9W10sdGhpcy5hdHRycz17fSx0aGlzLmlucHV0cz1lLmlucHV0TmFtZXMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiByLmdldElucHV0KGUpfSksbnVsbCE9ZS5yYXdBdHRycyYmKHRoaXMuYXR0cnM9T2JqZWN0LmtleXMoZS5yYXdBdHRycykucmVkdWNlKGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGVbdF09ci5nZXRBdHRyKHQpLGV9LHt9KSl9cmV0dXJuIGUucHJvdG90eXBlLmdldElucHV0PWZ1bmN0aW9uKGUpe3JldHVybiBnZXRUZW5zb3IoZSx0aGlzLnRlbnNvck1hcCx0aGlzLmNvbnRleHQpfSxlLnByb3RvdHlwZS5nZXRBdHRyPWZ1bmN0aW9uKGUsdCl7dmFyIGE9dGhpcy5ub2RlLnJhd0F0dHJzW2VdO2lmKG51bGwhPWEudGVuc29yKXJldHVybiBnZXRUZW5zb3IoZSx0aGlzLnRlbnNvck1hcCx0aGlzLmNvbnRleHQpO2lmKG51bGwhPWEuaXx8bnVsbCE9YS5mKXJldHVybiBnZXROdW1iZXJQYXJhbSh0aGlzLm5vZGUucmF3QXR0cnMsZSx0KTtpZihudWxsIT1hLnMpcmV0dXJuIGdldFN0cmluZ1BhcmFtKHRoaXMubm9kZS5yYXdBdHRycyxlLHQpO2lmKG51bGwhPWEuYilyZXR1cm4gZ2V0Qm9vbFBhcmFtKHRoaXMubm9kZS5yYXdBdHRycyxlLHQpO2lmKG51bGwhPWEuc2hhcGUpcmV0dXJuIGdldFRlbnNvclNoYXBlUGFyYW0odGhpcy5ub2RlLnJhd0F0dHJzLGUsdCk7aWYobnVsbCE9YS50eXBlKXJldHVybiBnZXREdHlwZVBhcmFtKHRoaXMubm9kZS5yYXdBdHRycyxlLHQpO2lmKG51bGwhPWEubGlzdCl7aWYobnVsbCE9YS5saXN0Lml8fG51bGwhPWEubGlzdC5mKXJldHVybiBnZXROdW1lcmljQXJyYXlQYXJhbSh0aGlzLm5vZGUucmF3QXR0cnMsZSx0KTtpZihudWxsIT1hLmxpc3QucylyZXR1cm4gZ2V0U3RyaW5nQXJyYXlQYXJhbSh0aGlzLm5vZGUucmF3QXR0cnMsZSx0KTtpZihudWxsIT1hLmxpc3Quc2hhcGUpcmV0dXJuIGdldFRlbnNvclNoYXBlQXJyYXlQYXJhbSh0aGlzLm5vZGUucmF3QXR0cnMsZSx0KTtpZihudWxsIT1hLmxpc3QuYilyZXR1cm4gZ2V0Qm9vbEFycmF5UGFyYW0odGhpcy5ub2RlLnJhd0F0dHJzLGUsdCk7aWYobnVsbCE9YS5saXN0LnR5cGUpcmV0dXJuIGdldER0eXBlQXJyYXlQYXJhbSh0aGlzLm5vZGUucmF3QXR0cnMsZSx0KX1yZXR1cm4gdH0sZX0oKSxleGVjdXRlT3A9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJCaWFzQWRkXCI6Y2FzZVwiQWRkVjJcIjpjYXNlXCJBZGRcIjpyZXR1cm5bYWRkKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiQWRkTlwiOnJldHVyblthZGROKGdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JzXCIsZSx0LGEpKV07Y2FzZVwiRmxvb3JNb2RcIjpjYXNlXCJNb2RcIjpyZXR1cm5bbW9kKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiTXVsXCI6cmV0dXJuW211bChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIlJlYWxEaXZcIjpjYXNlXCJEaXZcIjpyZXR1cm5bZGl2KGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiRGl2Tm9OYW5cIjpyZXR1cm5bZGl2Tm9OYW4oZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJGbG9vckRpdlwiOnJldHVybltmbG9vckRpdihnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIlN1YlwiOnJldHVybltzdWIoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJNaW5pbXVtXCI6cmV0dXJuW21pbmltdW0oZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJNYXhpbXVtXCI6cmV0dXJuW21heGltdW0oZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJQb3dcIjpyZXR1cm5bcG93KGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiU3F1YXJlZERpZmZlcmVuY2VcIjpyZXR1cm5bc3F1YXJlZERpZmZlcmVuY2UoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiQWJzXCI6Y2FzZVwiQ29tcGxleEFic1wiOnJldHVyblthYnMoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJBY29zXCI6cmV0dXJuW2Fjb3MoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJBY29zaFwiOnJldHVyblthY29zaChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkFzaW5cIjpyZXR1cm5bYXNpbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkFzaW5oXCI6cmV0dXJuW2FzaW5oKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiQXRhblwiOnJldHVyblthdGFuKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiQXRhbjJcIjpyZXR1cm5bYXRhbjIoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInlcIixlLHQsYSkpXTtjYXNlXCJBdGFuaFwiOnJldHVyblthdGFuaChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkNlaWxcIjpyZXR1cm5bY2VpbChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkNvbXBsZXhcIjpyZXR1cm5bY29tcGxleChnZXRQYXJhbVZhbHVlKFwicmVhbFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiaW1hZ1wiLGUsdCxhKSldO2Nhc2VcIkNvc1wiOnJldHVybltjb3MoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJDb3NoXCI6cmV0dXJuW2Nvc2goZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJFbHVcIjpyZXR1cm5bZWx1KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiRXJmXCI6cmV0dXJuW2VyZihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkV4cFwiOnJldHVybltleHAoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJFeHBtMVwiOnJldHVybltleHBtMShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkZsb29yXCI6cmV0dXJuW2Zsb29yKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiTG9nXCI6cmV0dXJuW2xvZyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkxvZzFwXCI6cmV0dXJuW2xvZzFwKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiSW1hZ1wiOnJldHVybltpbWFnKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiTmVnXCI6cmV0dXJuW25lZyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlJlY2lwcm9jYWxcIjpyZXR1cm5bcmVjaXByb2NhbChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlJlYWxcIjpyZXR1cm5bcmVhbChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlJlbHVcIjpyZXR1cm5bcmVsdShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlJvdW5kXCI6cmV0dXJuW3JvdW5kKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU2VsdVwiOnJldHVybltzZWx1KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU2lnbW9pZFwiOnJldHVybltzaWdtb2lkKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU2luXCI6cmV0dXJuW3NpbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNpZ25cIjpyZXR1cm5bc2lnbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNpbmhcIjpyZXR1cm5bc2luaChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNvZnRwbHVzXCI6cmV0dXJuW3NvZnRwbHVzKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU3FydFwiOnJldHVybltzcXJ0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiU3F1YXJlXCI6cmV0dXJuW3NxdWFyZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlRhbmhcIjpyZXR1cm5bdGFuaChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlRhblwiOnJldHVyblt0YW4oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJSZWx1NlwiOmNhc2VcIkNsaXBCeVZhbHVlXCI6cmV0dXJuW2NsaXBCeVZhbHVlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJjbGlwVmFsdWVNaW5cIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImNsaXBWYWx1ZU1heFwiLGUsdCxhKSldO2Nhc2VcIlJzcXJ0XCI6cmV0dXJuW3JzcXJ0KGdldFRlbnNvcihlLmlucHV0TmFtZXNbMF0sdCxhKSldO2Nhc2VcIlByb2RcIjpyZXR1cm5bcHJvZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYXhlc1wiLGUsdCxhKSldO2Nhc2VcIkxlYWt5UmVsdVwiOnJldHVybltsZWFreVJlbHUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImFscGhhXCIsZSx0LGEpKV07Y2FzZVwiUHJlbHVcIjpyZXR1cm5bcHJlbHUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImFscGhhXCIsZSx0LGEpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxUZW5zb3JBcnJheT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxhLHIsbixzLG8scCl7dGhpcy5uYW1lPXQsdGhpcy5kdHlwZT1hLHRoaXMubWF4U2l6ZT1yLHRoaXMuZWxlbWVudFNoYXBlPW4sdGhpcy5pZGVudGljYWxFbGVtZW50U2hhcGVzPXMsdGhpcy5keW5hbWljU2l6ZT1vLHRoaXMuY2xlYXJBZnRlclJlYWQ9cCx0aGlzLnRlbnNvcnM9W10sdGhpcy5jbG9zZWRfPSExLHRoaXMuaWQ9ZS5uZXh0SWQrK31yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiY2xvc2VkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNsb3NlZF99LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuY2xlYXJBbmRDbG9zZT1mdW5jdGlvbigpe3RoaXMudGVuc29ycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRlbnNvci5kaXNwb3NlKCl9KSx0aGlzLnRlbnNvcnM9W10sdGhpcy5jbG9zZWRfPSEwfSxlLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGVuc29ycy5sZW5ndGh9LGUucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24oZSl7aWYodGhpcy5jbG9zZWRfKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IFwiK3RoaXMubmFtZStcIiBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7aWYoZTwwfHxlPj10aGlzLnRlbnNvcnMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIHJlYWQgZnJvbSBpbmRleCBcIitlK1wiLCBidXQgYXJyYXkgc2l6ZSBpczogXCIrdGhpcy50ZW5zb3JzLmxlbmd0aCk7dmFyIHQ9dGhpcy50ZW5zb3JzW2VdO2lmKHQuY2xlYXJlZCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IENvdWxkIG5vdCByZWFkIGluZGV4IFwiK2UrXCIgdHdpY2UgYmVjYXVzZSBpdCB3YXMgY2xlYXJlZCBhZnRlciBhIHByZXZpb3VzIHJlYWQgKHBlcmhhcHMgdHJ5IHNldHRpbmcgY2xlYXJfYWZ0ZXJfcmVhZCA9IGZhbHNlPykuXCIpO3JldHVybiB0aGlzLmNsZWFyQWZ0ZXJSZWFkJiYodC5jbGVhcmVkPSEwKSx0LnJlYWQ9ITAsdC50ZW5zb3J9LGUucHJvdG90eXBlLnJlYWRNYW55PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0LnJlYWQoZSl9KX0sZS5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmNsb3NlZF8pdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtpZihlPDB8fCF0aGlzLmR5bmFtaWNTaXplJiZlPj10aGlzLm1heFNpemUpdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gd3JpdGUgdG8gaW5kZXggXCIrZStcIiwgYnV0IGFycmF5IGlzIG5vdCByZXNpemVhYmxlIGFuZCBzaXplIGlzOiBcIit0aGlzLm1heFNpemUpO3ZhciBhPXRoaXMudGVuc29yc1tlXXx8e307aWYodC5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggXCIrZStcIixcXG4gICAgICAgICAgYmVjYXVzZSB0aGUgdmFsdWUgZHR5cGUgaXMgXCIrdC5kdHlwZStcIiwgYnV0IFRlbnNvckFycmF5IGR0eXBlIGlzIFwiK3RoaXMuZHR5cGUrXCIuXCIpO2lmKDAhPT10aGlzLnNpemUoKXx8bnVsbCE9dGhpcy5lbGVtZW50U2hhcGUmJjAhPT10aGlzLmVsZW1lbnRTaGFwZS5sZW5ndGh8fCh0aGlzLmVsZW1lbnRTaGFwZT10LnNoYXBlKSx0aGlzLmFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKHRoaXMuZWxlbWVudFNoYXBlLHQuc2hhcGUsXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCBcIitlK1wiLlwiKSxhJiZhLnJlYWQpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yQXJyYXkgXCIrdGhpcy5uYW1lK1wiOiBDb3VsZCBub3Qgd3JpdGUgdG8gVGVuc29yQXJyYXkgaW5kZXggXCIrZStcIiwgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHJlYWQuXCIpO2lmKGEmJmEud3JpdHRlbil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCBcIitlK1wiLCBiZWNhdXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gd3JpdHRlbi5cIik7YS50ZW5zb3I9dCxhLndyaXR0ZW49ITAsdGhpcy50ZW5zb3JzW2VdPWF9LGUucHJvdG90eXBlLndyaXRlTWFueT1mdW5jdGlvbihlLHQpe3ZhciBhPXRoaXM7aWYoZS5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBcIit0aGlzLm5hbWUrXCI6IGNvdWxkIG5vdCB3cml0ZSBtdWx0aXBsZSB0ZW5zb3JzLGJlY2F1c2UgdGhlIGluZGV4IHNpemU6IFwiK2UubGVuZ3RoK1wiIGlzIG5vdCB0aGUgc2FtZSBhcyB0ZW5zb3JzIHNpemU6IFwiK3QubGVuZ3RoK1wiLlwiKTtlLmZvckVhY2goZnVuY3Rpb24oZSxyKXtyZXR1cm4gYS53cml0ZShlLHRbcl0pfSl9LGUucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbihlLHQpe2lmKHQmJnQhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IGR0eXBlIGlzIFwiK3RoaXMuZHR5cGUrXCIgYnV0IGdhdGhlciByZXF1ZXN0ZWQgZHR5cGUgXCIrdCk7aWYoIWUpe2U9W107Zm9yKHZhciBhPTA7YTx0aGlzLnNpemUoKTthKyspZS5wdXNoKGEpfWlmKDA9PT1lLmxlbmd0aClyZXR1cm4gdGVuc29yKFtdLFswXS5jb25jYXQodGhpcy5lbGVtZW50U2hhcGUpKTt2YXIgcj10aGlzLnJlYWRNYW55KGUpO3JldHVybiB0aGlzLmFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKHRoaXMuZWxlbWVudFNoYXBlLHJbMF0uc2hhcGUsXCJUZW5zb3JBcnJheSBzaGFwZSBtaXNtYXRjaDogXCIpLHN0YWNrKHIsMCl9LGUucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbihlKXtpZihlJiZlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBkdHlwZSBpcyBcIit0aGlzLmR0eXBlK1wiIGJ1dCBjb25jYXQgcmVxdWVzdGVkIGR0eXBlIFwiK2UpO2lmKDA9PT10aGlzLnNpemUoKSlyZXR1cm4gdGVuc29yKFtdLFswXS5jb25jYXQodGhpcy5lbGVtZW50U2hhcGUpKTtmb3IodmFyIHQ9W10sYT0wO2E8dGhpcy5zaXplKCk7YSsrKXQucHVzaChhKTt2YXIgcj10aGlzLnJlYWRNYW55KHQpO3JldHVybiB0aGlzLmFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKHRoaXMuZWxlbWVudFNoYXBlLHJbMF0uc2hhcGUsXCJUZW5zb3JBcnJheSBzaGFwZSBtaXNtYXRjaDogdGVuc29yIGFycmF5IHNoYXBlIChcIit0aGlzLmVsZW1lbnRTaGFwZStcIikgdnMgZmlyc3QgdGVuc29yIHNoYXBlIChcIityWzBdLnNoYXBlK1wiKVwiKSxjb25jYXQociwwKX0sZS5wcm90b3R5cGUuc2NhdHRlcj1mdW5jdGlvbihlLHQpe2lmKHQuZHR5cGUhPT10aGlzLmR0eXBlKXRocm93IG5ldyBFcnJvcihcIlRlbnNvckFycmF5IGR0eXBlIGlzIFwiK3RoaXMuZHR5cGUrXCIgYnV0IHRlbnNvciBoYXMgZHR5cGUgXCIrdC5kdHlwZSk7aWYoZS5sZW5ndGghPT10LnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGxlbihpbmRpY2VzKSA9PSB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzYXc6IFwiK2UubGVuZ3RoK1wiIHZzLiBcIit0LnNoYXBlWzBdKTt2YXIgYT1NYXRoLm1heC5hcHBseShNYXRoLGUpO2lmKCF0aGlzLmR5bmFtaWNTaXplJiZhPj10aGlzLm1heFNpemUpdGhyb3cgbmV3IEVycm9yKFwiTWF4IGluZGV4IG11c3QgYmUgPCBhcnJheSBzaXplIChcIithK1wiICB2cy4gXCIrdGhpcy5tYXhTaXplK1wiKVwiKTt0aGlzLndyaXRlTWFueShlLHVuc3RhY2sodCwwKSl9LGUucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKGUsdCl7dmFyIGE9dGhpcztpZih0LmR0eXBlIT09dGhpcy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSBkdHlwZSBpcyBcIit0aGlzLmR0eXBlK1wiIGJ1dCB0ZW5zb3IgaGFzIGR0eXBlIFwiK3QuZHR5cGUpO3ZhciByPTAsbj1lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcis9ZX0pO2lmKHIhPT10LnNoYXBlWzBdKXRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN1bSBvZiBsZW5ndGhzIHRvIGJlIGVxdWFsIHRvXFxuICAgICAgICAgIHRlbnNvci5zaGFwZVswXSwgYnV0IHN1bSBvZiBsZW5ndGhzIGlzXFxuICAgICAgICBcIityK1wiLCBhbmQgdGVuc29yJ3Mgc2hhcGUgaXM6IFwiK3Quc2hhcGUpO2lmKCF0aGlzLmR5bmFtaWNTaXplJiZlLmxlbmd0aCE9PXRoaXMubWF4U2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3JBcnJheSdzIHNpemUgaXMgbm90IGVxdWFsIHRvIHRoZSBzaXplIG9mIGxlbmd0aHMgKFwiK3RoaXMubWF4U2l6ZStcIiB2cy4gXCIrZS5sZW5ndGgrXCIpLCBhbmQgdGhlIFRlbnNvckFycmF5IGlzIG5vdCBtYXJrZWQgYXMgZHluYW1pY2FsbHkgcmVzaXplYWJsZVwiKTt2YXIgcz0wPT09cj8wOnQuc2l6ZS9yLG89W107dGlkeShmdW5jdGlvbigpe3Q9dC5yZXNoYXBlKFsxLHIsc10pO2Zvcih2YXIgcD0wO3A8ZS5sZW5ndGg7KytwKXt2YXIgdT1bMCwwPT09cD8wOm5bcC0xXSwwXSxpPVsxLGVbcF0sc107b1twXT1zbGljZSh0LHUsaSkucmVzaGFwZShhLmVsZW1lbnRTaGFwZSl9cmV0dXJuIG99KTtmb3IodmFyIHA9W10sdT0wO3U8ZS5sZW5ndGg7dSsrKXBbdV09dTt0aGlzLndyaXRlTWFueShwLG8pfSxlLnByb3RvdHlwZS5hc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZT1mdW5jdGlvbihlLHQsYSl7dm9pZCAwPT09YSYmKGE9XCJcIiksdXRpbC5hc3NlcnQodGhpcy5zaGFwZXNFcXVhbEFsbG93VW5kZWZpbmVkU2l6ZShlLHQpLGZ1bmN0aW9uKCl7cmV0dXJuIGErXCIgU2hhcGVzIFwiK2UrXCIgYW5kIFwiK3QrXCIgbXVzdCBtYXRjaFwifSl9LGUucHJvdG90eXBlLnNoYXBlc0VxdWFsQWxsb3dVbmRlZmluZWRTaXplPWZ1bmN0aW9uKGUsdCl7aWYoZS5sZW5ndGghPT10Lmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIGE9MDthPGUubGVuZ3RoO2ErKylpZigtMSE9PWVbYV0mJi0xIT09dFthXSYmZVthXSE9PXRbYV0pcmV0dXJuITE7cmV0dXJuITB9LGUubmV4dElkPTAsZX0oKSxfdGhpcz12b2lkIDAsZXhlY3V0ZU9wJDI9ZnVuY3Rpb24oZSx0LGEpe3JldHVybiBfX2F3YWl0ZXIoX3RoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLG4scyxvLHAsdSxpLG0sbCxjLGQseSxmLGcsaCxOLHgsVixiLFAsVCx2LE8sUyxfLHcsQSxELEUsSSxNLEMsayx6LEY7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oail7c3dpdGNoKGoubGFiZWwpe2Nhc2UgMDpzd2l0Y2goZS5vcCl7Y2FzZVwiTG9vcENvbmRcIjpyZXR1cm5bMywxXTtjYXNlXCJTd2l0Y2hcIjpyZXR1cm5bMywyXTtjYXNlXCJNZXJnZVwiOnJldHVyblszLDRdO2Nhc2VcIkVudGVyXCI6cmV0dXJuWzMsNV07Y2FzZVwiRXhpdFwiOnJldHVyblszLDZdO2Nhc2VcIk5leHRJdGVyYXRpb25cIjpyZXR1cm5bMyw3XTtjYXNlXCJUZW5zb3JBcnJheVYzXCI6cmV0dXJuWzMsOF07Y2FzZVwiVGVuc29yQXJyYXlXcml0ZVYzXCI6cmV0dXJuWzMsOV07Y2FzZVwiVGVuc29yQXJyYXlSZWFkVjNcIjpyZXR1cm5bMywxMF07Y2FzZVwiVGVuc29yQXJyYXlHYXRoZXJWM1wiOnJldHVyblszLDExXTtjYXNlXCJUZW5zb3JBcnJheVNjYXR0ZXJWM1wiOnJldHVyblszLDEyXTtjYXNlXCJUZW5zb3JBcnJheUNvbmNhdFYzXCI6cmV0dXJuWzMsMTNdO2Nhc2VcIlRlbnNvckFycmF5U3BsaXRWM1wiOnJldHVyblszLDE0XTtjYXNlXCJUZW5zb3JBcnJheVNpemVWM1wiOnJldHVyblszLDE1XTtjYXNlXCJUZW5zb3JBcnJheUNsb3NlVjNcIjpyZXR1cm5bMywxNl19cmV0dXJuWzMsMTddO2Nhc2UgMTpyZXR1cm5bMixbZ2V0UGFyYW1WYWx1ZShcInByZWRcIixlLHQsYSkuY2xvbmUoKV1dO2Nhc2UgMjpyZXR1cm4gcj1nZXRQYXJhbVZhbHVlKFwicHJlZFwiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJkYXRhXCIsZSx0LGEpLFs0LHIuZGF0YSgpXTtjYXNlIDM6cmV0dXJuWzIsai5zZW50KClbMF0/W3ZvaWQgMCxuLmNsb25lKCldOltuLmNsb25lKCksdm9pZCAwXV07Y2FzZSA0OnJldHVyblsyLChzPWUuaW5wdXROYW1lcy5maW5kKGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT1nZXRUZW5zb3IoZSx0LGEpfSkpP1tnZXRUZW5zb3Iocyx0LGEpLmNsb25lKCldOnZvaWQgMF07Y2FzZSA1OnJldHVybiBvPWdldFBhcmFtVmFsdWUoXCJmcmFtZU5hbWVcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpLGEuZW50ZXJGcmFtZShvKSxbMixbcC5jbG9uZSgpXV07Y2FzZSA2OnJldHVybiB1PWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSksYS5leGl0RnJhbWUoKSxbMixbdS5jbG9uZSgpXV07Y2FzZSA3OnJldHVybiBpPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSksYS5uZXh0SXRlcmF0aW9uKCksWzIsW2kuY2xvbmUoKV1dO2Nhc2UgODpyZXR1cm4gbT1nZXRQYXJhbVZhbHVlKFwic2l6ZVwiLGUsdCxhKSxsPWdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSxjPWdldFBhcmFtVmFsdWUoXCJlbGVtZW50U2hhcGVcIixlLHQsYSksZD1nZXRQYXJhbVZhbHVlKFwiZHluYW1pY1NpemVcIixlLHQsYSkseT1nZXRQYXJhbVZhbHVlKFwiY2xlYXJBZnRlclJlYWRcIixlLHQsYSksZj1nZXRQYXJhbVZhbHVlKFwiaWRlbnRpY2FsRWxlbWVudFNoYXBlc1wiLGUsdCxhKSxnPWdldFBhcmFtVmFsdWUoXCJuYW1lXCIsZSx0LGEpLGg9bmV3IFRlbnNvckFycmF5KGcsbCxtLGMsZixkLHkpLGEuYWRkVGVuc29yQXJyYXkoaCksWzIsW3NjYWxhcihoLmlkKSxzY2FsYXIoMSldXTtjYXNlIDk6cmV0dXJuIE49Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSkseD1nZXRQYXJhbVZhbHVlKFwiaW5kZXhcIixlLHQsYSksVj1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpLGEuZ2V0VGVuc29yQXJyYXkoTikud3JpdGUoeCxWKSxbMixbc2NhbGFyKDEpXV07Y2FzZSAxMDpyZXR1cm4gYj1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSxQPWdldFBhcmFtVmFsdWUoXCJpbmRleFwiLGUsdCxhKSxbMixbYS5nZXRUZW5zb3JBcnJheShiKS5yZWFkKFApXV07Y2FzZSAxMTpyZXR1cm4gVD1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSx2PWdldFBhcmFtVmFsdWUoXCJpbmRpY2VzXCIsZSx0LGEpLE89Z2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpLFsyLFthLmdldFRlbnNvckFycmF5KFQpLmdhdGhlcih2LE8pXV07Y2FzZSAxMjpyZXR1cm4gUz1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSxfPWdldFBhcmFtVmFsdWUoXCJpbmRpY2VzXCIsZSx0LGEpLHc9Z2V0UGFyYW1WYWx1ZShcInRlbnNvclwiLGUsdCxhKSxhLmdldFRlbnNvckFycmF5KFMpLnNjYXR0ZXIoXyx3KSxbMixbc2NhbGFyKDEpXV07Y2FzZSAxMzpyZXR1cm4gQT1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSxEPWEuZ2V0VGVuc29yQXJyYXkoQSksRT1nZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSksWzIsW0QuY29uY2F0KEUpXV07Y2FzZSAxNDpyZXR1cm4gST1nZXRQYXJhbVZhbHVlKFwidGVuc29yQXJyYXlJZFwiLGUsdCxhKSxNPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JcIixlLHQsYSksQz1nZXRQYXJhbVZhbHVlKFwibGVuZ3Roc1wiLGUsdCxhKSxhLmdldFRlbnNvckFycmF5KEkpLnNwbGl0KEMsTSksWzIsW3NjYWxhcigxKV1dO2Nhc2UgMTU6cmV0dXJuIGs9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksej1hLmdldFRlbnNvckFycmF5KGspLFsyLFtzY2FsYXIoei5zaXplKCksXCJpbnQzMlwiKV1dO2Nhc2UgMTY6cmV0dXJuIEY9Z2V0UGFyYW1WYWx1ZShcInRlbnNvckFycmF5SWRcIixlLHQsYSksYS5nZXRUZW5zb3JBcnJheShGKS5jbGVhckFuZENsb3NlKCksWzIsW3NjYWxhcigwKV1dO2Nhc2UgMTc6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0pfSl9LGV4ZWN1dGVPcCQzPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiQ29udjFEXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZVwiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwiZGF0YUZvcm1hdFwiLGUsdCxhKS50b1VwcGVyQ2FzZSgpLG89Z2V0UGFyYW1WYWx1ZShcImRpbGF0aW9uXCIsZSx0LGEpO3JldHVybltjb252MWQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImZpbHRlclwiLGUsdCxhKSxyLG4scyxvKV07Y2FzZVwiQ29udjJEXCI6cj1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwiZGF0YUZvcm1hdFwiLGUsdCxhKS50b1VwcGVyQ2FzZSgpO3ZhciBwPWdldFBhcmFtVmFsdWUoXCJkaWxhdGlvbnNcIixlLHQsYSk7cmV0dXJuW2NvbnYyZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZmlsdGVyXCIsZSx0LGEpLFtyWzFdLHJbMl1dLG4scyxbcFsxXSxwWzJdXSldO2Nhc2VcIl9GdXNlZENvbnYyRFwiOmNhc2VcIkZ1c2VkRGVwdGh3aXNlQ29udjJkTmF0aXZlXCI6dmFyIHU9Z2V0UGFyYW1WYWx1ZShcImZ1c2VkT3BzXCIsZSx0LGEpLGk9dVswXSxtPXVbMV0sbD1cImJpYXNhZGRcIj09PWksYz1cInByZWx1XCI9PT1tLGQ9XCJmdXNlZGJhdGNobm9ybVwiPT09aSx5PWdldFBhcmFtVmFsdWUoXCJudW1BcmdzXCIsZSx0LGEpO2lmKGwpe2lmKGMmJjIhPT15KXRocm93IG5ldyBFcnJvcihcIkZ1c2VkQ29udjJkIGFuZCBEZXB0aHdpc2VDb252MmQgd2l0aCBCaWFzQWRkIGFuZCBQcmVsdSBtdXN0IGhhdmUgdHdvIGV4dHJhIGFyZ3VtZW50czogYmlhcyBhbmQgYWxwaGEuXCIpO2lmKCFjJiYxIT09eSl0aHJvdyBuZXcgRXJyb3IoXCJGdXNlZENvbnYyZCBhbmQgRGVwdGh3aXNlQ29udjJkIHdpdGggQmlhc0FkZCBtdXN0IGhhdmUgb25lIGV4dHJhIGFyZ3VtZW50OiBiaWFzLlwiKX1pZihkKXRocm93IG5ldyBFcnJvcihcIkZ1c2VkQ29udjJkIGFuZCBEZXB0aHdpc2VDb252MmQgd2l0aCBGdXNlZEJhdGNoTm9ybSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtyPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJkYXRhRm9ybWF0XCIsZSx0LGEpLnRvVXBwZXJDYXNlKCkscD1nZXRQYXJhbVZhbHVlKFwiZGlsYXRpb25zXCIsZSx0LGEpO3ZhciBmPWdldFBhcmFtVmFsdWUoXCJhcmdzXCIsZSx0LGEpLGc9ZlswXSxoPWZbMV07cmV0dXJuWyhcIl9GdXNlZENvbnYyRFwiPT09ZS5vcD9mdXNlZC5jb252MmQ6ZnVzZWQuZGVwdGh3aXNlQ29udjJkKSh7eDpnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxmaWx0ZXI6Z2V0UGFyYW1WYWx1ZShcImZpbHRlclwiLGUsdCxhKSxzdHJpZGVzOltyWzFdLHJbMl1dLHBhZDpuLGRhdGFGb3JtYXQ6cyxkaWxhdGlvbnM6W3BbMV0scFsyXV0sYmlhczpnLGFjdGl2YXRpb246bSxwcmVsdUFjdGl2YXRpb25XZWlnaHRzOmh9KV07Y2FzZVwiQ29udjJEQmFja3Byb3BJbnB1dFwiOmNhc2VcIkNvbnYyZFRyYW5zcG9zZVwiOnZhciBOPWdldFBhcmFtVmFsdWUoXCJvdXRwdXRTaGFwZVwiLGUsdCxhKTtyPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGUsdCxhKTtyZXR1cm5bY29udjJkVHJhbnNwb3NlKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJmaWx0ZXJcIixlLHQsYSksTixbclsxXSxyWzJdXSxuKV07Y2FzZVwiRGVwdGh3aXNlQ29udjJkTmF0aXZlXCI6Y2FzZVwiRGVwdGh3aXNlQ29udjJkXCI6cj1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwiZGlsYXRpb25zXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcImRhdGFGb3JtYXRcIixlLHQsYSkudG9VcHBlckNhc2UoKTtyZXR1cm5bZGVwdGh3aXNlQ29udjJkKGdldFBhcmFtVmFsdWUoXCJpbnB1dFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZmlsdGVyXCIsZSx0LGEpLFtyWzFdLHJbMl1dLG4scyxbcFsxXSxwWzJdXSldO2Nhc2VcIkNvbnYzRFwiOnI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcImRhdGFGb3JtYXRcIixlLHQsYSkudG9VcHBlckNhc2UoKSxwPWdldFBhcmFtVmFsdWUoXCJkaWxhdGlvbnNcIixlLHQsYSk7cmV0dXJuW2NvbnYzZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZmlsdGVyXCIsZSx0LGEpLFtyWzFdLHJbMl0sclszXV0sbixzLFtwWzFdLHBbMl0scFszXV0pXTtjYXNlXCJBdmdQb29sXCI6cj1nZXRQYXJhbVZhbHVlKFwic3RyaWRlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJwYWRcIixlLHQsYSk7dmFyIHg9Z2V0UGFyYW1WYWx1ZShcImtlcm5lbFNpemVcIixlLHQsYSk7cmV0dXJuW2F2Z1Bvb2woZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksW3hbMV0seFsyXV0sW3JbMV0sclsyXV0sbildO2Nhc2VcIk1heFBvb2xcIjpyPWdldFBhcmFtVmFsdWUoXCJzdHJpZGVzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInBhZFwiLGUsdCxhKSx4PWdldFBhcmFtVmFsdWUoXCJrZXJuZWxTaXplXCIsZSx0LGEpO3JldHVyblttYXhQb29sKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLFt4WzFdLHhbMl1dLFtyWzFdLHJbMl1dLG4pXTtjYXNlXCJNYXhQb29sV2l0aEFyZ21heFwiOnI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpLHg9Z2V0UGFyYW1WYWx1ZShcImtlcm5lbFNpemVcIixlLHQsYSk7dmFyIFY9Z2V0UGFyYW1WYWx1ZShcImluY2x1ZGVCYXRjaEluSW5kZXhcIixlLHQsYSksYj1tYXhQb29sV2l0aEFyZ21heChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxbeFsxXSx4WzJdXSxbclsxXSxyWzJdXSxuLFYpO3JldHVybltiLnJlc3VsdCxiLmluZGV4ZXNdO2Nhc2VcIkF2Z1Bvb2wzRFwiOnI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpLHg9Z2V0UGFyYW1WYWx1ZShcImtlcm5lbFNpemVcIixlLHQsYSk7cmV0dXJuW2F2Z1Bvb2wzZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxbeFsxXSx4WzJdLHhbM11dLFtyWzFdLHJbMl0sclszXV0sbildO2Nhc2VcIk1heFBvb2wzRFwiOnI9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwicGFkXCIsZSx0LGEpLHg9Z2V0UGFyYW1WYWx1ZShcImtlcm5lbFNpemVcIixlLHQsYSk7cmV0dXJuW21heFBvb2wzZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxbeFsxXSx4WzJdLHhbM11dLFtyWzFdLHJbMl0sclszXV0sbildO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDQ9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJGaWxsXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcInZhbHVlXCIsZSx0LGEpO3JldHVybltmaWxsKHIscyxuKV07Y2FzZVwiTGluU3BhY2VcIjp2YXIgbz1nZXRQYXJhbVZhbHVlKFwic3RhcnRcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwic3RvcFwiLGUsdCxhKSx1PWdldFBhcmFtVmFsdWUoXCJudW1cIixlLHQsYSk7cmV0dXJuW2xpbnNwYWNlKG8scCx1KV07Y2FzZVwiTXVsdGlub21pYWxcIjp2YXIgaT1nZXRQYXJhbVZhbHVlKFwibG9naXRzXCIsZSx0LGEpLG09Z2V0UGFyYW1WYWx1ZShcIm51bVNhbXBsZXNcIixlLHQsYSksbD1nZXRQYXJhbVZhbHVlKFwic2VlZFwiLGUsdCxhKTtyZXR1cm5bbXVsdGlub21pYWwoaSxtLGwpXTtjYXNlXCJPbmVIb3RcIjp2YXIgYz1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKSxkPWdldFBhcmFtVmFsdWUoXCJkZXB0aFwiLGUsdCxhKSx5PWdldFBhcmFtVmFsdWUoXCJvblZhbHVlXCIsZSx0LGEpLGY9Z2V0UGFyYW1WYWx1ZShcIm9mZlZhbHVlXCIsZSx0LGEpO3JldHVybltvbmVIb3QoYyxkLHksZildO2Nhc2VcIk9uZXNcIjpyZXR1cm5bb25lcyhnZXRQYXJhbVZhbHVlKFwic2hhcGVcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpKV07Y2FzZVwiT25lc0xpa2VcIjpyZXR1cm5bb25lc0xpa2UoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtjYXNlXCJSYW5kb21Vbmlmb3JtXCI6cmV0dXJuW3JhbmRvbVVuaWZvcm0oZ2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJtaW52YWxcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcIm1heHZhbFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSkpXTtjYXNlXCJSYW5nZVwiOm89Z2V0UGFyYW1WYWx1ZShcInN0YXJ0XCIsZSx0LGEpO3ZhciBnPWdldFBhcmFtVmFsdWUoXCJzdG9wXCIsZSx0LGEpLGg9Z2V0UGFyYW1WYWx1ZShcInN0ZXBcIixlLHQsYSk7cmV0dXJuW3JhbmdlKG8sZyxoLGdldFBhcmFtVmFsdWUoXCJkdHlwZVwiLGUsdCxhKSldO2Nhc2VcIlRydW5jYXRlZE5vcm1hbFwiOnI9Z2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpO3ZhciBOPWdldFBhcmFtVmFsdWUoXCJtZWFuXCIsZSx0LGEpLHg9Z2V0UGFyYW1WYWx1ZShcInN0ZERldlwiLGUsdCxhKTtsPWdldFBhcmFtVmFsdWUoXCJzZWVkXCIsZSx0LGEpO3JldHVyblt0cnVuY2F0ZWROb3JtYWwocixOLHgsZ2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpLGwpXTtjYXNlXCJaZXJvc1wiOnJldHVyblt6ZXJvcyhnZXRQYXJhbVZhbHVlKFwic2hhcGVcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImR0eXBlXCIsZSx0LGEpKV07Y2FzZVwiWmVyb3NMaWtlXCI6cmV0dXJuW3plcm9zTGlrZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sX3RoaXMkMT12b2lkIDAsZXhlY3V0ZU9wJDU9ZnVuY3Rpb24oZSx0LGEpe3JldHVybiBfX2F3YWl0ZXIoX3RoaXMkMSx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHIsbixzLG8scCx1LGksbTtyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihsKXtzd2l0Y2gobC5sYWJlbCl7Y2FzZSAwOnN3aXRjaChlLm9wKXtjYXNlXCJOb25NYXhTdXBwcmVzc2lvblY1XCI6Y2FzZVwiTm9uTWF4U3VwcHJlc3Npb25WM1wiOmNhc2VcIk5vbk1heFN1cHByZXNzaW9uVjJcIjpyZXR1cm5bMywxXTtjYXNlXCJXaGVyZVwiOnJldHVyblszLDVdO2Nhc2VcIkxpc3REaWZmXCI6cmV0dXJuWzMsN119cmV0dXJuWzMsOF07Y2FzZSAxOnJldHVybiByPWdldFBhcmFtVmFsdWUoXCJib3hlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJzY29yZXNcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwibWF4T3V0cHV0U2l6ZVwiLGUsdCxhKSxvPWdldFBhcmFtVmFsdWUoXCJpb3VUaHJlc2hvbGRcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwic2NvcmVUaHJlc2hvbGRcIixlLHQsYSksXCJOb25NYXhTdXBwcmVzc2lvblY1XCIhPT1lLm9wP1szLDNdOih1PWdldFBhcmFtVmFsdWUoXCJzb2Z0Tm1zU2lnbWFcIixlLHQsYSksWzQsaW1hZ2Uubm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmVBc3luYyhyLG4scyxvLHAsdSldKTtjYXNlIDI6cmV0dXJuWzIsWyhtPWwuc2VudCgpKS5zZWxlY3RlZEluZGljZXMsbS5zZWxlY3RlZFNjb3Jlc11dO2Nhc2UgMzpyZXR1cm5bNCxpbWFnZS5ub25NYXhTdXBwcmVzc2lvbkFzeW5jKHIsbixzLG8scCldO2Nhc2UgNDpyZXR1cm5bMixbbC5zZW50KCldXTtjYXNlIDU6cmV0dXJuIGk9Z2V0UGFyYW1WYWx1ZShcImNvbmRpdGlvblwiLGUsdCxhKS5hc1R5cGUoXCJib29sXCIpLFs0LHdoZXJlQXN5bmMoaSldO2Nhc2UgNjpyZXR1cm4gbT1bbC5zZW50KCldLGkuZGlzcG9zZSgpLFsyLG1dO2Nhc2UgNzpyZXR1cm5bMixzZXRkaWZmMWRBc3luYyhnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwieVwiLGUsdCxhKSldO2Nhc2UgODp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSl9KX0sZXhlY3V0ZU9wJDY9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJUb3BLVjJcIjp2YXIgcj1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcInNvcnRlZFwiLGUsdCxhKSxvPXRvcGsocixuLHMpO3JldHVybltvLnZhbHVlcyxvLmluZGljZXNdO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDc9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJDb25zdFwiOnJldHVybiB0W2UubmFtZV07Y2FzZVwiUGxhY2Vob2xkZXJXaXRoRGVmYXVsdFwiOnZhciByPWdldFBhcmFtVmFsdWUoXCJkZWZhdWx0XCIsZSx0LGEpO3JldHVybltnZXRUZW5zb3IoZS5uYW1lLHQsYSl8fHJdO2Nhc2VcIlBsYWNlaG9sZGVyXCI6cmV0dXJuW2dldFRlbnNvcihlLm5hbWUsdCxhKV07Y2FzZVwiSWRlbnRpdHlcIjpjYXNlXCJTdG9wR3JhZGllbnRcIjpjYXNlXCJGYWtlUXVhbnRXaXRoTWluTWF4VmFyc1wiOnJldHVybltnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5jbG9uZSgpXTtjYXNlXCJJZGVudGl0eU5cIjpyZXR1cm4gZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNsb25lKCl9KTtjYXNlXCJTbmFwc2hvdFwiOnJldHVybltnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5jbG9uZSgpXTtjYXNlXCJTaGFwZVwiOnJldHVyblt0ZW5zb3IxZChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKS5zaGFwZSxcImludDMyXCIpXTtjYXNlXCJTaGFwZU5cIjpyZXR1cm4gZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiB0ZW5zb3IxZChlLnNoYXBlKX0pO2Nhc2VcIlNpemVcIjpyZXR1cm5bc2NhbGFyKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLnNpemUsXCJpbnQzMlwiKV07Y2FzZVwiUmFua1wiOnJldHVybltzY2FsYXIoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkucmFuayxcImludDMyXCIpXTtjYXNlXCJOb09wXCI6cmV0dXJuW3NjYWxhcigxKV07Y2FzZVwiUHJpbnRcIjp2YXIgbj1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxzPWdldFBhcmFtVmFsdWUoXCJkYXRhXCIsZSx0LGEpLG89Z2V0UGFyYW1WYWx1ZShcIm1lc3NhZ2VcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwic3VtbWFyaXplXCIsZSx0LGEpO2NvbnNvbGUud2FybihcIlRoZSBncmFwaCBoYXMgYSB0Zi5wcmludCgpIG9wZXJhdGlvbix1c3VhbGx5IHVzZWQgZm9yIGRlYnVnZ2luZywgd2hpY2ggc2xvd3MgZG93biBwZXJmb3JtYW5jZS5cIiksY29uc29sZS5sb2cobyk7Zm9yKHZhciB1PTA7dTxzLmxlbmd0aDt1KyspY29uc29sZS5sb2coQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc1t1XS5kYXRhU3luYygpKS5zbGljZSgwLHApKTtyZXR1cm5bbl07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkOD1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIlJlc2l6ZUJpbGluZWFyXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImltYWdlc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJzaXplXCIsZSx0LGEpLHM9Z2V0UGFyYW1WYWx1ZShcImFsaWduQ29ybmVyc1wiLGUsdCxhKTtyZXR1cm5baW1hZ2UucmVzaXplQmlsaW5lYXIocixbblswXSxuWzFdXSxzKV07Y2FzZVwiUmVzaXplTmVhcmVzdE5laWdoYm9yXCI6cj1nZXRQYXJhbVZhbHVlKFwiaW1hZ2VzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcInNpemVcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwiYWxpZ25Db3JuZXJzXCIsZSx0LGEpO3JldHVybltpbWFnZS5yZXNpemVOZWFyZXN0TmVpZ2hib3IocixbblswXSxuWzFdXSxzKV07Y2FzZVwiQ3JvcEFuZFJlc2l6ZVwiOnZhciBvPWdldFBhcmFtVmFsdWUoXCJpbWFnZVwiLGUsdCxhKSxwPWdldFBhcmFtVmFsdWUoXCJib3hlc1wiLGUsdCxhKSx1PWdldFBhcmFtVmFsdWUoXCJib3hJbmRcIixlLHQsYSksaT1nZXRQYXJhbVZhbHVlKFwiY3JvcFNpemVcIixlLHQsYSksbT1nZXRQYXJhbVZhbHVlKFwibWV0aG9kXCIsZSx0LGEpLGw9Z2V0UGFyYW1WYWx1ZShcImV4dHJhcG9sYXRpb25WYWx1ZVwiLGUsdCxhKTtyZXR1cm5baW1hZ2UuY3JvcEFuZFJlc2l6ZShvLHAsdSxpLG0sbCldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDk9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJFcXVhbFwiOnJldHVybltlcXVhbChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIk5vdEVxdWFsXCI6cmV0dXJuW25vdEVxdWFsKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiR3JlYXRlclwiOnJldHVybltncmVhdGVyKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiR3JlYXRlckVxdWFsXCI6cmV0dXJuW2dyZWF0ZXJFcXVhbChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIkxlc3NcIjpyZXR1cm5bbGVzcyhnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2Nhc2VcIkxlc3NFcXVhbFwiOnJldHVybltsZXNzRXF1YWwoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJMb2dpY2FsQW5kXCI6cmV0dXJuW2xvZ2ljYWxBbmQoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcImJcIixlLHQsYSkpXTtjYXNlXCJMb2dpY2FsTm90XCI6cmV0dXJuW2xvZ2ljYWxOb3QoZ2V0UGFyYW1WYWx1ZShcImFcIixlLHQsYSkpXTtjYXNlXCJMb2dpY2FsT3JcIjpyZXR1cm5bbG9naWNhbE9yKGdldFBhcmFtVmFsdWUoXCJhXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpKV07Y2FzZVwiU2VsZWN0XCI6Y2FzZVwiU2VsZWN0VjJcIjpyZXR1cm5bd2hlcmUoZ2V0UGFyYW1WYWx1ZShcImNvbmRpdGlvblwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSldO2RlZmF1bHQ6dGhyb3cgVHlwZUVycm9yKFwiTm9kZSB0eXBlIFwiK2Uub3ArXCIgaXMgbm90IGltcGxlbWVudGVkXCIpfX0sZXhlY3V0ZU9wJDEwPWZ1bmN0aW9uKGUsdCxhKXtzd2l0Y2goZS5vcCl7Y2FzZVwiQmF0Y2hNYXRNdWxcIjpjYXNlXCJCYXRjaE1hdE11bFYyXCI6Y2FzZVwiTWF0TXVsXCI6cmV0dXJuW21hdE11bChnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYlwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwidHJhbnNwb3NlQVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwidHJhbnNwb3NlQlwiLGUsdCxhKSldO2Nhc2VcIlRyYW5zcG9zZVwiOnJldHVyblt0cmFuc3Bvc2UoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInBlcm1cIixlLHQsYSkpXTtjYXNlXCJfRnVzZWRNYXRNdWxcIjp2YXIgcj1nZXRQYXJhbVZhbHVlKFwiZnVzZWRPcHNcIixlLHQsYSksbj1yWzBdLHM9clsxXSxvPVwiYmlhc2FkZFwiPT09bixwPVwicHJlbHVcIj09PXMsdT1nZXRQYXJhbVZhbHVlKFwibnVtQXJnc1wiLGUsdCxhKTtpZihvKXtpZihwJiYyIT09dSl0aHJvdyBuZXcgRXJyb3IoXCJGdXNlZCBNYXRNdWwgd2l0aCBCaWFzQWRkIGFuZCBQcmVsdSBtdXN0IGhhdmUgdHdvIGV4dHJhIGFyZ3VtZW50czogYmlhcyBhbmQgYWxwaGEuXCIpO2lmKCFwJiYxIT09dSl0aHJvdyBuZXcgRXJyb3IoXCJGdXNlZCBNYXRNdWwgd2l0aCBCaWFzQWRkIG11c3QgaGF2ZSBvbmUgZXh0cmEgYXJndW1lbnQ6IGJpYXMuXCIpfXZhciBpPWdldFBhcmFtVmFsdWUoXCJhcmdzXCIsZSx0LGEpLG09aVswXSxsPWlbMV07cmV0dXJuW2Z1c2VkLm1hdE11bCh7YTpnZXRQYXJhbVZhbHVlKFwiYVwiLGUsdCxhKSxiOmdldFBhcmFtVmFsdWUoXCJiXCIsZSx0LGEpLHRyYW5zcG9zZUE6Z2V0UGFyYW1WYWx1ZShcInRyYW5zcG9zZUFcIixlLHQsYSksdHJhbnNwb3NlQjpnZXRQYXJhbVZhbHVlKFwidHJhbnNwb3NlQlwiLGUsdCxhKSxiaWFzOm0sYWN0aXZhdGlvbjpzLHByZWx1QWN0aXZhdGlvbldlaWdodHM6bH0pXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxMT1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkZ1c2VkQmF0Y2hOb3JtXCI6Y2FzZVwiRnVzZWRCYXRjaE5vcm1WMlwiOmNhc2VcIkZ1c2VkQmF0Y2hOb3JtVjNcIjpyZXR1cm5bYmF0Y2hOb3JtKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJtZWFuXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJ2YXJpYW5jZVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwib2Zmc2V0XCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJzY2FsZVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZXBzaWxvblwiLGUsdCxhKSldO2Nhc2VcIkxSTlwiOnJldHVybltsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwicmFkaXVzXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJiaWFzXCIsZSx0LGEpLGdldFBhcmFtVmFsdWUoXCJhbHBoYVwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiYmV0YVwiLGUsdCxhKSldO2Nhc2VcIlNvZnRtYXhcIjpyZXR1cm5bc29mdG1heChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIkxvZ1NvZnRtYXhcIjpyZXR1cm5bbG9nU29mdG1heChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSldO2Nhc2VcIlNwYXJzZVRvRGVuc2VcIjpyZXR1cm5bc3BhcnNlVG9EZW5zZShnZXRQYXJhbVZhbHVlKFwic3BhcnNlSW5kaWNlc1wiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwib3V0cHV0U2hhcGVcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInNwYXJzZVZhbHVlc1wiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZGVmYXVsdFZhbHVlXCIsZSx0LGEpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkMTI9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJNYXhcIjp2YXIgcj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrZWVwRGltc1wiLGUsdCxhKTtyZXR1cm5bbWF4KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2Nhc2VcIk1lYW5cIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVyblttZWFuKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2Nhc2VcIk1pblwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW21pbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtjYXNlXCJTdW1cIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImtlZXBEaW1zXCIsZSx0LGEpO3JldHVybltzdW0oZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscixuKV07Y2FzZVwiQWxsXCI6cj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJrZWVwRGltc1wiLGUsdCxhKTtyZXR1cm5bYWxsKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIsbildO2Nhc2VcIkFueVwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW2FueShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyLG4pXTtjYXNlXCJBcmdNYXhcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpO3JldHVyblthcmdNYXgoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscildO2Nhc2VcIkFyZ01pblwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSk7cmV0dXJuW2FyZ01pbihnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxyKV07Y2FzZVwiUHJvZFwiOnI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwia2VlcERpbXNcIixlLHQsYSk7cmV0dXJuW3Byb2QoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscixuKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkMTM9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJDb25jYXRWMlwiOmNhc2VcIkNvbmNhdFwiOnZhciByPWdldFBhcmFtVmFsdWUoXCJuXCIsZSx0LGEpLG49Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSkscz1nZXRQYXJhbVZhbHVlKFwidGVuc29yc1wiLGUsdCxhKTtyZXR1cm4gcz1zLnNsaWNlKDAsciksW2NvbmNhdChzLG4pXTtjYXNlXCJHYXRoZXJWMlwiOmNhc2VcIkdhdGhlclwiOm49Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSk7dmFyIG89Z2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscD1nZXRQYXJhbVZhbHVlKFwiaW5kaWNlc1wiLGUsdCxhKTtyZXR1cm5bZ2F0aGVyKG8scC5hc1R5cGUoXCJpbnQzMlwiKSxuKV07Y2FzZVwiUmV2ZXJzZVYyXCI6Y2FzZVwiUmV2ZXJzZVwiOm49Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbz1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKTtyZXR1cm5bcmV2ZXJzZShvLG4pXTtjYXNlXCJTbGljZVwiOnZhciB1PWdldFBhcmFtVmFsdWUoXCJiZWdpblwiLGUsdCxhKSxpPWdldFBhcmFtVmFsdWUoXCJzaXplXCIsZSx0LGEpO3JldHVybltzbGljZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSx1LGkpXTtjYXNlXCJTdHJpZGVkU2xpY2VcIjp1PWdldFBhcmFtVmFsdWUoXCJiZWdpblwiLGUsdCxhKTt2YXIgbT1nZXRQYXJhbVZhbHVlKFwiZW5kXCIsZSx0LGEpLGw9Z2V0UGFyYW1WYWx1ZShcInN0cmlkZXNcIixlLHQsYSksYz1nZXRQYXJhbVZhbHVlKFwiYmVnaW5NYXNrXCIsZSx0LGEpLGQ9Z2V0UGFyYW1WYWx1ZShcImVuZE1hc2tcIixlLHQsYSkseT1nZXRQYXJhbVZhbHVlKFwiZWxsaXBzaXNNYXNrXCIsZSx0LGEpLGY9Z2V0UGFyYW1WYWx1ZShcIm5ld0F4aXNNYXNrXCIsZSx0LGEpLGc9Z2V0UGFyYW1WYWx1ZShcInNocmlua0F4aXNNYXNrXCIsZSx0LGEpLGg9Z2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSk7aWYoMT09PXUubGVuZ3RoJiZoLnNoYXBlLmxlbmd0aD4xKWZvcih2YXIgTj0xO048aC5zaGFwZS5sZW5ndGg7TisrKXUucHVzaCgwKSxtLnB1c2goaC5zaGFwZVtOXSksbC5wdXNoKGxbMF0pO3JldHVybltzdHJpZGVkU2xpY2UoaCx1LG0sbCxjLGQseSxmLGcpXTtjYXNlXCJQYWNrXCI6cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXt2YXIgcj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKSxuPWdldFBhcmFtVmFsdWUoXCJ0ZW5zb3JzXCIsZSx0LGEpLHM9blswXS5zaGFwZSxvPW5bMF0uc3F1ZWV6ZSgpLnNoYXBlLHA9bi5tYXAoZnVuY3Rpb24oZSl7dmFyIHQ9dXRpbC5hcnJheXNFcXVhbChlLnNoYXBlLHMpO2lmKCF0JiYhdXRpbC5hcnJheXNFcXVhbChlLnNxdWVlemUoKS5zaGFwZSxvKSl0aHJvdyBuZXcgRXJyb3IoXCJ0aGUgaW5wdXQgdGVuc29ycyBzaGFwZSBkb2VzIG5vdCBtYXRjaFwiKTtyZXR1cm4gdD9lOmUucmVzaGFwZShzKX0pO3JldHVybltzdGFjayhwLHIpXX0pO2Nhc2VcIlVucGFja1wiOnJldHVybiB0aWR5KGZ1bmN0aW9uKCl7dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSksbj1nZXRQYXJhbVZhbHVlKFwidGVuc29yXCIsZSx0LGEpO3JldHVybiB1bnN0YWNrKG4scil9KTtjYXNlXCJUaWxlXCI6dmFyIHg9Z2V0UGFyYW1WYWx1ZShcInJlcHNcIixlLHQsYSk7cmV0dXJuW3RpbGUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkseCldO2Nhc2VcIlNwbGl0XCI6Y2FzZVwiU3BsaXRWXCI6bj1nZXRQYXJhbVZhbHVlKFwiYXhpc1wiLGUsdCxhKTt2YXIgVj1nZXRQYXJhbVZhbHVlKFwibnVtT3JTaXplU3BsaXRzXCIsZSx0LGEpO3JldHVybiBzcGxpdChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxWLG4pO2Nhc2VcIlNjYXR0ZXJOZFwiOnA9Z2V0UGFyYW1WYWx1ZShcImluZGljZXNcIixlLHQsYSk7dmFyIGI9Z2V0UGFyYW1WYWx1ZShcInZhbHVlc1wiLGUsdCxhKSxQPWdldFBhcmFtVmFsdWUoXCJzaGFwZVwiLGUsdCxhKTtyZXR1cm5bc2NhdHRlck5EKHAsYixQKV07Y2FzZVwiR2F0aGVyTmRcIjp2YXIgVD1nZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKTtwPWdldFBhcmFtVmFsdWUoXCJpbmRpY2VzXCIsZSx0LGEpO3JldHVybltnYXRoZXJORChULHApXTtjYXNlXCJTcGFyc2VUb0RlbnNlXCI6cD1nZXRQYXJhbVZhbHVlKFwic3BhcnNlSW5kaWNlc1wiLGUsdCxhKSxQPWdldFBhcmFtVmFsdWUoXCJvdXRwdXRTaGFwZVwiLGUsdCxhKTt2YXIgdj1nZXRQYXJhbVZhbHVlKFwic3BhcnNlVmFsdWVzXCIsZSx0LGEpLE89Z2V0UGFyYW1WYWx1ZShcImRlZmF1bHRWYWx1ZVwiLGUsdCxhKTtyZXR1cm5bc3BhcnNlVG9EZW5zZShwLHYsUCx2LmR0eXBlPT09Ty5kdHlwZT9POk8uYXNUeXBlKHYuZHR5cGUpKV07ZGVmYXVsdDp0aHJvdyBUeXBlRXJyb3IoXCJOb2RlIHR5cGUgXCIrZS5vcCtcIiBpcyBub3QgaW1wbGVtZW50ZWRcIil9fSxleGVjdXRlT3AkMTQ9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLm9wKXtjYXNlXCJGRlRcIjpyZXR1cm5bZmZ0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiSUZGVFwiOnJldHVybltpZmZ0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiUkZGVFwiOnJldHVybltyZmZ0KGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpKV07Y2FzZVwiSVJGRlRcIjpyZXR1cm5baXJmZnQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19LGV4ZWN1dGVPcCQxNT1mdW5jdGlvbihlLHQsYSl7c3dpdGNoKGUub3Ape2Nhc2VcIkNhc3RcIjpyZXR1cm5bY2FzdChnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxnZXRQYXJhbVZhbHVlKFwiZHR5cGVcIixlLHQsYSkpXTtjYXNlXCJFeHBhbmREaW1zXCI6dmFyIHI9Z2V0UGFyYW1WYWx1ZShcImF4aXNcIixlLHQsYSk7cmV0dXJuW2V4cGFuZERpbXMoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSkscildO2Nhc2VcIlNxdWVlemVcIjpyPWdldFBhcmFtVmFsdWUoXCJheGlzXCIsZSx0LGEpO3JldHVybltzcXVlZXplKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHIpXTtjYXNlXCJSZXNoYXBlXCI6cmV0dXJuW3Jlc2hhcGUoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksZ2V0UGFyYW1WYWx1ZShcInNoYXBlXCIsZSx0LGEpKV07Y2FzZVwiUGFkVjJcIjpjYXNlXCJQYWRcIjpyZXR1cm5bcGFkKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLHNwbGl0JDEoZ2V0UGFyYW1WYWx1ZShcInBhZGRpbmdcIixlLHQsYSksMiksZ2V0UGFyYW1WYWx1ZShcImNvbnN0YW50VmFsdWVcIixlLHQsYSkpXTtjYXNlXCJTcGFjZVRvQmF0Y2hORFwiOnZhciBuPWdldFBhcmFtVmFsdWUoXCJibG9ja1NoYXBlXCIsZSx0LGEpLHM9c3BsaXQkMShnZXRQYXJhbVZhbHVlKFwicGFkZGluZ3NcIixlLHQsYSksMik7cmV0dXJuW3NwYWNlVG9CYXRjaE5EKGdldFBhcmFtVmFsdWUoXCJ4XCIsZSx0LGEpLG4scyldO2Nhc2VcIkJhdGNoVG9TcGFjZU5EXCI6bj1nZXRQYXJhbVZhbHVlKFwiYmxvY2tTaGFwZVwiLGUsdCxhKTt2YXIgbz1zcGxpdCQxKGdldFBhcmFtVmFsdWUoXCJjcm9wc1wiLGUsdCxhKSwyKTtyZXR1cm5bYmF0Y2hUb1NwYWNlTkQoZ2V0UGFyYW1WYWx1ZShcInhcIixlLHQsYSksbixvKV07Y2FzZVwiRGVwdGhUb1NwYWNlXCI6dmFyIHA9Z2V0UGFyYW1WYWx1ZShcImJsb2NrU2l6ZVwiLGUsdCxhKSx1PWdldFBhcmFtVmFsdWUoXCJkYXRhRm9ybWF0XCIsZSx0LGEpLnRvVXBwZXJDYXNlKCk7cmV0dXJuW2RlcHRoVG9TcGFjZShnZXRQYXJhbVZhbHVlKFwieFwiLGUsdCxhKSxwLHUpXTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIk5vZGUgdHlwZSBcIitlLm9wK1wiIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX19O2Z1bmN0aW9uIGV4ZWN1dGVPcCQxNihlLHQsYSl7dmFyIHI9ZnVuY3Rpb24oZSx0LGEpe3N3aXRjaChlLmNhdGVnb3J5KXtjYXNlXCJhcml0aG1ldGljXCI6cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZXhlY3V0ZU9wKGUsdCxhKX0pO2Nhc2VcImJhc2ljX21hdGhcIjpyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBleGVjdXRlT3AkMShlLHQsYSl9KTtjYXNlXCJjb250cm9sXCI6cmV0dXJuIGV4ZWN1dGVPcCQyKGUsdCxhKTtjYXNlXCJjb252b2x1dGlvblwiOnJldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGV4ZWN1dGVPcCQzKGUsdCxhKX0pO2Nhc2VcImNyZWF0aW9uXCI6cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZXhlY3V0ZU9wJDQoZSx0LGEpfSk7Y2FzZVwiZHluYW1pY1wiOnJldHVybiBleGVjdXRlT3AkNShlLHQsYSk7Y2FzZVwiZXZhbHVhdGlvblwiOnJldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGV4ZWN1dGVPcCQ2KGUsdCxhKX0pO2Nhc2VcImltYWdlXCI6cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZXhlY3V0ZU9wJDgoZSx0LGEpfSk7Y2FzZVwiZ3JhcGhcIjpyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBleGVjdXRlT3AkNyhlLHQsYSl9KTtjYXNlXCJsb2dpY2FsXCI6cmV0dXJuIHRpZHkoZnVuY3Rpb24oKXtyZXR1cm4gZXhlY3V0ZU9wJDkoZSx0LGEpfSk7Y2FzZVwibWF0cmljZXNcIjpyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBleGVjdXRlT3AkMTAoZSx0LGEpfSk7Y2FzZVwibm9ybWFsaXphdGlvblwiOnJldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGV4ZWN1dGVPcCQxMShlLHQsYSl9KTtjYXNlXCJyZWR1Y3Rpb25cIjpyZXR1cm4gdGlkeShmdW5jdGlvbigpe3JldHVybiBleGVjdXRlT3AkMTIoZSx0LGEpfSk7Y2FzZVwic2xpY2Vfam9pblwiOnJldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGV4ZWN1dGVPcCQxMyhlLHQsYSl9KTtjYXNlXCJzcGVjdHJhbFwiOnJldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGV4ZWN1dGVPcCQxNChlLHQsYSl9KTtjYXNlXCJ0cmFuc2Zvcm1hdGlvblwiOnJldHVybiB0aWR5KGZ1bmN0aW9uKCl7cmV0dXJuIGV4ZWN1dGVPcCQxNShlLHQsYSl9KTtjYXNlXCJjdXN0b21cIjp2YXIgcj1nZXRSZWdpc3RlcmVkT3AoZS5vcCk7aWYociYmci5jdXN0b21FeGVjdXRvcilyZXR1cm4gci5jdXN0b21FeGVjdXRvcihuZXcgTm9kZVZhbHVlSW1wbChlLHQsYSkpO3Rocm93IFR5cGVFcnJvcihcIkN1c3RvbSBvcCBcIitlLm9wK1wiIGlzIG5vdCByZWdpc3RlcmVkLlwiKTtkZWZhdWx0OnRocm93IFR5cGVFcnJvcihcIlVua25vd24gb3AgJ1wiK2Uub3ArXCInLiBGaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvaXNzdWVzIHNvIHdlIGNhbiBhZGQgaXQsIG9yIHJlZ2lzdGVyIGEgY3VzdG9tIGV4ZWN1dGlvbiB3aXRoIHRmLnJlZ2lzdGVyT3AoKVwiKX19KGUsdCxhKTtyZXR1cm4gciBpbnN0YW5jZW9mIFByb21pc2U/ci50aGVuKGZ1bmN0aW9uKGUpe3JldHVybltdLmNvbmNhdChlKX0pOltdLmNvbmNhdChyKX12YXIgRXhlY3V0aW9uQ29udGV4dD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXt0aGlzLndlaWdodE1hcD1lLHRoaXMudGVuc29yQXJyYXlNYXA9dCx0aGlzLnJvb3RDb250ZXh0PXtpZDowLGZyYW1lTmFtZTpcIlwiLGl0ZXJhdGlvbklkOjB9LHRoaXMuY29udGV4dHM9W3RoaXMucm9vdENvbnRleHRdLHRoaXMubGFzdElkPTAsdGhpcy5nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzKCl9cmV0dXJuIGUucHJvdG90eXBlLm5ld0ZyYW1lPWZ1bmN0aW9uKGUsdCl7cmV0dXJue2lkOmUsZnJhbWVOYW1lOnQsaXRlcmF0aW9uSWQ6MH19LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImN1cnJlbnRDb250ZXh0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRleHRzfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5jb250ZXh0cyE9PWUmJih0aGlzLmNvbnRleHRzPWUsdGhpcy5nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzKCkpfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImN1cnJlbnRDb250ZXh0SWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzWzBdfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImN1cnJlbnRDb250ZXh0SWRzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jdXJyZW50Q29udGV4dElkc30sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5nZW5lcmF0ZUN1cnJlbnRDb250ZXh0SWRzPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPVtdLHQ9MDt0PHRoaXMuY29udGV4dHMubGVuZ3RoLTE7dCsrKXt2YXIgYT10aGlzLmNvbnRleHRzLnNsaWNlKDAsdGhpcy5jb250ZXh0cy5sZW5ndGgtdCk7ZS5wdXNoKHRoaXMuY29udGV4dElkZm9yQ29udGV4dHMoYSkpfWUucHVzaChcIlwiKSx0aGlzLl9jdXJyZW50Q29udGV4dElkcz1lfSxlLnByb3RvdHlwZS5jb250ZXh0SWRmb3JDb250ZXh0cz1mdW5jdGlvbihlKXtyZXR1cm4gZT9lLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gMD09PWUuaWQmJjA9PT1lLml0ZXJhdGlvbklkP1wiXCI6ZS5mcmFtZU5hbWUrXCItXCIrZS5pdGVyYXRpb25JZH0pLmpvaW4oXCIvXCIpOlwiXCJ9LGUucHJvdG90eXBlLmVudGVyRnJhbWU9ZnVuY3Rpb24oZSl7dGhpcy5jb250ZXh0cyYmKHRoaXMubGFzdElkKyssdGhpcy5jb250ZXh0cz10aGlzLmNvbnRleHRzLnNsaWNlKCksdGhpcy5jb250ZXh0cy5wdXNoKHRoaXMubmV3RnJhbWUodGhpcy5sYXN0SWQsZSkpLHRoaXMuX2N1cnJlbnRDb250ZXh0SWRzLnVuc2hpZnQodGhpcy5jb250ZXh0SWRmb3JDb250ZXh0cyh0aGlzLmNvbnRleHRzKSkpfSxlLnByb3RvdHlwZS5leGl0RnJhbWU9ZnVuY3Rpb24oKXtpZighKHRoaXMuY29udGV4dHMmJnRoaXMuY29udGV4dHMubGVuZ3RoPjEpKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBleGl0IGZyYW1lLCB0aGUgY29udGV4dCBpcyBlbXB0eVwiKTt0aGlzLmNvbnRleHRzPXRoaXMuY29udGV4dHMuc2xpY2UoKSx0aGlzLmNvbnRleHRzLnNwbGljZSgtMSksdGhpcy5jdXJyZW50Q29udGV4dElkcy5zaGlmdCgpfSxlLnByb3RvdHlwZS5uZXh0SXRlcmF0aW9uPWZ1bmN0aW9uKCl7aWYoISh0aGlzLmNvbnRleHRzJiZ0aGlzLmNvbnRleHRzLmxlbmd0aD4wKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5jcmVhc2UgZnJhbWUgaXRlcmF0aW9uLCB0aGUgY29udGV4dCBpcyBlbXB0eVwiKTt0aGlzLmNvbnRleHRzPXRoaXMuY29udGV4dHMuc2xpY2UoKSx0aGlzLmxhc3RJZCsrO3ZhciBlPU9iamVjdC5hc3NpZ24oe30sdGhpcy5jb250ZXh0c1t0aGlzLmNvbnRleHRzLmxlbmd0aC0xXSk7ZS5pdGVyYXRpb25JZCs9MSxlLmlkPXRoaXMubGFzdElkLHRoaXMuY29udGV4dHMuc3BsaWNlKC0xLDEsZSksdGhpcy5fY3VycmVudENvbnRleHRJZHMuc3BsaWNlKDAsMSx0aGlzLmNvbnRleHRJZGZvckNvbnRleHRzKHRoaXMuY29udGV4dHMpKX0sZS5wcm90b3R5cGUuZ2V0V2VpZ2h0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLndlaWdodE1hcFtlXX0sZS5wcm90b3R5cGUuYWRkVGVuc29yQXJyYXk9ZnVuY3Rpb24oZSl7dGhpcy50ZW5zb3JBcnJheU1hcFtlLmlkXT1lfSxlLnByb3RvdHlwZS5nZXRUZW5zb3JBcnJheT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50ZW5zb3JBcnJheU1hcFtlXX0sZX0oKTtmdW5jdGlvbiBnZXRFeGVjdXRpb25TdWJncmFwaChlLHQsYSl7Zm9yKHZhciByPW5ldyBTZXQsbj1bXSxzPW51bGwsbz1udWxsLHA9bmV3IFNldCx1PU9iamVjdC5rZXlzKGUpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VOb2RlTmFtZShlKVswXX0pLGk9dC5zbGljZSgpO2kubGVuZ3RoPjA7KXt2YXIgbT1pLnBvcCgpOyhpc0NvbnRyb2xGbG93KG0pfHxpc0R5bmFtaWNTaGFwZShtKSkmJm51bGw9PXMmJihvPShzPW0pLmNoaWxkcmVuLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSkuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiByLmhhcyhlKX0pKSxyLmFkZChtLm5hbWUpLG51bGw9PWFbbS5uYW1lXSYmKC0xPT09dS5pbmRleE9mKG0ubmFtZSkmJigwIT09bS5pbnB1dHMubGVuZ3RoP20uaW5wdXRzLmZvckVhY2goZnVuY3Rpb24oZSl7cC5oYXMoZS5uYW1lKXx8KHAuYWRkKGUubmFtZSksaS5wdXNoKGUpKX0pOm4ucHVzaChtLm5hbWUpKSl9cmV0dXJue2lucHV0czplLG91dHB1dHM6dCx1c2VkTm9kZXM6cixtaXNzaW5nSW5wdXRzOm4sZHluYW1pY05vZGU6cyxzeW5jSW5wdXRzOm99fWZ1bmN0aW9uIGdldE5vZGVzSW5Ub3BvbG9naWNhbE9yZGVyKGUsdCxhKXt2YXIgcj1hLnVzZWROb2RlcyxuPWEuaW5wdXRzLHM9W107T2JqZWN0LmtleXMobikubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZU5vZGVOYW1lKGUpWzBdfSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLm5vZGVzW3RdfSkuZm9yRWFjaChmdW5jdGlvbihlKXtyLmhhcyhlLm5hbWUpJiZzLnB1c2goZSl9KSxlLndlaWdodHMuZm9yRWFjaChmdW5jdGlvbihlKXtyLmhhcyhlLm5hbWUpJiZzLnB1c2goZSl9KTtmb3IodmFyIG89bmV3IFNldCxwPVtdO3MubGVuZ3RoPjA7KXt2YXIgdT1zLnBvcCgpO28uYWRkKHUubmFtZSksdFt1Lm5hbWVdfHxwLnB1c2godSksdS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGUpeyFvLmhhcyhlLm5hbWUpJiZyLmhhcyhlLm5hbWUpJiZlLmlucHV0cy5ldmVyeShmdW5jdGlvbihlKXtyZXR1cm4gby5oYXMoZS5uYW1lKX0pJiZzLnB1c2goZSl9KX1yZXR1cm4gcH12YXIgQ09OVFJPTF9GTE9XX09QUz1bXCJTd2l0Y2hcIixcIk1lcmdlXCIsXCJFbnRlclwiLFwiRXhpdFwiLFwiTmV4dEl0ZXJhdGlvblwiXSxEWU5BTUlDX1NIQVBFX09QUz1bXCJOb25NYXhTdXBwcmVzc2lvblYyXCIsXCJOb25NYXhTdXBwcmVzc2lvblYzXCIsXCJOb25NYXhTdXBwcmVzc2lvblY1XCIsXCJXaGVyZVwiXTtmdW5jdGlvbiBpc0NvbnRyb2xGbG93KGUpe3JldHVybiBDT05UUk9MX0ZMT1dfT1BTLmluZGV4T2YoZS5vcCk+PTB9ZnVuY3Rpb24gaXNEeW5hbWljU2hhcGUoZSl7cmV0dXJuIERZTkFNSUNfU0hBUEVfT1BTLmluZGV4T2YoZS5vcCk+PTB9dmFyIEdyYXBoRXhlY3V0b3I9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUpe3RoaXMuZ3JhcGg9ZSx0aGlzLmNvbXBpbGVkTWFwPW5ldyBNYXAsdGhpcy5fd2VpZ2h0TWFwPXt9LHRoaXMuU0VQRVJBVE9SPVwiLFwiLHRoaXMuX291dHB1dHM9ZS5vdXRwdXRzLHRoaXMuX2lucHV0cz1lLmlucHV0cyx0aGlzLl9zaWduYXR1cmU9ZS5zaWduYXR1cmV9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIndlaWdodE1hcFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd2VpZ2h0TWFwfSxzZXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9T2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZH0pfSk7dGhpcy53ZWlnaHRJZHM9W10uY29uY2F0LmFwcGx5KFtdLHQpLHRoaXMuX3dlaWdodE1hcD1lfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlucHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faW5wdXRzLm1hcChmdW5jdGlvbihlKXtyZXR1cm57bmFtZTplLm5hbWUsc2hhcGU6ZS5hdHRyUGFyYW1zLnNoYXBlP2UuYXR0clBhcmFtcy5zaGFwZS52YWx1ZTp2b2lkIDAsZHR5cGU6ZS5hdHRyUGFyYW1zLmR0eXBlP2UuYXR0clBhcmFtcy5kdHlwZS52YWx1ZTp2b2lkIDB9fSl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwib3V0cHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fb3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJue25hbWU6ZS5uYW1lLHNoYXBlOmUuYXR0clBhcmFtcy5zaGFwZT9lLmF0dHJQYXJhbXMuc2hhcGUudmFsdWU6dm9pZCAwLGR0eXBlOmUuYXR0clBhcmFtcy5kdHlwZT9lLmF0dHJQYXJhbXMuZHR5cGUudmFsdWU6dm9pZCAwfX0pfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlucHV0Tm9kZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lucHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2lnbmF0dXJlS2V5fHxlLm5hbWV9KX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJvdXRwdXROb2Rlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fb3V0cHV0cy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2lnbmF0dXJlS2V5fHxlLm5hbWV9KX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxlLnByb3RvdHlwZS5nZXRDb21waWxhdGlvbktleT1mdW5jdGlvbihlLHQpe3ZhciBhPWUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5hbWV9KS5zb3J0KCkscj10Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5uYW1lfSkuc29ydCgpO3JldHVybiBhLmpvaW4odGhpcy5TRVBFUkFUT1IpK1wiLS1cIityLmpvaW4odGhpcy5TRVBFUkFUT1IpfSxlLnByb3RvdHlwZS5jb21waWxlPWZ1bmN0aW9uKGUsdCl7dmFyIGE9Z2V0RXhlY3V0aW9uU3ViZ3JhcGgoZSx0LHRoaXMud2VpZ2h0TWFwKSxyPWEubWlzc2luZ0lucHV0cyxuPWEuZHluYW1pY05vZGUscz1hLnN5bmNJbnB1dHM7aWYobnVsbCE9bil0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGV4ZWN1dGlvbiBjb250YWlucyB0aGUgbm9kZSAnXCIrbi5uYW1lK1wiJywgd2hpY2ggaGFzIHRoZSBkeW5hbWljIG9wICdcIituLm9wK1wiJy4gUGxlYXNlIHVzZSBtb2RlbC5leGVjdXRlQXN5bmMoKSBpbnN0ZWFkLiBBbHRlcm5hdGl2ZWx5LCB0byBhdm9pZCB0aGUgZHluYW1pYyBvcHMsIHNwZWNpZnkgdGhlIGlucHV0cyBbXCIrcytcIl1cIik7aWYoci5sZW5ndGg+MCl7dmFyIG89dC5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pLHA9T2JqZWN0LmtleXMoZSk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdGhlIG91dHB1dHMgW1wiK28rXCJdIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0cyBbXCIrcCtcIl0uIE1pc3NpbmcgdGhlIGZvbGxvd2luZyBpbnB1dHM6IFtcIityK1wiXVwiKX1yZXR1cm4gZ2V0Tm9kZXNJblRvcG9sb2dpY2FsT3JkZXIodGhpcy5ncmFwaCx0aGlzLndlaWdodE1hcCxhKX0sZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihlLHQpe3ZhciBhPXRoaXM7ZT10aGlzLm1hcElucHV0cyhlKTt2YXIgcj1PYmplY3Qua2V5cyhlKS5zb3J0KCk7dGhpcy5jaGVja0lucHV0cyhlKSx0aGlzLmNoZWNrSW5wdXRTaGFwZUFuZFR5cGUoZSksdD10aGlzLm1hcE91dHB1dHModCksdGhpcy5jaGVja091dHB1dHModCk7dmFyIG49ci5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGEuZ3JhcGgubm9kZXNbcGFyc2VOb2RlTmFtZShlKVswXV19KSxzPXQubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBhLmdyYXBoLm5vZGVzW3BhcnNlTm9kZU5hbWUoZSlbMF1dfSksbz10aGlzLmdldENvbXBpbGF0aW9uS2V5KG4scykscD10aGlzLmNvbXBpbGVkTWFwLmdldChvKTtudWxsPT1wJiYocD10aGlzLmNvbXBpbGUoZSxzKSx0aGlzLmNvbXBpbGVkTWFwLnNldChvLHApKTt2YXIgdT17fTtyZXR1cm4gdGlkeShmdW5jdGlvbigpe3ZhciByPW5ldyBFeGVjdXRpb25Db250ZXh0KGEuX3dlaWdodE1hcCx1KSxuPV9fYXNzaWduKHt9LGEud2VpZ2h0TWFwKTtPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBhPXBhcnNlTm9kZU5hbWUodCkscj1hWzBdLHM9W107c1thWzFdXT1lW3RdLG5bcl09c30pO2Zvcih2YXIgcz1hLmdldEZyb3plblRlbnNvcklkcyhuKSxvPXt9LGk9MDtpPHAubGVuZ3RoO2krKyl7dmFyIG09cFtpXTtpZighblttLm5hbWVdKXt2YXIgbD1leGVjdXRlT3AkMTYobSxuLHIpO2lmKGwgaW5zdGFuY2VvZiBQcm9taXNlKXRocm93IG5ldyBFcnJvcihcIlRoZSBleGVjdXRpb24gb2YgdGhlIG9wICdcIittLm9wK1wiJyByZXR1cm5lZCBhIHByb21pc2UuIFBsZWFzZSB1c2UgbW9kZWwuZXhlY3V0ZUFzeW5jKCkgaW5zdGVhZC5cIik7blttLm5hbWVdPWwsYS5jaGVja1RlbnNvckZvckRpc3Bvc2FsKG0ubmFtZSxtLG4scixzLHQsbyl9fXJldHVybiB0Lm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZ2V0VGVuc29yKGUsbixyKX0pfSl9LGUucHJvdG90eXBlLmdldEZyb3plblRlbnNvcklkcz1mdW5jdGlvbihlKXt2YXIgdD1bXS5jb25jYXQuYXBwbHkoW10sT2JqZWN0LmtleXMoZSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS5pZH0pfSkpO3JldHVybiBuZXcgU2V0KHQpfSxlLnByb3RvdHlwZS5jaGVja1RlbnNvckZvckRpc3Bvc2FsPWZ1bmN0aW9uKGUsdCxhLHIsbixzLG8pe1wiY29udHJvbFwiIT09dC5jYXRlZ29yeSYmLTE9PT1zLmluZGV4T2YoZSkmJihhW2VdLmZvckVhY2goZnVuY3Rpb24oZSl7bnVsbCE9ZSYmKG9bZS5pZF09KG9bZS5pZF18fDApK3QuY2hpbGRyZW4ubGVuZ3RoKX0pLHQuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24oZSl7aWYoXCJjb250cm9sXCIhPT1lLmNhdGVnb3J5KXt2YXIgdD1nZXRUZW5zb3JzRm9yQ3VycmVudENvbnRlbnh0KGUubmFtZSxhLHIpO251bGwhPXQmJnQuZm9yRWFjaChmdW5jdGlvbihlKXtpZihlJiYhbi5oYXMoZS5pZCkpe3ZhciB0PW9bZS5pZF07MT09PXQ/KGUuZGlzcG9zZSgpLGRlbGV0ZSBvW2UuaWRdKTpudWxsIT10JiZvW2UuaWRdLS19fSl9fSkpfSxlLnByb3RvdHlwZS5leGVjdXRlQXN5bmM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBhLHIsbixzLG8scCx1PXRoaXM7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oaSl7c3dpdGNoKGkubGFiZWwpe2Nhc2UgMDpyZXR1cm4gZT10aGlzLm1hcElucHV0cyhlKSx0aGlzLmNoZWNrSW5wdXRzKGUpLHRoaXMuY2hlY2tJbnB1dFNoYXBlQW5kVHlwZShlKSx0PXRoaXMubWFwT3V0cHV0cyh0KSx0aGlzLmNoZWNrT3V0cHV0cyh0KSxhPXt9LHI9bmV3IEV4ZWN1dGlvbkNvbnRleHQodGhpcy5fd2VpZ2h0TWFwLGEpLFs0LHRoaXMuZXhlY3V0ZVdpdGhDb250cm9sRmxvdyhlLHIsdCldO2Nhc2UgMTpyZXR1cm4gbj1pLnNlbnQoKSxzPXQubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBnZXRUZW5zb3IoZSxuLHIpfSksbz1uZXcgU2V0KHMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmlkfSkpLHA9bmV3IFNldChPYmplY3Qua2V5cyhlKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGVbdF0uaWR9KSksT2JqZWN0LmtleXMobikuZm9yRWFjaChmdW5jdGlvbihlKXtuW2VdLmZvckVhY2goZnVuY3Rpb24oZSl7IWV8fGUuaXNEaXNwb3NlZHx8by5oYXMoZS5pZCl8fHAuaGFzKGUuaWQpfHwtMSE9PXUud2VpZ2h0SWRzLmluZGV4T2YoZS5pZCl8fGUuZGlzcG9zZSgpfSl9KSxbMixzXX19KX0pfSxlLnByb3RvdHlwZS5leGVjdXRlV2l0aENvbnRyb2xGbG93PWZ1bmN0aW9uKGUsdCxhKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciByLG4scyxvLHAsdSxpLG0sbCxjLGQseSxmLGcsaCxOLHg9dGhpcztyZXR1cm4gX19nZW5lcmF0b3IodGhpcyxmdW5jdGlvbihWKXtzd2l0Y2goVi5sYWJlbCl7Y2FzZSAwOnI9T2JqZWN0LmtleXMoZSksbj1yLm1hcChmdW5jdGlvbihlKXtyZXR1cm4geC5ncmFwaC5ub2Rlc1twYXJzZU5vZGVOYW1lKGUpWzBdXX0pLHM9YS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHguZ3JhcGgubm9kZXNbcGFyc2VOb2RlTmFtZShlKVswXV19KSxvPWdldEV4ZWN1dGlvblN1YmdyYXBoKGUscyx0aGlzLndlaWdodE1hcCkscD1vLnVzZWROb2Rlcyx1PW8ubWlzc2luZ0lucHV0cyxpPW8uZHluYW1pY05vZGUsbT1vLnN5bmNJbnB1dHMsbD1uLmNvbmNhdCh0aGlzLmdyYXBoLndlaWdodHMpLm1hcChmdW5jdGlvbihlKXtyZXR1cm57bm9kZTplLGNvbnRleHRzOnQuY3VycmVudENvbnRleHR9fSksYz1fX2Fzc2lnbih7fSx0aGlzLndlaWdodE1hcCksT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgYT1wYXJzZU5vZGVOYW1lKHQpLHI9YVswXSxuPVtdO25bYVsxXV09ZVt0XSxjW3JdPW59KSxkPXt9LHk9dGhpcy5nZXRGcm96ZW5UZW5zb3JJZHMoYyksZj17fSxWLmxhYmVsPTE7Y2FzZSAxOnJldHVybiBsLmxlbmd0aD4wPyhnPXRoaXMucHJvY2Vzc1N0YWNrKG4sbCx0LGMsZix5LGEsZCxwKSxbNCxQcm9taXNlLmFsbChnKV0pOlszLDNdO2Nhc2UgMjpyZXR1cm4gVi5zZW50KCksWzMsMV07Y2FzZSAzOmlmKG51bGw9PWkmJmNvbnNvbGUud2FybihcIlRoaXMgbW9kZWwgZXhlY3V0aW9uIGRpZCBub3QgY29udGFpbiBhbnkgbm9kZXMgd2l0aCBjb250cm9sIGZsb3cgb3IgZHluYW1pYyBvdXRwdXQgc2hhcGVzLiBZb3UgY2FuIHVzZSBtb2RlbC5leGVjdXRlKCkgaW5zdGVhZC5cIiksKGg9cy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIWlzQ29udHJvbEZsb3coZSkmJiFnZXRUZW5zb3IoZS5uYW1lLGMsdCl9KS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZX0pKS5sZW5ndGg+MCl0aHJvdyBOPVwiXCIsbnVsbCE9aSYmKE49XCJBbHRlcm5hdGl2ZWx5LCB0byBhdm9pZCB0aGUgZHluYW1pYyBvcHMsIHVzZSBtb2RlbC5leGVjdXRlKCkgYW5kIHNwZWNpZnkgdGhlIGlucHV0cyBbXCIrbStcIl1cIiksbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgdGhlIG91dHB1dHMgW1wiK2grXCJdIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0cyBbXCIrcitcIl0uIENvbnNpZGVyIHByb3ZpZGluZyB0aGUgZm9sbG93aW5nIGlucHV0czogW1wiK3UrXCJdLiBcIitOKTtyZXR1cm5bMixjXX19KX0pfSxlLnByb3RvdHlwZS5wcm9jZXNzU3RhY2s9ZnVuY3Rpb24oZSx0LGEscixuLHMsbyxwLHUpe2Zvcih2YXIgaT10aGlzLG09W10sbD1mdW5jdGlvbigpe3ZhciBsPXQucG9wKCk7YS5jdXJyZW50Q29udGV4dD1sLmNvbnRleHRzO3ZhciBkPVwiXCI7aWYoXCJFbnRlclwiPT09bC5ub2RlLm9wJiZnZXRQYXJhbVZhbHVlKFwiaXNDb25zdGFudFwiLGwubm9kZSxyLGEpJiYoZD1nZXROb2RlTmFtZUFuZEluZGV4KGwubm9kZS5uYW1lLGEpWzBdKSwtMT09PWUuaW5kZXhPZihsLm5vZGUpKXt2YXIgeT1leGVjdXRlT3AkMTYobC5ub2RlLHIsYSk7ZHx8KGQ9Z2V0Tm9kZU5hbWVBbmRJbmRleChsLm5vZGUubmFtZSxhKVswXSk7dmFyIGY9YS5jdXJyZW50Q29udGV4dDt5IGluc3RhbmNlb2YgUHJvbWlzZT9tLnB1c2goeS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiByW2RdPWUsYS5jdXJyZW50Q29udGV4dD1mLGkuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbChkLGwubm9kZSxyLGEscyxvLHApLGkucHJvY2Vzc0NoaWxkTm9kZXMobC5ub2RlLHQsYSxyLG4sdSksZX0pKToocltkXT15LGMuY2hlY2tUZW5zb3JGb3JEaXNwb3NhbChkLGwubm9kZSxyLGEscyxvLHApLGMucHJvY2Vzc0NoaWxkTm9kZXMobC5ub2RlLHQsYSxyLG4sdSkpfWVsc2UgYy5wcm9jZXNzQ2hpbGROb2RlcyhsLm5vZGUsdCxhLHIsbix1KX0sYz10aGlzO3QubGVuZ3RoPjA7KWwoKTtyZXR1cm4gbX0sZS5wcm90b3R5cGUucHJvY2Vzc0NoaWxkTm9kZXM9ZnVuY3Rpb24oZSx0LGEscixuLHMpe2UuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgbz1nZXROb2RlTmFtZUFuZEluZGV4KGUubmFtZSxhKVswXTshbltvXSYmcy5oYXMoZS5uYW1lKSYmKFwiTWVyZ2VcIj09PWUub3A/ZS5pbnB1dE5hbWVzLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuISFnZXRUZW5zb3IoZSxyLGEpfSkmJihuW29dPSEwLHQucHVzaCh7Y29udGV4dHM6YS5jdXJyZW50Q29udGV4dCxub2RlOmV9KSk6ZS5pbnB1dE5hbWVzLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVybiEhZ2V0VGVuc29yKGUscixhKX0pJiYobltvXT0hMCx0LnB1c2goe2NvbnRleHRzOmEuY3VycmVudENvbnRleHQsbm9kZTplfSkpKX0pfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztPYmplY3Qua2V5cyh0aGlzLndlaWdodE1hcCkuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS53ZWlnaHRNYXBbdF0uZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gZS5kaXNwb3NlKCl9KX0pfSxlLnByb3RvdHlwZS5jaGVja0lucHV0U2hhcGVBbmRUeXBlPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7T2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgcj1lW2FdLG49cGFyc2VOb2RlTmFtZShhKVswXSxzPXQuZ3JhcGgubm9kZXNbbl07aWYocy5hdHRyUGFyYW1zLnNoYXBlJiZzLmF0dHJQYXJhbXMuc2hhcGUudmFsdWUpe3ZhciBvPXMuYXR0clBhcmFtcy5zaGFwZS52YWx1ZSxwPW8ubGVuZ3RoPT09ci5zaGFwZS5sZW5ndGgmJnIuc2hhcGUuZXZlcnkoZnVuY3Rpb24oZSx0KXtyZXR1cm4tMT09PW9bdF18fG9bdF09PT1lfSk7dXRpbC5hc3NlcnQocCxmdW5jdGlvbigpe3JldHVyblwiVGhlIHNoYXBlIG9mIGRpY3RbJ1wiK3MubmFtZStcIiddIHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgbXVzdCBiZSBbXCIrbytcIl0sIGJ1dCB3YXMgW1wiK3Iuc2hhcGUrXCJdXCJ9KX1zLmF0dHJQYXJhbXMuZHR5cGUmJnMuYXR0clBhcmFtcy5kdHlwZS52YWx1ZSYmdXRpbC5hc3NlcnQoci5kdHlwZT09PXMuYXR0clBhcmFtcy5kdHlwZS52YWx1ZSxmdW5jdGlvbigpe3JldHVyblwiVGhlIGR0eXBlIG9mIGRpY3RbJ1wiK3MubmFtZStcIiddIHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgbXVzdCBiZSBcIitzLmF0dHJQYXJhbXMuZHR5cGUudmFsdWUrXCIsIGJ1dCB3YXMgXCIrci5kdHlwZX0pfSl9LGUucHJvdG90eXBlLm1hcElucHV0cz1mdW5jdGlvbihlKXt2YXIgdD17fTtmb3IodmFyIGEgaW4gZSl7aWYobnVsbCE9dGhpcy5fc2lnbmF0dXJlJiZudWxsIT10aGlzLl9zaWduYXR1cmUuaW5wdXRzJiZudWxsIT10aGlzLl9zaWduYXR1cmUuaW5wdXRzW2FdKXRbdGhpcy5fc2lnbmF0dXJlLmlucHV0c1thXS5uYW1lXT1lW2FdO2Vsc2UgdFthXT1lW2FdfXJldHVybiB0fSxlLnByb3RvdHlwZS5jaGVja0lucHV0cz1mdW5jdGlvbihlKXt2YXIgdD10aGlzLGE9T2JqZWN0LmtleXMoZSkuZmlsdGVyKGZ1bmN0aW9uKGUpe3ZhciBhPXBhcnNlTm9kZU5hbWUoZSlbMF07cmV0dXJuIG51bGw9PXQuZ3JhcGgubm9kZXNbYV19KTtpZihhLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIlRoZSBkaWN0IHByb3ZpZGVkIGluIG1vZGVsLmV4ZWN1dGUoZGljdCkgaGFzIGtleXM6IFtcIithK1wiXSB0aGF0IGFyZSBub3QgcGFydCBvZiBncmFwaFwiKX0sZS5wcm90b3R5cGUubWFwT3V0cHV0cz1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBlLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9dC5fc2lnbmF0dXJlJiZudWxsIT10Ll9zaWduYXR1cmUub3V0cHV0cyYmbnVsbCE9dC5fc2lnbmF0dXJlLm91dHB1dHNbZV0/dC5fc2lnbmF0dXJlLm91dHB1dHNbZV0ubmFtZTplfSx7fSl9LGUucHJvdG90eXBlLmNoZWNrT3V0cHV0cz1mdW5jdGlvbihlKXt2YXIgdD10aGlzO2UuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgYT1wYXJzZU5vZGVOYW1lKGUpWzBdO2lmKCF0LmdyYXBoLm5vZGVzW2FdKXRocm93IG5ldyBFcnJvcihcIlRoZSBvdXRwdXQgJ1wiK2UrXCInIGlzIG5vdCBmb3VuZCBpbiB0aGUgZ3JhcGhcIil9KX0sZX0oKSxURkhVQl9TRUFSQ0hfUEFSQU09XCI/dGZqcy1mb3JtYXQ9ZmlsZVwiLERFRkFVTFRfTU9ERUxfTkFNRT1cIm1vZGVsLmpzb25cIixHcmFwaE1vZGVsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe3ZvaWQgMD09PXQmJih0PXt9KSx0aGlzLm1vZGVsVXJsPWUsdGhpcy5sb2FkT3B0aW9ucz10LHRoaXMudmVyc2lvbj1cIm4vYVwiLG51bGw9PXQmJih0aGlzLmxvYWRPcHRpb25zPXt9KX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwibW9kZWxWZXJzaW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnNpb259LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiaW5wdXROb2Rlc1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci5pbnB1dE5vZGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIm91dHB1dE5vZGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV4ZWN1dG9yLm91dHB1dE5vZGVzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImlucHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci5pbnB1dHN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwib3V0cHV0c1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRvci5vdXRwdXRzfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcIndlaWdodHNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhlY3V0b3Iud2VpZ2h0TWFwfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGUucHJvdG90eXBlLmZpbmRJT0hhbmRsZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm1vZGVsVXJsO2lmKG51bGwhPWUubG9hZCl0aGlzLmhhbmRsZXI9ZTtlbHNlIGlmKG51bGwhPXRoaXMubG9hZE9wdGlvbnMucmVxdWVzdEluaXQpdGhpcy5oYW5kbGVyPWlvLmJyb3dzZXJIVFRQUmVxdWVzdChlLHRoaXMubG9hZE9wdGlvbnMpO2Vsc2V7dmFyIHQ9aW8uZ2V0TG9hZEhhbmRsZXJzKGUsdGhpcy5sb2FkT3B0aW9ucy5vblByb2dyZXNzKTtpZigwPT09dC5sZW5ndGgpdC5wdXNoKGlvLmJyb3dzZXJIVFRQUmVxdWVzdChlLHRoaXMubG9hZE9wdGlvbnMpKTtlbHNlIGlmKHQubGVuZ3RoPjEpdGhyb3cgbmV3IEVycm9yKFwiRm91bmQgbW9yZSB0aGFuIG9uZSAoXCIrdC5sZW5ndGgrXCIpIGxvYWQgaGFuZGxlcnMgZm9yIFVSTCAnXCIrW2VdK1wiJ1wiKTt0aGlzLmhhbmRsZXI9dFswXX19LGUucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBlLHQsYSxyO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6aWYodGhpcy5maW5kSU9IYW5kbGVyKCksbnVsbD09dGhpcy5oYW5kbGVyLmxvYWQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHByb2NlZWQgd2l0aCBtb2RlbCBsb2FkaW5nIGJlY2F1c2UgdGhlIElPSGFuZGxlciBwcm92aWRlZCBkb2VzIG5vdCBoYXZlIHRoZSBgbG9hZGAgbWV0aG9kIGltcGxlbWVudGVkLlwiKTtyZXR1cm4gZT10aGlzLFs0LHRoaXMuaGFuZGxlci5sb2FkKCldO2Nhc2UgMTpyZXR1cm4gZS5hcnRpZmFjdHM9bi5zZW50KCksdD10aGlzLmFydGlmYWN0cy5tb2RlbFRvcG9sb2d5LGE9e30sbnVsbCE9dGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YSYmKGE9dGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YS5zaWduYXR1cmUpLHRoaXMudmVyc2lvbj10LnZlcnNpb25zLnByb2R1Y2VyK1wiLlwiK3QudmVyc2lvbnMubWluQ29uc3VtZXIscj1pby5kZWNvZGVXZWlnaHRzKHRoaXMuYXJ0aWZhY3RzLndlaWdodERhdGEsdGhpcy5hcnRpZmFjdHMud2VpZ2h0U3BlY3MpLHRoaXMuZXhlY3V0b3I9bmV3IEdyYXBoRXhlY3V0b3IoT3BlcmF0aW9uTWFwcGVyLkluc3RhbmNlLnRyYW5zZm9ybUdyYXBoKHQsYSkpLHRoaXMuZXhlY3V0b3Iud2VpZ2h0TWFwPXRoaXMuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcChyKSxbMiwhMF19fSl9KX0sZS5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbihlLHQpe3JldHVybiBfX2F3YWl0ZXIodGhpcyx2b2lkIDAsdm9pZCAwLGZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsZnVuY3Rpb24oYSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKDA9PT0odD1pby5nZXRTYXZlSGFuZGxlcnMoZSkpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBhbnkgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICdcIitlK1wiJ1wiKTtpZih0Lmxlbmd0aD4xKXRocm93IG5ldyBFcnJvcihcIkZvdW5kIG1vcmUgdGhhbiBvbmUgKFwiK3QubGVuZ3RoK1wiKSBzYXZlIGhhbmRsZXJzIGZvciBVUkwgJ1wiK2UrXCInXCIpO2U9dFswXX1pZihudWxsPT1lLnNhdmUpdGhyb3cgbmV3IEVycm9yKFwiR3JhcGhNb2RlbC5zYXZlKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSB0aGUgSU9IYW5kbGVyIHByb3ZpZGVkIGRvZXMgbm90IGhhdmUgdGhlIGBzYXZlYCBhdHRyaWJ1dGUgZGVmaW5lZC5cIik7cmV0dXJuWzIsZS5zYXZlKHRoaXMuYXJ0aWZhY3RzKV19KX0pfSxlLnByb3RvdHlwZS5wcmVkaWN0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuZXhlY3V0ZShlLHRoaXMub3V0cHV0Tm9kZXMpfSxlLnByb3RvdHlwZS5ub3JtYWxpemVJbnB1dHM9ZnVuY3Rpb24oZSl7aWYoIShlIGluc3RhbmNlb2YgVGVuc29yfHxBcnJheS5pc0FycmF5KGUpKSlyZXR1cm4gZTtpZigoZT1BcnJheS5pc0FycmF5KGUpP2U6W2VdKS5sZW5ndGghPT10aGlzLmlucHV0Tm9kZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIklucHV0IHRlbnNvciBjb3VudCBtaXNtYXRjaCx0aGUgZ3JhcGggbW9kZWwgaGFzIFwiK3RoaXMuaW5wdXROb2Rlcy5sZW5ndGgrXCIgcGxhY2Vob2xkZXJzLCB3aGlsZSB0aGVyZSBhcmUgXCIrZS5sZW5ndGgrXCIgaW5wdXQgdGVuc29ycy5cIik7cmV0dXJuIHRoaXMuaW5wdXROb2Rlcy5yZWR1Y2UoZnVuY3Rpb24odCxhLHIpe3JldHVybiB0W2FdPWVbcl0sdH0se30pfSxlLnByb3RvdHlwZS5ub3JtYWxpemVPdXRwdXRzPWZ1bmN0aW9uKGUpe3JldHVybiBlPWV8fHRoaXMub3V0cHV0Tm9kZXMsQXJyYXkuaXNBcnJheShlKT9lOltlXX0sZS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbihlLHQpe2U9dGhpcy5ub3JtYWxpemVJbnB1dHMoZSksdD10aGlzLm5vcm1hbGl6ZU91dHB1dHModCk7dmFyIGE9dGhpcy5leGVjdXRvci5leGVjdXRlKGUsdCk7cmV0dXJuIGEubGVuZ3RoPjE/YTphWzBdfSxlLnByb3RvdHlwZS5leGVjdXRlQXN5bmM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBhO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGU9dGhpcy5ub3JtYWxpemVJbnB1dHMoZSksdD10aGlzLm5vcm1hbGl6ZU91dHB1dHModCksWzQsdGhpcy5leGVjdXRvci5leGVjdXRlQXN5bmMoZSx0KV07Y2FzZSAxOnJldHVyblsyLChhPXIuc2VudCgpKS5sZW5ndGg+MT9hOmFbMF1dfX0pfSl9LGUucHJvdG90eXBlLmNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXA9ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUpLnJlZHVjZShmdW5jdGlvbih0LGEpe3JldHVybiB0W2FdPVtlW2FdXSx0fSx7fSl9LGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmV4ZWN1dG9yLmRpc3Bvc2UoKX0sZX0oKTtmdW5jdGlvbiBsb2FkR3JhcGhNb2RlbChlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD17fSksX19hd2FpdGVyKHRoaXMsdm9pZCAwLHZvaWQgMCxmdW5jdGlvbigpe3ZhciBhO3JldHVybiBfX2dlbmVyYXRvcih0aGlzLGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlbFVybCBpbiBsb2FkR3JhcGhNb2RlbCgpIGNhbm5vdCBiZSBudWxsLiBQbGVhc2UgcHJvdmlkZSBhIHVybCBvciBhbiBJT0hhbmRsZXIgdGhhdCBsb2FkcyB0aGUgbW9kZWxcIik7cmV0dXJuIG51bGw9PXQmJih0PXt9KSx0LmZyb21URkh1YiYmbnVsbD09ZS5sb2FkJiYoZS5lbmRzV2l0aChcIi9cIil8fChlKz1cIi9cIiksZT1cIlwiK2UrREVGQVVMVF9NT0RFTF9OQU1FK1RGSFVCX1NFQVJDSF9QQVJBTSksWzQsKGE9bmV3IEdyYXBoTW9kZWwoZSx0KSkubG9hZCgpXTtjYXNlIDE6cmV0dXJuIHIuc2VudCgpLFsyLGFdfX0pfSl9dmFyIHZlcnNpb249XCIxLjcuNFwiO2V4cG9ydHtHcmFwaE1vZGVsLGxvYWRHcmFwaE1vZGVsLGRlcmVnaXN0ZXJPcCxyZWdpc3Rlck9wLHZlcnNpb24gYXMgdmVyc2lvbl9jb252ZXJ0ZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGYtY29udmVydGVyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJlbnYiLCJjb25jYXQiLCJzbGljZSIsInN0YWNrIiwidGVuc29yIiwidGlkeSIsInVuc3RhY2siLCJ1dGlsIiwiaW8iLCJUZW5zb3IiLCJhZGQiLCJhZGROIiwibW9kIiwibXVsIiwiZGl2IiwiZGl2Tm9OYW4iLCJmbG9vckRpdiIsInN1YiIsIm1pbmltdW0iLCJtYXhpbXVtIiwicG93Iiwic3F1YXJlZERpZmZlcmVuY2UiLCJhYnMiLCJhY29zIiwiYWNvc2giLCJhc2luIiwiYXNpbmgiLCJhdGFuIiwiYXRhbjIiLCJhdGFuaCIsImNlaWwiLCJjb21wbGV4IiwiY29zIiwiY29zaCIsImVsdSIsImVyZiIsImV4cCIsImV4cG0xIiwiZmxvb3IiLCJsb2ciLCJsb2cxcCIsImltYWciLCJuZWciLCJyZWNpcHJvY2FsIiwicmVhbCIsInJlbHUiLCJyb3VuZCIsInNlbHUiLCJzaWdtb2lkIiwic2luIiwic2lnbiIsInNpbmgiLCJzb2Z0cGx1cyIsInNxcnQiLCJzcXVhcmUiLCJ0YW5oIiwidGFuIiwiY2xpcEJ5VmFsdWUiLCJyc3FydCIsInByb2QiLCJsZWFreVJlbHUiLCJwcmVsdSIsInNjYWxhciIsImNvbnYxZCIsImNvbnYyZCIsImZ1c2VkIiwiY29udjJkVHJhbnNwb3NlIiwiZGVwdGh3aXNlQ29udjJkIiwiY29udjNkIiwiYXZnUG9vbCIsIm1heFBvb2wiLCJtYXhQb29sV2l0aEFyZ21heCIsImF2Z1Bvb2wzZCIsIm1heFBvb2wzZCIsImZpbGwiLCJsaW5zcGFjZSIsIm11bHRpbm9taWFsIiwib25lSG90Iiwib25lcyIsIm9uZXNMaWtlIiwicmFuZG9tVW5pZm9ybSIsInJhbmdlIiwidHJ1bmNhdGVkTm9ybWFsIiwiemVyb3MiLCJ6ZXJvc0xpa2UiLCJpbWFnZSIsIndoZXJlQXN5bmMiLCJzZXRkaWZmMWRBc3luYyIsInRvcGsiLCJ0ZW5zb3IxZCIsImVxdWFsIiwibm90RXF1YWwiLCJncmVhdGVyIiwiZ3JlYXRlckVxdWFsIiwibGVzcyIsImxlc3NFcXVhbCIsImxvZ2ljYWxBbmQiLCJsb2dpY2FsTm90IiwibG9naWNhbE9yIiwid2hlcmUiLCJtYXRNdWwiLCJ0cmFuc3Bvc2UiLCJiYXRjaE5vcm0iLCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbiIsInNvZnRtYXgiLCJsb2dTb2Z0bWF4Iiwic3BhcnNlVG9EZW5zZSIsIm1heCIsIm1lYW4iLCJtaW4iLCJzdW0iLCJhbGwiLCJhbnkiLCJhcmdNYXgiLCJhcmdNaW4iLCJnYXRoZXIiLCJyZXZlcnNlIiwic3RyaWRlZFNsaWNlIiwidGlsZSIsInNwbGl0Iiwic2NhdHRlck5EIiwiZ2F0aGVyTkQiLCJmZnQiLCJpZmZ0IiwicmZmdCIsImlyZmZ0IiwiY2FzdCIsImV4cGFuZERpbXMiLCJzcXVlZXplIiwicmVzaGFwZSIsInBhZCIsInNwYWNlVG9CYXRjaE5EIiwiYmF0Y2hUb1NwYWNlTkQiLCJkZXB0aFRvU3BhY2UiLCJEYXRhVHlwZSIsIlNhdmVyRGVmIiwiX19hc3NpZ24iLCJPYmplY3QiLCJhc3NpZ24iLCJlIiwidCIsImEiLCJyIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwibiIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX19hd2FpdGVyIiwiUHJvbWlzZSIsInMiLCJvIiwidSIsIm5leHQiLCJwIiwidGhyb3ciLCJkb25lIiwidmFsdWUiLCJ0aGVuIiwiX19nZW5lcmF0b3IiLCJsYWJlbCIsInNlbnQiLCJ0cnlzIiwib3BzIiwicmV0dXJuIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJUeXBlRXJyb3IiLCJwb3AiLCJwdXNoIiwiRFRfSU5WQUxJRCIsIkRUX0ZMT0FUIiwiRFRfRE9VQkxFIiwiRFRfSU5UMzIiLCJEVF9VSU5UOCIsIkRUX0lOVDE2IiwiRFRfSU5UOCIsIkRUX1NUUklORyIsIkRUX0NPTVBMRVg2NCIsIkRUX0lOVDY0IiwiRFRfQk9PTCIsIkRUX1FJTlQ4IiwiRFRfUVVJTlQ4IiwiRFRfUUlOVDMyIiwiRFRfQkZMT0FUMTYiLCJEVF9GTE9BVF9SRUYiLCJEVF9ET1VCTEVfUkVGIiwiRFRfSU5UMzJfUkVGIiwiRFRfVUlOVDhfUkVGIiwiRFRfSU5UMTZfUkVGIiwiRFRfSU5UOF9SRUYiLCJEVF9TVFJJTkdfUkVGIiwiRFRfQ09NUExFWDY0X1JFRiIsIkRUX0lOVDY0X1JFRiIsIkRUX0JPT0xfUkVGIiwiRFRfUUlOVDhfUkVGIiwiRFRfUVVJTlQ4X1JFRiIsIkRUX1FJTlQzMl9SRUYiLCJEVF9CRkxPQVQxNl9SRUYiLCJMRUdBQ1kiLCJWMSIsIlYyIiwiQ2hlY2twb2ludEZvcm1hdFZlcnNpb24iLCJDVVNUT01fT1BTIiwicmVnaXN0ZXJPcCIsInRmT3BOYW1lIiwiY2F0ZWdvcnkiLCJpbnB1dHMiLCJhdHRycyIsImN1c3RvbUV4ZWN1dG9yIiwiZ2V0UmVnaXN0ZXJlZE9wIiwiZGVyZWdpc3Rlck9wIiwiZ2V0UGFyYW1WYWx1ZSIsImlucHV0UGFyYW1zIiwiaW5wdXRJbmRleFN0YXJ0IiwiaW5wdXRJbmRleEVuZCIsInR5cGUiLCJnZXRUZW5zb3IiLCJpbnB1dE5hbWVzIiwibWFwIiwiQXJyYXkiLCJkYXRhU3luYyIsImF0dHJQYXJhbXMiLCJwYXJzZU5vZGVOYW1lIiwiY3VycmVudENvbnRleHRJZHMiLCJmaW5kIiwiZ2V0Tm9kZU5hbWVXaXRoQ29udGV4dElkIiwiZ2V0VGVuc29yc0ZvckN1cnJlbnRDb250ZW54dCIsImN1cnJlbnRDb250ZXh0SWQiLCJnZXROb2RlTmFtZUFuZEluZGV4IiwibGFzdEluZGV4T2YiLCJzdWJzdHJpbmciLCJOdW1iZXIiLCJzcGxpdCQxIiwianNvbiIsInN0YXJ0IiwibmFtZSIsInRmTmFtZSIsIm5vdFN1cHBvcnRlZCIsImVuZCIsImFyaXRobWV0aWMiLCJmcmVlemUiLCJqc29uJDEiLCJkZWZhdWx0VmFsdWUiLCJiYXNpY01hdGgiLCJqc29uJDIiLCJjb250cm9sIiwianNvbiQzIiwiY29udm9sdXRpb24iLCJqc29uJDQiLCJjcmVhdGlvbiIsImpzb24kNSIsImR5bmFtaWMiLCJqc29uJDYiLCJldmFsdWF0aW9uIiwianNvbiQ3IiwiZ3JhcGgiLCJqc29uJDgiLCJpbWFnZSQxIiwianNvbiQ5IiwibG9naWNhbCIsImpzb24kMTAiLCJtYXRyaWNlcyIsImpzb24kMTEiLCJub3JtYWxpemF0aW9uIiwianNvbiQxMiIsInJlZHVjdGlvbiIsImpzb24kMTMiLCJzbGljZUpvaW4iLCJqc29uJDE0Iiwic3BlY3RyYWwiLCJqc29uJDE1IiwidGZEZXByZWNhdGVkTmFtZSIsInRyYW5zZm9ybWF0aW9uIiwiT3BlcmF0aW9uTWFwcGVyIiwib3BNYXBwZXJzIiwicmVkdWNlIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJfaW5zdGFuY2UiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwidHJhbnNmb3JtR3JhcGgiLCJub2RlIiwibWFwTm9kZSIsIm9wIiwic3RhcnRzV2l0aCIsImkiLCJtYXBTaWduYXR1cmVFbnRyaWVzIiwib3V0cHV0cyIsIm0iLCJrZXlzIiwiZm9yRWFjaCIsImNoaWxkcmVuIiwic2lnbmF0dXJlS2V5Iiwibm9kZXMiLCJ3ZWlnaHRzIiwicGxhY2Vob2xkZXJzIiwic2lnbmF0dXJlIiwiYXR0ciIsImlucHV0Iiwic3Vic3RyIiwicmF3QXR0cnMiLCJnZXRTdHJpbmdQYXJhbSIsImdldFN0cmluZ0FycmF5UGFyYW0iLCJnZXROdW1iZXJQYXJhbSIsImdldE51bWVyaWNBcnJheVBhcmFtIiwiZ2V0Qm9vbFBhcmFtIiwiZ2V0Qm9vbEFycmF5UGFyYW0iLCJnZXRUZW5zb3JTaGFwZVBhcmFtIiwiZ2V0VGVuc29yU2hhcGVBcnJheVBhcmFtIiwiZ2V0RHR5cGVQYXJhbSIsImdldER0eXBlQXJyYXlQYXJhbSIsIkVycm9yIiwiZGVjb2RlQmFzZTY0IiwiZ2xvYmFsIiwiYXRvYiIsIkJ1ZmZlciIsInRvU3RyaW5nIiwicGFyc2VTdHJpbmdQYXJhbSIsImlzQXJyYXkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0b0xvd2VyQ2FzZSIsImIiLCJmIiwicGFyc2VJbnQiLCJwYXJzZUR0eXBlUGFyYW0iLCJsaXN0IiwicGFyc2VUZW5zb3JTaGFwZVBhcmFtIiwidW5rbm93blJhbmsiLCJkaW0iLCJzaXplIiwic2hhcGUiLCJOb2RlVmFsdWVJbXBsIiwidGVuc29yTWFwIiwiY29udGV4dCIsImdldElucHV0IiwiZ2V0QXR0ciIsImV4ZWN1dGVPcCIsImV4ZWN1dGVPcCQxIiwiVGVuc29yQXJyYXkiLCJkdHlwZSIsIm1heFNpemUiLCJlbGVtZW50U2hhcGUiLCJpZGVudGljYWxFbGVtZW50U2hhcGVzIiwiZHluYW1pY1NpemUiLCJjbGVhckFmdGVyUmVhZCIsInRlbnNvcnMiLCJjbG9zZWRfIiwiaWQiLCJuZXh0SWQiLCJjbGVhckFuZENsb3NlIiwiZGlzcG9zZSIsInJlYWQiLCJjbGVhcmVkIiwicmVhZE1hbnkiLCJ3cml0ZSIsImFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplIiwid3JpdHRlbiIsIndyaXRlTWFueSIsInNjYXR0ZXIiLCJNYXRoIiwiYXNzZXJ0Iiwic2hhcGVzRXF1YWxBbGxvd1VuZGVmaW5lZFNpemUiLCJfdGhpcyIsImV4ZWN1dGVPcCQyIiwibCIsImMiLCJkIiwieSIsImciLCJoIiwiTiIsIngiLCJWIiwiUCIsIlQiLCJ2IiwiTyIsIlMiLCJfIiwidyIsIkEiLCJEIiwiRSIsIkkiLCJNIiwiQyIsImsiLCJ6IiwiRiIsImoiLCJjbG9uZSIsImRhdGEiLCJlbnRlckZyYW1lIiwiZXhpdEZyYW1lIiwibmV4dEl0ZXJhdGlvbiIsImFkZFRlbnNvckFycmF5IiwiZ2V0VGVuc29yQXJyYXkiLCJleGVjdXRlT3AkMyIsInRvVXBwZXJDYXNlIiwiZmlsdGVyIiwic3RyaWRlcyIsImRhdGFGb3JtYXQiLCJkaWxhdGlvbnMiLCJiaWFzIiwiYWN0aXZhdGlvbiIsInByZWx1QWN0aXZhdGlvbldlaWdodHMiLCJyZXN1bHQiLCJpbmRleGVzIiwiZXhlY3V0ZU9wJDQiLCJfdGhpcyQxIiwiZXhlY3V0ZU9wJDUiLCJub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZUFzeW5jIiwic2VsZWN0ZWRJbmRpY2VzIiwic2VsZWN0ZWRTY29yZXMiLCJub25NYXhTdXBwcmVzc2lvbkFzeW5jIiwiYXNUeXBlIiwiZXhlY3V0ZU9wJDYiLCJ2YWx1ZXMiLCJpbmRpY2VzIiwiZXhlY3V0ZU9wJDciLCJyYW5rIiwiY29uc29sZSIsIndhcm4iLCJleGVjdXRlT3AkOCIsInJlc2l6ZUJpbGluZWFyIiwicmVzaXplTmVhcmVzdE5laWdoYm9yIiwiY3JvcEFuZFJlc2l6ZSIsImV4ZWN1dGVPcCQ5IiwiZXhlY3V0ZU9wJDEwIiwidHJhbnNwb3NlQSIsInRyYW5zcG9zZUIiLCJleGVjdXRlT3AkMTEiLCJleGVjdXRlT3AkMTIiLCJleGVjdXRlT3AkMTMiLCJhcnJheXNFcXVhbCIsImV4ZWN1dGVPcCQxNCIsImV4ZWN1dGVPcCQxNSIsImV4ZWN1dGVPcCQxNiIsIkV4ZWN1dGlvbkNvbnRleHQiLCJ3ZWlnaHRNYXAiLCJ0ZW5zb3JBcnJheU1hcCIsInJvb3RDb250ZXh0IiwiZnJhbWVOYW1lIiwiaXRlcmF0aW9uSWQiLCJjb250ZXh0cyIsImxhc3RJZCIsImdlbmVyYXRlQ3VycmVudENvbnRleHRJZHMiLCJuZXdGcmFtZSIsInNldCIsIl9jdXJyZW50Q29udGV4dElkcyIsImNvbnRleHRJZGZvckNvbnRleHRzIiwiam9pbiIsInVuc2hpZnQiLCJzcGxpY2UiLCJzaGlmdCIsImdldFdlaWdodCIsImdldEV4ZWN1dGlvblN1YmdyYXBoIiwiU2V0IiwiaXNDb250cm9sRmxvdyIsImlzRHluYW1pY1NoYXBlIiwiaGFzIiwiaW5kZXhPZiIsInVzZWROb2RlcyIsIm1pc3NpbmdJbnB1dHMiLCJkeW5hbWljTm9kZSIsInN5bmNJbnB1dHMiLCJnZXROb2Rlc0luVG9wb2xvZ2ljYWxPcmRlciIsImV2ZXJ5IiwiQ09OVFJPTF9GTE9XX09QUyIsIkRZTkFNSUNfU0hBUEVfT1BTIiwiR3JhcGhFeGVjdXRvciIsImNvbXBpbGVkTWFwIiwiTWFwIiwiX3dlaWdodE1hcCIsIlNFUEVSQVRPUiIsIl9vdXRwdXRzIiwiX2lucHV0cyIsIl9zaWduYXR1cmUiLCJ3ZWlnaHRJZHMiLCJnZXRDb21waWxhdGlvbktleSIsInNvcnQiLCJjb21waWxlIiwiZXhlY3V0ZSIsIm1hcElucHV0cyIsImNoZWNrSW5wdXRzIiwiY2hlY2tJbnB1dFNoYXBlQW5kVHlwZSIsIm1hcE91dHB1dHMiLCJjaGVja091dHB1dHMiLCJnZXRGcm96ZW5UZW5zb3JJZHMiLCJjaGVja1RlbnNvckZvckRpc3Bvc2FsIiwiZXhlY3V0ZUFzeW5jIiwiZXhlY3V0ZVdpdGhDb250cm9sRmxvdyIsImlzRGlzcG9zZWQiLCJjdXJyZW50Q29udGV4dCIsInByb2Nlc3NTdGFjayIsInByb2Nlc3NDaGlsZE5vZGVzIiwic29tZSIsIlRGSFVCX1NFQVJDSF9QQVJBTSIsIkRFRkFVTFRfTU9ERUxfTkFNRSIsIkdyYXBoTW9kZWwiLCJtb2RlbFVybCIsImxvYWRPcHRpb25zIiwidmVyc2lvbiIsImV4ZWN1dG9yIiwiaW5wdXROb2RlcyIsIm91dHB1dE5vZGVzIiwiZmluZElPSGFuZGxlciIsImxvYWQiLCJoYW5kbGVyIiwicmVxdWVzdEluaXQiLCJicm93c2VySFRUUFJlcXVlc3QiLCJnZXRMb2FkSGFuZGxlcnMiLCJvblByb2dyZXNzIiwiYXJ0aWZhY3RzIiwibW9kZWxUb3BvbG9neSIsInVzZXJEZWZpbmVkTWV0YWRhdGEiLCJ2ZXJzaW9ucyIsInByb2R1Y2VyIiwibWluQ29uc3VtZXIiLCJkZWNvZGVXZWlnaHRzIiwid2VpZ2h0RGF0YSIsIndlaWdodFNwZWNzIiwiSW5zdGFuY2UiLCJjb252ZXJ0VGVuc29yTWFwVG9UZW5zb3JzTWFwIiwic2F2ZSIsImdldFNhdmVIYW5kbGVycyIsInByZWRpY3QiLCJub3JtYWxpemVJbnB1dHMiLCJub3JtYWxpemVPdXRwdXRzIiwibG9hZEdyYXBoTW9kZWwiLCJmcm9tVEZIdWIiLCJlbmRzV2l0aCIsInZlcnNpb25fY29udmVydGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow/tfjs-converter/dist/tf-converter.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AdadeltaOptimizer: () => (/* binding */ Yd),\n/* harmony export */   AdagradOptimizer: () => (/* binding */ $d),\n/* harmony export */   AdamOptimizer: () => (/* binding */ Qd),\n/* harmony export */   AdamaxOptimizer: () => (/* binding */ Jd),\n/* harmony export */   Add: () => (/* binding */ xr),\n/* harmony export */   AddN: () => (/* binding */ br),\n/* harmony export */   BroadcastTo: () => (/* binding */ Sr),\n/* harmony export */   DataStorage: () => (/* binding */ ca),\n/* harmony export */   Div: () => (/* binding */ wr),\n/* harmony export */   ENV: () => (/* binding */ s),\n/* harmony export */   Environment: () => (/* binding */ o),\n/* harmony export */   FromPixels: () => (/* binding */ Fr),\n/* harmony export */   FusedBatchNorm: () => (/* binding */ Cr),\n/* harmony export */   Identity: () => (/* binding */ Tr),\n/* harmony export */   KernelBackend: () => (/* binding */ la),\n/* harmony export */   MaxPoolWithArgmax: () => (/* binding */ _r),\n/* harmony export */   MomentumOptimizer: () => (/* binding */ tp),\n/* harmony export */   NonMaxSuppressionV5: () => (/* binding */ kr),\n/* harmony export */   OneHot: () => (/* binding */ Ar),\n/* harmony export */   Optimizer: () => (/* binding */ Xd),\n/* harmony export */   PadV2: () => (/* binding */ Nr),\n/* harmony export */   RMSPropOptimizer: () => (/* binding */ ep),\n/* harmony export */   Rank: () => (/* binding */ Ct),\n/* harmony export */   Reduction: () => (/* binding */ Nh),\n/* harmony export */   SGDOptimizer: () => (/* binding */ Zd),\n/* harmony export */   Square: () => (/* binding */ Rr),\n/* harmony export */   SquaredDifference: () => (/* binding */ Er),\n/* harmony export */   Tensor: () => (/* binding */ wt),\n/* harmony export */   TensorBuffer: () => (/* binding */ mt),\n/* harmony export */   Tile: () => (/* binding */ Dr),\n/* harmony export */   Transpose: () => (/* binding */ Ir),\n/* harmony export */   Variable: () => (/* binding */ St),\n/* harmony export */   abs: () => (/* binding */ Lr),\n/* harmony export */   acos: () => (/* binding */ Wr),\n/* harmony export */   acosh: () => (/* binding */ Ur),\n/* harmony export */   add: () => (/* binding */ Or),\n/* harmony export */   addN: () => (/* binding */ $u),\n/* harmony export */   addStrict: () => (/* binding */ xo),\n/* harmony export */   all: () => (/* binding */ ql),\n/* harmony export */   any: () => (/* binding */ Kl),\n/* harmony export */   argMax: () => (/* binding */ jl),\n/* harmony export */   argMin: () => (/* binding */ Xl),\n/* harmony export */   asin: () => (/* binding */ Vr),\n/* harmony export */   asinh: () => (/* binding */ zr),\n/* harmony export */   atan: () => (/* binding */ Gr),\n/* harmony export */   atan2: () => (/* binding */ bo),\n/* harmony export */   atanh: () => (/* binding */ Hr),\n/* harmony export */   avgPool: () => (/* binding */ Ol),\n/* harmony export */   avgPool3d: () => (/* binding */ Pl),\n/* harmony export */   backend: () => (/* binding */ hn),\n/* harmony export */   backend_util: () => (/* binding */ Sa),\n/* harmony export */   basicLSTMCell: () => (/* binding */ lh),\n/* harmony export */   batchNorm: () => (/* binding */ nc),\n/* harmony export */   batchNorm2d: () => (/* binding */ ac),\n/* harmony export */   batchNorm3d: () => (/* binding */ uc),\n/* harmony export */   batchNorm4d: () => (/* binding */ hc),\n/* harmony export */   batchNormalization: () => (/* binding */ ec),\n/* harmony export */   batchNormalization2d: () => (/* binding */ oc),\n/* harmony export */   batchNormalization3d: () => (/* binding */ sc),\n/* harmony export */   batchNormalization4d: () => (/* binding */ lc),\n/* harmony export */   batchToSpaceND: () => (/* binding */ rr),\n/* harmony export */   booleanMaskAsync: () => (/* binding */ ul),\n/* harmony export */   broadcastTo: () => (/* binding */ fc),\n/* harmony export */   browser: () => (/* binding */ Vd),\n/* harmony export */   buffer: () => (/* binding */ er),\n/* harmony export */   cast: () => (/* binding */ or),\n/* harmony export */   ceil: () => (/* binding */ qr),\n/* harmony export */   clipByValue: () => (/* binding */ Kr),\n/* harmony export */   clone: () => (/* binding */ dc),\n/* harmony export */   complex: () => (/* binding */ Tn),\n/* harmony export */   concat: () => (/* binding */ Yn),\n/* harmony export */   concat1d: () => (/* binding */ $n),\n/* harmony export */   concat2d: () => (/* binding */ Qn),\n/* harmony export */   concat3d: () => (/* binding */ Jn),\n/* harmony export */   concat4d: () => (/* binding */ Zn),\n/* harmony export */   conv1d: () => (/* binding */ fl),\n/* harmony export */   conv2d: () => (/* binding */ dl),\n/* harmony export */   conv2dTranspose: () => (/* binding */ wl),\n/* harmony export */   conv3d: () => (/* binding */ pl),\n/* harmony export */   conv3dTranspose: () => (/* binding */ Cl),\n/* harmony export */   cos: () => (/* binding */ jr),\n/* harmony export */   cosh: () => (/* binding */ Xr),\n/* harmony export */   cumsum: () => (/* binding */ ar),\n/* harmony export */   customGrad: () => (/* binding */ oa),\n/* harmony export */   deprecationWarn: () => (/* binding */ Xe),\n/* harmony export */   depthToSpace: () => (/* binding */ ir),\n/* harmony export */   depthwiseConv2d: () => (/* binding */ ml),\n/* harmony export */   diag: () => (/* binding */ Eh),\n/* harmony export */   disableDeprecationWarnings: () => (/* binding */ je),\n/* harmony export */   dispose: () => (/* binding */ tn),\n/* harmony export */   disposeVariables: () => (/* binding */ Ye),\n/* harmony export */   div: () => (/* binding */ Bo),\n/* harmony export */   divNoNan: () => (/* binding */ bc),\n/* harmony export */   divStrict: () => (/* binding */ wo),\n/* harmony export */   dot: () => (/* binding */ Rl),\n/* harmony export */   dropout: () => (/* binding */ Rh),\n/* harmony export */   elu: () => (/* binding */ nh),\n/* harmony export */   enableDebugMode: () => (/* binding */ Ke),\n/* harmony export */   enableProdMode: () => (/* binding */ qe),\n/* harmony export */   engine: () => (/* binding */ $e),\n/* harmony export */   env: () => (/* binding */ i),\n/* harmony export */   equal: () => (/* binding */ Kc),\n/* harmony export */   equalStrict: () => (/* binding */ jc),\n/* harmony export */   erf: () => (/* binding */ Yr),\n/* harmony export */   exp: () => (/* binding */ $r),\n/* harmony export */   expandDims: () => (/* binding */ sr),\n/* harmony export */   expm1: () => (/* binding */ Qr),\n/* harmony export */   eye: () => (/* binding */ Cc),\n/* harmony export */   fft: () => (/* binding */ gh),\n/* harmony export */   fill: () => (/* binding */ Hn),\n/* harmony export */   findBackend: () => (/* binding */ un),\n/* harmony export */   findBackendFactory: () => (/* binding */ cn),\n/* harmony export */   floor: () => (/* binding */ Jr),\n/* harmony export */   floorDiv: () => (/* binding */ Co),\n/* harmony export */   frame: () => (/* binding */ Ah),\n/* harmony export */   fused: () => (/* binding */ hf),\n/* harmony export */   gather: () => (/* binding */ il),\n/* harmony export */   gatherND: () => (/* binding */ Ch),\n/* harmony export */   gather_util: () => (/* binding */ Lo),\n/* harmony export */   getBackend: () => (/* binding */ an),\n/* harmony export */   getGradient: () => (/* binding */ h),\n/* harmony export */   getKernel: () => (/* binding */ l),\n/* harmony export */   getKernelsForBackend: () => (/* binding */ f),\n/* harmony export */   grad: () => (/* binding */ Zo),\n/* harmony export */   grads: () => (/* binding */ ta),\n/* harmony export */   greater: () => (/* binding */ Xc),\n/* harmony export */   greaterEqual: () => (/* binding */ Yc),\n/* harmony export */   greaterEqualStrict: () => (/* binding */ $c),\n/* harmony export */   greaterStrict: () => (/* binding */ Qc),\n/* harmony export */   hammingWindow: () => (/* binding */ Sh),\n/* harmony export */   hannWindow: () => (/* binding */ kh),\n/* harmony export */   ifft: () => (/* binding */ mh),\n/* harmony export */   imag: () => (/* binding */ Nn),\n/* harmony export */   image: () => (/* binding */ nf),\n/* harmony export */   inTopKAsync: () => (/* binding */ Fh),\n/* harmony export */   io: () => (/* binding */ Bd),\n/* harmony export */   irfft: () => (/* binding */ xh),\n/* harmony export */   isFinite: () => (/* binding */ lo),\n/* harmony export */   isInf: () => (/* binding */ co),\n/* harmony export */   isNaN: () => (/* binding */ uo),\n/* harmony export */   keep: () => (/* binding */ en),\n/* harmony export */   leakyRelu: () => (/* binding */ rh),\n/* harmony export */   less: () => (/* binding */ Jc),\n/* harmony export */   lessEqual: () => (/* binding */ Zc),\n/* harmony export */   lessEqualStrict: () => (/* binding */ tl),\n/* harmony export */   lessStrict: () => (/* binding */ el),\n/* harmony export */   linalg: () => (/* binding */ jh),\n/* harmony export */   linspace: () => (/* binding */ qn),\n/* harmony export */   localResponseNormalization: () => (/* binding */ uh),\n/* harmony export */   log: () => (/* binding */ Zr),\n/* harmony export */   log1p: () => (/* binding */ to),\n/* harmony export */   logSigmoid: () => (/* binding */ eo),\n/* harmony export */   logSoftmax: () => (/* binding */ sa),\n/* harmony export */   logSumExp: () => (/* binding */ Yl),\n/* harmony export */   logicalAnd: () => (/* binding */ pc),\n/* harmony export */   logicalNot: () => (/* binding */ vc),\n/* harmony export */   logicalOr: () => (/* binding */ gc),\n/* harmony export */   logicalXor: () => (/* binding */ mc),\n/* harmony export */   losses: () => (/* binding */ zh),\n/* harmony export */   matMul: () => (/* binding */ El),\n/* harmony export */   math: () => (/* binding */ Wd),\n/* harmony export */   max: () => (/* binding */ $l),\n/* harmony export */   maxPool: () => (/* binding */ _l),\n/* harmony export */   maxPool3d: () => (/* binding */ Bl),\n/* harmony export */   maxPoolWithArgmax: () => (/* binding */ Ll),\n/* harmony export */   maximum: () => (/* binding */ Eo),\n/* harmony export */   maximumStrict: () => (/* binding */ Ro),\n/* harmony export */   mean: () => (/* binding */ Ql),\n/* harmony export */   memory: () => (/* binding */ Qe),\n/* harmony export */   min: () => (/* binding */ Jl),\n/* harmony export */   minimum: () => (/* binding */ Io),\n/* harmony export */   minimumStrict: () => (/* binding */ ko),\n/* harmony export */   mod: () => (/* binding */ So),\n/* harmony export */   modStrict: () => (/* binding */ Ao),\n/* harmony export */   moments: () => (/* binding */ Zl),\n/* harmony export */   movingAverage: () => (/* binding */ fh),\n/* harmony export */   mul: () => (/* binding */ To),\n/* harmony export */   mulStrict: () => (/* binding */ Do),\n/* harmony export */   multiRNNCell: () => (/* binding */ hh),\n/* harmony export */   multinomial: () => (/* binding */ Ec),\n/* harmony export */   neg: () => (/* binding */ no),\n/* harmony export */   nextFrame: () => (/* binding */ ap),\n/* harmony export */   norm: () => (/* binding */ ch),\n/* harmony export */   notEqual: () => (/* binding */ nl),\n/* harmony export */   notEqualStrict: () => (/* binding */ rl),\n/* harmony export */   oneHot: () => (/* binding */ Rc),\n/* harmony export */   ones: () => (/* binding */ zn),\n/* harmony export */   onesLike: () => (/* binding */ jn),\n/* harmony export */   op: () => (/* binding */ An),\n/* harmony export */   outerProduct: () => (/* binding */ Il),\n/* harmony export */   pad: () => (/* binding */ Ic),\n/* harmony export */   pad1d: () => (/* binding */ kc),\n/* harmony export */   pad2d: () => (/* binding */ Sc),\n/* harmony export */   pad3d: () => (/* binding */ Ac),\n/* harmony export */   pad4d: () => (/* binding */ Tc),\n/* harmony export */   pool: () => (/* binding */ Ml),\n/* harmony export */   pow: () => (/* binding */ No),\n/* harmony export */   powStrict: () => (/* binding */ Fo),\n/* harmony export */   prelu: () => (/* binding */ oh),\n/* harmony export */   print: () => (/* binding */ nr),\n/* harmony export */   prod: () => (/* binding */ eh),\n/* harmony export */   profile: () => (/* binding */ Je),\n/* harmony export */   rand: () => (/* binding */ Dc),\n/* harmony export */   randomGamma: () => (/* binding */ Uc),\n/* harmony export */   randomNormal: () => (/* binding */ Vc),\n/* harmony export */   randomUniform: () => (/* binding */ zc),\n/* harmony export */   range: () => (/* binding */ Kn),\n/* harmony export */   ready: () => (/* binding */ on),\n/* harmony export */   real: () => (/* binding */ Dn),\n/* harmony export */   reciprocal: () => (/* binding */ ro),\n/* harmony export */   registerBackend: () => (/* binding */ ln),\n/* harmony export */   registerGradient: () => (/* binding */ p),\n/* harmony export */   registerKernel: () => (/* binding */ d),\n/* harmony export */   relu: () => (/* binding */ ah),\n/* harmony export */   relu6: () => (/* binding */ ih),\n/* harmony export */   removeBackend: () => (/* binding */ sn),\n/* harmony export */   reshape: () => (/* binding */ ur),\n/* harmony export */   reverse: () => (/* binding */ kl),\n/* harmony export */   reverse1d: () => (/* binding */ Sl),\n/* harmony export */   reverse2d: () => (/* binding */ Al),\n/* harmony export */   reverse3d: () => (/* binding */ Tl),\n/* harmony export */   reverse4d: () => (/* binding */ Dl),\n/* harmony export */   rfft: () => (/* binding */ yh),\n/* harmony export */   round: () => (/* binding */ oo),\n/* harmony export */   rsqrt: () => (/* binding */ ao),\n/* harmony export */   scalar: () => (/* binding */ On),\n/* harmony export */   scatterND: () => (/* binding */ vh),\n/* harmony export */   scatter_util: () => (/* binding */ Ho),\n/* harmony export */   selu: () => (/* binding */ sh),\n/* harmony export */   separableConv2d: () => (/* binding */ bl),\n/* harmony export */   serialization: () => (/* binding */ qd),\n/* harmony export */   setBackend: () => (/* binding */ rn),\n/* harmony export */   setPlatform: () => (/* binding */ fn),\n/* harmony export */   setdiff1dAsync: () => (/* binding */ dr),\n/* harmony export */   sigmoid: () => (/* binding */ io),\n/* harmony export */   sign: () => (/* binding */ so),\n/* harmony export */   signal: () => (/* binding */ Dh),\n/* harmony export */   sin: () => (/* binding */ ho),\n/* harmony export */   sinh: () => (/* binding */ fo),\n/* harmony export */   slice: () => (/* binding */ Wl),\n/* harmony export */   slice1d: () => (/* binding */ Ul),\n/* harmony export */   slice2d: () => (/* binding */ Vl),\n/* harmony export */   slice3d: () => (/* binding */ zl),\n/* harmony export */   slice4d: () => (/* binding */ Gl),\n/* harmony export */   slice_util: () => (/* binding */ Jo),\n/* harmony export */   softmax: () => (/* binding */ ia),\n/* harmony export */   softplus: () => (/* binding */ po),\n/* harmony export */   spaceToBatchND: () => (/* binding */ cr),\n/* harmony export */   sparseToDense: () => (/* binding */ wh),\n/* harmony export */   spectral: () => (/* binding */ bh),\n/* harmony export */   split: () => (/* binding */ tr),\n/* harmony export */   sqrt: () => (/* binding */ vo),\n/* harmony export */   square: () => (/* binding */ Gc),\n/* harmony export */   squaredDifference: () => (/* binding */ Hc),\n/* harmony export */   squaredDifferenceStrict: () => (/* binding */ _o),\n/* harmony export */   squeeze: () => (/* binding */ lr),\n/* harmony export */   stack: () => (/* binding */ hr),\n/* harmony export */   step: () => (/* binding */ go),\n/* harmony export */   stft: () => (/* binding */ Th),\n/* harmony export */   stridedSlice: () => (/* binding */ dh),\n/* harmony export */   sub: () => (/* binding */ Oo),\n/* harmony export */   subStrict: () => (/* binding */ Mo),\n/* harmony export */   sum: () => (/* binding */ th),\n/* harmony export */   sumOutType: () => (/* binding */ Dt),\n/* harmony export */   tan: () => (/* binding */ mo),\n/* harmony export */   tanh: () => (/* binding */ yo),\n/* harmony export */   tensor: () => (/* binding */ Fn),\n/* harmony export */   tensor1d: () => (/* binding */ Mn),\n/* harmony export */   tensor2d: () => (/* binding */ Bn),\n/* harmony export */   tensor3d: () => (/* binding */ Pn),\n/* harmony export */   tensor4d: () => (/* binding */ Ln),\n/* harmony export */   tensor5d: () => (/* binding */ Wn),\n/* harmony export */   tensor6d: () => (/* binding */ Un),\n/* harmony export */   tensor_util: () => (/* binding */ Mt),\n/* harmony export */   test_util: () => (/* binding */ Bc),\n/* harmony export */   tidy: () => (/* binding */ Ze),\n/* harmony export */   tile: () => (/* binding */ wc),\n/* harmony export */   time: () => (/* binding */ nn),\n/* harmony export */   topk: () => (/* binding */ ph),\n/* harmony export */   train: () => (/* binding */ rp),\n/* harmony export */   transpose: () => (/* binding */ ua),\n/* harmony export */   truncatedNormal: () => (/* binding */ qc),\n/* harmony export */   unregisterGradient: () => (/* binding */ g),\n/* harmony export */   unregisterKernel: () => (/* binding */ v),\n/* harmony export */   unsortedSegmentSum: () => (/* binding */ sl),\n/* harmony export */   unstack: () => (/* binding */ fr),\n/* harmony export */   util: () => (/* binding */ st),\n/* harmony export */   valueAndGrad: () => (/* binding */ ea),\n/* harmony export */   valueAndGrads: () => (/* binding */ na),\n/* harmony export */   variable: () => (/* binding */ Vn),\n/* harmony export */   variableGrads: () => (/* binding */ ra),\n/* harmony export */   version_core: () => (/* binding */ Kd),\n/* harmony export */   webgl: () => (/* binding */ jd),\n/* harmony export */   where: () => (/* binding */ yc),\n/* harmony export */   whereAsync: () => (/* binding */ xc),\n/* harmony export */   zeros: () => (/* binding */ Gn),\n/* harmony export */   zerosLike: () => (/* binding */ Xn)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */ var t = function(e, n) {\n    return (t = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(t, e) {\n        t.__proto__ = e;\n    } || function(t, e) {\n        for(var n in e)e.hasOwnProperty(n) && (t[n] = e[n]);\n    })(e, n);\n};\nfunction e(e, n) {\n    function r() {\n        this.constructor = e;\n    }\n    t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r);\n}\nfunction n(t, e, n, r) {\n    return new (n || (n = Promise))(function(o, a) {\n        function i(t) {\n            try {\n                u(r.next(t));\n            } catch (t) {\n                a(t);\n            }\n        }\n        function s(t) {\n            try {\n                u(r.throw(t));\n            } catch (t) {\n                a(t);\n            }\n        }\n        function u(t) {\n            t.done ? o(t.value) : new n(function(e) {\n                e(t.value);\n            }).then(i, s);\n        }\n        u((r = r.apply(t, e || [])).next());\n    });\n}\nfunction r(t, e) {\n    var n, r, o, a, i = {\n        label: 0,\n        sent: function() {\n            if (1 & o[0]) throw o[1];\n            return o[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return a = {\n        next: s(0),\n        throw: s(1),\n        return: s(2)\n    }, \"function\" == typeof Symbol && (a[Symbol.iterator] = function() {\n        return this;\n    }), a;\n    function s(a) {\n        return function(s) {\n            return function(a) {\n                if (n) throw new TypeError(\"Generator is already executing.\");\n                for(; i;)try {\n                    if (n = 1, r && (o = 2 & a[0] ? r.return : a[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, a[1])).done) return o;\n                    switch(r = 0, o && (a = [\n                        2 & a[0],\n                        o.value\n                    ]), a[0]){\n                        case 0:\n                        case 1:\n                            o = a;\n                            break;\n                        case 4:\n                            return i.label++, {\n                                value: a[1],\n                                done: !1\n                            };\n                        case 5:\n                            i.label++, r = a[1], a = [\n                                0\n                            ];\n                            continue;\n                        case 7:\n                            a = i.ops.pop(), i.trys.pop();\n                            continue;\n                        default:\n                            if (!(o = (o = i.trys).length > 0 && o[o.length - 1]) && (6 === a[0] || 2 === a[0])) {\n                                i = 0;\n                                continue;\n                            }\n                            if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {\n                                i.label = a[1];\n                                break;\n                            }\n                            if (6 === a[0] && i.label < o[1]) {\n                                i.label = o[1], o = a;\n                                break;\n                            }\n                            if (o && i.label < o[2]) {\n                                i.label = o[2], i.ops.push(a);\n                                break;\n                            }\n                            o[2] && i.ops.pop(), i.trys.pop();\n                            continue;\n                    }\n                    a = e.call(t, i);\n                } catch (t) {\n                    a = [\n                        6,\n                        t\n                    ], r = 0;\n                } finally{\n                    n = o = 0;\n                }\n                if (5 & a[0]) throw a[1];\n                return {\n                    value: a[0] ? a[1] : void 0,\n                    done: !0\n                };\n            }([\n                a,\n                s\n            ]);\n        };\n    }\n}\nvar o = function() {\n    function t(t) {\n        this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();\n    }\n    return t.prototype.setPlatform = function(t, e) {\n        null != this.platform && console.warn(\"Platform \" + this.platformName + \" has already been set. Overwriting the platform with \" + e + \".\"), this.platformName = t, this.platform = e;\n    }, t.prototype.registerFlag = function(t, e, n) {\n        if (this.flagRegistry[t] = {\n            evaluationFn: e,\n            setHook: n\n        }, null != this.urlFlags[t]) {\n            var r = this.urlFlags[t];\n            console.warn(\"Setting feature override from URL \" + t + \": \" + r + \".\"), this.set(t, r);\n        }\n    }, t.prototype.get = function(t) {\n        return t in this.flags ? this.flags[t] : (this.flags[t] = this.evaluateFlag(t), this.flags[t]);\n    }, t.prototype.getNumber = function(t) {\n        return this.get(t);\n    }, t.prototype.getBool = function(t) {\n        return this.get(t);\n    }, t.prototype.getFlags = function() {\n        return this.flags;\n    }, Object.defineProperty(t.prototype, \"features\", {\n        get: function() {\n            return this.flags;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.set = function(t, e) {\n        if (null == this.flagRegistry[t]) throw new Error(\"Cannot set flag \" + t + \" as it has not been registered.\");\n        this.flags[t] = e, null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e);\n    }, t.prototype.evaluateFlag = function(t) {\n        if (null == this.flagRegistry[t]) throw new Error(\"Cannot evaluate flag '\" + t + \"': no evaluation function found.\");\n        return this.flagRegistry[t].evaluationFn();\n    }, t.prototype.setFlags = function(t) {\n        this.flags = Object.assign({}, t);\n    }, t.prototype.reset = function() {\n        this.flags = {}, this.urlFlags = {}, this.populateURLFlags();\n    }, t.prototype.populateURLFlags = function() {\n        var t = this;\n        if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {\n            var e, n, r = (e = this.global.location.search, n = {}, e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function(t) {\n                for(var e = [], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r];\n                return a(n, e[0], e[1]), e.join(\"=\");\n            }), n);\n            if (\"tfjsflags\" in r) r.tfjsflags.split(\",\").forEach(function(e) {\n                var n = e.split(\":\"), r = n[0], o = n[1];\n                t.urlFlags[r] = function(t, e) {\n                    if (\"true\" === (e = e.toLowerCase()) || \"false\" === e) return \"true\" === e;\n                    if (\"\" + +e === e) return +e;\n                    throw new Error(\"Could not parse value flag value \" + e + \" for flag \" + t + \".\");\n                }(r, o);\n            });\n        }\n    }, t;\n}();\nfunction a(t, e, n) {\n    t[decodeURIComponent(e)] = decodeURIComponent(n || \"\");\n}\nfunction i() {\n    return s;\n}\nvar s = null;\nvar u = new Map, c = new Map;\nfunction l(t, e) {\n    var n = m(t, e);\n    return u.get(n);\n}\nfunction h(t) {\n    return c.get(t);\n}\nfunction f(t) {\n    for(var e = u.entries(), n = [];;){\n        var r = e.next(), o = r.done, a = r.value;\n        if (o) break;\n        var i = a[0], s = a[1];\n        i.split(\"_\")[0] === t && n.push(s);\n    }\n    return n;\n}\nfunction d(t) {\n    var e = t.kernelName, n = t.backendName, r = m(e, n);\n    if (u.has(r)) throw new Error(\"The kernel '\" + e + \"' for backend '\" + n + \"' is already registered\");\n    u.set(r, t);\n}\nfunction p(t) {\n    var e = t.kernelName;\n    c.has(e) && console.warn(\"Overriding the gradient for '\" + e + \"'\"), c.set(e, t);\n}\nfunction v(t, e) {\n    var n = m(t, e);\n    if (!u.has(n)) throw new Error(\"The kernel '\" + t + \"' for backend '\" + e + \"' is not registered\");\n    u.delete(n);\n}\nfunction g(t) {\n    if (!c.has(t)) throw new Error(\"The gradient '\" + t + \"' for backend is not registered\");\n    c.delete(t);\n}\nfunction m(t, e) {\n    return e + \"_\" + t;\n}\nfunction y(t) {\n    for(var e = t.length, n = 0, r = 0; e > 0;)r = Math.random() * e | 0, n = t[--e], t[e] = t[r], t[r] = n;\n}\nfunction x(t, e, n) {\n    return Math.max(t, Math.min(e, n));\n}\nfunction b(t) {\n    return t % 2 == 0 ? t : t + 1;\n}\nfunction w(t) {\n    for(var e = 0, n = 0; n < t.length; n++)e += t[n];\n    return e;\n}\nfunction C(t, e) {\n    if (!t) throw new Error(\"string\" == typeof e ? e : e());\n}\nfunction E(t, e, n) {\n    void 0 === n && (n = \"\"), C(S(t, e), function() {\n        return n + \" Shapes \" + t + \" and \" + e + \" must match\";\n    });\n}\nfunction R(t) {\n    C(null != t, function() {\n        return \"The input to the tensor constructor must be a non-null value.\";\n    });\n}\nfunction I(t, e, n) {\n    if (void 0 === e && (e = []), void 0 === n && (n = !1), null == e && (e = []), Array.isArray(t) || V(t) && !n) for(var r = 0; r < t.length; ++r)I(t[r], e, n);\n    else e.push(t);\n    return e;\n}\nfunction k(t) {\n    if (0 === t.length) return 1;\n    for(var e = t[0], n = 1; n < t.length; n++)e *= t[n];\n    return e;\n}\nfunction S(t, e) {\n    if (t === e) return !0;\n    if (null == t || null == e) return !1;\n    if (t.length !== e.length) return !1;\n    for(var n = 0; n < t.length; n++)if (t[n] !== e[n]) return !1;\n    return !0;\n}\nfunction A(t) {\n    return t % 1 == 0;\n}\nfunction T(t) {\n    if (null != Math.tanh) return Math.tanh(t);\n    if (t === 1 / 0) return 1;\n    if (t === -1 / 0) return -1;\n    var e = Math.exp(2 * t);\n    return (e - 1) / (e + 1);\n}\nfunction D(t) {\n    var e = Math.ceil(Math.sqrt(t));\n    return [\n        e,\n        Math.ceil(t / e)\n    ];\n}\nfunction N(t, e) {\n    return e <= t.length ? t : t + \" \".repeat(e - t.length);\n}\nfunction F(t, e, n) {\n    return void 0 === e && (e = function(t) {\n        return 0;\n    }), new Promise(function(r, o) {\n        var a = 0, i = function() {\n            if (t()) r();\n            else {\n                a++;\n                var s = e(a);\n                null != n && a >= n ? o() : setTimeout(i, s);\n            }\n        };\n        i();\n    });\n}\nfunction _(t, e) {\n    for(var n = 1, r = -1, o = 0; o < t.length; ++o)if (t[o] >= 0) n *= t[o];\n    else if (-1 === t[o]) {\n        if (-1 !== r) throw Error(\"Shapes can only have 1 implicit size. Found -1 at dim \" + r + \" and dim \" + o);\n        r = o;\n    } else if (t[o] < 0) throw Error(\"Shapes can not be < 0. Found \" + t[o] + \" at dim \" + o);\n    if (-1 === r) {\n        if (e > 0 && e !== n) throw Error(\"Size(\" + e + \") must match the product of shape \" + t);\n        return t;\n    }\n    if (0 === n) throw Error(\"Cannot infer the missing size in [\" + t + \"] when there are 0 elements\");\n    if (e % n != 0) throw Error(\"The implicit shape can't be a fractional number. Got \" + e + \" / \" + n);\n    var a = t.slice();\n    return a[r] = e / n, a;\n}\nfunction O(t, e) {\n    var n = e.length;\n    return C((t = null == t ? e.map(function(t, e) {\n        return e;\n    }) : [].concat(t)).every(function(t) {\n        return t >= -n && t < n;\n    }), function() {\n        return \"All values in axis param must be in range [-\" + n + \", \" + n + \") but got axis \" + t;\n    }), C(t.every(function(t) {\n        return A(t);\n    }), function() {\n        return \"All values in axis param must be integers but got axis \" + t;\n    }), t.map(function(t) {\n        return t < 0 ? n + t : t;\n    });\n}\nfunction M(t, e) {\n    for(var n = [], r = [], o = null != e && Array.isArray(e) && 0 === e.length, a = null == e || o ? null : O(e, t).sort(), i = 0, s = 0; s < t.length; ++s){\n        if (null != a) {\n            if (a[i] === s && 1 !== t[s]) throw new Error(\"Can't squeeze axis \" + s + \" since its dim '\" + t[s] + \"' is not 1\");\n            (null == a[i] || a[i] > s) && 1 === t[s] && (n.push(t[s]), r.push(s)), a[i] <= s && i++;\n        }\n        1 !== t[s] && (n.push(t[s]), r.push(s));\n    }\n    return {\n        newShape: n,\n        keptDims: r\n    };\n}\nfunction B(t, e) {\n    var n = null;\n    if (null == t || \"float32\" === t) n = new Float32Array(e);\n    else if (\"int32\" === t) n = new Int32Array(e);\n    else {\n        if (\"bool\" !== t) throw new Error(\"Unknown data type \" + t);\n        n = new Uint8Array(e);\n    }\n    return n;\n}\nfunction P(t, e) {\n    var n = null;\n    if (null == t || \"float32\" === t) n = new Float32Array(e);\n    else if (\"int32\" === t) n = new Int32Array(e);\n    else if (\"bool\" === t) n = new Uint8Array(e);\n    else {\n        if (\"string\" !== t) throw new Error(\"Unknown data type \" + t);\n        n = new Array(e);\n    }\n    return n;\n}\nfunction L(t, e) {\n    for(var n = 0; n < t.length; n++){\n        var r = t[n];\n        if (isNaN(r) || !isFinite(r)) throw Error(\"A tensor of type \" + e + \" being uploaded contains \" + r + \".\");\n    }\n}\nfunction W(t) {\n    return \"bool\" === t || \"complex64\" === t || \"float32\" === t || \"int32\" === t || \"string\" === t;\n}\nfunction U(t, e) {\n    return \"complex64\" !== e && (\"float32\" !== e || \"complex64\" === t) && (\"int32\" !== e || \"float32\" === t || \"complex64\" === t) && (\"bool\" !== e || \"bool\" !== t);\n}\nfunction V(t) {\n    return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array;\n}\nfunction z(t) {\n    if (\"float32\" === t || \"int32\" === t) return 4;\n    if (\"complex64\" === t) return 8;\n    if (\"bool\" === t) return 1;\n    throw new Error(\"Unknown dtype \" + t);\n}\nfunction G(t) {\n    if (null == t) return 0;\n    var e = 0;\n    return t.forEach(function(t) {\n        return e += t.length;\n    }), e;\n}\nfunction H(t) {\n    return \"string\" == typeof t || t instanceof String;\n}\nfunction q(t) {\n    return \"boolean\" == typeof t;\n}\nfunction K(t) {\n    return \"number\" == typeof t;\n}\nfunction j(t) {\n    return Array.isArray(t) ? j(t[0]) : t instanceof Float32Array ? \"float32\" : t instanceof Int32Array || t instanceof Uint8Array ? \"int32\" : K(t) ? \"float32\" : H(t) ? \"string\" : q(t) ? \"bool\" : \"float32\";\n}\nfunction X(t) {\n    return !!(t && t.constructor && t.call && t.apply);\n}\nfunction Y(t, e) {\n    for(var n = e; n < t; ++n)if (t % n == 0) return n;\n    return t;\n}\nfunction $(t) {\n    var e = t.length;\n    if (e < 2) return [];\n    var n = new Array(e - 1);\n    n[e - 2] = t[e - 1];\n    for(var r = e - 3; r >= 0; --r)n[r] = n[r + 1] * t[r + 1];\n    return n;\n}\nfunction Q(t, e, n) {\n    if (\"string\" === e) throw new Error(\"Cannot convert a string[] to a TypedArray\");\n    if (Array.isArray(t) && (t = I(t)), n && L(t, e), function(t, e) {\n        return t instanceof Float32Array && \"float32\" === e || t instanceof Int32Array && \"int32\" === e || t instanceof Uint8Array && \"bool\" === e;\n    }(t, e)) return t;\n    if (null == e || \"float32\" === e || \"complex64\" === e) return new Float32Array(t);\n    if (\"int32\" === e) return new Int32Array(t);\n    if (\"bool\" === e) {\n        for(var r = new Uint8Array(t.length), o = 0; o < r.length; ++o)0 !== Math.round(t[o]) && (r[o] = 1);\n        return r;\n    }\n    throw new Error(\"Unknown data type \" + e);\n}\nfunction J(t, e) {\n    if (0 === t.length) return e[0];\n    var n = t.reduce(function(t, e) {\n        return t * e;\n    });\n    if (0 === n) return [];\n    if (n !== e.length) throw new Error(\"[\" + t + \"] does not match the input size.\");\n    return function t(e, n, r) {\n        var o = new Array;\n        if (1 === n.length) for(var a = n[0], i = 0; i < a; i++)o[i] = r[e + i];\n        else {\n            a = n[0];\n            var s = n.slice(1), u = s.reduce(function(t, e) {\n                return t * e;\n            });\n            for(i = 0; i < a; i++)o[i] = t(e + i * u, s, r);\n        }\n        return o;\n    }(0, t, e);\n}\nfunction Z(t, e) {\n    for(var n = tt(t, e), r = 0; r < n.length; r++)n[r] = 1;\n    return n;\n}\nfunction tt(t, e) {\n    if (null == e || \"float32\" === e || \"complex64\" === e) return new Float32Array(t);\n    if (\"int32\" === e) return new Int32Array(t);\n    if (\"bool\" === e) return new Uint8Array(t);\n    throw new Error(\"Unknown data type \" + e);\n}\nfunction et() {\n    return i().platform.now();\n}\nfunction nt(t) {\n    t.forEach(function(e) {\n        C(Number.isInteger(e) && e >= 0, function() {\n            return \"Tensor must have a shape comprised of positive integers but got shape [\" + t + \"].\";\n        });\n    });\n}\nfunction rt(t, e) {\n    return void 0 === e && (e = \"utf-8\"), e = e || \"utf-8\", i().platform.encode(t, e);\n}\nfunction ot(t, e) {\n    return void 0 === e && (e = \"utf-8\"), e = e || \"utf-8\", i().platform.decode(t, e);\n}\nfunction at(t, e, n) {\n    if (0 === e) return 0;\n    if (1 === e) return t[0];\n    for(var r = t[t.length - 1], o = 0; o < t.length - 1; ++o)r += n[o] * t[o];\n    return r;\n}\nfunction it(t, e, n) {\n    if (0 === e) return [];\n    if (1 === e) return [\n        t\n    ];\n    for(var r = new Array(e), o = 0; o < r.length - 1; ++o)r[o] = Math.floor(t / n[o]), t -= r[o] * n[o];\n    return r[r.length - 1] = t, r;\n}\nvar st = Object.freeze({\n    shuffle: y,\n    clamp: x,\n    nearestLargerEven: b,\n    sum: w,\n    randUniform: function(t, e) {\n        var n = Math.random();\n        return e * n + (1 - n) * t;\n    },\n    distSquared: function(t, e) {\n        for(var n = 0, r = 0; r < t.length; r++){\n            var o = Number(t[r]) - Number(e[r]);\n            n += o * o;\n        }\n        return n;\n    },\n    assert: C,\n    assertShapesMatch: E,\n    assertNonNull: R,\n    flatten: I,\n    sizeFromShape: k,\n    isScalarShape: function(t) {\n        return 0 === t.length;\n    },\n    arraysEqual: S,\n    isInt: A,\n    tanh: T,\n    sizeToSquarishShape: D,\n    createShuffledIndices: function(t) {\n        for(var e = new Uint32Array(t), n = 0; n < t; ++n)e[n] = n;\n        return y(e), e;\n    },\n    rightPad: N,\n    repeatedTry: F,\n    inferFromImplicitShape: _,\n    parseAxisParam: O,\n    squeezeShape: M,\n    getTypedArrayFromDType: B,\n    getArrayFromDType: P,\n    checkConversionForErrors: L,\n    isValidDtype: W,\n    hasEncodingLoss: U,\n    isTypedArray: V,\n    bytesPerElement: z,\n    bytesFromStringArray: G,\n    isString: H,\n    isBoolean: q,\n    isNumber: K,\n    inferDtype: j,\n    isFunction: X,\n    nearestDivisor: Y,\n    computeStrides: $,\n    toTypedArray: Q,\n    toNestedArray: J,\n    makeOnesTypedArray: Z,\n    makeZerosTypedArray: tt,\n    now: et,\n    assertNonNegativeIntegerDimensions: nt,\n    fetch: function(t, e) {\n        return i().platform.fetch(t, e);\n    },\n    encodeString: rt,\n    decodeString: ot,\n    locToIndex: at,\n    indexToLoc: it\n}), ut = function() {\n    function t(t, e) {\n        this.backendTimer = t, this.logger = e, null == e && (this.logger = new ct);\n    }\n    return t.prototype.profileKernel = function(t, e, n) {\n        var r, o = this, a = this.backendTimer.time(function() {\n            r = n();\n        });\n        return r.forEach(function(n) {\n            n.data().then(function(r) {\n                !function(t, e, n) {\n                    if (\"float32\" !== e) return !1;\n                    for(var r = 0; r < t.length; r++){\n                        var o = t[r];\n                        if (isNaN(o) || !isFinite(o)) return console.warn(\"Found \" + o + \" in the result of '\" + n + \"'\"), !0;\n                    }\n                }(r, n.dtype, t), a.then(function(a) {\n                    var i = \"\";\n                    null != a.getExtraProfileInfo && (i = a.getExtraProfileInfo()), o.logger.logKernelProfile(t, n, r, a.kernelMs, e, i);\n                });\n            });\n        }), r;\n    }, t;\n}();\nvar ct = function() {\n    function t() {}\n    return t.prototype.logKernelProfile = function(t, e, n, r, o, a) {\n        var i = \"number\" == typeof r ? N(r + \"ms\", 9) : r.error, s = N(t, 25), u = e.rank, c = e.size, l = N(e.shape.toString(), 14), h = \"\";\n        for(var f in o){\n            var d = o[f].shape || e.shape, p = d.length;\n            h += f + \": \" + p + \"D \" + (p > 0 ? d : \"\") + \" \";\n        }\n        console.log(\"%c\" + s + \"\t%c\" + i + \"\t%c\" + u + \"D \" + l + \"\t%c\" + c + \"\t%c\" + h + \"\t%c\" + a, \"font-weight:bold\", \"color:red\", \"color:blue\", \"color: orange\", \"color: green\", \"color: steelblue\");\n    }, t;\n}();\nvar lt = 20, ht = 3, ft = 7;\nfunction dt(t, e, n, r) {\n    var o = $(e), a = function(t, e, n, r) {\n        var o = k(e), a = r[r.length - 1], i = new Array(a).fill(0), s = e.length, u = \"complex64\" === n ? gt(t) : t;\n        if (s > 1) for(var c = 0; c < o / a; c++)for(var l = c * a, h = 0; h < a; h++)i[h] = Math.max(i[h], pt(u[l + h], 0, n).length);\n        return i;\n    }(t, e, n, o), i = e.length, s = function t(e, n, r, o, a, i) {\n        void 0 === i && (i = !0);\n        var s = \"complex64\" === r ? 2 : 1, u = n[0], c = n.length;\n        if (0 === c) {\n            return \"complex64\" === r ? [\n                pt(gt(e)[0], 0, r)\n            ] : \"bool\" === r ? [\n                vt(e[0])\n            ] : [\n                e[0].toString()\n            ];\n        }\n        if (1 === c) {\n            if (u > lt) {\n                var l = ht * s, h = Array.from(e.slice(0, l)), f = Array.from(e.slice((u - ht) * s, u * s));\n                return \"complex64\" === r && (h = gt(h), f = gt(f)), [\n                    \"[\" + h.map(function(t, e) {\n                        return pt(t, a[e], r);\n                    }).join(\", \") + \", ..., \" + f.map(function(t, e) {\n                        return pt(t, a[u - ht + e], r);\n                    }).join(\", \") + \"]\"\n                ];\n            }\n            return [\n                \"[\" + (\"complex64\" === r ? gt(e) : Array.from(e)).map(function(t, e) {\n                    return pt(t, a[e], r);\n                }).join(\", \") + \"]\"\n            ];\n        }\n        var d = n.slice(1), p = o.slice(1), v = o[0] * s, g = [];\n        if (u > lt) {\n            for(var m = 0; m < ht; m++){\n                var y = (x = m * v) + v;\n                g.push.apply(g, t(e.slice(x, y), d, r, p, a, !1));\n            }\n            g.push(\"...\");\n            for(m = u - ht; m < u; m++){\n                y = (x = m * v) + v;\n                g.push.apply(g, t(e.slice(x, y), d, r, p, a, m === u - 1));\n            }\n        } else for(m = 0; m < u; m++){\n            var x;\n            y = (x = m * v) + v;\n            g.push.apply(g, t(e.slice(x, y), d, r, p, a, m === u - 1));\n        }\n        var b = 2 === c ? \",\" : \"\";\n        g[0] = \"[\" + g[0] + b;\n        for(m = 1; m < g.length - 1; m++)g[m] = \" \" + g[m] + b;\n        var w = \",\\n\";\n        for(m = 2; m < c; m++)w += \"\\n\";\n        return g[g.length - 1] = \" \" + g[g.length - 1] + \"]\" + (i ? \"\" : w), g;\n    }(t, e, n, o, a), u = [\n        \"Tensor\"\n    ];\n    return r && (u.push(\"  dtype: \" + n), u.push(\"  rank: \" + i), u.push(\"  shape: [\" + e + \"]\"), u.push(\"  values:\")), u.push(s.map(function(t) {\n        return \"    \" + t;\n    }).join(\"\\n\")), u.join(\"\\n\");\n}\nfunction pt(t, e, n) {\n    return N(Array.isArray(t) ? parseFloat(t[0].toFixed(ft)) + \" + \" + parseFloat(t[1].toFixed(ft)) + \"j\" : H(t) ? \"'\" + t + \"'\" : \"bool\" === n ? vt(t) : parseFloat(t.toFixed(ft)).toString(), e);\n}\nfunction vt(t) {\n    return 0 === t ? \"false\" : \"true\";\n}\nfunction gt(t) {\n    for(var e = [], n = 0; n < t.length; n += 2)e.push([\n        t[n],\n        t[n + 1]\n    ]);\n    return e;\n}\nvar mt = function() {\n    function t(t, e, n) {\n        var r = this;\n        if (this.dtype = e, this.shape = t.slice(), this.size = k(t), null != n) {\n            var o = n.length;\n            C(o === this.size, function() {\n                return \"Length of values '\" + o + \"' does not match the size inferred by the shape '\" + r.size + \"'.\";\n            });\n        }\n        if (\"complex64\" === e) throw new Error(\"complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).\");\n        this.values = n || P(e, this.size), this.strides = $(t);\n    }\n    return t.prototype.set = function(t) {\n        for(var e = this, n = [], r = 1; r < arguments.length; r++)n[r - 1] = arguments[r];\n        0 === n.length && (n = [\n            0\n        ]), C(n.length === this.rank, function() {\n            return \"The number of provided coordinates (\" + n.length + \") must match the rank (\" + e.rank + \")\";\n        });\n        var o = this.locToIndex(n);\n        this.values[o] = t;\n    }, t.prototype.get = function() {\n        for(var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e];\n        0 === t.length && (t = [\n            0\n        ]);\n        for(var n = 0, r = 0, o = t; r < o.length; r++){\n            var a = o[r];\n            if (a < 0 || a >= this.shape[n]) {\n                var i = \"Requested out of range element at \" + t + \".   Buffer shape=\" + this.shape;\n                throw new Error(i);\n            }\n            n++;\n        }\n        for(var s = t[t.length - 1], u = 0; u < t.length - 1; ++u)s += this.strides[u] * t[u];\n        return this.values[s];\n    }, t.prototype.locToIndex = function(t) {\n        if (0 === this.rank) return 0;\n        if (1 === this.rank) return t[0];\n        for(var e = t[t.length - 1], n = 0; n < t.length - 1; ++n)e += this.strides[n] * t[n];\n        return e;\n    }, t.prototype.indexToLoc = function(t) {\n        if (0 === this.rank) return [];\n        if (1 === this.rank) return [\n            t\n        ];\n        for(var e = new Array(this.shape.length), n = 0; n < e.length - 1; ++n)e[n] = Math.floor(t / this.strides[n]), t -= e[n] * this.strides[n];\n        return e[e.length - 1] = t, e;\n    }, Object.defineProperty(t.prototype, \"rank\", {\n        get: function() {\n            return this.shape.length;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.toTensor = function() {\n        return yt().makeTensor(this.values, this.shape, this.dtype);\n    }, t;\n}(), yt = null, xt = null, bt = null;\nvar wt = function() {\n    function t(t, e, n, r) {\n        this.kept = !1, this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = e || \"float32\", this.size = k(t), this.strides = $(t), this.dataId = n, this.id = r, this.rankType = this.rank < 5 ? this.rank.toString() : \"higher\";\n    }\n    return t.prototype.flatten = function() {\n        return this.throwIfDisposed(), this.as1D();\n    }, t.prototype.asScalar = function() {\n        return this.throwIfDisposed(), C(1 === this.size, function() {\n            return \"The array must have only 1 element.\";\n        }), this.reshape([]);\n    }, t.prototype.as1D = function() {\n        return this.throwIfDisposed(), this.reshape([\n            this.size\n        ]);\n    }, t.prototype.as2D = function(t, e) {\n        return this.throwIfDisposed(), this.reshape([\n            t,\n            e\n        ]);\n    }, t.prototype.as3D = function(t, e, n) {\n        return this.throwIfDisposed(), this.reshape([\n            t,\n            e,\n            n\n        ]);\n    }, t.prototype.as4D = function(t, e, n, r) {\n        return this.throwIfDisposed(), this.reshape([\n            t,\n            e,\n            n,\n            r\n        ]);\n    }, t.prototype.as5D = function(t, e, n, r, o) {\n        return this.throwIfDisposed(), this.reshape([\n            t,\n            e,\n            n,\n            r,\n            o\n        ]);\n    }, t.prototype.asType = function(t) {\n        return this.throwIfDisposed(), xt.cast(this, t);\n    }, Object.defineProperty(t.prototype, \"rank\", {\n        get: function() {\n            return this.shape.length;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.buffer = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return [\n                            4,\n                            this.data()\n                        ];\n                    case 1:\n                        return t = e.sent(), [\n                            2,\n                            xt.buffer(this.shape, this.dtype, t)\n                        ];\n                }\n            });\n        });\n    }, t.prototype.bufferSync = function() {\n        return xt.buffer(this.shape, this.dtype, this.dataSync());\n    }, t.prototype.array = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return [\n                            4,\n                            this.data()\n                        ];\n                    case 1:\n                        return t = e.sent(), [\n                            2,\n                            J(this.shape, t)\n                        ];\n                }\n            });\n        });\n    }, t.prototype.arraySync = function() {\n        return J(this.shape, this.dataSync());\n    }, t.prototype.data = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e;\n            return r(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        return this.throwIfDisposed(), t = yt().read(this.dataId), \"string\" !== this.dtype ? [\n                            3,\n                            2\n                        ] : [\n                            4,\n                            t\n                        ];\n                    case 1:\n                        e = n.sent();\n                        try {\n                            return [\n                                2,\n                                e.map(function(t) {\n                                    return ot(t);\n                                })\n                            ];\n                        } catch (t) {\n                            throw new Error(\"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().\");\n                        }\n                        n.label = 2;\n                    case 2:\n                        return [\n                            2,\n                            t\n                        ];\n                }\n            });\n        });\n    }, t.prototype.dataSync = function() {\n        this.throwIfDisposed();\n        var t = yt().readSync(this.dataId);\n        if (\"string\" === this.dtype) try {\n            return t.map(function(t) {\n                return ot(t);\n            });\n        } catch (t) {\n            throw new Error(\"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().\");\n        }\n        return t;\n    }, t.prototype.bytes = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return this.throwIfDisposed(), [\n                            4,\n                            yt().read(this.dataId)\n                        ];\n                    case 1:\n                        return t = e.sent(), \"string\" === this.dtype ? [\n                            2,\n                            t\n                        ] : [\n                            2,\n                            new Uint8Array(t.buffer)\n                        ];\n                }\n            });\n        });\n    }, t.prototype.dispose = function() {\n        this.isDisposed || (yt().disposeTensor(this), this.isDisposedInternal = !0);\n    }, Object.defineProperty(t.prototype, \"isDisposed\", {\n        get: function() {\n            return this.isDisposedInternal;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.throwIfDisposed = function() {\n        if (this.isDisposed) throw new Error(\"Tensor is disposed.\");\n    }, t.prototype.toFloat = function() {\n        return this.asType(\"float32\");\n    }, t.prototype.toInt = function() {\n        return this.asType(\"int32\");\n    }, t.prototype.toBool = function() {\n        return this.asType(\"bool\");\n    }, t.prototype.print = function(t) {\n        return void 0 === t && (t = !1), xt.print(this, t);\n    }, t.prototype.reshape = function(t) {\n        return this.throwIfDisposed(), xt.reshape(this, t);\n    }, t.prototype.reshapeAs = function(t) {\n        return this.throwIfDisposed(), this.reshape(t.shape);\n    }, t.prototype.expandDims = function(t) {\n        return void 0 === t && (t = 0), xt.expandDims(this, t);\n    }, t.prototype.cumsum = function(t, e, n) {\n        return void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === n && (n = !1), xt.cumsum(this, t, e, n);\n    }, t.prototype.squeeze = function(t) {\n        return this.throwIfDisposed(), xt.squeeze(this, t);\n    }, t.prototype.clone = function() {\n        return this.throwIfDisposed(), xt.clone(this);\n    }, t.prototype.toString = function(t) {\n        return void 0 === t && (t = !1), dt(this.dataSync(), this.shape, this.dtype, t);\n    }, t.prototype.gather = function(t, e) {\n        return void 0 === e && (e = 0), this.throwIfDisposed(), xt.gather(this, t, e);\n    }, t.prototype.matMul = function(t, e, n) {\n        return void 0 === e && (e = !1), void 0 === n && (n = !1), this.throwIfDisposed(), xt.matMul(this, t, e, n);\n    }, t.prototype.dot = function(t) {\n        return this.throwIfDisposed(), xt.dot(this, t);\n    }, t.prototype.norm = function(t, e, n) {\n        return void 0 === t && (t = \"euclidean\"), void 0 === e && (e = null), void 0 === n && (n = !1), this.throwIfDisposed(), xt.norm(this, t, e, n);\n    }, t.prototype.slice = function(t, e) {\n        return this.throwIfDisposed(), xt.slice(this, t, e);\n    }, t.prototype.reverse = function(t) {\n        return this.throwIfDisposed(), xt.reverse(this, t);\n    }, t.prototype.concat = function(e, n) {\n        return void 0 === n && (n = 0), this.throwIfDisposed(), e instanceof t && (e = [\n            e\n        ]), xt.concat([\n            this\n        ].concat(e), n);\n    }, t.prototype.split = function(t, e) {\n        return void 0 === e && (e = 0), this.throwIfDisposed(), xt.split(this, t, e);\n    }, t.prototype.stack = function(t, e) {\n        return void 0 === e && (e = 0), xt.stack([\n            this,\n            t\n        ], e);\n    }, t.prototype.unstack = function(t) {\n        return void 0 === t && (t = 0), xt.unstack(this, t);\n    }, t.prototype.batchNormalization = function(t, e, n, r, o) {\n        return void 0 === n && (n = .001), bt(\"tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon\"), this.batchNorm(t, e, o, r, n);\n    }, t.prototype.all = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.all(this, t, e);\n    }, t.prototype.any = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.any(this, t, e);\n    }, t.prototype.logSumExp = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.logSumExp(this, t, e);\n    }, t.prototype.sum = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.sum(this, t, e);\n    }, t.prototype.prod = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.prod(this, t, e);\n    }, t.prototype.mean = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.mean(this, t, e);\n    }, t.prototype.min = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.min(this, t, e);\n    }, t.prototype.max = function(t, e) {\n        return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), xt.max(this, t, e);\n    }, t.prototype.argMin = function(t) {\n        return void 0 === t && (t = null), this.throwIfDisposed(), xt.argMin(this, t);\n    }, t.prototype.argMax = function(t) {\n        return void 0 === t && (t = null), this.throwIfDisposed(), xt.argMax(this, t);\n    }, t.prototype.cast = function(t) {\n        return this.throwIfDisposed(), xt.cast(this, t);\n    }, t.prototype.addStrict = function(t) {\n        return this.throwIfDisposed(), xt.addStrict(this, t);\n    }, t.prototype.atan2 = function(t) {\n        return this.throwIfDisposed(), xt.atan2(this, t);\n    }, t.prototype.sub = function(t) {\n        return this.throwIfDisposed(), xt.sub(this, t);\n    }, t.prototype.subStrict = function(t) {\n        return this.throwIfDisposed(), xt.subStrict(this, t);\n    }, t.prototype.pow = function(t) {\n        return this.throwIfDisposed(), xt.pow(this, t);\n    }, t.prototype.powStrict = function(t) {\n        return this.throwIfDisposed(), xt.powStrict(this, t);\n    }, t.prototype.mul = function(t) {\n        return this.throwIfDisposed(), xt.mul(this, t);\n    }, t.prototype.mulStrict = function(t) {\n        return this.throwIfDisposed(), xt.mulStrict(this, t);\n    }, t.prototype.floorDiv = function(t) {\n        return this.throwIfDisposed(), xt.floorDiv(this, t);\n    }, t.prototype.divStrict = function(t) {\n        return this.throwIfDisposed(), xt.divStrict(this, t);\n    }, t.prototype.minimum = function(t) {\n        return this.throwIfDisposed(), xt.minimum(this, t);\n    }, t.prototype.minimumStrict = function(t) {\n        return this.throwIfDisposed(), xt.minimumStrict(this, t);\n    }, t.prototype.maximum = function(t) {\n        return this.throwIfDisposed(), xt.maximum(this, t);\n    }, t.prototype.maximumStrict = function(t) {\n        return this.throwIfDisposed(), xt.maximumStrict(this, t);\n    }, t.prototype.mod = function(t) {\n        return this.throwIfDisposed(), xt.mod(this, t);\n    }, t.prototype.modStrict = function(t) {\n        return this.throwIfDisposed(), xt.modStrict(this, t);\n    }, t.prototype.squaredDifferenceStrict = function(t) {\n        return this.throwIfDisposed(), xt.squaredDifferenceStrict(this, t);\n    }, t.prototype.notEqual = function(t) {\n        return this.throwIfDisposed(), xt.notEqual(this, t);\n    }, t.prototype.notEqualStrict = function(t) {\n        return this.throwIfDisposed(), xt.notEqualStrict(this, t);\n    }, t.prototype.less = function(t) {\n        return this.throwIfDisposed(), xt.less(this, t);\n    }, t.prototype.lessStrict = function(t) {\n        return this.throwIfDisposed(), xt.lessStrict(this, t);\n    }, t.prototype.equal = function(t) {\n        return this.throwIfDisposed(), xt.equal(this, t);\n    }, t.prototype.equalStrict = function(t) {\n        return this.throwIfDisposed(), xt.equalStrict(this, t);\n    }, t.prototype.lessEqual = function(t) {\n        return this.throwIfDisposed(), xt.lessEqual(this, t);\n    }, t.prototype.lessEqualStrict = function(t) {\n        return this.throwIfDisposed(), xt.lessEqualStrict(this, t);\n    }, t.prototype.greater = function(t) {\n        return this.throwIfDisposed(), xt.greater(this, t);\n    }, t.prototype.greaterStrict = function(t) {\n        return this.throwIfDisposed(), xt.greaterStrict(this, t);\n    }, t.prototype.greaterEqual = function(t) {\n        return this.throwIfDisposed(), xt.greaterEqual(this, t);\n    }, t.prototype.greaterEqualStrict = function(t) {\n        return this.throwIfDisposed(), xt.greaterEqualStrict(this, t);\n    }, t.prototype.logicalAnd = function(t) {\n        return this.throwIfDisposed(), xt.logicalAnd(this, t);\n    }, t.prototype.logicalOr = function(t) {\n        return this.throwIfDisposed(), xt.logicalOr(this, t);\n    }, t.prototype.logicalNot = function() {\n        return this.throwIfDisposed(), xt.logicalNot(this);\n    }, t.prototype.logicalXor = function(t) {\n        return this.throwIfDisposed(), xt.logicalXor(this, t);\n    }, t.prototype.where = function(t, e) {\n        return this.throwIfDisposed(), xt.where(t, this, e);\n    }, t.prototype.neg = function() {\n        return this.throwIfDisposed(), xt.neg(this);\n    }, t.prototype.ceil = function() {\n        return this.throwIfDisposed(), xt.ceil(this);\n    }, t.prototype.floor = function() {\n        return this.throwIfDisposed(), xt.floor(this);\n    }, t.prototype.sign = function() {\n        return this.throwIfDisposed(), xt.sign(this);\n    }, t.prototype.isNaN = function() {\n        return this.throwIfDisposed(), xt.isNaN(this);\n    }, t.prototype.isInf = function() {\n        return this.throwIfDisposed(), xt.isInf(this);\n    }, t.prototype.isFinite = function() {\n        return this.throwIfDisposed(), xt.isFinite(this);\n    }, t.prototype.exp = function() {\n        return this.throwIfDisposed(), xt.exp(this);\n    }, t.prototype.expm1 = function() {\n        return this.throwIfDisposed(), xt.expm1(this);\n    }, t.prototype.log = function() {\n        return this.throwIfDisposed(), xt.log(this);\n    }, t.prototype.log1p = function() {\n        return this.throwIfDisposed(), xt.log1p(this);\n    }, t.prototype.sqrt = function() {\n        return this.throwIfDisposed(), xt.sqrt(this);\n    }, t.prototype.rsqrt = function() {\n        return this.throwIfDisposed(), xt.rsqrt(this);\n    }, t.prototype.square = function() {\n        return this.throwIfDisposed(), xt.square(this);\n    }, t.prototype.reciprocal = function() {\n        return this.throwIfDisposed(), xt.reciprocal(this);\n    }, t.prototype.abs = function() {\n        return this.throwIfDisposed(), xt.abs(this);\n    }, t.prototype.clipByValue = function(t, e) {\n        return this.throwIfDisposed(), xt.clipByValue(this, t, e);\n    }, t.prototype.relu = function() {\n        return this.throwIfDisposed(), xt.relu(this);\n    }, t.prototype.relu6 = function() {\n        return this.throwIfDisposed(), xt.relu6(this);\n    }, t.prototype.elu = function() {\n        return this.throwIfDisposed(), xt.elu(this);\n    }, t.prototype.selu = function() {\n        return this.throwIfDisposed(), xt.selu(this);\n    }, t.prototype.leakyRelu = function(t) {\n        return void 0 === t && (t = .2), this.throwIfDisposed(), xt.leakyRelu(this, t);\n    }, t.prototype.prelu = function(t) {\n        return this.throwIfDisposed(), xt.prelu(this, t);\n    }, t.prototype.sigmoid = function() {\n        return this.throwIfDisposed(), xt.sigmoid(this);\n    }, t.prototype.logSigmoid = function() {\n        return this.throwIfDisposed(), xt.logSigmoid(this);\n    }, t.prototype.softplus = function() {\n        return this.throwIfDisposed(), xt.softplus(this);\n    }, t.prototype.zerosLike = function() {\n        return this.throwIfDisposed(), xt.zerosLike(this);\n    }, t.prototype.onesLike = function() {\n        return this.throwIfDisposed(), xt.onesLike(this);\n    }, t.prototype.sin = function() {\n        return this.throwIfDisposed(), xt.sin(this);\n    }, t.prototype.cos = function() {\n        return this.throwIfDisposed(), xt.cos(this);\n    }, t.prototype.tan = function() {\n        return this.throwIfDisposed(), xt.tan(this);\n    }, t.prototype.asin = function() {\n        return this.throwIfDisposed(), xt.asin(this);\n    }, t.prototype.acos = function() {\n        return this.throwIfDisposed(), xt.acos(this);\n    }, t.prototype.atan = function() {\n        return this.throwIfDisposed(), xt.atan(this);\n    }, t.prototype.sinh = function() {\n        return this.throwIfDisposed(), xt.sinh(this);\n    }, t.prototype.cosh = function() {\n        return this.throwIfDisposed(), xt.cosh(this);\n    }, t.prototype.tanh = function() {\n        return this.throwIfDisposed(), xt.tanh(this);\n    }, t.prototype.asinh = function() {\n        return this.throwIfDisposed(), xt.asinh(this);\n    }, t.prototype.acosh = function() {\n        return this.throwIfDisposed(), xt.acosh(this);\n    }, t.prototype.atanh = function() {\n        return this.throwIfDisposed(), xt.atanh(this);\n    }, t.prototype.erf = function() {\n        return this.throwIfDisposed(), xt.erf(this);\n    }, t.prototype.round = function() {\n        return this.throwIfDisposed(), xt.round(this);\n    }, t.prototype.step = function(t) {\n        return void 0 === t && (t = 0), this.throwIfDisposed(), xt.step(this, t);\n    }, t.prototype.softmax = function(t) {\n        return void 0 === t && (t = -1), this.throwIfDisposed(), xt.softmax(this, t);\n    }, t.prototype.logSoftmax = function(t) {\n        return void 0 === t && (t = -1), this.throwIfDisposed(), xt.logSoftmax(this, t);\n    }, t.prototype.resizeBilinear = function(t, e) {\n        return void 0 === e && (e = !1), this.throwIfDisposed(), xt.image.resizeBilinear(this, t, e);\n    }, t.prototype.resizeNearestNeighbor = function(t, e) {\n        return void 0 === e && (e = !1), this.throwIfDisposed(), xt.image.resizeNearestNeighbor(this, t, e);\n    }, t.prototype.conv1d = function(t, e, n, r, o, a) {\n        return void 0 === r && (r = \"NWC\"), void 0 === o && (o = 1), this.throwIfDisposed(), xt.conv1d(this, t, e, n, r, o, a);\n    }, t.prototype.conv2d = function(t, e, n, r, o, a) {\n        return void 0 === r && (r = \"NHWC\"), void 0 === o && (o = [\n            1,\n            1\n        ]), this.throwIfDisposed(), xt.conv2d(this, t, e, n, r, o, a);\n    }, t.prototype.conv2dTranspose = function(t, e, n, r, o) {\n        return this.throwIfDisposed(), xt.conv2dTranspose(this, t, e, n, r, o);\n    }, t.prototype.depthwiseConv2D = function(t, e, n, r, o, a) {\n        return void 0 === r && (r = \"NHWC\"), void 0 === o && (o = [\n            1,\n            1\n        ]), this.throwIfDisposed(), xt.depthwiseConv2d(this, t, e, n, r, o, a);\n    }, t.prototype.separableConv2d = function(t, e, n, r, o, a) {\n        return void 0 === o && (o = [\n            1,\n            1\n        ]), void 0 === a && (a = \"NHWC\"), this.throwIfDisposed(), xt.separableConv2d(this, t, e, n, r, o, a);\n    }, t.prototype.avgPool = function(t, e, n, r) {\n        return this.throwIfDisposed(), xt.avgPool(this, t, e, n, r);\n    }, t.prototype.maxPool = function(t, e, n, r) {\n        return this.throwIfDisposed(), xt.maxPool(this, t, e, n, r);\n    }, t.prototype.localResponseNormalization = function(t, e, n, r) {\n        return void 0 === t && (t = 5), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = .5), xt.localResponseNormalization(this, t, e, n, r);\n    }, t.prototype.pool = function(t, e, n, r, o) {\n        return this.throwIfDisposed(), xt.pool(this, t, e, n, r, o);\n    }, t.prototype.variable = function(t, e, n) {\n        return void 0 === t && (t = !0), this.throwIfDisposed(), yt().makeVariable(this, t, e, n);\n    }, t.prototype.unsortedSegmentSum = function(t, e) {\n        return this.throwIfDisposed(), xt.unsortedSegmentSum(this, t, e);\n    }, t.prototype.batchToSpaceND = function(t, e) {\n        return this.throwIfDisposed(), xt.batchToSpaceND(this, t, e);\n    }, t.prototype.spaceToBatchND = function(t, e) {\n        return this.throwIfDisposed(), xt.spaceToBatchND(this, t, e);\n    }, t.prototype.topk = function(t, e) {\n        return void 0 === t && (t = 1), void 0 === e && (e = !0), this.throwIfDisposed(), xt.topk(this, t, e);\n    }, t.prototype.stridedSlice = function(t, e, n, r, o, a, i, s) {\n        return void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.throwIfDisposed(), xt.stridedSlice(this, t, e, n, r, o, a, i, s);\n    }, t.prototype.depthToSpace = function(t, e) {\n        return this.throwIfDisposed(), xt.depthToSpace(this, t, e);\n    }, t.prototype.fft = function() {\n        return this.throwIfDisposed(), xt.spectral.fft(this);\n    }, t.prototype.ifft = function() {\n        return this.throwIfDisposed(), xt.spectral.ifft(this);\n    }, t.prototype.rfft = function() {\n        return this.throwIfDisposed(), xt.spectral.rfft(this);\n    }, t.prototype.irfft = function() {\n        return this.throwIfDisposed(), xt.spectral.irfft(this);\n    }, t;\n}();\nObject.defineProperty(wt, Symbol.hasInstance, {\n    value: function(t) {\n        return !!t && null != t.dataId && null != t.shape && null != t.dtype;\n    }\n});\nvar Ct, Et, Rt, It, kt, St = function(t) {\n    function n(e, n, r, o) {\n        var a = t.call(this, e.shape, e.dtype, e.dataId, o) || this;\n        return a.trainable = n, a.name = r, a;\n    }\n    return e(n, t), n.prototype.assign = function(t) {\n        if (t.dtype !== this.dtype) throw new Error(\"dtype of the new value (\" + t.dtype + \") and previous value (\" + this.dtype + \") must match\");\n        if (!S(t.shape, this.shape)) throw new Error(\"shape of the new value (\" + t.shape + \") and previous value (\" + this.shape + \") must match\");\n        yt().disposeTensor(this), this.dataId = t.dataId, yt().incRef(this, null);\n    }, n.prototype.dispose = function() {\n        yt().disposeVariable(this), this.isDisposedInternal = !0;\n    }, n;\n}(wt);\nObject.defineProperty(St, Symbol.hasInstance, {\n    value: function(t) {\n        return t instanceof wt && null != t.assign && t.assign instanceof Function;\n    }\n}), function(t) {\n    t.R0 = \"R0\", t.R1 = \"R1\", t.R2 = \"R2\", t.R3 = \"R3\", t.R4 = \"R4\", t.R5 = \"R5\", t.R6 = \"R6\";\n}(Ct || (Ct = {})), function(t) {\n    t.float32 = \"float32\", t.int32 = \"int32\", t.bool = \"int32\", t.complex64 = \"complex64\";\n}(Et || (Et = {})), function(t) {\n    t.float32 = \"float32\", t.int32 = \"int32\", t.bool = \"bool\", t.complex64 = \"complex64\";\n}(Rt || (Rt = {})), function(t) {\n    t.float32 = \"float32\", t.int32 = \"float32\", t.bool = \"float32\", t.complex64 = \"complex64\";\n}(It || (It = {})), function(t) {\n    t.float32 = \"complex64\", t.int32 = \"complex64\", t.bool = \"complex64\", t.complex64 = \"complex64\";\n}(kt || (kt = {}));\nvar At = {\n    float32: It,\n    int32: Et,\n    bool: Rt,\n    complex64: kt\n};\nfunction Tt(t, e) {\n    if (\"string\" === t || \"string\" === e) {\n        if (\"string\" === t && \"string\" === e) return \"string\";\n        throw new Error(\"Can not upcast \" + t + \" with \" + e);\n    }\n    return At[t][e];\n}\nfunction Dt(t) {\n    return Tt(t, \"int32\");\n}\nfunction Nt(t, e) {\n    if (t.dtype === e.dtype) return [\n        t,\n        e\n    ];\n    var n = Tt(t.dtype, e.dtype);\n    return [\n        t.cast(n),\n        e.cast(n)\n    ];\n}\nfunction Ft(t, e) {\n    C(t.dtype === e.dtype, function() {\n        return \"The dtypes of the first(\" + t.dtype + \") and second(\" + e.dtype + \") input must match\";\n    });\n}\nfunction _t(t) {\n    var e = [];\n    return function t(e, n, r) {\n        if (null == e) return;\n        if (e instanceof wt) return void n.push(e);\n        if (o = e, !Array.isArray(o) && \"object\" != typeof o) return;\n        var o;\n        var a = e;\n        for(var i in a){\n            var s = a[i];\n            r.has(s) || (r.add(s), t(s, n, r));\n        }\n    }(t, e, new Set), e;\n}\nvar Ot, Mt = Object.freeze({\n    makeTypesMatch: Nt,\n    assertTypesMatch: Ft,\n    isTensorInList: function(t, e) {\n        return e.some(function(e) {\n            return e.id === t.id;\n        });\n    },\n    getTensorsInContainer: _t\n}), Bt = function() {\n    function t() {\n        this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap, this.profiling = !1, this.activeProfile = {\n            newBytes: 0,\n            newTensors: 0,\n            peakBytes: 0,\n            kernels: [],\n            result: null\n        };\n    }\n    return t.prototype.dispose = function() {\n        for(var t in this.registeredVariables)this.registeredVariables[t].dispose();\n    }, t;\n}(), Pt = function() {\n    function t(t) {\n        this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Bt;\n    }\n    return t.prototype.ready = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (null != this.pendingBackendInit) return [\n                            2,\n                            this.pendingBackendInit.then(function() {})\n                        ];\n                        if (null != this.backendInstance) return [\n                            2\n                        ];\n                        t = this.getSortedBackends(), e = 0, r.label = 1;\n                    case 1:\n                        return e < t.length ? (n = t[e], [\n                            4,\n                            this.initializeBackend(n).success\n                        ]) : [\n                            3,\n                            5\n                        ];\n                    case 2:\n                        return r.sent() ? [\n                            4,\n                            this.setBackend(n)\n                        ] : [\n                            3,\n                            4\n                        ];\n                    case 3:\n                        return r.sent(), [\n                            2\n                        ];\n                    case 4:\n                        return e++, [\n                            3,\n                            1\n                        ];\n                    case 5:\n                        throw new Error(\"Could not initialize any backends, all backend initializations failed.\");\n                }\n            });\n        });\n    }, Object.defineProperty(t.prototype, \"backend\", {\n        get: function() {\n            if (null != this.pendingBackendInit) throw new Error(\"Backend '\" + this.backendName + \"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods\");\n            if (null == this.backendInstance) {\n                var t = this.initializeBackendsAndReturnBest(), e = t.name;\n                if (t.asyncInit) throw new Error(\"The highest priority backend '\" + e + \"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods\");\n                this.setBackend(e);\n            }\n            return this.backendInstance;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.backendNames = function() {\n        return Object.keys(this.registryFactory);\n    }, t.prototype.findBackend = function(t) {\n        if (!(t in this.registry)) {\n            if (!(t in this.registryFactory)) return null;\n            if (this.initializeBackend(t).asyncInit) return null;\n        }\n        return this.registry[t];\n    }, t.prototype.findBackendFactory = function(t) {\n        return t in this.registryFactory ? this.registryFactory[t].factory : null;\n    }, t.prototype.registerBackend = function(t, e, n) {\n        return void 0 === n && (n = 1), t in this.registryFactory ? (console.warn(t + \" backend was already registered. Reusing existing backend factory.\"), !1) : (this.registryFactory[t] = {\n            factory: e,\n            priority: n\n        }, !0);\n    }, t.prototype.setBackend = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (null == this.registryFactory[t]) throw new Error(\"Backend name '\" + t + \"' not found in registry\");\n                        return this.backendName = t, null != this.registry[t] ? [\n                            3,\n                            4\n                        ] : (this.backendInstance = null, e = this.initializeBackend(t), n = e.success, e.asyncInit ? [\n                            4,\n                            n\n                        ] : [\n                            3,\n                            2\n                        ]);\n                    case 1:\n                        return o = r.sent(), [\n                            3,\n                            3\n                        ];\n                    case 2:\n                        o = n, r.label = 3;\n                    case 3:\n                        if (!o) return [\n                            2,\n                            !1\n                        ];\n                        r.label = 4;\n                    case 4:\n                        return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new ut(this.backendInstance), [\n                            2,\n                            !0\n                        ];\n                }\n            });\n        });\n    }, t.prototype.setupRegisteredKernels = function() {\n        var t = this;\n        f(this.backendName).forEach(function(e) {\n            null != e.setupFunc && e.setupFunc(t.backendInstance);\n        });\n    }, t.prototype.disposeRegisteredKernels = function(t) {\n        var e = this;\n        f(t).forEach(function(n) {\n            null != n.disposeFunc && n.disposeFunc(e.registry[t]);\n        });\n    }, t.prototype.initializeBackend = function(t) {\n        var e = this, n = this.registryFactory[t];\n        if (null == n) throw new Error(\"Cannot initialize backend \" + t + \", no registration found.\");\n        try {\n            var r = n.factory();\n            if (Promise.resolve(r) === r) {\n                var o = ++this.pendingBackendInitId, a = r.then(function(n) {\n                    return !(o < e.pendingBackendInitId) && (e.registry[t] = n, e.pendingBackendInit = null, !0);\n                }).catch(function(n) {\n                    return !(o < e.pendingBackendInitId) && (e.pendingBackendInit = null, console.warn(\"Initialization of backend \" + t + \" failed\"), console.warn(n.stack || n.message), !1);\n                });\n                return this.pendingBackendInit = a, {\n                    success: a,\n                    asyncInit: !0\n                };\n            }\n            return this.registry[t] = r, {\n                success: !0,\n                asyncInit: !1\n            };\n        } catch (e) {\n            return console.warn(\"Initialization of backend \" + t + \" failed\"), console.warn(e.stack || e.message), {\n                success: !1,\n                asyncInit: !1\n            };\n        }\n    }, t.prototype.removeBackend = function(t) {\n        if (!(t in this.registryFactory)) throw new Error(t + \" backend not found in registry\");\n        this.backendName === t && null != this.pendingBackendInit && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);\n    }, t.prototype.getSortedBackends = function() {\n        var t = this;\n        if (0 === Object.keys(this.registryFactory).length) throw new Error(\"No backend found in registry.\");\n        return Object.keys(this.registryFactory).sort(function(e, n) {\n            return t.registryFactory[n].priority - t.registryFactory[e].priority;\n        });\n    }, t.prototype.initializeBackendsAndReturnBest = function() {\n        for(var t = this.getSortedBackends(), e = 0; e < t.length; e++){\n            var n = t[e], r = this.initializeBackend(n), o = r.success, a = r.asyncInit;\n            if (a || o) return {\n                name: n,\n                asyncInit: a\n            };\n        }\n        throw new Error(\"Could not initialize any backends, all backend initializations failed.\");\n    }, t.prototype.moveData = function(t, e) {\n        var n = this.state.tensorInfo.get(e), r = n.backend, o = this.readSync(e);\n        r.disposeData(e), n.backend = t, t.move(e, o, n.shape, n.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;\n    }, t.prototype.tidy = function(t, e) {\n        var n, r = this, o = null;\n        if (null == e) {\n            if (\"function\" != typeof t) throw new Error(\"Please provide a function to tidy()\");\n            e = t;\n        } else {\n            if (\"string\" != typeof t && !(t instanceof String)) throw new Error(\"When calling with two arguments, the first argument to tidy() must be a string\");\n            if (\"function\" != typeof e) throw new Error(\"When calling with two arguments, the 2nd argument to tidy() must be a function\");\n            o = t;\n        }\n        return this.scopedRun(function() {\n            return r.startScope(o);\n        }, function() {\n            return r.endScope(n);\n        }, function() {\n            return (n = e()) instanceof Promise && console.error(\"Cannot return a Promise inside of tidy.\"), n;\n        });\n    }, t.prototype.scopedRun = function(t, e, n) {\n        t();\n        try {\n            var r = n();\n            return e(), r;\n        } catch (t) {\n            throw e(), t;\n        }\n    }, t.prototype.nextTensorId = function() {\n        return t.nextTensorId++;\n    }, t.prototype.nextVariableId = function() {\n        return t.nextVariableId++;\n    }, t.prototype.clone = function(t) {\n        var e = this.makeTensorFromDataId(t.dataId, t.shape, t.dtype), n = {\n            x: t\n        };\n        return this.addTapeNode(this.state.activeScope.name, n, [\n            e\n        ], function(t) {\n            return {\n                x: function() {\n                    return t.toFloat();\n                }\n            };\n        }, [], {}), e;\n    }, t.prototype.runKernel = function(t, e, n, r, o) {\n        return this.runKernelFunc(null, e, null, t, n, r, o);\n    }, t.prototype.shouldCheckForMemLeaks = function() {\n        return this.ENV.getBool(\"IS_TEST\");\n    }, t.prototype.checkKernelForMemLeak = function(t, e, n) {\n        var r = this.backend.numDataIds(), o = 0;\n        n.forEach(function(t) {\n            o += \"complex64\" === t.dtype ? 3 : 1;\n        });\n        var a = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], i = r - e - o - a;\n        if (i > 0) throw new Error(\"Backend '\" + this.backendName + \"' has an internal memory leak (\" + i + \" data ids) after running '\" + t + \"'\");\n    }, t.prototype.runKernelFunc = function(t, e, n, r, o, a, i) {\n        var s, u = this, c = [], h = this.isTapeOn();\n        null == r && (r = null != this.state.activeScope ? this.state.activeScope.name : \"\");\n        var f, d = this.state.numBytes, p = this.state.numTensors;\n        this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);\n        var v, g = l(r, this.backendName);\n        if (null != g) f = function() {\n            var t = u.backend.numDataIds();\n            v = g.kernelFunc({\n                inputs: e,\n                attrs: o,\n                backend: u.backend\n            });\n            var n = Array.isArray(v) ? v : [\n                v\n            ];\n            u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, t, n);\n            var s = n.map(function(t) {\n                var e = t.dataId, n = t.shape, r = t.dtype;\n                return u.makeTensorFromDataId(e, n, r);\n            });\n            if (h) {\n                var l = u.getTensorsForGradient(r, e, s);\n                if (null == l) {\n                    null == i && (i = []);\n                    var f = s.filter(function(t, e) {\n                        return i[e];\n                    });\n                    l = (a || []).slice().concat(f);\n                }\n                c = u.saveTensorsForBackwardMode(l);\n            }\n            return s;\n        };\n        else {\n            var m = function(t) {\n                h && (c = t.map(function(t) {\n                    return u.keep(u.clone(t));\n                }));\n            };\n            f = function() {\n                var e = u.backend.numDataIds();\n                v = u.tidy(function() {\n                    return t(u.backend, m);\n                });\n                var n = Array.isArray(v) ? v : [\n                    v\n                ];\n                return u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(r, e, n), n;\n            };\n        }\n        return this.scopedRun(function() {\n            return u.state.kernelDepth++;\n        }, function() {\n            return u.state.kernelDepth--;\n        }, function() {\n            s = u.ENV.getBool(\"DEBUG\") ? u.profiler.profileKernel(r, e, function() {\n                return f();\n            }) : f();\n        }), h && this.addTapeNode(r, e, s, n, c, o), this.state.profiling && this.state.activeProfile.kernels.push({\n            name: r,\n            bytesAdded: this.state.numBytes - d,\n            totalBytesSnapshot: this.state.numBytes,\n            tensorsAdded: this.state.numTensors - p,\n            totalTensorsSnapshot: this.state.numTensors,\n            inputShapes: Object.keys(e).map(function(t) {\n                return e[t].shape;\n            }),\n            outputShapes: s.map(function(t) {\n                return t.shape;\n            })\n        }), Array.isArray(v) ? s : s[0];\n    }, t.prototype.saveTensorsForBackwardMode = function(t) {\n        var e = this;\n        return t.map(function(t) {\n            return e.keep(e.clone(t));\n        });\n    }, t.prototype.getTensorsForGradient = function(t, e, n) {\n        var r = h(t);\n        if (null != r) {\n            var o = r.inputsToSave || [], a = r.outputsToSave || [], i = void 0;\n            r.saveAllInputs ? (C(Array.isArray(e), function() {\n                return \"saveAllInputs is true, expected inputs to be an array.\";\n            }), i = Object.keys(e).map(function(t) {\n                return e[t];\n            })) : i = o.map(function(t) {\n                return e[t];\n            });\n            var s = n.filter(function(t, e) {\n                return a[e];\n            });\n            return i.concat(s);\n        }\n        return null;\n    }, t.prototype.makeTensor = function(t, e, n, r) {\n        if (null == t) throw new Error(\"Values passed to engine.makeTensor() are null\");\n        n = n || \"float32\", r = r || this.backend;\n        var o = t;\n        \"string\" === n && H(t[0]) && (o = t.map(function(t) {\n            return rt(t);\n        }));\n        var a = r.write(o, e, n), i = new wt(e, n, a, this.nextTensorId());\n        if (this.incRef(i, r), \"string\" === n) {\n            var s = this.state.tensorInfo.get(a), u = G(o);\n            this.state.numBytes += u - s.bytes, s.bytes = u;\n        }\n        return i;\n    }, t.prototype.makeTensorFromDataId = function(t, e, n, r) {\n        var o = new wt(e, n = n || \"float32\", t, this.nextTensorId());\n        return this.incRef(o, r), o;\n    }, t.prototype.makeVariable = function(t, e, n, r) {\n        void 0 === e && (e = !0), n = n || this.nextVariableId().toString(), null != r && r !== t.dtype && (t = t.asType(r));\n        var o = new St(t, e, n, this.nextTensorId());\n        if (null != this.state.registeredVariables[o.name]) throw new Error(\"Variable with name \" + o.name + \" was already registered\");\n        return this.state.registeredVariables[o.name] = o, this.incRef(o, this.backend), o;\n    }, t.prototype.incRef = function(t, e) {\n        var n = this.state.tensorInfo.has(t.dataId) ? this.state.tensorInfo.get(t.dataId).refCount : 0;\n        if (this.state.numTensors++, \"string\" === t.dtype && this.state.numStringTensors++, 0 === n) {\n            this.state.numDataBuffers++;\n            var r = 0;\n            \"complex64\" !== t.dtype && \"string\" !== t.dtype && (r = t.size * z(t.dtype)), this.state.tensorInfo.set(t.dataId, {\n                backend: e || this.backend,\n                dtype: t.dtype,\n                shape: t.shape,\n                bytes: r,\n                refCount: 0\n            }), this.state.numBytes += r;\n        }\n        this.state.tensorInfo.get(t.dataId).refCount++, t instanceof St || this.track(t);\n    }, t.prototype.disposeTensor = function(t) {\n        if (this.state.tensorInfo.has(t.dataId)) {\n            this.state.numTensors--, \"string\" === t.dtype && this.state.numStringTensors--;\n            var e = this.state.tensorInfo.get(t.dataId);\n            e.refCount <= 1 ? (\"complex64\" !== t.dtype && (this.state.numBytes -= e.bytes), this.state.numDataBuffers--, e.backend.disposeData(t.dataId), this.state.tensorInfo.delete(t.dataId)) : this.state.tensorInfo.get(t.dataId).refCount--;\n        }\n    }, t.prototype.disposeVariables = function() {\n        for(var t in this.state.registeredVariables){\n            var e = this.state.registeredVariables[t];\n            this.disposeVariable(e);\n        }\n    }, t.prototype.disposeVariable = function(t) {\n        this.disposeTensor(t), null != this.state.registeredVariables[t.name] && delete this.state.registeredVariables[t.name];\n    }, t.prototype.memory = function() {\n        var t = this.backend.memory();\n        return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = !0, null == t.reasons && (t.reasons = []), t.reasons.push(\"Memory usage by string tensors is approximate (2 bytes per character)\")), t;\n    }, t.prototype.profile = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n;\n            return r(this, function(r) {\n                return this.state.profiling = !0, e = this.state.numBytes, n = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function(t) {\n                    return t.totalBytesSnapshot;\n                })), this.state.activeProfile.newBytes = this.state.numBytes - e, this.state.activeProfile.newTensors = this.state.numTensors - n, [\n                    2,\n                    this.state.activeProfile\n                ];\n            });\n        });\n    }, t.prototype.isTapeOn = function() {\n        return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;\n    }, t.prototype.addTapeNode = function(t, e, n, r, o, a) {\n        var i = this, s = {\n            id: this.state.nextTapeNodeId++,\n            kernelName: t,\n            inputs: e,\n            outputs: n,\n            saved: o\n        }, u = h(t);\n        null != u && (r = u.gradFunc), null != r && (s.gradient = function(t) {\n            return t = t.map(function(t, e) {\n                if (null == t) {\n                    var r = n[e], o = tt(r.size, r.dtype);\n                    return i.makeTensor(o, r.shape, r.dtype);\n                }\n                return t;\n            }), r(t.length > 1 ? t : t[0], o, a);\n        }), this.state.activeTape.push(s);\n    }, t.prototype.keep = function(t) {\n        return t.kept = !0, t;\n    }, t.prototype.startTape = function() {\n        0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;\n    }, t.prototype.endTape = function() {\n        this.state.gradientDepth--;\n    }, t.prototype.startScope = function(t) {\n        var e = {\n            track: [],\n            name: \"unnamed scope\",\n            id: this.state.nextScopeId++\n        };\n        t && (e.name = t), this.state.scopeStack.push(e), this.state.activeScope = e;\n    }, t.prototype.endScope = function(t) {\n        for(var e = this, n = _t(t), r = new Set(n.map(function(t) {\n            return t.id;\n        })), o = 0; o < this.state.activeScope.track.length; o++){\n            var a = this.state.activeScope.track[o];\n            a.kept || r.has(a.id) || a.dispose();\n        }\n        var i = this.state.scopeStack.pop();\n        this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach(function(t) {\n            t.kept || t.scopeId !== i.id || e.track(t);\n        });\n    }, t.prototype.gradients = function(t, e, n, r) {\n        var o = this;\n        if (void 0 === r && (r = !1), C(e.length > 0, function() {\n            return \"gradients() received an empty list of xs.\";\n        }), null != n && \"float32\" !== n.dtype) throw new Error(\"dy must have 'float32' dtype, but has '\" + n.dtype + \"'\");\n        var a = this.scopedRun(function() {\n            return o.startTape();\n        }, function() {\n            return o.endTape();\n        }, function() {\n            return o.tidy(\"forward\", t);\n        });\n        C(a instanceof wt, function() {\n            return \"The result y returned by f() must be a tensor.\";\n        });\n        var i = function(t, e, n) {\n            for(var r = {}, o = {}, a = 0; a < e.length; a++)r[e[a].id] = !0;\n            for(a = 0; a < t.length; a++){\n                var i = (p = t[a]).inputs;\n                for(var s in i){\n                    for(var u = i[s], c = !1, l = 0; l < e.length; l++)if (r[u.id]) {\n                        p.outputs.forEach(function(t) {\n                            return r[t.id] = !0;\n                        }), c = !0, o[p.id] = !0;\n                        break;\n                    }\n                    if (c) break;\n                }\n            }\n            var h = {};\n            h[n.id] = !0;\n            var f = {};\n            for(a = t.length - 1; a >= 0; a--)for(i = (p = t[a]).inputs, l = 0; l < p.outputs.length; l++)if (h[p.outputs[l].id]) {\n                for(var s in i)h[i[s].id] = !0, f[p.id] = !0;\n                break;\n            }\n            var d = [];\n            for(a = 0; a < t.length; a++){\n                var p;\n                if (o[(p = t[a]).id] && f[p.id]) {\n                    var v = {};\n                    for(var s in p.inputs){\n                        var g = p.inputs[s];\n                        r[g.id] && (v[s] = g);\n                    }\n                    var m = Object.assign({}, p);\n                    m.inputs = v, m.outputs = p.outputs, d.push(m);\n                }\n            }\n            return d;\n        }(this.state.activeTape, e, a);\n        if (!r && 0 === i.length && e.length > 0) throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.\");\n        return this.tidy(\"backward\", function() {\n            var t, r, s = {};\n            s[a.id] = null == n ? (t = a.shape, r = Z(k(t), \"float32\"), Lt.makeTensor(r, t, \"float32\")) : n, function(t, e, n) {\n                for(var r = function(r) {\n                    var o = e[r], a = [];\n                    if (o.outputs.forEach(function(e) {\n                        var n = t[e.id];\n                        null != n ? a.push(n) : a.push(null);\n                    }), null == o.gradient) throw new Error(\"Cannot compute gradient: gradient function not found for \" + o.kernelName + \".\");\n                    var i = o.gradient(a), s = function(e) {\n                        if (!(e in i)) throw new Error(\"Cannot backprop through input \" + e + \". Available gradients found: \" + Object.keys(i) + \".\");\n                        var r = n(function() {\n                            return i[e]();\n                        });\n                        if (\"float32\" !== r.dtype) throw new Error(\"Error in gradient for op \" + o.kernelName + \". The gradient of input \" + e + \" must have 'float32' dtype, but has '\" + r.dtype + \"'\");\n                        var a = o.inputs[e];\n                        if (!S(r.shape, a.shape)) throw new Error(\"Error in gradient for op \" + o.kernelName + \". The gradient of input '\" + e + \"' has shape '\" + r.shape + \"', which does not match the shape of the input '\" + a.shape + \"'\");\n                        if (null == t[a.id]) t[a.id] = r;\n                        else {\n                            var s = t[a.id];\n                            t[a.id] = s.add(r), s.dispose();\n                        }\n                    };\n                    for(var u in o.inputs)s(u);\n                }, o = e.length - 1; o >= 0; o--)r(o);\n            }(s, i, function(t) {\n                return o.tidy(t);\n            });\n            var u = e.map(function(t) {\n                return s[t.id];\n            });\n            return 0 === o.state.gradientDepth && (o.state.activeTape.forEach(function(t) {\n                for(var e = 0, n = t.saved; e < n.length; e++){\n                    n[e].dispose();\n                }\n            }), o.state.activeTape = null), {\n                value: a,\n                grads: u\n            };\n        });\n    }, t.prototype.customGrad = function(t) {\n        var e = this;\n        return C(X(t), function() {\n            return \"The f passed in customGrad(f) must be a function.\";\n        }), function() {\n            for(var n, r = [], o = 0; o < arguments.length; o++)r[o] = arguments[o];\n            C(r.every(function(t) {\n                return t instanceof wt;\n            }), function() {\n                return \"The args passed in customGrad(f)(x1, x2,...) must all be tensors\";\n            });\n            var a = {};\n            return r.forEach(function(t, e) {\n                a[e] = t;\n            }), e.runKernelFunc(function(e, o) {\n                return C((n = t.apply(void 0, r.concat([\n                    o\n                ]))).value instanceof wt, function() {\n                    return \"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor\";\n                }), C(X(n.gradFunc), function() {\n                    return \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.\";\n                }), n.value;\n            }, a, function(t, e) {\n                var o = n.gradFunc(t, e), a = Array.isArray(o) ? o : [\n                    o\n                ];\n                C(a.length === r.length, function() {\n                    return \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).\";\n                }), C(a.every(function(t) {\n                    return t instanceof wt;\n                }), function() {\n                    return \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.\";\n                });\n                var i = {};\n                return a.forEach(function(t, e) {\n                    i[e] = function() {\n                        return t;\n                    };\n                }), i;\n            });\n        };\n    }, t.prototype.readSync = function(t) {\n        return this.state.tensorInfo.get(t).backend.readSync(t);\n    }, t.prototype.read = function(t) {\n        return this.state.tensorInfo.get(t).backend.read(t);\n    }, t.prototype.time = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        return e = et(), [\n                            4,\n                            this.backend.time(t)\n                        ];\n                    case 1:\n                        return (n = r.sent()).wallMs = et() - e, [\n                            2,\n                            n\n                        ];\n                }\n            });\n        });\n    }, t.prototype.track = function(t) {\n        return null != this.state.activeScope && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t;\n    }, Object.defineProperty(t.prototype, \"registeredVariables\", {\n        get: function() {\n            return this.state.registeredVariables;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.reset = function() {\n        for(var t in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Bt, this.registry)this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];\n        this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;\n    }, t.nextTensorId = 0, t.nextVariableId = 0, t;\n}();\nvar Lt = function() {\n    var t = function() {\n        if (null == Ot) {\n            var t = void 0;\n            if (false) {}\n            else if (\"undefined\" != typeof global) t = global;\n            else if (\"undefined\" != typeof process) t = process;\n            else {\n                if (\"undefined\" == typeof self) throw new Error(\"Could not find a global object\");\n                t = self;\n            }\n            Ot = t;\n        }\n        return Ot;\n    }();\n    if (null == t._tfengine) {\n        var e = new o(t);\n        t._tfengine = new Pt(e);\n    }\n    return function(t) {\n        s = t;\n    }(t._tfengine.ENV), yt = function() {\n        return t._tfengine;\n    }, t._tfengine;\n}();\nfunction Wt() {\n    return  false || \"undefined\" != typeof WorkerGlobalScope;\n}\nvar Ut = i();\nUt.registerFlag(\"DEBUG\", function() {\n    return !1;\n}, function(t) {\n    t && console.warn(\"Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.\");\n}), Ut.registerFlag(\"IS_BROWSER\", function() {\n    return Wt();\n}), Ut.registerFlag(\"IS_NODE\", function() {\n    return \"undefined\" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;\n}), Ut.registerFlag(\"IS_CHROME\", function() {\n    return \"undefined\" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n}), Ut.registerFlag(\"PROD\", function() {\n    return !1;\n}), Ut.registerFlag(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\", function() {\n    return Ut.getBool(\"DEBUG\");\n}), Ut.registerFlag(\"DEPRECATION_WARNINGS_ENABLED\", function() {\n    return !0;\n}), Ut.registerFlag(\"IS_TEST\", function() {\n    return !1;\n});\nvar Vt, zt, Gt, Ht = {}, qt = {\n    alpha: !1,\n    antialias: !1,\n    premultipliedAlpha: !1,\n    preserveDrawingBuffer: !1,\n    depth: !1,\n    stencil: !1,\n    failIfMajorPerformanceCaveat: !0\n};\nfunction Kt(t, e) {\n    Ht[t] = e;\n}\nfunction jt(t) {\n    t in Ht || (Ht[t] = function(t) {\n        if (1 !== t && 2 !== t) throw new Error(\"Cannot get WebGL rendering context, WebGL is disabled.\");\n        var e = function(t) {\n            if (\"undefined\" != typeof OffscreenCanvas && 2 === t) return new OffscreenCanvas(300, 150);\n            if (\"undefined\" != typeof document) return document.createElement(\"canvas\");\n            throw new Error(\"Cannot create a canvas in this context\");\n        }(t);\n        if (e.addEventListener(\"webglcontextlost\", function(e) {\n            e.preventDefault(), delete Ht[t];\n        }, !1), 1 === t) return e.getContext(\"webgl\", qt) || e.getContext(\"experimental-webgl\", qt);\n        return e.getContext(\"webgl2\", qt);\n    }(t));\n    var e = Ht[t];\n    return e.isContextLost() ? (delete Ht[t], jt(t)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), Ht[t]);\n}\nfunction Xt(t, e) {\n    return [\n        e,\n        t\n    ];\n}\nfunction Yt(t) {\n    var e = k(t);\n    return D(Math.ceil(e / 4));\n}\nfunction $t(t, e) {\n    return [\n        Math.max(1, Math.ceil(e / 2)),\n        Math.max(1, Math.ceil(t / 2))\n    ];\n}\nfunction Qt(t, e) {\n    var n, r, o, a, s, u, c, l, h, f = t;\n    return 2 === i().getNumber(\"WEBGL_VERSION\") ? (n = f.R32F, r = f.R16F, o = f.RGBA16F, a = f.RGBA32F, s = f.RED, u = 4, c = 1, l = f.HALF_FLOAT, h = f.FLOAT) : (n = t.RGBA, r = t.RGBA, o = t.RGBA, a = f.RGBA, s = t.RGBA, u = 4, c = 4, l = null != e ? e.HALF_FLOAT_OES : null, h = t.FLOAT), {\n        internalFormatFloat: n,\n        internalFormatHalfFloat: r,\n        internalFormatPackedHalfFloat: o,\n        internalFormatPackedFloat: a,\n        textureFormatFloat: s,\n        downloadTextureFormat: t.RGBA,\n        downloadUnpackNumChannels: u,\n        defaultNumChannels: c,\n        textureTypeHalfFloat: l,\n        textureTypeFloat: h\n    };\n}\nfunction Jt(t, e, n) {\n    var r = n();\n    return e && function(t) {\n        var e = t.getError();\n        if (e !== t.NO_ERROR) throw new Error(\"WebGL Error: \" + ne(t, e));\n    }(t), r;\n}\n!function(t) {\n    t[t.DENSE = 0] = \"DENSE\", t[t.SHARED_BATCH = 1] = \"SHARED_BATCH\";\n}(Vt || (Vt = {})), function(t) {\n    t[t.RENDER = 0] = \"RENDER\", t[t.UPLOAD = 1] = \"UPLOAD\", t[t.PIXELS = 2] = \"PIXELS\", t[t.DOWNLOAD = 3] = \"DOWNLOAD\";\n}(zt || (zt = {})), function(t) {\n    t[t.UNPACKED_FLOAT16 = 0] = \"UNPACKED_FLOAT16\", t[t.UNPACKED_FLOAT32 = 1] = \"UNPACKED_FLOAT32\", t[t.PACKED_4X1_UNSIGNED_BYTE = 2] = \"PACKED_4X1_UNSIGNED_BYTE\", t[t.PACKED_2X2_FLOAT32 = 3] = \"PACKED_2X2_FLOAT32\", t[t.PACKED_2X2_FLOAT16 = 4] = \"PACKED_2X2_FLOAT16\";\n}(Gt || (Gt = {}));\nvar Zt = 5.96e-8, te = 65504;\nfunction ee(t) {\n    return !!(i().getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\") || 0 === t || Zt < Math.abs(t) && Math.abs(t) < te);\n}\nfunction ne(t, e) {\n    switch(e){\n        case t.NO_ERROR:\n            return \"NO_ERROR\";\n        case t.INVALID_ENUM:\n            return \"INVALID_ENUM\";\n        case t.INVALID_VALUE:\n            return \"INVALID_VALUE\";\n        case t.INVALID_OPERATION:\n            return \"INVALID_OPERATION\";\n        case t.INVALID_FRAMEBUFFER_OPERATION:\n            return \"INVALID_FRAMEBUFFER_OPERATION\";\n        case t.OUT_OF_MEMORY:\n            return \"OUT_OF_MEMORY\";\n        case t.CONTEXT_LOST_WEBGL:\n            return \"CONTEXT_LOST_WEBGL\";\n        default:\n            return \"Unknown error code \" + e;\n    }\n}\nfunction re(t, e, n) {\n    return ke(t, e, function() {\n        return t.getExtension(n);\n    }, 'Extension \"' + n + '\" not supported on this browser.');\n}\nfunction oe(t, e, n) {\n    var r = ke(t, e, function() {\n        return t.createShader(t.VERTEX_SHADER);\n    }, \"Unable to create vertex WebGLShader.\");\n    if (Jt(t, e, function() {\n        return t.shaderSource(r, n);\n    }), Jt(t, e, function() {\n        return t.compileShader(r);\n    }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw console.log(t.getShaderInfoLog(r)), new Error(\"Failed to compile vertex shader.\");\n    return r;\n}\nfunction ae(t, e, n) {\n    var r = ke(t, e, function() {\n        return t.createShader(t.FRAGMENT_SHADER);\n    }, \"Unable to create fragment WebGLShader.\");\n    if (Jt(t, e, function() {\n        return t.shaderSource(r, n);\n    }), Jt(t, e, function() {\n        return t.compileShader(r);\n    }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw function(t, e) {\n        var n = ue.exec(e);\n        if (null == n) return console.log(\"Couldn't parse line number in error: \" + e), void console.log(t);\n        for(var r = +n[1], o = t.split(\"\\n\"), a = o.length.toString().length + 2, i = o.map(function(t, e) {\n            return N((e + 1).toString(), a) + t;\n        }), s = 0, u = 0; u < i.length; u++)s = Math.max(i[u].length, s);\n        var c = i.slice(0, r - 1), l = i.slice(r - 1, r), h = i.slice(r);\n        console.log(c.join(\"\\n\")), console.log(e.split(\"\\n\")[0]), console.log(\"%c \" + N(l[0], s), \"border:1px solid red; background-color:#e3d2d2; color:#a61717\"), console.log(h.join(\"\\n\"));\n    }(n, t.getShaderInfoLog(r)), new Error(\"Failed to compile fragment shader.\");\n    return r;\n}\nvar ie, se, ue = /ERROR: [0-9]+:([0-9]+):/g;\nfunction ce(t, e) {\n    return ke(t, e, function() {\n        return t.createProgram();\n    }, \"Unable to create WebGLProgram.\");\n}\nfunction le(t, e, n) {\n    if (Jt(t, e, function() {\n        return t.linkProgram(n);\n    }), !1 === t.getProgramParameter(n, t.LINK_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error(\"Failed to link vertex and fragment shaders.\");\n}\nfunction he(t, e, n) {\n    if (Jt(t, e, function() {\n        return t.validateProgram(n);\n    }), !1 === t.getProgramParameter(n, t.VALIDATE_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error(\"Shader program validation failed.\");\n}\nfunction fe(t, e, n) {\n    var r = ke(t, e, function() {\n        return t.createBuffer();\n    }, \"Unable to create WebGLBuffer\");\n    return Jt(t, e, function() {\n        return t.bindBuffer(t.ARRAY_BUFFER, r);\n    }), Jt(t, e, function() {\n        return t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW);\n    }), r;\n}\nfunction de(t, e, n) {\n    var r = ke(t, e, function() {\n        return t.createBuffer();\n    }, \"Unable to create WebGLBuffer\");\n    return Jt(t, e, function() {\n        return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, r);\n    }), Jt(t, e, function() {\n        return t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW);\n    }), r;\n}\nfunction pe(t, e) {\n    return ke(t, e, function() {\n        return t.createTexture();\n    }, \"Unable to create WebGLTexture.\");\n}\nfunction ve(t, e) {\n    var n = i().getNumber(\"WEBGL_MAX_TEXTURE_SIZE\");\n    if (t <= 0 || e <= 0) {\n        var r = \"[\" + t + \"x\" + e + \"]\";\n        throw new Error(\"Requested texture size \" + r + \" is invalid.\");\n    }\n    if (t > n || e > n) {\n        r = \"[\" + t + \"x\" + e + \"]\";\n        throw new Error(\"Requested texture size \" + r + \" greater than WebGL maximum on this browser / GPU \" + (\"[\" + n + \"x\" + n + \"]\") + \".\");\n    }\n}\nfunction ge(t, e) {\n    return ke(t, e, function() {\n        return t.createFramebuffer();\n    }, \"Unable to create WebGLFramebuffer.\");\n}\nfunction me(t, e, n, r, o, a, i, s) {\n    var u = t.getAttribLocation(n, r);\n    return -1 !== u && (Jt(t, e, function() {\n        return t.bindBuffer(t.ARRAY_BUFFER, o);\n    }), Jt(t, e, function() {\n        return t.vertexAttribPointer(u, a, t.FLOAT, !1, i, s);\n    }), Jt(t, e, function() {\n        return t.enableVertexAttribArray(u);\n    }), !0);\n}\nfunction ye(t, e, n, r) {\n    Se(t, r), Jt(t, e, function() {\n        return t.activeTexture(t.TEXTURE0 + r);\n    }), Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, n);\n    });\n}\nfunction xe(t, e, n, r) {\n    return ke(t, e, function() {\n        return t.getUniformLocation(n, r);\n    }, 'uniform \"' + r + '\" not present in program.');\n}\nfunction be(t, e, n) {\n    return t.getUniformLocation(e, n);\n}\nfunction we(t, e, n, r, o, a) {\n    Jt(t, e, function() {\n        return ye(t, e, r, a);\n    }), Jt(t, e, function() {\n        return t.uniform1i(o, a);\n    });\n}\nfunction Ce(t, e, n, r) {\n    Jt(t, e, function() {\n        return t.bindFramebuffer(t.FRAMEBUFFER, r);\n    }), Jt(t, e, function() {\n        return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);\n    });\n}\nfunction Ee(t, e, n) {\n    Jt(t, e, function() {\n        return t.bindFramebuffer(t.FRAMEBUFFER, n);\n    }), Jt(t, e, function() {\n        return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0);\n    });\n}\nfunction Re(t) {\n    var e = t.checkFramebufferStatus(t.FRAMEBUFFER);\n    if (e !== t.FRAMEBUFFER_COMPLETE) throw new Error(\"Error binding framebuffer: \" + Ie(t, e));\n}\nfunction Ie(t, e) {\n    switch(e){\n        case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            return \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\";\n        case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            return \"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\";\n        case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            return \"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\";\n        case t.FRAMEBUFFER_UNSUPPORTED:\n            return \"FRAMEBUFFER_UNSUPPORTED\";\n        default:\n            return \"unknown error \" + e;\n    }\n}\nfunction ke(t, e, n, r) {\n    var o = Jt(t, e, function() {\n        return n();\n    });\n    if (null == o) throw new Error(r);\n    return o;\n}\nfunction Se(t, e) {\n    var n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, r = e + t.TEXTURE0;\n    if (r < t.TEXTURE0 || r > n) throw new Error(\"textureUnit must be in \" + (\"[gl.TEXTURE0, gl.TEXTURE\" + n + \"]\") + \".\");\n}\nfunction Ae(t, e) {\n    return void 0 === e && (e = 2), k(t.slice(0, t.length - e));\n}\nfunction Te(t) {\n    if (0 === t.length) throw Error(\"Cannot get rows and columns of an empty shape array.\");\n    return [\n        t.length > 1 ? t[t.length - 2] : 1,\n        t[t.length - 1]\n    ];\n}\nfunction De(t) {\n    var e = [\n        1,\n        1,\n        1\n    ];\n    return 0 === t.length || 1 === t.length && 1 === t[0] || (e = [\n        Ae(t)\n    ].concat(Te(t))), e;\n}\nfunction Ne(t, e) {\n    var n;\n    void 0 === e && (e = !1);\n    var r = i().getNumber(\"WEBGL_MAX_TEXTURE_SIZE\");\n    if (e && (r *= 2, 1 === (t = t.map(function(e, n) {\n        return n >= t.length - 2 ? b(t[n]) : t[n];\n    })).length && (t = [\n        2,\n        t[0]\n    ])), 2 !== t.length) {\n        var o = M(t);\n        t = o.newShape;\n    }\n    var a = k(t);\n    if (t.length <= 1 && a <= r) return [\n        1,\n        a\n    ];\n    if (2 === t.length && t[0] <= r && t[1] <= r) return t;\n    if (3 === t.length && t[0] * t[1] <= r && t[2] <= r) return [\n        t[0] * t[1],\n        t[2]\n    ];\n    if (3 === t.length && t[0] <= r && t[1] * t[2] <= r) return [\n        t[0],\n        t[1] * t[2]\n    ];\n    if (4 === t.length && t[0] * t[1] * t[2] <= r && t[3] <= r) return [\n        t[0] * t[1] * t[2],\n        t[3]\n    ];\n    if (4 === t.length && t[0] <= r && t[1] * t[2] * t[3] <= r) return [\n        t[0],\n        t[1] * t[2] * t[3]\n    ];\n    if (e) {\n        var s = Ae(t), u = 2, c = 2;\n        return t.length && (u = (n = Te(t))[0], c = n[1]), D(a = s * (u / 2) * (c / 2)).map(function(t) {\n            return 2 * t;\n        });\n    }\n    return D(a);\n}\nfunction Fe(t) {\n    return t % 2 == 0;\n}\nfunction _e(t, e) {\n    if (S(t = t.slice(-2), e = e.slice(-2))) return !0;\n    if (!t.length || !e.length) return !0;\n    if (0 === t[0] || 0 === t[1] || 0 === e[0] || 0 === e[1]) return !0;\n    if (t.length !== e.length) {\n        var n = t.slice(-1)[0], r = e.slice(-1)[0];\n        if (n === r) return !0;\n        if (Fe(n) && Fe(r) && (1 === t[0] || 1 === e[0])) return !0;\n    }\n    return t[1] === e[1] && Fe(t[0]) && Fe(e[0]);\n}\nfunction Oe(t) {\n    if (null == ie) {\n        var e = jt(t);\n        ie = e.getParameter(e.MAX_TEXTURE_SIZE);\n    }\n    return ie;\n}\nfunction Me(t) {\n    if (null == se) {\n        var e = jt(t);\n        se = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);\n    }\n    return Math.min(16, se);\n}\nfunction Be(t) {\n    if (0 === t) return 0;\n    var e = jt(t);\n    return Pe(e, \"EXT_disjoint_timer_query_webgl2\") && 2 === t ? 2 : Pe(e, \"EXT_disjoint_timer_query\") ? 1 : 0;\n}\nfunction Pe(t, e) {\n    return null != t.getExtension(e);\n}\nfunction Le(t) {\n    try {\n        if (null != jt(t)) return !0;\n    } catch (t) {\n        return !1;\n    }\n    return !1;\n}\nfunction We(t) {\n    if (0 === t) return !1;\n    var e = jt(t);\n    if (1 === t) {\n        if (!Pe(e, \"OES_texture_float\")) return !1;\n    } else if (!Pe(e, \"EXT_color_buffer_float\")) return !1;\n    return Ve(e);\n}\nfunction Ue(t) {\n    if (0 === t) return !1;\n    var e = jt(t);\n    if (1 !== t) {\n        if (Pe(e, \"EXT_color_buffer_float\")) return Ve(e);\n        if (Pe(e, \"EXT_color_buffer_half_float\")) {\n            var n = e.getExtension(\"EXT_color_buffer_half_float\");\n            return function(t, e) {\n                var n = Qt(t, e), r = t.createTexture();\n                t.bindTexture(t.TEXTURE_2D, r);\n                t.texImage2D(t.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);\n                var o = t.createFramebuffer();\n                t.bindFramebuffer(t.FRAMEBUFFER, o), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0);\n                var a = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;\n                return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(r), t.deleteFramebuffer(o), a;\n            }(e, n);\n        }\n        return !1;\n    }\n    return !!Pe(e, \"OES_texture_float\") && !!Pe(e, \"WEBGL_color_buffer_float\") && Ve(e);\n}\nfunction Ve(t) {\n    var e = Qt(t), n = t.createTexture();\n    t.bindTexture(t.TEXTURE_2D, n);\n    t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null);\n    var r = t.createFramebuffer();\n    t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);\n    var o = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;\n    return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(n), t.deleteFramebuffer(r), o;\n}\nfunction ze(t) {\n    return 2 === t && null != jt(t).fenceSync;\n}\nvar Ge = Object.freeze({\n    callAndCheck: Jt,\n    canBeRepresented: ee,\n    getWebGLErrorMessage: ne,\n    getExtensionOrThrow: re,\n    createVertexShader: oe,\n    createFragmentShader: ae,\n    createProgram: ce,\n    linkProgram: le,\n    validateProgram: he,\n    createStaticVertexBuffer: fe,\n    createStaticIndexBuffer: de,\n    getNumChannels: function() {\n        return 2 === i().getNumber(\"WEBGL_VERSION\") ? 1 : 4;\n    },\n    createTexture: pe,\n    validateTextureSize: ve,\n    createFramebuffer: ge,\n    bindVertexBufferToProgramAttribute: me,\n    bindTextureUnit: ye,\n    unbindTextureUnit: function(t, e, n) {\n        Se(t, n), Jt(t, e, function() {\n            return t.activeTexture(t.TEXTURE0 + n);\n        }), Jt(t, e, function() {\n            return t.bindTexture(t.TEXTURE_2D, null);\n        });\n    },\n    getProgramUniformLocationOrThrow: xe,\n    getProgramUniformLocation: be,\n    bindTextureToProgramUniformSampler: we,\n    bindCanvasToFramebuffer: function(t, e) {\n        Jt(t, e, function() {\n            return t.bindFramebuffer(t.FRAMEBUFFER, null);\n        }), Jt(t, e, function() {\n            return t.viewport(0, 0, t.canvas.width, t.canvas.height);\n        }), Jt(t, e, function() {\n            return t.scissor(0, 0, t.canvas.width, t.canvas.height);\n        });\n    },\n    bindColorTextureToFramebuffer: Ce,\n    unbindColorTextureFromFramebuffer: Ee,\n    validateFramebuffer: Re,\n    getFramebufferErrorMessage: Ie,\n    getBatchDim: Ae,\n    getRowsCols: Te,\n    getShapeAs3D: De,\n    getTextureShapeFromLogicalShape: Ne,\n    isReshapeFree: _e,\n    getWebGLMaxTextureSize: Oe,\n    resetMaxTextureSize: function() {\n        ie = null;\n    },\n    resetMaxTexturesInShader: function() {\n        se = null;\n    },\n    getMaxTexturesInShader: Me,\n    getWebGLDisjointQueryTimerVersion: Be,\n    hasExtension: Pe,\n    isWebGLVersionEnabled: Le,\n    isCapableOfRenderingToFloatTexture: We,\n    isDownloadFloatTextureEnabled: Ue,\n    isWebGLFenceEnabled: ze\n}), He = i();\nfunction qe() {\n    i().set(\"PROD\", !0);\n}\nfunction Ke() {\n    i().set(\"DEBUG\", !0);\n}\nfunction je() {\n    i().set(\"DEPRECATION_WARNINGS_ENABLED\", !1), console.warn(\"TensorFlow.js deprecation warnings have been disabled.\");\n}\nfunction Xe(t) {\n    i().getBool(\"DEPRECATION_WARNINGS_ENABLED\") && console.warn(t + \" You can disable deprecation warnings with tf.disableDeprecationWarnings().\");\n}\nfunction Ye() {\n    Lt.disposeVariables();\n}\nfunction $e() {\n    return Lt;\n}\nfunction Qe() {\n    return Lt.memory();\n}\nfunction Je(t) {\n    return Lt.profile(t);\n}\nfunction Ze(t, e) {\n    return Lt.tidy(t, e);\n}\nfunction tn(t) {\n    _t(t).forEach(function(t) {\n        return t.dispose();\n    });\n}\nfunction en(t) {\n    return Lt.keep(t);\n}\nfunction nn(t) {\n    return Lt.time(t);\n}\nfunction rn(t) {\n    return Lt.setBackend(t);\n}\nfunction on() {\n    return Lt.ready();\n}\nfunction an() {\n    return Lt.backendName;\n}\nfunction sn(t) {\n    Lt.removeBackend(t);\n}\nfunction un(t) {\n    return Lt.findBackend(t);\n}\nfunction cn(t) {\n    return Lt.findBackendFactory(t);\n}\nfunction ln(t, e, n) {\n    return void 0 === n && (n = 1), Lt.registerBackend(t, e, n);\n}\nfunction hn() {\n    return Lt.backend;\n}\nfunction fn(t, e) {\n    i().setPlatform(t, e);\n}\nfunction dn() {\n    for(var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e];\n    i().getBool(\"IS_TEST\") || console.warn.apply(console, t);\n}\nfunction pn(t, e) {\n    var n = t;\n    if (V(t)) return \"string\" === e ? [] : [\n        t.length\n    ];\n    if (!Array.isArray(t)) return [];\n    for(var r = []; Array.isArray(n) || V(n) && \"string\" !== e;)r.push(n.length), n = n[0];\n    return Array.isArray(t) && i().getBool(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\") && function t(e, n, r) {\n        if (r = r || [], !Array.isArray(e) && !V(e)) return void C(0 === n.length, function() {\n            return \"Element arr[\" + r.join(\"][\") + \"] is a primitive, but should be an array/TypedArray of \" + n[0] + \" elements\";\n        });\n        C(n.length > 0, function() {\n            return \"Element arr[\" + r.join(\"][\") + \"] should be a primitive, but is an array of \" + e.length + \" elements\";\n        }), C(e.length === n[0], function() {\n            return \"Element arr[\" + r.join(\"][\") + \"] should have \" + n[0] + \" elements, but has \" + e.length + \" elements\";\n        });\n        for(var o = n.slice(1), a = 0; a < e.length; ++a)t(e[a], o, r.concat(a));\n    }(t, r, []), r;\n}\nfunction vn(t, e, n, r) {\n    if (null != t && (\"numeric\" !== t && t !== e || \"numeric\" === t && \"string\" === e)) throw new Error(\"Argument '\" + n + \"' passed to '\" + r + \"' must be \" + t + \" tensor, but got \" + e + \" tensor\");\n}\nfunction gn(t, e, n, r) {\n    if (void 0 === r && (r = \"numeric\"), t instanceof wt) return vn(r, t.dtype, e, n), t;\n    var o = j(t);\n    if (\"string\" !== o && [\n        \"bool\",\n        \"int32\",\n        \"float32\"\n    ].indexOf(r) >= 0 && (o = r), vn(r, o, e, n), null == t || !V(t) && !Array.isArray(t) && \"number\" != typeof t && \"boolean\" != typeof t && \"string\" != typeof t) {\n        var a = null == t ? \"null\" : t.constructor.name;\n        throw new Error(\"Argument '\" + e + \"' passed to '\" + n + \"' must be a Tensor or TensorLike, but got '\" + a + \"'\");\n    }\n    var s = pn(t, o);\n    V(t) || Array.isArray(t) || (t = [\n        t\n    ]);\n    var u = \"string\" !== o ? Q(t, o, i().getBool(\"DEBUG\")) : I(t, [], !0);\n    return Lt.makeTensor(u, s, o);\n}\nfunction mn(t, e, n, r) {\n    if (void 0 === r && (r = \"numeric\"), !Array.isArray(t)) throw new Error(\"Argument \" + e + \" passed to \" + n + \" must be a `Tensor[]` or `TensorLike[]`\");\n    return t.map(function(t, r) {\n        return gn(t, e + \"[\" + r + \"]\", n);\n    }, r);\n}\nfunction yn(t, e) {\n    for(var n = 0; n < t.length; ++n)if (t[t.length - n - 1] !== e - 1 - n) return !1;\n    return !0;\n}\nfunction xn(t, e, n) {\n    for(var r = t.length + e.length, o = [], a = 0, i = 0, s = 0; s < r; s++)-1 === n.indexOf(s) ? o.push(t[a++]) : o.push(e[i++]);\n    return o;\n}\nfunction bn(t, e) {\n    for(var n = [], r = t.length, o = 0; o < r; o++)-1 === e.indexOf(o) && n.push(t[o]);\n    return [\n        n,\n        e.map(function(e) {\n            return t[e];\n        })\n    ];\n}\nfunction wn(t, e) {\n    return xn(t, e.map(function(t) {\n        return 1;\n    }), e);\n}\nfunction Cn(t, e, n) {\n    C(yn(e, n), function() {\n        return t + \" supports only inner-most axes for now. Got axes \" + e + \" and rank-\" + n + \" input.\";\n    });\n}\nfunction En(t, e) {\n    if (yn(t, e)) return null;\n    for(var n = [], r = 0; r < e; ++r)-1 === t.indexOf(r) && n.push(r);\n    return t.forEach(function(t) {\n        return n.push(t);\n    }), n;\n}\nfunction Rn(t) {\n    return t.map(function(t, e) {\n        return [\n            e,\n            t\n        ];\n    }).sort(function(t, e) {\n        return t[1] - e[1];\n    }).map(function(t) {\n        return t[0];\n    });\n}\nfunction In(t, e) {\n    for(var n = [], r = e - t; r < e; ++r)n.push(r);\n    return n;\n}\nfunction kn(t, e) {\n    var n = t[0].length;\n    t.forEach(function(t, e) {\n        C(t.length === n, function() {\n            return \"Error in concat\" + n + \"D: rank of tensors[\" + e + \"] must be the same as the rank of the rest (\" + n + \")\";\n        });\n    }), C(e >= 0 && e < n, function() {\n        return \"Error in concat\" + n + \"D: axis must be between 0 and \" + (n - 1) + \".\";\n    });\n    var r = t[0];\n    t.forEach(function(t, o) {\n        for(var a = 0; a < n; a++)C(a === e || t[a] === r[a], function() {\n            return \"Error in concat\" + n + \"D: Shape of tensors[\" + o + \"] (\" + t + \") does not match the shape of the rest (\" + r + \") along the non-concatenated axis \" + o + \".\";\n        });\n    });\n}\nfunction Sn(t, e) {\n    for(var n = t[0].slice(), r = 1; r < t.length; r++)n[e] += t[r][e];\n    return n;\n}\nfunction An(t) {\n    var e = Object.keys(t);\n    if (1 !== e.length) throw new Error(\"Please provide an object with a single key (operation name) mapping to a function. Got an object with \" + e.length + \" keys.\");\n    var n = e[0], r = t[n];\n    n.endsWith(\"_\") && (n = n.substring(0, n.length - 1));\n    var o = function() {\n        for(var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e];\n        Lt.startScope(n);\n        try {\n            var o = r.apply(void 0, t);\n            return o instanceof Promise && console.error(\"Cannot return a Promise inside of tidy.\"), Lt.endScope(o), o;\n        } catch (t) {\n            throw Lt.endScope(null), t;\n        }\n    };\n    return Object.defineProperty(o, \"name\", {\n        value: n,\n        configurable: !0\n    }), o;\n}\nHe.registerFlag(\"HAS_WEBGL\", function() {\n    return He.getNumber(\"WEBGL_VERSION\") > 0;\n}), He.registerFlag(\"WEBGL_VERSION\", function() {\n    return Le(2) ? 2 : Le(1) ? 1 : 0;\n}), He.registerFlag(\"WEBGL_BUFFER_SUPPORTED\", function() {\n    return 2 === He.get(\"WEBGL_VERSION\");\n}), He.registerFlag(\"WEBGL_CPU_FORWARD\", function() {\n    return !0;\n}), He.registerFlag(\"WEBGL_FORCE_F16_TEXTURES\", function() {\n    return !1;\n}), He.registerFlag(\"WEBGL_PACK\", function() {\n    return He.getBool(\"HAS_WEBGL\");\n}), He.registerFlag(\"WEBGL_PACK_NORMALIZATION\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_CLIP\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_DEPTHWISECONV\", function() {\n    return !1;\n}), He.registerFlag(\"WEBGL_PACK_BINARY_OPERATIONS\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_UNARY_OPERATIONS\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_ARRAY_OPERATIONS\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_IMAGE_OPERATIONS\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_PACK_REDUCE\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_LAZILY_UNPACK\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_CONV_IM2COL\", function() {\n    return He.getBool(\"WEBGL_PACK\");\n}), He.registerFlag(\"WEBGL_MAX_TEXTURE_SIZE\", function() {\n    return Oe(He.getNumber(\"WEBGL_VERSION\"));\n}), He.registerFlag(\"WEBGL_MAX_TEXTURES_IN_SHADER\", function() {\n    return Me(He.getNumber(\"WEBGL_VERSION\"));\n}), He.registerFlag(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\", function() {\n    var t = He.getNumber(\"WEBGL_VERSION\");\n    return 0 === t ? 0 : Be(t);\n}), He.registerFlag(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\", function() {\n    return He.getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 && (t = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(t.substr(0, 4))));\n    var t;\n}), He.registerFlag(\"WEBGL_RENDER_FLOAT32_CAPABLE\", function() {\n    return We(He.getNumber(\"WEBGL_VERSION\"));\n}), He.registerFlag(\"WEBGL_RENDER_FLOAT32_ENABLED\", function() {\n    return !He.getBool(\"WEBGL_FORCE_F16_TEXTURES\") && He.getBool(\"WEBGL_RENDER_FLOAT32_CAPABLE\");\n}), He.registerFlag(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\", function() {\n    return Ue(He.getNumber(\"WEBGL_VERSION\"));\n}), He.registerFlag(\"WEBGL_FENCE_API_ENABLED\", function() {\n    return ze(He.getNumber(\"WEBGL_VERSION\"));\n}), He.registerFlag(\"WEBGL_SIZE_UPLOAD_UNIFORM\", function() {\n    return He.getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\") ? 4 : 0;\n}), bt = Xe;\nvar Tn = An({\n    complex_: function(t, e) {\n        var n = gn(t, \"real\", \"complex\"), r = gn(e, \"imag\", \"complex\");\n        return E(n.shape, r.shape, \"real and imag shapes, \" + n.shape + \" and \" + r.shape + \", must match in call to tf.complex().\"), Lt.runKernelFunc(function(t) {\n            return t.complex(n, r);\n        }, {\n            $real: n,\n            $imag: r\n        });\n    }\n}), Dn = An({\n    real_: function(t) {\n        var e = gn(t, \"input\", \"real\");\n        return Lt.runKernelFunc(function(t) {\n            return t.real(e);\n        }, {\n            $input: e\n        });\n    }\n}), Nn = An({\n    imag_: function(t) {\n        var e = gn(t, \"input\", \"imag\");\n        return Lt.runKernelFunc(function(t) {\n            return t.imag(e);\n        }, {\n            $input: e\n        });\n    }\n});\nfunction Fn(t, e, n) {\n    return _n(t, e, pn(t, n), n);\n}\nfunction _n(t, e, n, r) {\n    if (null == r && (r = j(t)), \"complex64\" === r) throw new Error(\"Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).\");\n    if (!V(t) && !Array.isArray(t) && \"number\" != typeof t && \"boolean\" != typeof t && \"string\" != typeof t) throw new Error(\"values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray\");\n    if (null != e) {\n        nt(e);\n        var o = k(e), a = k(n);\n        C(o === a, function() {\n            return \"Based on the provided shape, [\" + e + \"], the tensor should have \" + o + \" values but has \" + a;\n        });\n        for(var s = 0; s < n.length; ++s){\n            var u = n[s], c = s !== n.length - 1 || u !== k(e.slice(s));\n            C(n[s] === e[s] || !c, function() {\n                return \"Error creating a new Tensor. Inferred shape (\" + n + \") does not match the provided shape (\" + e + \"). \";\n            });\n        }\n    }\n    return V(t) || Array.isArray(t) || (t = [\n        t\n    ]), e = e || n, t = \"string\" !== r ? Q(t, r, i().getBool(\"DEBUG\")) : I(t, [], !0), Lt.makeTensor(t, e, r);\n}\nfunction On(t, e) {\n    if ((V(t) && \"string\" !== e || Array.isArray(t)) && \"complex64\" !== e) throw new Error(\"Error creating a new Scalar: value must be a primitive (number|boolean|string)\");\n    if (\"string\" === e && V(t) && !(t instanceof Uint8Array)) throw new Error(\"When making a scalar from encoded string, the value must be `Uint8Array`.\");\n    return _n(t, [], [], e);\n}\nfunction Mn(t, e) {\n    R(t);\n    var n = pn(t, e);\n    if (1 !== n.length) throw new Error(\"tensor1d() requires values to be a flat/TypedArray\");\n    return _n(t, null, n, e);\n}\nfunction Bn(t, e, n) {\n    if (R(t), null != e && 2 !== e.length) throw new Error(\"tensor2d() requires shape to have two numbers\");\n    var r = pn(t, n);\n    if (2 !== r.length && 1 !== r.length) throw new Error(\"tensor2d() requires values to be number[][] or flat/TypedArray\");\n    if (1 === r.length && null == e) throw new Error(\"tensor2d() requires shape to be provided when `values` are a flat/TypedArray\");\n    return _n(t, e, r, n);\n}\nfunction Pn(t, e, n) {\n    if (R(t), null != e && 3 !== e.length) throw new Error(\"tensor3d() requires shape to have three numbers\");\n    var r = pn(t, n);\n    if (3 !== r.length && 1 !== r.length) throw new Error(\"tensor3d() requires values to be number[][][] or flat/TypedArray\");\n    if (1 === r.length && null == e) throw new Error(\"tensor3d() requires shape to be provided when `values` are a flat array\");\n    return _n(t, e, r, n);\n}\nfunction Ln(t, e, n) {\n    if (R(t), null != e && 4 !== e.length) throw new Error(\"tensor4d() requires shape to have four numbers\");\n    var r = pn(t, n);\n    if (4 !== r.length && 1 !== r.length) throw new Error(\"tensor4d() requires values to be number[][][][] or flat/TypedArray\");\n    if (1 === r.length && null == e) throw new Error(\"tensor4d() requires shape to be provided when `values` are a flat array\");\n    return _n(t, e, r, n);\n}\nfunction Wn(t, e, n) {\n    if (R(t), null != e && 5 !== e.length) throw new Error(\"tensor5d() requires shape to have five numbers\");\n    var r = pn(t, n);\n    if (5 !== r.length && 1 !== r.length) throw new Error(\"tensor5d() requires values to be number[][][][][] or flat/TypedArray\");\n    if (1 === r.length && null == e) throw new Error(\"tensor5d() requires shape to be provided when `values` are a flat array\");\n    return _n(t, e, r, n);\n}\nfunction Un(t, e, n) {\n    if (R(t), null != e && 6 !== e.length) throw new Error(\"tensor6d() requires shape to have six numbers\");\n    var r = pn(t, n);\n    if (6 !== r.length && 1 !== r.length) throw new Error(\"tensor6d() requires values to be number[][][][][][] or flat/TypedArray\");\n    if (1 === r.length && null == e) throw new Error(\"tensor6d() requires shape to be provided when `values` are a flat array\");\n    return _n(t, e = e || r, r, n);\n}\nfunction Vn(t, e, n, r) {\n    return void 0 === e && (e = !0), Lt.makeVariable(t, e, n, r);\n}\nfunction zn(t, e) {\n    if (void 0 === e && (e = \"float32\"), \"complex64\" === e) {\n        var n = zn(t, \"float32\"), r = Gn(t, \"float32\");\n        return Tn(n, r);\n    }\n    var o = Z(k(t), e);\n    return Lt.makeTensor(o, t, e);\n}\nfunction Gn(t, e) {\n    if (void 0 === e && (e = \"float32\"), \"complex64\" === e) {\n        var n = Gn(t, \"float32\"), r = Gn(t, \"float32\");\n        return Tn(n, r);\n    }\n    var o = tt(k(t), e);\n    return Lt.makeTensor(o, t, e);\n}\nfunction Hn(t, e, n) {\n    return Lt.runKernelFunc(function(r) {\n        return r.fill(t, e, n);\n    }, {});\n}\nfunction qn(t, e, n) {\n    if (n <= 0) throw new Error(\"The number of values should be positive.\");\n    return Lt.runKernelFunc(function(r) {\n        return r.linspace(t, e, n);\n    }, {});\n}\nfunction Kn(t, e, n, r) {\n    if (void 0 === n && (n = 1), void 0 === r && (r = \"float32\"), 0 === n) throw new Error(\"Cannot have a step of zero\");\n    if (t === e || t < e && n < 0 || e < t && n > 1) return Gn([\n        0\n    ], r);\n    var o = tt(Math.abs(Math.ceil((e - t) / n)), r);\n    e < t && 1 === n && (n = -1), o[0] = t;\n    for(var a = 1; a < o.length; a++)o[a] = o[a - 1] + n;\n    return Mn(o, r);\n}\nvar jn = An({\n    onesLike_: function(t) {\n        var e = gn(t, \"x\", \"onesLike\");\n        if (\"complex64\" === e.dtype) {\n            var n = jn(Dn(e)), r = Xn(Nn(e));\n            return Tn(n, r);\n        }\n        return Lt.runKernelFunc(function(t) {\n            return t.onesLike(e);\n        }, {\n            x: e\n        }, function(t, e) {\n            return {\n                x: function() {\n                    return Xn(t);\n                }\n            };\n        }, \"OnesLike\");\n    }\n}), Xn = An({\n    zerosLike_: function(t) {\n        var e = gn(t, \"x\", \"zerosLike\");\n        return Lt.runKernelFunc(function(t) {\n            return t.zerosLike(e);\n        }, {\n            x: e\n        }, function(t, e) {\n            return {\n                x: function() {\n                    return Xn(t);\n                }\n            };\n        }, \"ZerosLike\");\n    }\n});\nvar Yn = An({\n    concat_: function(t, e) {\n        void 0 === e && (e = 0), C(t.length >= 1, function() {\n            return \"Pass at least one tensor to concat\";\n        });\n        var n = mn(t, \"tensors\", \"concat\");\n        \"complex64\" === n[0].dtype && n.forEach(function(t) {\n            if (\"complex64\" !== t.dtype) throw new Error(\"Cannot concatenate complex64 tensors with a tensor\\n          with dtype \" + t.dtype + \". \");\n        }), e = O(e, n[0].shape)[0];\n        var r = Sn(n.map(function(t) {\n            return t.shape;\n        }), e);\n        if (0 === k(r)) return Fn([], r);\n        if (1 === (n = n.filter(function(t) {\n            return t.size > 0;\n        })).length) return n[0];\n        var o = n.map(function(t) {\n            return t.shape;\n        });\n        kn(o, e);\n        var a = n, i = {\n            axis: e\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.concat(n, e);\n        }, a, function(t) {\n            var n = o.map(function(t) {\n                return t[e];\n            });\n            return tr(t, n, e).map(function(t) {\n                return function() {\n                    return t;\n                };\n            });\n        }, \"Concat\", i);\n    }\n}), $n = An({\n    concat1d_: function(t) {\n        return Yn(t, 0);\n    }\n}), Qn = An({\n    concat2d_: function(t, e) {\n        return Yn(t, e);\n    }\n}), Jn = An({\n    concat3d_: function(t, e) {\n        return Yn(t, e);\n    }\n}), Zn = An({\n    concat4d_: function(t, e) {\n        return Yn(t, e);\n    }\n}), tr = An({\n    split_: function(t, e, n) {\n        void 0 === n && (n = 0);\n        var r, o = gn(t, \"x\", \"split\");\n        return n = O(n, o.shape)[0], \"number\" == typeof e ? (C(o.shape[n] % e == 0, function() {\n            return \"Number of splits must evenly divide the axis.\";\n        }), r = new Array(e).fill(o.shape[n] / e)) : (C(o.shape[n] === e.reduce(function(t, e) {\n            return t + e;\n        }), function() {\n            return \"The sum of sizes must match the size of the axis dimension.\";\n        }), r = e), Lt.runKernelFunc(function(t) {\n            return t.split(o, r, n);\n        }, {\n            $x: o\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Yn(t, n);\n                }\n            };\n        });\n    }\n});\nfunction er(t, e, n) {\n    return void 0 === e && (e = \"float32\"), e = e || \"float32\", nt(t), new mt(t, e, n);\n}\nfunction nr(t, e) {\n    void 0 === e && (e = !1), console.log(t.toString(e));\n}\nvar rr = An({\n    batchToSpaceND_: function(t, e, n) {\n        var r = gn(t, \"x\", \"batchToSpaceND\"), o = e.reduce(function(t, e) {\n            return t * e;\n        });\n        return C(r.rank >= 1 + e.length, function() {\n            return \"input rank is \" + r.rank + \" but should be > than blockShape.length \" + e.length;\n        }), C(n.length === e.length, function() {\n            return \"crops.length is \" + n.length + \" but should be equal to blockShape.length  \" + e.length;\n        }), C(r.shape[0] % o == 0, function() {\n            return \"input tensor batch is \" + r.shape[0] + \" but is not divisible by the product of the elements of blockShape \" + e.join(\" * \") + \" === \" + o;\n        }), Lt.runKernelFunc(function(t) {\n            return t.batchToSpaceND(r, e, n);\n        }, {\n            $x: r\n        }, function(t) {\n            return {\n                $x: function() {\n                    return t.spaceToBatchND(e, n);\n                }\n            };\n        });\n    }\n}), or = An({\n    cast_: function(t, e) {\n        var n = gn(t, \"x\", \"cast\");\n        if (!W(e)) throw new Error(\"Failed to cast to unknown dtype \" + e);\n        if (\"string\" === e && \"string\" !== n.dtype || \"string\" !== e && \"string\" === n.dtype) throw new Error(\"Only strings can be casted to strings\");\n        var r = {\n            dtype: e\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.cast(n, e);\n        }, {\n            x: n\n        }, function(t) {\n            return {\n                x: function() {\n                    return t.clone();\n                }\n            };\n        }, \"Cast\", r);\n    }\n}), ar = An({\n    cumsum_: function(t, e, n, r) {\n        void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);\n        var o = gn(t, \"x\", \"cumsum\"), a = En([\n            e |= 0\n        ], o.rank), i = o;\n        null != a && (i = o.transpose(a));\n        var s = In(1, o.rank)[0], u = Lt.runKernelFunc(function(t) {\n            return t.cumsum(i, s, n, r);\n        }, {\n            permutedX: i\n        }, function(t) {\n            return {\n                permutedX: function() {\n                    return t.cumsum(e, n, !r);\n                }\n            };\n        });\n        return null != a && (u = u.transpose(a)), u;\n    }\n}), ir = An({\n    depthToSpace_: function(t, e, n) {\n        void 0 === n && (n = \"NHWC\");\n        var r = gn(t, \"x\", \"depthToSpace\"), o = \"NHWC\" === n ? r.shape[1] : r.shape[2], a = \"NHWC\" === n ? r.shape[2] : r.shape[3], i = \"NHWC\" === n ? r.shape[3] : r.shape[1];\n        return C(o * e >= 0, function() {\n            return \"Negative dimension size caused by overflow when multiplying\\n      \" + o + \" and \" + e + \"  for depthToSpace with input shape\\n      \" + r.shape;\n        }), C(a * e >= 0, function() {\n            return \"Negative dimension size caused by overflow when multiplying\\n      \" + a + \" and \" + e + \" for depthToSpace with input shape\\n          \" + r.shape;\n        }), C(i % (e * e) == 0, function() {\n            return \"Dimension size must be evenly divisible by \" + e * e + \" but is \" + i + \" for depthToSpace with input shape \" + r.shape;\n        }), Lt.runKernelFunc(function(t) {\n            return t.depthToSpace(r, e, n);\n        }, {\n            $x: r\n        });\n    }\n}), sr = An({\n    expandDims_: function(t, e) {\n        void 0 === e && (e = 0);\n        var n = gn(t, \"x\", \"expandDims\", null);\n        C(e <= n.rank, function() {\n            return \"Axis must be <= rank of the tensor\";\n        });\n        var r = n.shape.slice();\n        return e < 0 && (C(-(n.rank + 1) <= e, function() {\n            return \"Axis must be in the interval [\" + -(n.rank + 1) + \", \" + n.rank + \"]\";\n        }), e = n.rank + e + 1), r.splice(e, 0, 1), ur(n, r);\n    }\n}), ur = An({\n    reshape_: function(t, e) {\n        var n = gn(t, \"x\", \"reshape\", null);\n        e = _(e, n.size), C(n.size === k(e), function() {\n            return \"new shape and old shape must have the same number of elements.\";\n        });\n        var r = {\n            shape: e\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.reshape(n, e);\n        }, {\n            x: n\n        }, function(t) {\n            return {\n                x: function() {\n                    return t.reshape(n.shape);\n                }\n            };\n        }, \"Reshape\", r);\n    }\n}), cr = An({\n    spaceToBatchND_: function(t, e, n) {\n        var r = gn(t, \"x\", \"spaceToBatchND\");\n        return C(r.rank >= 1 + e.length, function() {\n            return \"input rank \" + r.rank + \" should be > than [blockShape] \" + e.length;\n        }), C(n.length === e.length, function() {\n            return \"paddings.shape[0] \" + n.length + \" must be equal to [blockShape] \" + e.length;\n        }), C(r.shape.reduce(function(t, r, o) {\n            return o > 0 && o <= e.length ? t && (r + n[o - 1][0] + n[o - 1][1]) % e[o - 1] == 0 : t;\n        }, !0), function() {\n            return \"input spatial dimensions \" + r.shape.slice(1) + \" with paddings \" + n.toString() + \" must be divisible by blockShapes \" + e.toString();\n        }), Lt.runKernelFunc(function(t) {\n            return t.spaceToBatchND(r, e, n);\n        }, {\n            $x: r\n        }, function(t) {\n            return {\n                $x: function() {\n                    return t.batchToSpaceND(e, n);\n                }\n            };\n        });\n    }\n}), lr = An({\n    squeeze_: function(t, e) {\n        var n = gn(t, \"x\", \"squeeze\");\n        return ur(n, M(n.shape, e).newShape);\n    }\n}), hr = An({\n    stack_: function(t, e) {\n        void 0 === e && (e = 0);\n        var n = mn(t, \"tensors\", \"stack\");\n        if (C(n.length >= 1, function() {\n            return \"Pass at least one tensor to tf.stack\";\n        }), 1 === n.length) return n[0].expandDims(e);\n        var r = n[0].rank, o = n[0].shape, a = n[0].dtype;\n        C(e <= r, function() {\n            return \"Axis must be <= rank of the tensor\";\n        }), n.forEach(function(t) {\n            E(o, t.shape, \"All tensors passed to stack must have matching shapes\");\n        }), n.forEach(function(t) {\n            C(a === t.dtype, function() {\n                return \"All tensors passed to stack must have matching dtypes\";\n            });\n        });\n        var i = n.map(function(t) {\n            return t.expandDims(e);\n        });\n        return Yn(i, e);\n    }\n}), fr = An({\n    unstack_: function(t, e) {\n        void 0 === e && (e = 0), e = e || 0;\n        var n = gn(t, \"x\", \"unstack\");\n        C(e >= -n.shape.length && e < n.shape.length, function() {\n            return \"Axis = \" + e + \" is not in [-\" + n.shape.length + \", \" + n.shape.length + \")\";\n        }), e < 0 && (e += n.shape.length);\n        var r = {\n            axis: e\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.unstack(n, e);\n        }, {\n            x: n\n        }, function(t) {\n            return {\n                x: function() {\n                    return hr(t, e);\n                }\n            };\n        }, \"Unpack\", r);\n    }\n}), dr = function(t, e) {\n    return n(this, void 0, void 0, function() {\n        var n, o, a, i, s, u, c, l, h, f;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return n = gn(t, \"x\", \"setdiff1d\"), o = gn(e, \"y\", \"setdiff1d\"), C(n.dtype === o.dtype, function() {\n                        return \"x and y should have the same dtype, but got x (\" + n.dtype + \") and y (\" + o.dtype + \").\";\n                    }), C(1 === n.rank, function() {\n                        return \"x should be 1D tensor, but got x (\" + n.shape + \").\";\n                    }), C(1 === o.rank, function() {\n                        return \"y should be 1D tensor, but got y (\" + o.shape + \").\";\n                    }), [\n                        4,\n                        n.data()\n                    ];\n                case 1:\n                    return a = r.sent(), [\n                        4,\n                        o.data()\n                    ];\n                case 2:\n                    for(i = r.sent(), s = new Set(i), u = 0, h = 0; h < a.length; h++)s.has(a[h]) || u++;\n                    for(c = new mt([\n                        u\n                    ], n.dtype), l = new mt([\n                        u\n                    ], \"int32\"), h = 0, f = 0; h < a.length; h++)s.has(a[h]) || (c.values[f] = a[h], l.values[f] = h, f++);\n                    return [\n                        2,\n                        [\n                            c.toTensor(),\n                            l.toTensor()\n                        ]\n                    ];\n            }\n        });\n    });\n};\nfunction pr(t, e, n, r) {\n    void 0 === r && (r = !0);\n    var o = [];\n    if (r) (o = o.concat(e.slice(0))).push(t[0] / n), o = o.concat(t.slice(1));\n    else {\n        o = o.concat(t[0]);\n        for(var a = e.length, i = 0; i < a; ++i)o = o.concat([\n            t[i + 1] / e[i],\n            e[i]\n        ]);\n        o = o.concat(t.slice(a + 1));\n    }\n    return o;\n}\nfunction vr(t, e, n) {\n    void 0 === n && (n = !0);\n    var r = [];\n    if (n) {\n        r.push(e);\n        for(var o = e + 1; o < t; ++o)o <= 2 * e ? (r.push(o), r.push(o - (e + 1))) : r.push(o);\n    } else {\n        var a = [], i = [];\n        for(o = 1; o < t; ++o)o >= 2 * e + 1 || o % 2 == 1 ? i.push(o) : a.push(o);\n        r.push.apply(r, a), r.push(0), r.push.apply(r, i);\n    }\n    return r;\n}\nfunction gr(t, e, n, r) {\n    void 0 === r && (r = !0);\n    var o = [];\n    r ? o.push(t[0] / n) : o.push(t[0] * n);\n    for(var a = 1; a < t.length; ++a)a <= e.length ? r ? o.push(e[a - 1] * t[a]) : o.push(t[a] / e[a - 1]) : o.push(t[a]);\n    return o;\n}\nfunction mr(t, e) {\n    for(var n = [\n        0\n    ], r = 0; r < e; ++r)n.push(t[r][0]);\n    return n;\n}\nfunction yr(t, e, n) {\n    for(var r = t.slice(0, 1), o = 0; o < n; ++o)r.push(t[o + 1] - e[o][0] - e[o][1]);\n    return r;\n}\nvar xr = \"Add\", br = \"AddN\", wr = \"Div\", Cr = \"FusedBatchNorm\", Er = \"SquaredDifference\", Rr = \"Square\", Ir = \"Transpose\", kr = \"NonMaxSuppressionV5\", Sr = \"BroadcastTo\", Ar = \"OneHot\", Tr = \"Identity\", Dr = \"Tile\", Nr = \"PadV2\", Fr = \"FromPixels\", _r = \"MaxPoolWithArgmax\";\nvar Or = An({\n    add_: function(t, e) {\n        var n, r = gn(t, \"a\", \"add\"), o = gn(e, \"b\", \"add\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = {\n            a: r,\n            b: o\n        };\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.add(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, a, null, xr);\n    }\n});\nfunction Mr(t, e) {\n    for(var n = t.length, r = [], o = 0; o < n; o++){\n        var a = n - 1 - o, i = t[a] || 1;\n        (e[e.length - 1 - o] || 1) > 1 && 1 === i && r.unshift(a);\n    }\n    return r;\n}\nfunction Br(t, e) {\n    for(var n = [], r = 0; r < e.length; r++){\n        var o = t[t.length - r - 1], a = e.length - r - 1, i = e[a];\n        (null == o || 1 === o && i > 1) && n.unshift(a);\n    }\n    return n;\n}\nfunction Pr(t, e) {\n    for(var n = [], r = Math.max(t.length, e.length), o = 0; o < r; o++){\n        var a = t[t.length - o - 1];\n        null == a && (a = 1);\n        var i = e[e.length - o - 1];\n        if (null == i && (i = 1), 1 === a) n.unshift(i);\n        else if (1 === i) n.unshift(a);\n        else {\n            if (a !== i) throw Error(\"Operands could not be broadcast together with shapes \" + t + \" and \" + e + \".\");\n            n.unshift(a);\n        }\n    }\n    return n;\n}\nvar Lr = An({\n    abs_: function(t) {\n        var e = gn(t, \"x\", \"abs\");\n        return \"complex64\" === e.dtype ? Lt.runKernelFunc(function(t) {\n            return t.complexAbs(e);\n        }, {\n            $x: e\n        }) : Lt.runKernelFunc(function(t, n) {\n            var r = t.abs(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.mul(n.toFloat().step(-1));\n                }\n            };\n        }, \"Abs\");\n    }\n}), Wr = An({\n    acos_: function(t) {\n        var e = gn(t, \"x\", \"acos\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.acos(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.divStrict(On(1).sub(n.toFloat().square()).sqrt()).neg();\n                }\n            };\n        });\n    }\n}), Ur = An({\n    acosh_: function(t) {\n        var e = gn(t, \"x\", \"acosh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.acosh(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.divStrict(n.toFloat().square().sub(1).sqrt());\n                }\n            };\n        });\n    }\n}), Vr = An({\n    asin_: function(t) {\n        var e = gn(t, \"x\", \"asin\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.asin(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.divStrict(On(1).sub(n.toFloat().square()).sqrt());\n                }\n            };\n        });\n    }\n}), zr = An({\n    asinh_: function(t) {\n        var e = gn(t, \"x\", \"asinh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.asinh(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.divStrict(On(1).add(n.toFloat().square()).sqrt());\n                }\n            };\n        });\n    }\n}), Gr = An({\n    atan_: function(t) {\n        var e = gn(t, \"x\", \"atan\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.atan(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(n.toFloat().square().add(1));\n                }\n            };\n        });\n    }\n}), Hr = An({\n    atanh_: function(t) {\n        var e = gn(t, \"x\", \"atanh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.atanh(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(On(1).sub(n.toFloat().square()));\n                }\n            };\n        });\n    }\n}), qr = An({\n    ceil_: function(t) {\n        var e = gn(t, \"x\", \"ceil\");\n        return Lt.runKernelFunc(function(t) {\n            return t.ceil(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), Kr = An({\n    clipByValue_: function(t, e, n) {\n        var r = gn(t, \"x\", \"clipByValue\");\n        C(e <= n, function() {\n            return \"Error in clip: min (\" + e + \") must be less than or equal to max (\" + n + \").\";\n        });\n        var o = [\n            r\n        ], a = {\n            min: e,\n            max: n\n        };\n        return Lt.runKernelFunc(function(t, o) {\n            var a = t.clip(r, e, n);\n            return o([\n                r\n            ]), a;\n        }, {\n            x: r\n        }, function(t, r) {\n            var o = r[0];\n            return {\n                x: function() {\n                    return t.where(o.greaterEqual(e).logicalAnd(o.lessEqual(n)), Xn(t));\n                }\n            };\n        }, \"ClipByValue\", a, o);\n    }\n}), jr = An({\n    cos_: function(t) {\n        var e = gn(t, \"x\", \"cos\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.cos(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return n.toFloat().sin().neg().mul(t);\n                }\n            };\n        }, \"Cos\", {}, n);\n    }\n}), Xr = An({\n    cosh_: function(t) {\n        var e = gn(t, \"x\", \"cosh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.cosh(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return n.toFloat().sinh().mulStrict(t);\n                }\n            };\n        });\n    }\n}), Yr = An({\n    erf_: function(t) {\n        var e = gn(t, \"x\", \"erf\");\n        return C(\"int32\" === e.dtype || \"float32\" === e.dtype, function() {\n            return \"Input dtype must be `int32` or `float32`.\";\n        }), \"int32\" === e.dtype && (e = e.toFloat()), Lt.runKernelFunc(function(t, n) {\n            var r = t.erf(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.mul(n.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));\n                }\n            };\n        });\n    }\n}), $r = An({\n    exp_: function(t) {\n        var e = gn(t, \"x\", \"exp\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.exp(e);\n            return n([\n                r\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            return {\n                x: function() {\n                    return t.mulStrict(e[0]);\n                }\n            };\n        }, \"Exp\", {}, [], [\n            !0\n        ]);\n    }\n}), Qr = An({\n    expm1_: function(t) {\n        var e = gn(t, \"x\", \"expm1\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.expm1(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.mul(n.exp());\n                }\n            };\n        });\n    }\n}), Jr = An({\n    floor_: function(t) {\n        var e = gn(t, \"x\", \"floor\");\n        return Lt.runKernelFunc(function(t) {\n            return t.floor(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), Zr = An({\n    log_: function(t) {\n        var e = gn(t, \"x\", \"log\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.log(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.div(n.toFloat());\n                }\n            };\n        }, \"Log\", {}, n);\n    }\n}), to = An({\n    log1p_: function(t) {\n        var e = gn(t, \"x\", \"log1p\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.log1p(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(n.add(1));\n                }\n            };\n        });\n    }\n}), eo = An({\n    logSigmoid_: function(t) {\n        var e = gn(t, \"x\", \"logSigmoid\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.softplus(e.neg()).neg();\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.mul(n.neg().sigmoid());\n                }\n            };\n        });\n    }\n}), no = An({\n    neg_: function(t) {\n        var e = gn(t, \"x\", \"neg\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t) {\n            return t.neg(e);\n        }, {\n            x: e\n        }, function(t) {\n            return {\n                x: function() {\n                    return t.neg();\n                }\n            };\n        }, \"Neg\", {}, n);\n    }\n}), ro = An({\n    reciprocal_: function(t) {\n        var e = gn(t, \"x\", \"reciprocal\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.reciprocal(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(n.square().neg());\n                }\n            };\n        });\n    }\n}), oo = An({\n    round_: function(t) {\n        var e = gn(t, \"x\", \"round\");\n        return Lt.runKernelFunc(function(t) {\n            return t.round(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), ao = An({\n    rsqrt_: function(t) {\n        var e = gn(t, \"x\", \"rsqrt\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.rsqrt(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.div(n.pow(1.5).mul(2)).neg();\n                }\n            };\n        }, \"Rsqrt\", {}, n);\n    }\n}), io = An({\n    sigmoid_: function(t) {\n        var e = gn(t, \"x\", \"sigmoid\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.sigmoid(e);\n            return n([\n                r\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.mul(n.mul(On(1).sub(n)));\n                }\n            };\n        }, \"Sigmoid\");\n    }\n}), so = An({\n    sign_: function(t) {\n        var e = gn(t, \"x\", \"sign\");\n        return Lt.runKernelFunc(function(t) {\n            return t.sign(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), uo = An({\n    isNaN_: function(t) {\n        var e = gn(t, \"x\", \"isNaN\");\n        return Lt.runKernelFunc(function(t) {\n            return t.isNaN(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), co = An({\n    isInf_: function(t) {\n        var e = gn(t, \"x\", \"isInf\");\n        return Lt.runKernelFunc(function(t) {\n            return t.isInf(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), lo = An({\n    isFinite_: function(t) {\n        var e = gn(t, \"x\", \"isFinite\");\n        return Lt.runKernelFunc(function(t) {\n            return t.isFinite(e);\n        }, {\n            $x: e\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), ho = An({\n    sin_: function(t) {\n        var e = gn(t, \"x\", \"sin\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.sin(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return n.toFloat().cos().mul(t);\n                }\n            };\n        }, \"Sin\", {}, n);\n    }\n}), fo = An({\n    sinh_: function(t) {\n        var e = gn(t, \"x\", \"sinh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.sinh(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return n.toFloat().cosh().mulStrict(t);\n                }\n            };\n        });\n    }\n}), po = An({\n    softplus_: function(t) {\n        var e = gn(t, \"x\", \"softplus\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.softplus(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.mul(n.sigmoid());\n                }\n            };\n        });\n    }\n}), vo = An({\n    sqrt_: function(t) {\n        var e = gn(t, \"x\", \"sqrt\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.sqrt(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(n.toFloat().sqrt().mul(2));\n                }\n            };\n        });\n    }\n}), go = An({\n    step_: function(t, e) {\n        void 0 === e && (e = 0);\n        var n = gn(t, \"x\", \"step\");\n        return Lt.runKernelFunc(function(t) {\n            return t.step(n, e);\n        }, {\n            $x: n\n        }, function(t) {\n            return {\n                $x: function() {\n                    return Xn(t);\n                }\n            };\n        });\n    }\n}), mo = An({\n    tan_: function(t) {\n        var e = gn(t, \"x\", \"tan\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.tan(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return t.div(n.cos().square());\n                }\n            };\n        });\n    }\n}), yo = An({\n    tanh_: function(t) {\n        var e = gn(t, \"x\", \"tanh\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.tanh(e);\n            return n([\n                r\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return On(1).sub(n.square()).mulStrict(t);\n                }\n            };\n        }, \"Tanh\", {}, null, [\n            !0\n        ]);\n    }\n});\nvar xo = An({\n    addStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"addStrict\"), r = gn(e, \"b\", \"addStrict\");\n        return E(n.shape, r.shape, \"Error in addStrict: \"), n.add(r);\n    }\n}), bo = An({\n    atan2_: function(t, e) {\n        var n, r = gn(t, \"a\", \"atan2\"), o = gn(e, \"b\", \"atan2\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Pr(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.atan2(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            $a: r,\n            $b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                $a: function() {\n                    var e = Or(n.square(), r.square()), o = t.mul(r.div(e)), i = Br(n.shape, a);\n                    return i.length > 0 && (o = o.sum(i)), o.reshape(n.shape);\n                },\n                $b: function() {\n                    var e = Or(n.square(), r.square()), o = no(t.mul(n.div(e))), i = Br(r.shape, a);\n                    return i.length > 0 && (o = o.sum(i)), o.reshape(r.shape);\n                }\n            };\n        });\n    }\n}), wo = An({\n    divStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"div\"), r = gn(e, \"b\", \"div\");\n        return E(n.shape, r.shape, \"Error in divideStrict: \"), n.div(r);\n    }\n}), Co = An({\n    floorDiv_: function(t, e) {\n        var n, r = gn(t, \"a\", \"floorDiv\"), o = gn(e, \"b\", \"floorDiv\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Pr(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.floorDiv(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                a: function() {\n                    var e = t.div(r.toFloat()), o = Br(n.shape, a);\n                    return o.length > 0 ? e.sum(o).reshape(n.shape) : e;\n                },\n                b: function() {\n                    var e = t.mul(n.toFloat()), o = Br(r.shape, a);\n                    o.length > 0 && (e = e.sum(o).reshape(r.shape));\n                    var i = r.square();\n                    return e.div(i.toFloat()).neg();\n                }\n            };\n        }, \"FloorDiv\");\n    }\n}), Eo = An({\n    maximum_: function(t, e) {\n        var n, r = gn(t, \"a\", \"maximum\"), o = gn(e, \"b\", \"maximum\");\n        return n = Nt(r, o), r = n[0], o = n[1], \"bool\" === r.dtype && (r = r.toInt(), o = o.toInt()), Pr(r.shape, o.shape), Lt.runKernelFunc(function(t, e) {\n            var n = t.maximum(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                a: function() {\n                    return t.mul(n.greaterEqual(r).toFloat());\n                },\n                b: function() {\n                    return t.mul(n.less(r).toFloat());\n                }\n            };\n        }, \"Maximum\");\n    }\n}), Ro = An({\n    maximumStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"maximumStrict\"), r = gn(e, \"b\", \"maximumStrict\");\n        return E(n.shape, r.shape, \"Error in maximumStrict: \"), n.maximum(r);\n    }\n}), Io = An({\n    minimum_: function(t, e) {\n        var n, r = gn(t, \"a\", \"minimum\"), o = gn(e, \"b\", \"minimum\");\n        return n = Nt(r, o), r = n[0], o = n[1], \"bool\" === r.dtype && (r = r.toInt(), o = o.toInt()), Pr(r.shape, o.shape), Lt.runKernelFunc(function(t, e) {\n            var n = t.minimum(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                a: function() {\n                    return t.mul(n.lessEqual(r).toFloat());\n                },\n                b: function() {\n                    return t.mul(n.greater(r).toFloat());\n                }\n            };\n        }, \"Minimum\");\n    }\n}), ko = An({\n    minimumStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"minimumStrict\"), r = gn(e, \"b\", \"minimumStrict\");\n        return E(n.shape, r.shape, \"Error in minimumStrict: \"), n.minimum(r);\n    }\n}), So = An({\n    mod_: function(t, e) {\n        var n, r = gn(t, \"a\", \"mod\"), o = gn(e, \"b\", \"mod\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Pr(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.mod(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            $a: r,\n            $b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                $a: function() {\n                    var e = Br(n.shape, a);\n                    return e.length > 0 ? t.sum(e).reshape(n.shape) : t;\n                },\n                $b: function() {\n                    var e = t.mul(n.div(r).floor().neg()), o = Br(r.shape, a);\n                    return o.length > 0 ? e.sum(o).reshape(r.shape) : e;\n                }\n            };\n        });\n    }\n}), Ao = An({\n    modStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"modStrict\"), r = gn(e, \"b\", \"modStrict\");\n        return E(n.shape, r.shape, \"Error in modStrict: \"), n.mod(r);\n    }\n}), To = An({\n    mul_: function(t, e) {\n        var n, r = gn(t, \"a\", \"mul\"), o = gn(e, \"b\", \"mul\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Pr(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.multiply(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                a: function() {\n                    var e = t.mul(r.toFloat()), o = Br(n.shape, a);\n                    return o.length > 0 ? e.sum(o).reshape(n.shape) : e;\n                },\n                b: function() {\n                    var e = t.mul(n.toFloat()), o = Br(r.shape, a);\n                    return o.length > 0 ? e.sum(o).reshape(r.shape) : e;\n                }\n            };\n        }, \"Mul\");\n    }\n}), Do = An({\n    mulStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"mul\"), r = gn(e, \"b\", \"mul\");\n        return E(n.shape, r.shape, \"Error in multiplyStrict: \"), n.mul(r);\n    }\n}), No = An({\n    pow_: function(t, e) {\n        var n, r = gn(t, \"base\", \"pow\"), o = gn(e, \"exp\", \"pow\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Pr(r.shape, o.shape), i = [\n            r,\n            o\n        ];\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.pow(r, o);\n            return e([\n                r,\n                o,\n                n\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1], o = e[2];\n            return {\n                a: function() {\n                    var e = r.toFloat(), o = t.mul(e.mul(n.pow(e.sub(On(1))))), i = Br(n.shape, a);\n                    return i.length > 0 && (o = o.sum(i)), o.reshape(n.shape);\n                },\n                b: function() {\n                    var e = n.greater(0), i = n.log().where(e, Xn(n)), s = t.mul(o.mul(i)), u = Br(r.shape, a);\n                    return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape);\n                }\n            };\n        }, \"Pow\", {}, i, [\n            !0\n        ]);\n    }\n}), Fo = An({\n    powStrict_: function(t, e) {\n        return E(t.shape, e.shape, \"Error in powStrict: \"), t.pow(e);\n    }\n}), _o = An({\n    squaredDifferenceStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"squaredDifferenceStrict\"), r = gn(e, \"b\", \"squaredDifferenceStrict\");\n        return E(n.shape, r.shape, \"Error in squaredDifferenceStrict: \"), n.squaredDifference(r);\n    }\n}), Oo = An({\n    sub_: function(t, e) {\n        var n, r = gn(t, \"a\", \"sub\"), o = gn(e, \"b\", \"sub\");\n        n = Nt(r, o), r = n[0], o = n[1];\n        var a = Pr(r.shape, o.shape);\n        return Lt.runKernelFunc(function(t) {\n            return t.subtract(r, o);\n        }, {\n            a: r,\n            b: o\n        }, function(t) {\n            return {\n                a: function() {\n                    var e = t, n = Br(r.shape, a);\n                    return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);\n                },\n                b: function() {\n                    var e = t, n = Br(o.shape, a);\n                    return n.length > 0 && (e = e.sum(n)), e.neg().reshape(o.shape);\n                }\n            };\n        }, \"Sub\");\n    }\n}), Mo = An({\n    subStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"subStrict\"), r = gn(e, \"b\", \"subStrict\");\n        return E(n.shape, r.shape, \"Error in subStrict: \"), n.sub(r);\n    }\n});\nvar Bo = An({\n    div_: function(t, e) {\n        var n, r = gn(t, \"a\", \"div\"), o = gn(e, \"b\", \"div\");\n        if (n = Nt(r, o), r = n[0], o = n[1], \"int32\" === r.dtype && \"int32\" === o.dtype) return Co(r, o);\n        var a = {\n            a: r,\n            b: o\n        };\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.realDivide(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, a, null, wr, {});\n    }\n});\nfunction Po(t, e) {\n    if (t.rank < 1) throw new Error(\"tf.gatherND() expects the input to be rank 1 or higher, but the rank was \" + t.rank + \".\");\n    if (e.rank < 1) throw new Error(\"tf.gatherND() expects the indices to be rank 1 or higher, but the rank was \" + e.rank + \".\");\n    if (\"int32\" !== e.dtype) throw new Error(\"tf.gatherND() expects the indices to be int32 type, but the dtype was \" + e.dtype + \".\");\n    if (e.shape[e.rank - 1] > t.rank) throw new Error(\"index innermost dimension length must be <= tensor rank; saw: \" + e.shape[e.rank - 1] + \" vs. \" + t.rank);\n    if (0 === t.size) throw new Error(\"Requested more than 0 entries, but input is empty. Input shape: \" + t.shape + \".\");\n    for(var n = e.shape, r = n[n.length - 1], o = 1, a = 0; a < n.length - 1; ++a)o *= n[a];\n    var i = t.shape, s = n.slice();\n    s.pop();\n    var u = 1;\n    for(a = r; a < t.rank; ++a)u *= i[a], s.push(i[a]);\n    var c = $(t.shape).map(function(t) {\n        return t / u;\n    }).concat([\n        1\n    ]).slice(0, r);\n    return [\n        s,\n        o,\n        u,\n        c\n    ];\n}\nvar Lo = Object.freeze({\n    prepareAndValidate: Po\n}), Wo = 30;\nfunction Uo(t) {\n    return t <= Wo ? t : Y(t, Math.floor(Math.sqrt(t)));\n}\nfunction Vo(t, e, n) {\n    var r = e.rank > 1 ? e.shape[e.rank - 1] : 1, o = e.rank > 1 ? e.rank - 1 : 1, a = \"Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: \" + n.shape + \", indices.shape: \" + e.shape + \", shape: \" + t + \", sliceDim: \" + r + \", and batchDim: \" + o + \".\";\n    if (n.rank < o) throw new Error(a + \" update.rank < \" + o + \". \");\n    if (t.length < r + (n.rank - o)) throw new Error(a + \" Output shape length < \" + (r + (n.rank - o)));\n    if (n.rank !== o + t.length - r) throw new Error(a + \" update.rank != \" + (o + t.length - r));\n    for(var i = 0; i < o; ++i)if (n.shape[i] !== e.shape[i]) throw new Error(a + \" updates.shape[\" + i + \"] (\" + n.shape[i] + \") != indices.shape[\" + i + \"] (\" + e.shape[i] + \").\");\n    for(i = 0; i < n.rank - o; ++i)if (n.shape[i + o] !== t[i + r]) throw new Error(a + \" updates.shape[\" + (i + o) + \"] (\" + n.shape[i + o] + \") != shape[\" + (i + o) + \"] (\" + t[i + o] + \")\");\n}\nfunction zo(t, e, n) {\n    if (e.rank < 1) throw new Error(\"tf.scatterND() expects the indices to be rank 1 or higher, but the rank was \" + e.rank + \".\");\n    if (t.rank < 1) throw new Error(\"tf.scatterND() expects the updates to be rank 1 or higher, but the rank was \" + t.rank + \".\");\n    if (\"int32\" !== e.dtype) throw new Error(\"The dtype of 'indices' should be int32, but got dtype: \" + e.dtype);\n    if (n.length < 1) throw new Error(\"Output rank must be greater or equal to 1, but got shape: \" + n);\n    if (0 === n.length) {\n        if (0 === e.size) throw new Error(\"Indices specified for empty output. indices shape: \" + e.shape);\n        if (0 === t.size) throw new Error(\"Updates specified for empty output. updates shape: \" + t.shape);\n    }\n    Vo(n, e, t);\n}\nfunction Go(t, e, n) {\n    for(var r = e.shape.length, o = r > 1 ? e.shape[r - 1] : 1, a = n.length, i = 1, s = o; s < a; ++s)i *= n[s];\n    var u = o < 1 ? 1 : o;\n    return {\n        sliceRank: o,\n        numUpdates: k(e.shape) / u,\n        sliceSize: i,\n        strides: $(n.slice(0, o)).concat([\n            1\n        ]),\n        outputSize: k(n)\n    };\n}\nvar Ho = Object.freeze({\n    validateUpdateShape: Vo,\n    validateInput: zo,\n    calculateShapes: Go\n});\nfunction qo(t, e, n) {\n    C(t.rank === e.length, function() {\n        return \"Error in slice\" + t.rank + \"D: Length of begin \" + e + \" must match the rank of the array (\" + t.rank + \").\";\n    }), C(t.rank === n.length, function() {\n        return \"Error in slice\" + t.rank + \"D: Length of size \" + n + \" must match the rank of the array (\" + t.rank + \").\";\n    });\n    for(var r = function(r) {\n        C(e[r] + n[r] <= t.shape[r], function() {\n            return \"Error in slice\" + t.rank + \"D: begin[\" + r + \"] + size[\" + r + \"] (\" + (e[r] + n[r]) + \") would overflow input.shape[\" + r + \"] (\" + t.shape[r] + \")\";\n        });\n    }, o = 0; o < t.rank; ++o)r(o);\n}\nfunction Ko(t) {\n    for(var e = [], n = 0; t > 0;)1 & t && e.push(n), t /= 2, n++;\n    return e;\n}\nfunction jo(t, e, n) {\n    for(var r = [], o = 0; o < t.length; o++)r[o] = Math.ceil((e[o] - t[o]) / n[o]);\n    return r;\n}\nfunction Xo(t, e, n, r, o) {\n    var a = e[o], i = n[o] || 1;\n    (t & 1 << o || null == a) && (a = i > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);\n    var s = r[o];\n    return a < 0 && (a += s), a = x(0, a, s - 1);\n}\nfunction Yo(t, e, n, r, o) {\n    var a = e[o], i = n[o] || 1;\n    (t & 1 << o || null == a) && (a = i > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);\n    var s = r[o];\n    return a < 0 && (a += s), a = i > 0 ? x(0, a, s) : x(-1, a, s - 1);\n}\nfunction $o(t, e, n) {\n    for(var r = n.length, o = 0; o < n.length; o++)if (n[o] > 1) {\n        r = o;\n        break;\n    }\n    for(o = r + 1; o < n.length; o++)if (e[o] > 0 || n[o] !== t[o]) return !1;\n    return !0;\n}\nfunction Qo(t, e) {\n    for(var n = t.length > 0 ? t[t.length - 1] : 1, r = 0; r < t.length - 1; r++)n += t[r] * e[r];\n    return n;\n}\nvar Jo = Object.freeze({\n    assertParamsValid: qo,\n    maskToAxes: Ko,\n    computeOutShape: jo,\n    startForAxis: Xo,\n    stopForAxis: Yo,\n    isSliceContinous: $o,\n    computeFlatOffset: Qo\n});\nfunction Zo(t) {\n    return C(X(t), function() {\n        return \"The f passed in grad(f) must be a function\";\n    }), function(e, n) {\n        var r = gn(e, \"x\", \"tf.grad\", null), o = null != n ? gn(n, \"dy\", \"tf.grad\") : null;\n        return Lt.tidy(function() {\n            var e = Lt.gradients(function() {\n                return t(r);\n            }, [\n                r\n            ], o), n = e.value, a = e.grads;\n            return null != o && E(n.shape, o.shape, \"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)\"), aa(a), a[0];\n        });\n    };\n}\nfunction ta(t) {\n    return C(X(t), function() {\n        return \"The f passed in grads(f) must be a function\";\n    }), function(e, n) {\n        C(Array.isArray(e), function() {\n            return \"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s\";\n        });\n        var r = mn(e, \"args\", \"tf.grads\", null), o = null != n ? gn(n, \"dy\", \"tf.grads\") : null;\n        return Lt.tidy(function() {\n            var e = Lt.gradients(function() {\n                return t.apply(void 0, r);\n            }, r, o), n = e.value, a = e.grads;\n            return null != o && E(n.shape, o.shape, \"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"), aa(a), a;\n        });\n    };\n}\nfunction ea(t) {\n    return C(X(t), function() {\n        return \"The f passed in valueAndGrad(f) must be a function\";\n    }), function(e, n) {\n        C(e instanceof wt, function() {\n            return \"The x passed in valueAndGrad(f)(x) must be a tensor\";\n        }), C(null == n || n instanceof wt, function() {\n            return \"The dy passed in valueAndGrad(f)(x, dy) must be a tensor\";\n        });\n        var r = Lt.gradients(function() {\n            return t(e);\n        }, [\n            e\n        ], n), o = r.grads, a = r.value;\n        return aa(o), {\n            grad: o[0],\n            value: a\n        };\n    };\n}\nfunction na(t) {\n    return C(X(t), function() {\n        return \"The f passed in valueAndGrads(f) must be a function\";\n    }), function(e, n) {\n        C(Array.isArray(e) && e.every(function(t) {\n            return t instanceof wt;\n        }), function() {\n            return \"The args passed in valueAndGrads(f)(args) must be array of tensors\";\n        }), C(null == n || n instanceof wt, function() {\n            return \"The dy passed in valueAndGrads(f)(args, dy) must be a tensor\";\n        });\n        var r = Lt.gradients(function() {\n            return t.apply(void 0, e);\n        }, e, n);\n        return null != n && E(r.value.shape, n.shape, \"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"), aa(r.grads), r;\n    };\n}\nfunction ra(t, e) {\n    C(X(t), function() {\n        return \"The f passed in variableGrads(f) must be a function\";\n    }), C(null == e || Array.isArray(e) && e.every(function(t) {\n        return t instanceof St;\n    }), function() {\n        return \"The varList passed in variableGrads(f, varList) must be an array of variables\";\n    });\n    var n = null != e;\n    if (!n) for(var r in e = [], Lt.registeredVariables)e.push(Lt.registeredVariables[r]);\n    var o = n ? e.filter(function(t) {\n        return !t.trainable;\n    }) : null, a = e.length;\n    C((e = e.filter(function(t) {\n        return t.trainable;\n    })).length > 0, function() {\n        return \"variableGrads() expects at least one of the input variables to be trainable, but none of the \" + a + \" variables is trainable.\";\n    });\n    var i = Lt.gradients(t, e, null, !0), s = i.value, u = i.grads;\n    C(u.some(function(t) {\n        return null != t;\n    }), function() {\n        return \"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().\";\n    }), C(0 === s.rank, function() {\n        return \"The f passed in variableGrads(f) must return a scalar, but it returned a rank-\" + s.rank + \" tensor\";\n    });\n    var c = {};\n    return e.forEach(function(t, e) {\n        null != u[e] && (c[t.name] = u[e]);\n    }), null != o && o.forEach(function(t) {\n        return c[t.name] = null;\n    }), {\n        value: s,\n        grads: c\n    };\n}\nfunction oa(t) {\n    return Lt.customGrad(t);\n}\nfunction aa(t) {\n    if (t.filter(function(t) {\n        return null == t;\n    }).length > 0) throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that\\n    the f you passed encloses all operations that lead from x to y.\");\n}\nvar ia = An({\n    softmax_: function(t, e) {\n        void 0 === e && (e = -1);\n        var n = gn(t, \"logits\", \"softmax\", \"float32\");\n        if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error(\"Softmax along a non-last dimension is not yet supported. Logits was rank \" + n.rank + \" and dim was \" + e);\n        return Lt.runKernelFunc(function(t, r) {\n            var o = t.softmax(n, e);\n            return r([\n                o\n            ]), o;\n        }, {\n            logits: n\n        }, function(t, n) {\n            var r = n[0], o = t.mul(r);\n            return {\n                logits: function() {\n                    return o.sub(o.sum([\n                        e\n                    ], !0).mul(r));\n                }\n            };\n        }, \"Softmax\", {\n            dim: e\n        }, [], [\n            !0\n        ]);\n    }\n}), sa = An({\n    logSoftmax_: function(t, e) {\n        void 0 === e && (e = -1);\n        var n = gn(t, \"logits\", \"logSoftmax\");\n        if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error(\"Log Softmax along a non-last dimension is not yet supported. Logits was rank \" + n.rank + \" and axis was \" + e);\n        return oa(function(t, n) {\n            var r = t.max(e, !0), o = t.sub(r), a = o.toFloat().sub(o.exp().sum(e, !0).log());\n            n([\n                a\n            ]);\n            return {\n                value: a,\n                gradFunc: function(t, n) {\n                    var r = n[0].exp();\n                    return t.sub(t.sum(e, !0).mul(r));\n                }\n            };\n        })(n);\n    }\n});\nvar ua = An({\n    transpose_: function(t, e) {\n        var n = gn(t, \"x\", \"transpose\");\n        if (null == e && (e = n.shape.map(function(t, e) {\n            return e;\n        }).reverse()), C(n.rank === e.length, function() {\n            return \"Error in transpose: rank of input \" + n.rank + \" must match length of perm \" + e + \".\";\n        }), e.forEach(function(t) {\n            C(t >= 0 && t < n.rank, function() {\n                return \"All entries in 'perm' must be between 0 and \" + (n.rank - 1) + \" but got \" + e;\n            });\n        }), n.rank <= 1) return n.clone();\n        var r = {\n            perm: e\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.transpose(n, e);\n        }, {\n            x: n\n        }, null, \"Transpose\", r);\n    }\n}), ca = function() {\n    function t(t, e) {\n        this.backend = t, this.dataMover = e, this.data = new WeakMap, this.dataIdsCount = 0;\n    }\n    return t.prototype.get = function(t) {\n        return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t);\n    }, t.prototype.set = function(t, e) {\n        this.dataIdsCount++, this.data.set(t, e);\n    }, t.prototype.has = function(t) {\n        return this.data.has(t);\n    }, t.prototype.delete = function(t) {\n        return this.dataIdsCount--, this.data.delete(t);\n    }, t.prototype.numDataIds = function() {\n        return this.dataIdsCount;\n    }, t;\n}(), la = function() {\n    function t() {}\n    return t.prototype.time = function(t) {\n        return ha(\"time\");\n    }, t.prototype.read = function(t) {\n        return ha(\"read\");\n    }, t.prototype.readSync = function(t) {\n        return ha(\"readSync\");\n    }, t.prototype.numDataIds = function() {\n        return ha(\"numDataIds\");\n    }, t.prototype.disposeData = function(t) {\n        return ha(\"disposeData\");\n    }, t.prototype.write = function(t, e, n) {\n        return ha(\"write\");\n    }, t.prototype.move = function(t, e, n, r) {\n        return ha(\"move\");\n    }, t.prototype.memory = function() {\n        return ha(\"memory\");\n    }, t.prototype.floatPrecision = function() {\n        return ha(\"floatPrecision\");\n    }, t.prototype.epsilon = function() {\n        return 32 === this.floatPrecision() ? 1e-7 : 1e-4;\n    }, t.prototype.batchMatMul = function(t, e, n, r) {\n        return ha(\"batchMatMul\");\n    }, t.prototype.fusedBatchMatMul = function(t) {\n        t.a, t.b, t.transposeA, t.transposeB, t.bias, t.activation, t.preluActivationWeights;\n        return ha(\"fusedBatchMatMul\");\n    }, t.prototype.slice = function(t, e, n) {\n        return ha(\"slice\");\n    }, t.prototype.stridedSlice = function(t, e, n, r) {\n        return ha(\"stridedSlice\");\n    }, t.prototype.unstack = function(t, e) {\n        return ha(\"unstack\");\n    }, t.prototype.reverse = function(t, e) {\n        return ha(\"reverse\");\n    }, t.prototype.concat = function(t, e) {\n        return ha(\"concat\");\n    }, t.prototype.neg = function(t) {\n        return ha(\"neg\");\n    }, t.prototype.add = function(t, e) {\n        return ha(\"add\");\n    }, t.prototype.addN = function(t) {\n        return ha(\"addN\");\n    }, t.prototype.subtract = function(t, e) {\n        return ha(\"subtract\");\n    }, t.prototype.multiply = function(t, e) {\n        return ha(\"multiply\");\n    }, t.prototype.realDivide = function(t, e) {\n        return ha(\"realDivide\");\n    }, t.prototype.floorDiv = function(t, e) {\n        return ha(\"floorDiv\");\n    }, t.prototype.sum = function(t, e) {\n        return ha(\"sum\");\n    }, t.prototype.prod = function(t, e) {\n        return ha(\"prod\");\n    }, t.prototype.unsortedSegmentSum = function(t, e, n) {\n        return ha(\"unsortedSegmentSum\");\n    }, t.prototype.argMin = function(t, e) {\n        return ha(\"argMin\");\n    }, t.prototype.argMax = function(t, e) {\n        return ha(\"argMax\");\n    }, t.prototype.equal = function(t, e) {\n        return ha(\"equal\");\n    }, t.prototype.notEqual = function(t, e) {\n        return ha(\"notEqual\");\n    }, t.prototype.less = function(t, e) {\n        return ha(\"less\");\n    }, t.prototype.lessEqual = function(t, e) {\n        return ha(\"lessEqual\");\n    }, t.prototype.greater = function(t, e) {\n        return ha(\"greater\");\n    }, t.prototype.greaterEqual = function(t, e) {\n        return ha(\"greaterEqual\");\n    }, t.prototype.logicalNot = function(t) {\n        return ha(\"logicalNot\");\n    }, t.prototype.logicalAnd = function(t, e) {\n        return ha(\"logicalAnd\");\n    }, t.prototype.logicalOr = function(t, e) {\n        return ha(\"logicalOr\");\n    }, t.prototype.where = function(t) {\n        return ha(\"where\");\n    }, t.prototype.select = function(t, e, n) {\n        return ha(\"select\");\n    }, t.prototype.topk = function(t, e, n) {\n        return ha(\"topk\");\n    }, t.prototype.min = function(t, e) {\n        return ha(\"min\");\n    }, t.prototype.minimum = function(t, e) {\n        return ha(\"minimum\");\n    }, t.prototype.mod = function(t, e) {\n        return ha(\"mod\");\n    }, t.prototype.max = function(t, e) {\n        return ha(\"max\");\n    }, t.prototype.maximum = function(t, e) {\n        return ha(\"maximum\");\n    }, t.prototype.all = function(t, e) {\n        return ha(\"all\");\n    }, t.prototype.any = function(t, e) {\n        return ha(\"any\");\n    }, t.prototype.squaredDifference = function(t, e) {\n        return ha(\"squaredDifference\");\n    }, t.prototype.ceil = function(t) {\n        return ha(\"ceil\");\n    }, t.prototype.floor = function(t) {\n        return ha(\"floor\");\n    }, t.prototype.round = function(t) {\n        return ha(\"round\");\n    }, t.prototype.sign = function(t) {\n        return ha(\"sign\");\n    }, t.prototype.isNaN = function(t) {\n        return ha(\"isNaN\");\n    }, t.prototype.isInf = function(t) {\n        return ha(\"isInf\");\n    }, t.prototype.isFinite = function(t) {\n        return ha(\"isFinite\");\n    }, t.prototype.pow = function(t, e) {\n        return ha(\"pow\");\n    }, t.prototype.exp = function(t) {\n        return ha(\"exp\");\n    }, t.prototype.expm1 = function(t) {\n        return ha(\"expm1\");\n    }, t.prototype.softmax = function(t, e) {\n        return ha(\"softmax\");\n    }, t.prototype.log = function(t) {\n        return ha(\"log\");\n    }, t.prototype.log1p = function(t) {\n        return ha(\"log1p\");\n    }, t.prototype.sqrt = function(t) {\n        return ha(\"sqrt\");\n    }, t.prototype.rsqrt = function(t) {\n        return ha(\"rsqrt\");\n    }, t.prototype.square = function(t) {\n        return ha(\"square\");\n    }, t.prototype.reciprocal = function(t) {\n        return ha(\"reciprocal\");\n    }, t.prototype.relu = function(t) {\n        return ha(\"relu\");\n    }, t.prototype.relu6 = function(t) {\n        return ha(\"relu6\");\n    }, t.prototype.prelu = function(t, e) {\n        return ha(\"prelu\");\n    }, t.prototype.elu = function(t) {\n        return ha(\"elu\");\n    }, t.prototype.eluDer = function(t, e) {\n        return ha(\"eluDer\");\n    }, t.prototype.selu = function(t) {\n        return ha(\"selu\");\n    }, t.prototype.int = function(t) {\n        return ha(\"int\");\n    }, t.prototype.clip = function(t, e, n) {\n        return ha(\"clip\");\n    }, t.prototype.abs = function(t) {\n        return ha(\"abs\");\n    }, t.prototype.complexAbs = function(t) {\n        return ha(\"complexAbs\");\n    }, t.prototype.sigmoid = function(t) {\n        return ha(\"sigmoid\");\n    }, t.prototype.softplus = function(t) {\n        return ha(\"softplus\");\n    }, t.prototype.sin = function(t) {\n        return ha(\"sin\");\n    }, t.prototype.cos = function(t) {\n        return ha(\"cos\");\n    }, t.prototype.tan = function(t) {\n        return ha(\"tan\");\n    }, t.prototype.asin = function(t) {\n        return ha(\"asin\");\n    }, t.prototype.acos = function(t) {\n        return ha(\"acos\");\n    }, t.prototype.atan = function(t) {\n        return ha(\"atan\");\n    }, t.prototype.atan2 = function(t, e) {\n        return ha(\"atan2\");\n    }, t.prototype.sinh = function(t) {\n        return ha(\"sinh\");\n    }, t.prototype.cosh = function(t) {\n        return ha(\"cosh\");\n    }, t.prototype.tanh = function(t) {\n        return ha(\"tanh\");\n    }, t.prototype.asinh = function(t) {\n        return ha(\"asinh\");\n    }, t.prototype.acosh = function(t) {\n        return ha(\"acosh\");\n    }, t.prototype.atanh = function(t) {\n        return ha(\"atanh\");\n    }, t.prototype.erf = function(t) {\n        return ha(\"erf\");\n    }, t.prototype.step = function(t, e) {\n        return ha(\"step\");\n    }, t.prototype.fusedConv2d = function(t) {\n        t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights;\n        return ha(\"fusedConv2d\");\n    }, t.prototype.conv2d = function(t, e, n) {\n        return ha(\"conv2d\");\n    }, t.prototype.conv2dDerInput = function(t, e, n) {\n        return ha(\"conv2dDerInput\");\n    }, t.prototype.conv2dDerFilter = function(t, e, n) {\n        return ha(\"conv2dDerFilter\");\n    }, t.prototype.fusedDepthwiseConv2D = function(t) {\n        t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights;\n        return ha(\"fusedDepthwiseConv2D\");\n    }, t.prototype.depthwiseConv2D = function(t, e, n) {\n        return ha(\"depthwiseConv2D\");\n    }, t.prototype.depthwiseConv2DDerInput = function(t, e, n) {\n        return ha(\"depthwiseConv2DDerInput\");\n    }, t.prototype.depthwiseConv2DDerFilter = function(t, e, n) {\n        return ha(\"depthwiseConv2DDerFilter\");\n    }, t.prototype.conv3d = function(t, e, n) {\n        return ha(\"conv3d\");\n    }, t.prototype.conv3dDerInput = function(t, e, n) {\n        return ha(\"conv3dDerInput\");\n    }, t.prototype.conv3dDerFilter = function(t, e, n) {\n        return ha(\"conv3dDerFilter\");\n    }, t.prototype.maxPool = function(t, e) {\n        return ha(\"maxPool\");\n    }, t.prototype.maxPoolBackprop = function(t, e, n, r) {\n        return ha(\"maxPoolBackprop\");\n    }, t.prototype.avgPool = function(t, e) {\n        return ha(\"avgPool\");\n    }, t.prototype.avgPoolBackprop = function(t, e, n) {\n        return ha(\"avgPoolBackprop\");\n    }, t.prototype.avgPool3d = function(t, e) {\n        return ha(\"avgPool3d\");\n    }, t.prototype.avgPool3dBackprop = function(t, e, n) {\n        return ha(\"avgPool3dBackprop\");\n    }, t.prototype.maxPool3d = function(t, e) {\n        return ha(\"maxPool3d\");\n    }, t.prototype.maxPool3dBackprop = function(t, e, n, r) {\n        return ha(\"maxPool3dBackprop\");\n    }, t.prototype.reshape = function(t, e) {\n        return ha(\"reshape\");\n    }, t.prototype.cast = function(t, e) {\n        return ha(\"cast\");\n    }, t.prototype.tile = function(t, e) {\n        return ha(\"tile\");\n    }, t.prototype.pad = function(t, e, n) {\n        return ha(\"pad\");\n    }, t.prototype.transpose = function(t, e) {\n        return ha(\"transpose\");\n    }, t.prototype.gather = function(t, e, n) {\n        return ha(\"gather\");\n    }, t.prototype.gatherND = function(t, e) {\n        return ha(\"gatherND\");\n    }, t.prototype.scatterND = function(t, e, n) {\n        return ha(\"scatterND\");\n    }, t.prototype.batchToSpaceND = function(t, e, n) {\n        return ha(\"batchToSpaceND\");\n    }, t.prototype.spaceToBatchND = function(t, e, n) {\n        return ha(\"spaceToBatchND\");\n    }, t.prototype.resizeBilinear = function(t, e, n, r) {\n        return ha(\"resizeBilinear\");\n    }, t.prototype.resizeBilinearBackprop = function(t, e, n) {\n        return ha(\"resizeBilinearBackprop\");\n    }, t.prototype.resizeNearestNeighbor = function(t, e, n, r) {\n        return ha(\"resizeNearestNeighbor\");\n    }, t.prototype.resizeNearestNeighborBackprop = function(t, e, n) {\n        return ha(\"resizeNearestNeighborBackprop\");\n    }, t.prototype.batchNormalization = function(t, e, n, r, o, a) {\n        return ha(\"batchNormalization\");\n    }, t.prototype.localResponseNormalization4D = function(t, e, n, r, o) {\n        return ha(\"localResponseNormalization4D\");\n    }, t.prototype.LRNGrad = function(t, e, n, r, o, a, i) {\n        return ha(\"LRNGrad\");\n    }, t.prototype.multinomial = function(t, e, n, r) {\n        return ha(\"multinomial\");\n    }, t.prototype.oneHot = function(t, e, n, r) {\n        return ha(\"oneHot\");\n    }, t.prototype.cumsum = function(t, e, n, r) {\n        return ha(\"cumsum\");\n    }, t.prototype.nonMaxSuppression = function(t, e, n, r, o) {\n        return ha(\"nonMaxSuppression\");\n    }, t.prototype.fft = function(t) {\n        return ha(\"fft\");\n    }, t.prototype.ifft = function(t) {\n        return ha(\"ifft\");\n    }, t.prototype.complex = function(t, e) {\n        return ha(\"complex\");\n    }, t.prototype.real = function(t) {\n        return ha(\"real\");\n    }, t.prototype.imag = function(t) {\n        return ha(\"imag\");\n    }, t.prototype.cropAndResize = function(t, e, n, r, o, a) {\n        return ha(\"cropAndResize\");\n    }, t.prototype.depthToSpace = function(t, e, n) {\n        return ha(\"depthToSpace\");\n    }, t.prototype.split = function(t, e, n) {\n        return ha(\"split\");\n    }, t.prototype.sparseToDense = function(t, e, n, r) {\n        return ha(\"sparseToDense\");\n    }, t.prototype.diag = function(t) {\n        return ha(\"diag\");\n    }, t.prototype.fill = function(t, e, n) {\n        return ha(\"fill\");\n    }, t.prototype.onesLike = function(t) {\n        return ha(\"onesLike\");\n    }, t.prototype.zerosLike = function(t) {\n        return ha(\"zerosLike\");\n    }, t.prototype.linspace = function(t, e, n) {\n        return ha(\"linspace\");\n    }, t.prototype.dispose = function() {\n        return ha(\"dispose\");\n    }, t;\n}();\nfunction ha(t) {\n    throw new Error(\"'\" + t + \"' not yet implemented or not found in the registry. Did you forget to import the kernel?\");\n}\nfunction fa(t, e, n, r, o, a, i) {\n    void 0 === i && (i = \"channelsLast\");\n    var s, u = ma(e), c = u[0], l = u[1];\n    if (\"channelsLast\" === i) s = [\n        c,\n        l,\n        t[3],\n        t[3]\n    ];\n    else {\n        if (\"channelsFirst\" !== i) throw new Error(\"Unknown dataFormat \" + i);\n        s = [\n            c,\n            l,\n            t[1],\n            t[1]\n        ];\n    }\n    return pa(t, s, n, r, o, a, !1, i);\n}\nfunction da(t, e, n, r, o, a, i) {\n    void 0 === i && (i = \"NDHWC\");\n    var s, u, c = ya(e), l = c[0], h = c[1], f = c[2];\n    if (\"NDHWC\" === i) u = \"channelsLast\", s = [\n        l,\n        h,\n        f,\n        t[4],\n        t[4]\n    ];\n    else {\n        if (\"NCDHW\" !== i) throw new Error(\"Unknown dataFormat \" + i);\n        u = \"channelsFirst\", s = [\n            l,\n            h,\n            f,\n            t[1],\n            t[1]\n        ];\n    }\n    return va(t, s, n, r, o, !1, u, a);\n}\nfunction pa(t, e, n, r, o, a, i, s) {\n    void 0 === i && (i = !1), void 0 === s && (s = \"channelsLast\");\n    var u = [\n        -1,\n        -1,\n        -1,\n        -1\n    ], c = u[0], l = u[1], h = u[2], f = u[3];\n    if (\"channelsLast\" === s) c = t[0], l = t[1], h = t[2], f = t[3];\n    else {\n        if (\"channelsFirst\" !== s) throw new Error(\"Unknown dataFormat \" + s);\n        c = t[0], f = t[1], l = t[2], h = t[3];\n    }\n    var d, p = e[0], v = e[1], g = e[3], m = ma(n), y = m[0], x = m[1], b = ma(r), w = b[0], E = b[1], R = xa(p, w), I = xa(v, E), k = function(t, e, n, r, o, a, i, s) {\n        var u, c, l;\n        if (\"number\" == typeof t) {\n            u = {\n                top: t,\n                bottom: t,\n                left: t,\n                right: t,\n                type: 0 === t ? \"VALID\" : \"NUMBER\"\n            };\n            var h = function(t, e, n, r, o) {\n                null == r && (r = ga(t, e, n));\n                var a = t[0], i = t[1], s = ba((a - e + 2 * r) / n + 1, o);\n                C(A(s), function() {\n                    return \"The output # of rows (\" + s + \") must be an integer. Change the stride and/or zero pad parameters\";\n                });\n                var u = ba((i - e + 2 * r) / n + 1, o);\n                return C(A(u), function() {\n                    return \"The output # of columns (\" + u + \") must be an integer. Change the stride and/or zero pad parameters\";\n                }), [\n                    s,\n                    u\n                ];\n            }([\n                e,\n                n\n            ], a, r, t, s);\n            c = h[0], l = h[1];\n        } else if (\"same\" === t) {\n            c = Math.ceil(e / r), l = Math.ceil(n / o);\n            var f = Math.max(0, (c - 1) * r + a - e), d = Math.max(0, (l - 1) * o + i - n), p = Math.floor(f / 2), v = f - p, g = Math.floor(d / 2);\n            u = {\n                top: p,\n                bottom: v,\n                left: g,\n                right: d - g,\n                type: \"SAME\"\n            };\n        } else {\n            if (\"valid\" !== t) throw Error(\"Unknown padding parameter: \" + t);\n            u = {\n                top: 0,\n                bottom: 0,\n                left: 0,\n                right: 0,\n                type: \"VALID\"\n            }, c = Math.ceil((e - a + 1) / r), l = Math.ceil((n - i + 1) / o);\n        }\n        return {\n            padInfo: u,\n            outHeight: c,\n            outWidth: l\n        };\n    }(o, l, h, y, x, R, I, a), S = k.padInfo, T = k.outHeight, D = k.outWidth, N = i ? g * f : g;\n    return \"channelsFirst\" === s ? d = [\n        c,\n        N,\n        T,\n        D\n    ] : \"channelsLast\" === s && (d = [\n        c,\n        T,\n        D,\n        N\n    ]), {\n        batchSize: c,\n        dataFormat: s,\n        inHeight: l,\n        inWidth: h,\n        inChannels: f,\n        outHeight: T,\n        outWidth: D,\n        outChannels: N,\n        padInfo: S,\n        strideHeight: y,\n        strideWidth: x,\n        filterHeight: p,\n        filterWidth: v,\n        effectiveFilterHeight: R,\n        effectiveFilterWidth: I,\n        dilationHeight: w,\n        dilationWidth: E,\n        inShape: t,\n        outShape: d,\n        filterShape: e\n    };\n}\nfunction va(t, e, n, r, o, a, i, s) {\n    void 0 === a && (a = !1), void 0 === i && (i = \"channelsLast\");\n    var u = [\n        -1,\n        -1,\n        -1,\n        -1,\n        -1\n    ], c = u[0], l = u[1], h = u[2], f = u[3], d = u[4];\n    if (\"channelsLast\" === i) c = t[0], l = t[1], h = t[2], f = t[3], d = t[4];\n    else {\n        if (\"channelsFirst\" !== i) throw new Error(\"Unknown dataFormat \" + i);\n        c = t[0], d = t[1], l = t[2], h = t[3], f = t[4];\n    }\n    var p, v = e[0], g = e[1], m = e[2], y = e[4], x = ya(n), b = x[0], w = x[1], E = x[2], R = ya(r), I = R[0], k = R[1], S = R[2], T = xa(v, I), D = xa(g, k), N = xa(m, S), F = function(t, e, n, r, o, a, i, s, u, c, l) {\n        var h, f, d, p;\n        if (\"number\" == typeof t) {\n            h = {\n                top: t,\n                bottom: t,\n                left: t,\n                right: t,\n                front: t,\n                back: t,\n                type: 0 === t ? \"VALID\" : \"NUMBER\"\n            };\n            var v = function(t, e, n, r, o, a) {\n                null == o && (o = ga(t, e, r));\n                var i = t[0], s = t[1], u = t[2], c = ba((i - e + 2 * o) / r + 1, a);\n                C(A(c), function() {\n                    return \"The output # of depths (\" + c + \") must be an integer. Change the stride and/or zero pad parameters\";\n                });\n                var l = ba((s - e + 2 * o) / r + 1, a);\n                C(A(l), function() {\n                    return \"The output # of rows (\" + l + \") must be an integer. Change the stride and/or zero pad parameters\";\n                });\n                var h = ba((u - e + 2 * o) / r + 1, a);\n                return C(A(h), function() {\n                    return \"The output # of columns (\" + h + \") must be an integer. Change the stride and/or zero pad parameters\";\n                }), [\n                    c,\n                    l,\n                    h,\n                    n\n                ];\n            }([\n                e,\n                n,\n                r,\n                1\n            ], s, 1, o, t, l);\n            f = v[0], d = v[1], p = v[2];\n        } else if (\"same\" === t) {\n            f = Math.ceil(e / o), d = Math.ceil(n / a), p = Math.ceil(r / i);\n            var g = (f - 1) * o + s - e, m = (d - 1) * a + u - n, y = (p - 1) * i + c - r, x = Math.floor(g / 2), b = g - x, w = Math.floor(m / 2), E = m - w, R = Math.floor(y / 2);\n            h = {\n                top: w,\n                bottom: E,\n                left: R,\n                right: y - R,\n                front: x,\n                back: b,\n                type: \"SAME\"\n            };\n        } else {\n            if (\"valid\" !== t) throw Error(\"Unknown padding parameter: \" + t);\n            h = {\n                top: 0,\n                bottom: 0,\n                left: 0,\n                right: 0,\n                front: 0,\n                back: 0,\n                type: \"VALID\"\n            }, f = Math.ceil((e - s + 1) / o), d = Math.ceil((n - u + 1) / a), p = Math.ceil((r - c + 1) / i);\n        }\n        return {\n            padInfo: h,\n            outDepth: f,\n            outHeight: d,\n            outWidth: p\n        };\n    }(o, l, h, f, b, w, E, T, D, N, s), _ = F.padInfo, O = F.outDepth, M = F.outHeight, B = F.outWidth, P = a ? y * d : y;\n    return \"channelsFirst\" === i ? p = [\n        c,\n        P,\n        O,\n        M,\n        B\n    ] : \"channelsLast\" === i && (p = [\n        c,\n        O,\n        M,\n        B,\n        P\n    ]), {\n        batchSize: c,\n        dataFormat: i,\n        inDepth: l,\n        inHeight: h,\n        inWidth: f,\n        inChannels: d,\n        outDepth: O,\n        outHeight: M,\n        outWidth: B,\n        outChannels: P,\n        padInfo: _,\n        strideDepth: b,\n        strideHeight: w,\n        strideWidth: E,\n        filterDepth: v,\n        filterHeight: g,\n        filterWidth: m,\n        effectiveFilterDepth: T,\n        effectiveFilterHeight: D,\n        effectiveFilterWidth: N,\n        dilationDepth: I,\n        dilationHeight: k,\n        dilationWidth: S,\n        inShape: t,\n        outShape: p,\n        filterShape: e\n    };\n}\nfunction ga(t, e, n, r) {\n    void 0 === r && (r = 1);\n    var o = xa(e, r);\n    return Math.floor((t[0] * (n - 1) - n + o) / 2);\n}\nfunction ma(t) {\n    return \"number\" == typeof t ? [\n        t,\n        t,\n        t\n    ] : 2 === t.length ? [\n        t[0],\n        t[1],\n        1\n    ] : t;\n}\nfunction ya(t) {\n    return \"number\" == typeof t ? [\n        t,\n        t,\n        t\n    ] : t;\n}\nfunction xa(t, e) {\n    return e <= 1 ? t : t + (t - 1) * (e - 1);\n}\nfunction ba(t, e) {\n    if (!e) return t;\n    switch(e){\n        case \"round\":\n            return Math.round(t);\n        case \"ceil\":\n            return Math.ceil(t);\n        case \"floor\":\n            return Math.floor(t);\n        default:\n            throw new Error(\"Unknown roundingMode \" + e);\n    }\n}\nfunction wa(t) {\n    var e = ma(t), n = e[0], r = e[1], o = e[2];\n    return 1 === n && 1 === r && 1 === o;\n}\nfunction Ca(t, e) {\n    return wa(t) || wa(e);\n}\nfunction Ea(t) {\n    if (\"NHWC\" === t) return \"channelsLast\";\n    if (\"NCHW\" === t) return \"channelsFirst\";\n    throw new Error(\"Unknown dataFormat \" + t);\n}\nfunction Ra(t, e, n) {\n    if (\"complex64\" === e) {\n        if (\"complex64\" === t.dtype) return t.clone();\n        var r = Gn(t.shape), o = t.toFloat(), a = n.complex(o, r);\n        return r.dispose(), o.dispose(), a;\n    }\n    if (!U(t.dtype, e)) return Lt.makeTensorFromDataId(t.dataId, t.shape, e);\n    if (\"complex64\" === t.dtype) {\n        var i = n.real(t);\n        a = i.cast(e);\n        return i.dispose(), a;\n    }\n    if (\"int32\" === e) return n.int(t);\n    if (\"bool\" === e) {\n        var s = On(0, t.dtype);\n        a = n.notEqual(t, s);\n        return s.dispose(), a;\n    }\n    throw new Error(\"Error in Cast: failed to cast \" + t.dtype + \" to \" + e);\n}\nfunction Ia(t, e) {\n    return Lt.makeTensorFromDataId(t.dataId, e, t.dtype);\n}\nfunction ka(t, e, n) {\n    var r = (e - t) / (n - 1), o = tt(n, \"float32\");\n    o[0] = t;\n    for(var a = 1; a < o.length; a++)o[a] = o[a - 1] + r;\n    return Mn(o, \"float32\");\n}\nvar Sa = Object.freeze({\n    castTensor: Ra,\n    reshapeTensor: Ia,\n    linspaceImpl: ka,\n    upcastType: Tt,\n    axesAreInnerMostDims: yn,\n    combineLocations: xn,\n    computeOutAndReduceShapes: bn,\n    expandShapeToKeepDim: wn,\n    assertAxesAreInnerMostDims: Cn,\n    getAxesPermutation: En,\n    getUndoAxesPermutation: Rn,\n    getInnerMostAxes: In,\n    getBroadcastDims: Mr,\n    getReductionAxes: Br,\n    assertAndGetBroadcastShape: Pr,\n    assertParamsConsistent: kn,\n    computeOutShape: Sn,\n    computePool2DInfo: fa,\n    computePool3DInfo: da,\n    computeConv2DInfo: pa,\n    computeConv3DInfo: va,\n    computeDefaultPad: ga,\n    tupleValuesAreOne: wa,\n    eitherStridesOrDilationsAreOne: Ca,\n    convertConv2DDataFormat: Ea,\n    PARALLELIZE_THRESHOLD: Wo,\n    computeOptimalWindowSize: Uo\n});\nfunction Aa(t, e) {\n    if (t.length !== e.length) throw new Error(\"Cannot merge real and imag arrays of different lengths. real:\" + t.length + \", imag: \" + e.length + \".\");\n    for(var n = new Float32Array(2 * t.length), r = 0; r < n.length; r += 2)n[r] = t[r / 2], n[r + 1] = e[r / 2];\n    return n;\n}\nfunction Ta(t, e) {\n    return {\n        real: t[2 * e],\n        imag: t[2 * e + 1]\n    };\n}\nfunction Da(t, e, n, r) {\n    t[2 * r] = e, t[2 * r + 1] = n;\n}\nfunction Na(t, e, n) {\n    var r = (n ? 2 : -2) * Math.PI * (t / e);\n    return {\n        real: Math.cos(r),\n        imag: Math.sin(r)\n    };\n}\nfunction Fa(t, e, n) {\n    var r = function(t, e, n) {\n        return function(t, e, n) {\n            var r = 0, o = t.length, a = 0, i = !1;\n            for(; r < o;){\n                var s = n(e, t[a = r + (o - r >>> 1)]);\n                s > 0 ? r = a + 1 : (o = a, i = !s);\n            }\n            return i ? r : -r - 1;\n        }(t, e, n || _a);\n    }(t, e, n), o = r < 0 ? -(r + 1) : r;\n    t.splice(o, 0, e);\n}\nfunction _a(t, e) {\n    return t > e ? 1 : t < e ? -1 : 0;\n}\nfunction Oa(t, e, n, r, o) {\n    return Ba(t, e, n, r, o, 0).selectedIndices;\n}\nfunction Ma(t, e, n, r, o, a) {\n    var i = Ba(t, e, n, r, o, a, !0);\n    return i.numValidOutputs.dispose(), {\n        selectedIndices: i.selectedIndices,\n        selectedScores: i.selectedScores\n    };\n}\nfunction Ba(t, e, n, r, o, a, i, s) {\n    void 0 === i && (i = !1), void 0 === s && (s = !1);\n    for(var u = Array.from(e).map(function(t, e) {\n        return {\n            score: t,\n            boxIndex: e,\n            suppressBeginIndex: 0\n        };\n    }).filter(function(t) {\n        return t.score > o;\n    }).sort(Wa), c = a > 0 ? -.5 / a : 0, l = [], h = []; l.length < n && u.length > 0;){\n        var f = u.pop(), d = f.score, p = f.boxIndex, v = f.suppressBeginIndex;\n        if (d < o) break;\n        for(var g = !1, m = l.length - 1; m >= v; --m){\n            var y = Pa(t, p, l[m]);\n            if (y >= r) {\n                g = !0;\n                break;\n            }\n            if (f.score = f.score * La(r, c, y), f.score <= o) break;\n        }\n        f.suppressBeginIndex = l.length, g || (f.score === d ? (l.push(p), h.push(f.score)) : f.score > o && Fa(u, f, Wa));\n    }\n    var x = l.length;\n    return s && (l.fill(0, x), h.fill(0, x)), {\n        selectedIndices: Mn(l, \"int32\"),\n        selectedScores: Mn(h, \"float32\"),\n        numValidOutputs: On(x, \"int32\")\n    };\n}\nfunction Pa(t, e, n) {\n    var r = t.subarray(4 * e, 4 * e + 4), o = t.subarray(4 * n, 4 * n + 4), a = Math.min(r[0], r[2]), i = Math.min(r[1], r[3]), s = Math.max(r[0], r[2]), u = Math.max(r[1], r[3]), c = Math.min(o[0], o[2]), l = Math.min(o[1], o[3]), h = Math.max(o[0], o[2]), f = Math.max(o[1], o[3]), d = (s - a) * (u - i), p = (h - c) * (f - l);\n    if (d <= 0 || p <= 0) return 0;\n    var v = Math.max(a, c), g = Math.max(i, l), m = Math.min(s, h), y = Math.min(u, f), x = Math.max(m - v, 0) * Math.max(y - g, 0);\n    return x / (d + p - x);\n}\nfunction La(t, e, n) {\n    var r = Math.exp(e * n * n);\n    return n <= t ? r : 0;\n}\nfunction Wa(t, e) {\n    return t.score - e.score || t.score === e.score && e.boxIndex - t.boxIndex;\n}\nfunction Ua(t, e, n) {\n    var r = new Array(t.rank).fill(0), o = t.shape.slice();\n    return e.map(function(e) {\n        o[n] = e;\n        var a = t.slice(r, o);\n        return r[n] += e, a;\n    });\n}\nfunction Va(t, e) {\n    for(var n = new Array(t.rank), r = 0; r < n.length; r++)n[r] = t.shape[r] * e[r];\n    var o = er(n, t.dtype);\n    for(r = 0; r < o.values.length; ++r){\n        for(var a = o.indexToLoc(r), i = new Array(t.rank), s = 0; s < i.length; s++)i[s] = a[s] % t.shape[s];\n        var u = t.locToIndex(i);\n        o.values[r] = t.values[u];\n    }\n    return o.toTensor();\n}\nfunction za(t, e, n, r, o) {\n    for(var a = e[e.length - 1], i = [\n        t.length / a,\n        a\n    ], s = i[0], u = i[1], c = B(n, s * r), l = B(\"int32\", s * r), h = 0; h < s; h++){\n        for(var f = h * u, d = t.subarray(f, f + u), p = [], v = 0; v < d.length; v++)p.push({\n            value: d[v],\n            index: v\n        });\n        p.sort(function(t, e) {\n            return e.value - t.value;\n        });\n        var g = h * r, m = c.subarray(g, g + r), y = l.subarray(g, g + r);\n        for(v = 0; v < r; v++)m[v] = p[v].value, y[v] = p[v].index;\n    }\n    var x = e.slice();\n    return x[x.length - 1] = r, [\n        Fn(c, x, n),\n        Fn(l, x, \"int32\")\n    ];\n}\nfunction Ga(t, e) {\n    for(var n = [], r = 0; r < e.length; r++)e[r] && n.push(r);\n    var o = er(t, \"int32\"), a = er([\n        n.length,\n        t.length\n    ], \"int32\");\n    for(r = 0; r < n.length; r++){\n        var i = o.indexToLoc(n[r]), s = r * t.length;\n        a.values.set(i, s);\n    }\n    return a.toTensor();\n}\nvar Ha = function(t, e) {\n    this.outputShape = [], this.outputShape = t, this.variableNames = e.map(function(t, e) {\n        return \"T\" + e;\n    });\n    var n = [];\n    this.variableNames.forEach(function(t) {\n        n.push(\"float v\" + t + \" = get\" + t + \"AtOutCoords();\");\n    });\n    var r = this.variableNames.map(function(t) {\n        return \"v\" + t;\n    }).join(\" + \");\n    this.userCode = \"\\n      void main() {\\n        \" + n.join(\"\\n        \") + \"\\n\\n        float result = \" + r + \";\\n        setOutput(result);\\n      }\\n    \";\n}, qa = function(t, e) {\n    this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.variableNames = e.map(function(t, e) {\n        return \"T\" + e;\n    });\n    var n = [];\n    this.variableNames.forEach(function(t) {\n        n.push(\"vec4 v\" + t + \" = get\" + t + \"AtOutCoords();\");\n    });\n    var r = this.variableNames.map(function(t) {\n        return \"v\" + t;\n    }).join(\" + \");\n    this.userCode = \"\\n      void main() {\\n        \" + n.join(\"\\n        \") + \"\\n\\n        vec4 result = \" + r + \";\\n        setOutput(result);\\n      }\\n    \";\n}, Ka = function(t, e, n) {\n    this.variableNames = [\n        \"A\"\n    ];\n    var r = t.windowSize, o = t.batchSize, a = t.inSize, i = Math.ceil(a / r);\n    n || this.variableNames.push(\"bestIndicesA\"), this.outputShape = [\n        o,\n        i\n    ];\n    var s = \"max\" === e ? \">\" : \"<\", u = n ? \"inOffset + i;\" : \"round(getBestIndicesA(batch, inOffset + i));\";\n    this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + r + \";\\n\\n        int bestIndex = inOffset;\\n        float bestValue = getA(batch, bestIndex);\\n\\n        for (int i = 0; i < \" + r + \"; i++) {\\n          int inIdx = \" + u + \";\\n          float candidate = getA(batch, inIdx);\\n          if (candidate \" + s + \" bestValue) {\\n            bestValue = candidate;\\n            bestIndex = inIdx;\\n          }\\n        }\\n        setOutput(float(bestIndex));\\n      }\\n    \";\n};\nfunction ja(t, e) {\n    return [\n        \"x\",\n        \"y\",\n        \"z\",\n        \"w\",\n        \"u\",\n        \"v\"\n    ].slice(0, e).map(function(e) {\n        return t + \".\" + e;\n    });\n}\nfunction Xa(t, e) {\n    return 1 === e ? [\n        t\n    ] : ja(t, e);\n}\nfunction Ya() {\n    var t, e, n, r, o, a, s, u, c, l;\n    return 2 === i().getNumber(\"WEBGL_VERSION\") ? (t = \"#version 300 es\", e = \"in\", n = \"out\", r = \"in\", o = \"texture\", a = \"outputColor\", s = \"out vec4 outputColor;\", u = \"\\n      bool isnan_custom(float val) {\\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\\n      }\\n\\n      bvec4 isnan_custom(vec4 val) {\\n        return bvec4(isnan_custom(val.x),\\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\\n      }\\n\\n      #define isnan(value) isnan_custom(value)\\n    \", c = \"\", l = \"\\n      #define round(value) newRound(value)\\n      int newRound(float value) {\\n        return int(floor(value + 0.5));\\n      }\\n\\n      ivec4 newRound(vec4 value) {\\n        return ivec4(floor(value + vec4(0.5)));\\n      }\\n    \") : (t = \"\", e = \"attribute\", n = \"varying\", r = \"varying\", o = \"texture2D\", a = \"gl_FragColor\", s = \"\", u = \"\\n      #define isnan(value) isnan_custom(value)\\n      bool isnan_custom(float val) {\\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\\n      }\\n      bvec4 isnan_custom(vec4 val) {\\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\\n      }\\n    \", c = \"\\n      uniform float INFINITY;\\n\\n      bool isinf(float val) {\\n        return abs(val) == INFINITY;\\n      }\\n      bvec4 isinf(vec4 val) {\\n        return equal(abs(val), vec4(INFINITY));\\n      }\\n    \", l = \"\\n      int round(float value) {\\n        return int(floor(value + 0.5));\\n      }\\n\\n      ivec4 round(vec4 value) {\\n        return ivec4(floor(value + vec4(0.5)));\\n      }\\n    \"), {\n        version: t,\n        attribute: e,\n        varyingVs: n,\n        varyingFs: r,\n        texture2D: o,\n        output: a,\n        defineOutput: s,\n        defineSpecialNaN: u,\n        defineSpecialInf: c,\n        defineRound: l\n    };\n}\nfunction $a(t, e, n) {\n    void 0 === n && (n = \"index\");\n    var r = $(e);\n    return r.map(function(e, o) {\n        return \"int \" + t[o] + \" = \" + n + \" / \" + e + \"; \" + (o === r.length - 1 ? \"int \" + t[o + 1] + \" = \" + n + \" - \" + t[o] + \" * \" + e : \"index -= \" + t[o] + \" * \" + e) + \";\";\n    }).join(\"\");\n}\nfunction Qa(t) {\n    var e = $(t).map(function(t) {\n        return t.toString();\n    });\n    return \"\\n  int getFlatIndex(ivec3 coords) {\\n    return coords.x * \" + e[0] + \" + coords.y * \" + e[1] + \" + coords.z;\\n  }\\n\";\n}\nvar Ja = \"\\n  const float FLOAT_MAX = 1.70141184e38;\\n  const float FLOAT_MIN = 1.17549435e-38;\\n\\n  lowp vec4 encode_float(highp float v) {\\n    if (isnan(v)) {\\n      return vec4(255, 255, 255, 255);\\n    }\\n\\n    highp float av = abs(v);\\n\\n    if(av < FLOAT_MIN) {\\n      return vec4(0.0, 0.0, 0.0, 0.0);\\n    } else if(v > FLOAT_MAX) {\\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n    } else if(v < -FLOAT_MAX) {\\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n    }\\n\\n    highp vec4 c = vec4(0,0,0,0);\\n\\n    highp float e = floor(log2(av));\\n    highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n    c[2] = floor(128.0 * m);\\n    m -= c[2] / 128.0;\\n    c[1] = floor(32768.0 * m);\\n    m -= c[1] / 32768.0;\\n    c[0] = floor(8388608.0 * m);\\n\\n    highp float ebias = e + 127.0;\\n    c[3] = floor(ebias / 2.0);\\n    ebias -= c[3] * 2.0;\\n    c[2] += floor(ebias) * 128.0;\\n\\n    c[3] += 128.0 * step(0.0, -v);\\n\\n    return c / 255.0;\\n  }\\n\";\nfunction Za(t, e, n, r) {\n    var o = [];\n    t.forEach(function(t) {\n        var e = k(t.shapeInfo.logicalShape);\n        t.shapeInfo.isUniform ? o.push(\"uniform float \" + t.name + (e > 1 ? \"[\" + e + \"]\" : \"\") + \";\") : (o.push(\"uniform sampler2D \" + t.name + \";\"), o.push(\"uniform int offset\" + t.name + \";\"));\n    });\n    var a, i, s = o.join(\"\\n\"), u = t.map(function(t) {\n        return function(t, e, n) {\n            void 0 === n && (n = !1);\n            var r = \"\";\n            r += n ? ei(t) : ti(t);\n            var o = t.shapeInfo.logicalShape, a = e.logicalShape;\n            o.length <= a.length && (r += n ? function(t, e) {\n                var n, r = t.name, o = r.charAt(0).toUpperCase() + r.slice(1), a = \"get\" + o + \"AtOutCoords\", i = t.shapeInfo.logicalShape.length, s = e.logicalShape.length, u = Mr(t.shapeInfo.logicalShape, e.logicalShape), c = ui(s), l = s - i, h = [\n                    \"x\",\n                    \"y\",\n                    \"z\",\n                    \"w\",\n                    \"u\",\n                    \"v\"\n                ];\n                n = 0 === i ? \"\" : s < 2 && u.length >= 1 ? \"coords = 0;\" : u.map(function(t) {\n                    return \"coords.\" + h[t + l] + \" = 0;\";\n                }).join(\"\\n\");\n                var f = \"\";\n                f = s < 2 && i > 0 ? \"coords\" : t.shapeInfo.logicalShape.map(function(t, e) {\n                    return \"coords.\" + h[e + l];\n                }).join(\", \");\n                var d = \"return outputValue;\", p = 1 === k(t.shapeInfo.logicalShape), v = 1 === k(e.logicalShape);\n                if (1 !== i || p || v) {\n                    if (p && !v) d = 1 === s ? \"\\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\\n      \" : \"\\n        return vec4(outputValue.x);\\n      \";\n                    else if (u.length) {\n                        var g = i - 2, m = i - 1;\n                        u.indexOf(g) > -1 && u.indexOf(m) > -1 ? d = \"return vec4(outputValue.x);\" : u.indexOf(g) > -1 ? d = \"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\" : u.indexOf(m) > -1 && (d = \"return vec4(outputValue.xx, outputValue.zz);\");\n                    }\n                } else d = \"\\n      return vec4(outputValue.xy, outputValue.xy);\\n    \";\n                return \"\\n    vec4 \" + a + \"() {\\n      \" + c + \" coords = getOutputCoords();\\n      \" + n + \"\\n      vec4 outputValue = get\" + o + \"(\" + f + \");\\n      \" + d + \"\\n    }\\n  \";\n            }(t, e) : function(t, e) {\n                var n = t.name, r = n.charAt(0).toUpperCase() + n.slice(1), o = \"get\" + r + \"AtOutCoords\", a = e.texShape, i = t.shapeInfo.texShape, s = t.shapeInfo.logicalShape.length, u = e.logicalShape.length;\n                if (!t.shapeInfo.isUniform && s === u && null == t.shapeInfo.flatOffset && S(i, a)) return \"\\n      float \" + o + \"() {\\n        return sampleTexture(\" + n + \", resultUV);\\n      }\\n    \";\n                var c, l = ui(u), h = Mr(t.shapeInfo.logicalShape, e.logicalShape), f = u - s, d = [\n                    \"x\",\n                    \"y\",\n                    \"z\",\n                    \"w\",\n                    \"u\",\n                    \"v\"\n                ];\n                c = 0 === s ? \"\" : u < 2 && h.length >= 1 ? \"coords = 0;\" : h.map(function(t) {\n                    return \"coords.\" + d[t + f] + \" = 0;\";\n                }).join(\"\\n\");\n                var p = \"\";\n                p = u < 2 && s > 0 ? \"coords\" : t.shapeInfo.logicalShape.map(function(t, e) {\n                    return \"coords.\" + d[e + f];\n                }).join(\", \");\n                return \"\\n    float \" + o + \"() {\\n      \" + l + \" coords = getOutputCoords();\\n      \" + c + \"\\n      return get\" + r + \"(\" + p + \");\\n    }\\n  \";\n            }(t, e));\n            return r;\n        }(t, e, r);\n    }).join(\"\\n\"), c = e.texShape, l = Ya(), h = function(t) {\n        return \"\\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n      return \" + t.texture2D + \"(textureSampler, uv).r;\\n    }\\n  \";\n    }(l), f = function(t) {\n        return t.version + \"\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n    \" + t.varyingFs + \" vec2 resultUV;\\n    \" + t.defineOutput + \"\\n    const vec2 halfCR = vec2(0.5, 0.5);\\n\\n    struct ivec5\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n    };\\n\\n    struct ivec6\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n      int v;\\n    };\\n\\n    uniform float NAN;\\n    \" + t.defineSpecialNaN + \"\\n    \" + t.defineSpecialInf + \"\\n    \" + t.defineRound + \"\\n\\n    int imod(int x, int y) {\\n      return x - y * (x / y);\\n    }\\n\\n    int idiv(int a, int b, float sign) {\\n      int res = a / b;\\n      int mod = imod(a, b);\\n      if (sign < 0. && mod != 0) {\\n        res -= 1;\\n      }\\n      return res;\\n    }\\n\\n    //Based on the work of Dave Hoskins\\n    //https://www.shadertoy.com/view/4djSRW\\n    #define HASHSCALE1 443.8975\\n    float random(float seed){\\n      vec2 p = resultUV * seed;\\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n      p3 += dot(p3, p3.yzx + 19.19);\\n      return fract((p3.x + p3.y) * p3.z);\\n    }\\n\\n    \" + ni + \"\\n    \" + ri + \"\\n    \" + oi + \"\\n  \";\n    }(l);\n    return e.isPacked ? (a = function(t, e) {\n        switch(t.length){\n            case 0:\n                return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \";\n            case 1:\n                return function(t, e) {\n                    var n = [\n                        Math.ceil(e[0] / 2),\n                        Math.ceil(e[1] / 2)\n                    ];\n                    if (1 === n[0]) return \"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.x * \" + n[1] + \".0);\\n      }\\n    \";\n                    if (1 === n[1]) return \"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.y * \" + n[0] + \".0);\\n      }\\n    \";\n                    return \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n      return 2 * (resTexRC.x * \" + n[1] + \" + resTexRC.y);\\n    }\\n  \";\n                }(0, e);\n            case 2:\n                return function(t, e) {\n                    var n = [\n                        Math.ceil(e[0] / 2),\n                        Math.ceil(e[1] / 2)\n                    ];\n                    if (S(t, e)) return \"\\n      ivec2 getOutputCoords() {\\n        return 2 * ivec2(resultUV.yx * vec2(\" + n[0] + \", \" + n[1] + \"));\\n      }\\n    \";\n                    var r = Math.ceil(t[1] / 2);\n                    return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n\\n      int index = resTexRC.x * \" + n[1] + \" + resTexRC.y;\\n      int r = 2 * (index / \" + r + \");\\n      int c = imod(index, \" + r + \") * 2;\\n\\n      return ivec2(r, c);\\n    }\\n  \";\n                }(t, e);\n            case 3:\n                return n = t, r = e, o = [\n                    Math.ceil(r[0] / 2),\n                    Math.ceil(r[1] / 2)\n                ], a = Math.ceil(n[2] / 2), i = a * Math.ceil(n[1] / 2), \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + o[0] + \", \" + o[1] + \"));\\n      int index = resTexRC.x * \" + o[1] + \" + resTexRC.y;\\n\\n      int b = index / \" + i + \";\\n      index -= b * \" + i + \";\\n\\n      int r = 2 * (index / \" + a + \");\\n      int c = imod(index, \" + a + \") * 2;\\n\\n      return ivec3(b, r, c);\\n    }\\n  \";\n            default:\n                return function(t, e) {\n                    for(var n = [\n                        Math.ceil(e[0] / 2),\n                        Math.ceil(e[1] / 2)\n                    ], r = Math.ceil(t[t.length - 1] / 2), o = r * Math.ceil(t[t.length - 2] / 2), a = o, i = \"\", s = \"b, r, c\", u = 2; u < t.length - 1; u++)a *= t[t.length - u - 1], i = \"\\n      int b\" + u + \" = index / \" + a + \";\\n      index -= b\" + u + \" * \" + a + \";\\n    \" + i, s = \"b\" + u + \", \" + s;\n                    return \"\\n    ivec\" + t.length + \" getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n      int index = resTexRC.x * \" + n[1] + \" + resTexRC.y;\\n\\n      \" + i + \"\\n\\n      int b = index / \" + o + \";\\n      index -= b * \" + o + \";\\n\\n      int r = 2 * (index / \" + r + \");\\n      int c = imod(index, \" + r + \") * 2;\\n\\n      return ivec\" + t.length + \"(\" + s + \");\\n    }\\n  \";\n                }(t, e);\n        }\n        var n, r, o, a, i;\n    }(e.logicalShape, c), i = function(t) {\n        return \"\\n    void setOutput(vec4 val) {\\n      \" + t.output + \" = val;\\n    }\\n  \";\n    }(l)) : (a = function(t, e) {\n        switch(t.length){\n            case 0:\n                return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \";\n            case 1:\n                return function(t, e) {\n                    if (1 === e[0]) return \"\\n      int getOutputCoords() {\\n        return int(resultUV.x * \" + e[1] + \".0);\\n      }\\n    \";\n                    if (1 === e[1]) return \"\\n      int getOutputCoords() {\\n        return int(resultUV.y * \" + e[0] + \".0);\\n      }\\n    \";\n                    return \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + e[0] + \", \" + e[1] + \"));\\n      return resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n    }\\n  \";\n                }(0, e);\n            case 2:\n                return function(t, e) {\n                    if (S(t, e)) return \"\\n      ivec2 getOutputCoords() {\\n        return ivec2(resultUV.yx * vec2(\" + e[0] + \", \" + e[1] + \"));\\n      }\\n    \";\n                    if (1 === t[1]) return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n        return ivec2(index, 0);\\n      }\\n    \";\n                    if (1 === t[0]) return \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n        return ivec2(0, index);\\n      }\\n    \";\n                    return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + e[0] + \", \" + e[1] + \"));\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n      int r = index / \" + t[1] + \";\\n      int c = index - r * \" + t[1] + \";\\n      return ivec2(r, c);\\n    }\\n  \";\n                }(t, e);\n            case 3:\n                return n = e, r = $a([\n                    \"r\",\n                    \"c\",\n                    \"d\"\n                ], t), \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n      int index = resTexRC.x * \" + n[1] + \" + resTexRC.y;\\n      \" + r + \"\\n      return ivec3(r, c, d);\\n    }\\n  \";\n            case 4:\n                return function(t, e) {\n                    var n = $a([\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\"\n                    ], t);\n                    return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + e[0] + \", \" + e[1] + \"));\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n      \" + n + \"\\n      return ivec4(r, c, d, d2);\\n    }\\n  \";\n                }(t, e);\n            case 5:\n                return function(t, e) {\n                    var n = $a([\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\",\n                        \"d3\"\n                    ], t);\n                    return \"\\n    ivec5 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(\" + e[0] + \",\\n                             \" + e[1] + \"));\\n\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n\\n      \" + n + \"\\n\\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\\n      return outShape;\\n    }\\n  \";\n                }(t, e);\n            case 6:\n                return function(t, e) {\n                    var n = $a([\n                        \"r\",\n                        \"c\",\n                        \"d\",\n                        \"d2\",\n                        \"d3\",\n                        \"d4\"\n                    ], t);\n                    return \"\\n    ivec6 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + e[0] + \", \" + e[1] + \"));\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n\\n      \" + n + \"\\n\\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\\n      return result;\\n    }\\n  \";\n                }(t, e);\n            default:\n                throw new Error(t.length + \"-D output sampling is not yet supported\");\n        }\n        var n, r;\n    }(e.logicalShape, c), i = function(t) {\n        return \"\\n    void setOutput(float val) {\\n      \" + t.output + \" = vec4(val, 0, 0, 0);\\n    }\\n  \";\n    }(l)), r && (f += ai), [\n        f,\n        h,\n        i,\n        s,\n        a,\n        u,\n        n\n    ].join(\"\\n\");\n}\nfunction ti(t) {\n    var e = t.shapeInfo.logicalShape;\n    switch(e.length){\n        case 0:\n            return function(t) {\n                var e = t.name, n = \"get\" + e.charAt(0).toUpperCase() + e.slice(1);\n                if (t.shapeInfo.isUniform) return \"float \" + n + \"() {return \" + e + \";}\";\n                var r = t.shapeInfo.texShape, o = r[0], a = r[1];\n                if (1 === o && 1 === a) return \"\\n      float \" + n + \"() {\\n        return sampleTexture(\" + e + \", halfCR);\\n      }\\n    \";\n                var i = t.shapeInfo.texShape, s = i[0], u = i[1], c = ii(e);\n                return \"\\n    float \" + n + \"() {\\n      vec2 uv = uvFromFlat(\" + s + \", \" + u + \", \" + c + \");\\n      return sampleTexture(\" + e + \", uv);\\n    }\\n  \";\n            }(t);\n        case 1:\n            return function(t) {\n                var e = t.name, n = \"get\" + e.charAt(0).toUpperCase() + e.slice(1);\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + n + \"(int index) {\\n        \" + si(t) + \"\\n      }\\n    \";\n                var r = t.shapeInfo.texShape, o = r[0], a = r[1];\n                if (1 === a && 1 === o) return \"\\n      float \" + n + \"(int index) {\\n        return sampleTexture(\" + e + \", halfCR);\\n      }\\n    \";\n                var i = ii(e);\n                if (1 === a) return \"\\n      float \" + n + \"(int index) {\\n        vec2 uv = vec2(0.5, (float(index + \" + i + \") + 0.5) / \" + o + \".0);\\n        return sampleTexture(\" + e + \", uv);\\n      }\\n    \";\n                if (1 === o) return \"\\n      float \" + n + \"(int index) {\\n        vec2 uv = vec2((float(index + \" + i + \") + 0.5) / \" + a + \".0, 0.5);\\n        return sampleTexture(\" + e + \", uv);\\n      }\\n    \";\n                return \"\\n    float \" + n + \"(int index) {\\n      vec2 uv = uvFromFlat(\" + o + \", \" + a + \", index + \" + i + \");\\n      return sampleTexture(\" + e + \", uv);\\n    }\\n  \";\n            }(t);\n        case 2:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = t.shapeInfo.texShape;\n                if (null != o && S(e, o)) {\n                    var a = o[0], i = o[1];\n                    return \"\\n    float \" + r + \"(int row, int col) {\\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + i + \".0, \" + a + \".0);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n                }\n                var s = M(e), u = s.newShape, c = s.keptDims, l = u;\n                if (l.length < e.length) {\n                    var h = ci(t, l);\n                    return \"\\n      \" + ti(h) + \"\\n      float \" + r + \"(int row, int col) {\\n        return \" + r + \"(\" + li([\n                        \"row\",\n                        \"col\"\n                    ], c) + \");\\n      }\\n    \";\n                }\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col) {\\n        int index = round(dot(vec2(row, col), vec2(\" + e[1] + \", 1)));\\n        \" + si(t) + \"\\n      }\\n    \";\n                var f = o[0], d = o[1], p = ii(n);\n                if (1 === d) return \"\\n    float \" + r + \"(int row, int col) {\\n      float index = dot(vec3(row, col, \" + p + \"), vec3(\" + e[1] + \", 1, 1));\\n      vec2 uv = vec2(0.5, (index + 0.5) / \" + f + \".0);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n                if (1 === f) return \"\\n    float \" + r + \"(int row, int col) {\\n      float index = dot(vec3(row, col, \" + p + \"), vec3(\" + e[1] + \", 1, 1));\\n      vec2 uv = vec2((index + 0.5) / \" + d + \".0, 0.5);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n                return \"\\n  float \" + r + \"(int row, int col) {\\n    // Explicitly use integer operations as dot() only works on floats.\\n    int index = row * \" + e[1] + \" + col + \" + p + \";\\n    vec2 uv = uvFromFlat(\" + f + \", \" + d + \", index);\\n    return sampleTexture(\" + n + \", uv);\\n  }\\n\";\n            }(t);\n        case 3:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = e[1] * e[2], a = e[2], i = M(e), s = i.newShape, u = i.keptDims, c = s;\n                if (c.length < e.length) {\n                    var l = ci(t, c);\n                    return \"\\n        \" + ti(l) + \"\\n        float \" + r + \"(int row, int col, int depth) {\\n          return \" + r + \"(\" + li([\n                        \"row\",\n                        \"col\",\n                        \"depth\"\n                    ], u) + \");\\n        }\\n      \";\n                }\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth) {\\n        int index = round(dot(vec3(row, col, depth),\\n                          vec3(\" + o + \", \" + a + \", 1)));\\n        \" + si(t) + \"\\n      }\\n    \";\n                var h = t.shapeInfo.texShape, f = h[0], d = h[1], p = t.shapeInfo.flatOffset;\n                if (d === o && null == p) return \"\\n        float \" + r + \"(int row, int col, int depth) {\\n          float texR = float(row);\\n          float texC = dot(vec2(col, depth), vec2(\" + a + \", 1));\\n          vec2 uv = (vec2(texC, texR) + halfCR) /\\n                     vec2(\" + d + \".0, \" + f + \".0);\\n          return sampleTexture(\" + n + \", uv);\\n        }\\n      \";\n                if (d === a && null == p) return \"\\n    float \" + r + \"(int row, int col, int depth) {\\n      float texR = dot(vec2(row, col), vec2(\" + e[1] + \", 1));\\n      float texC = float(depth);\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + d + \".0, \" + f + \".0);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n                var v = ii(n);\n                return \"\\n      float \" + r + \"(int row, int col, int depth) {\\n        // Explicitly use integer operations as dot() only works on floats.\\n        int index = row * \" + o + \" + col * \" + a + \" + depth + \" + v + \";\\n        vec2 uv = uvFromFlat(\" + f + \", \" + d + \", index);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n  \";\n            }(t);\n        case 4:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = e[3], a = e[2] * o, i = e[1] * a, s = M(e), u = s.newShape, c = s.keptDims;\n                if (u.length < e.length) {\n                    var l = ci(t, u);\n                    return \"\\n      \" + ti(l) + \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        return \" + r + \"(\" + li([\n                        \"row\",\n                        \"col\",\n                        \"depth\",\n                        \"depth2\"\n                    ], c) + \");\\n      }\\n    \";\n                }\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        int index = round(dot(vec4(row, col, depth, depth2),\\n                          vec4(\" + i + \", \" + a + \", \" + o + \", 1)));\\n        \" + si(t) + \"\\n      }\\n    \";\n                var h = t.shapeInfo.flatOffset, f = t.shapeInfo.texShape, d = f[0], p = f[1];\n                if (p === i && null == h) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        float texR = float(row);\\n        float texC =\\n            dot(vec3(col, depth, depth2),\\n                vec3(\" + a + \", \" + o + \", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + p + \".0, \" + d + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                if (p === o && null == h) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2) {\\n        float texR = dot(vec3(row, col, depth),\\n                         vec3(\" + e[1] * e[2] + \", \" + e[2] + \", 1));\\n        float texC = float(depth2);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + p + \".0, \" + d + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                var v = ii(n);\n                return \"\\n    float \" + r + \"(int row, int col, int depth, int depth2) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + i + \" + col * \" + a + \" +\\n          depth * \" + o + \" + depth2;\\n      vec2 uv = uvFromFlat(\" + d + \", \" + p + \", index + \" + v + \");\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n            }(t);\n        case 5:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = e[4], a = e[3] * o, i = e[2] * a, s = e[1] * i, u = M(e), c = u.newShape, l = u.keptDims;\n                if (c.length < e.length) {\n                    var h = ci(t, c);\n                    return \"\\n      \" + ti(h) + \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        return \" + r + \"(\" + li([\n                        \"row\",\n                        \"col\",\n                        \"depth\",\n                        \"depth2\",\n                        \"depth3\"\n                    ], l) + \");\\n      }\\n    \";\n                }\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        float index = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + s + \", \" + i + \", \" + a + \", \" + o + \")) +\\n          depth3;\\n        \" + si(t) + \"\\n      }\\n    \";\n                var f = t.shapeInfo.flatOffset, d = t.shapeInfo.texShape, p = d[0], v = d[1];\n                if (v === s && null == f) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        int texR = row;\\n        float texC = dot(vec4(col, depth, depth2, depth3),\\n                         vec4(\" + i + \", \" + a + \", \" + o + \", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + v + \".0, \" + p + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                if (v === o && null == f) return \"\\n      float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n        float texR = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + e[1] * e[2] * e[3] + \",\\n               \" + e[2] * e[3] + \", \" + e[3] + \", 1));\\n        int texC = depth3;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + v + \".0, \" + p + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                var g = ii(n);\n                return \"\\n    float \" + r + \"(int row, int col, int depth, int depth2, int depth3) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + s + \" + col * \" + i + \" + depth * \" + a + \" +\\n          depth2 * \" + o + \" + depth3 + \" + g + \";\\n      vec2 uv = uvFromFlat(\" + p + \", \" + v + \", index);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n            }(t);\n        case 6:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = M(e), a = o.newShape, i = o.keptDims;\n                if (a.length < e.length) {\n                    var s = ci(t, a);\n                    return \"\\n      \" + ti(s) + \"\\n      float \" + r + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        return \" + r + \"(\" + li([\n                        \"row\",\n                        \"col\",\n                        \"depth\",\n                        \"depth2\",\n                        \"depth3\",\n                        \"depth4\"\n                    ], i) + \");\\n      }\\n    \";\n                }\n                var u = e[5], c = e[4] * u, l = e[3] * c, h = e[2] * l, f = e[1] * h;\n                if (t.shapeInfo.isUniform) return \"\\n      float \" + r + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n        int index = round(dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + f + \", \" + h + \", \" + l + \", \" + c + \")) +\\n          dot(\\n            vec2(depth3, depth4),\\n            vec2(\" + u + \", 1)));\\n        \" + si(t) + \"\\n      }\\n    \";\n                var d = t.shapeInfo.flatOffset, p = t.shapeInfo.texShape, v = p[0], g = p[1];\n                if (g === f && null == d) return \"\\n      float \" + r + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        int texR = row;\\n        float texC = dot(vec4(col, depth, depth2, depth3),\\n          vec4(\" + h + \", \" + l + \", \" + c + \", \" + u + \")) +\\n               float(depth4);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + g + \".0, \" + v + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                if (g === u && null == d) return \"\\n      float \" + r + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        float texR = dot(vec4(row, col, depth, depth2),\\n          vec4(\" + e[1] * e[2] * e[3] * e[4] + \",\\n               \" + e[2] * e[3] * e[4] + \",\\n               \" + e[3] * e[4] + \",\\n               \" + e[4] + \")) + float(depth3);\\n        int texC = depth4;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + g + \".0, \" + v + \".0);\\n        return sampleTexture(\" + n + \", uv);\\n      }\\n    \";\n                var m = ii(n);\n                return \"\\n    float \" + r + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + f + \" + col * \" + h + \" + depth * \" + l + \" +\\n          depth2 * \" + c + \" + depth3 * \" + u + \" + depth4 + \" + m + \";\\n      vec2 uv = uvFromFlat(\" + v + \", \" + g + \", index);\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n            }(t);\n        default:\n            throw new Error(e.length + \"-D input sampling is not yet supported\");\n    }\n}\nfunction ei(t) {\n    var e, n, r;\n    switch(t.shapeInfo.logicalShape.length){\n        case 0:\n            return e = t.name, n = \"get\" + e.charAt(0).toUpperCase() + e.slice(1), r = Ya(), \"\\n    vec4 \" + n + \"() {\\n      return \" + r.texture2D + \"(\" + e + \", halfCR);\\n    }\\n  \";\n        case 1:\n            return function(t) {\n                var e = t.name, n = \"get\" + e.charAt(0).toUpperCase() + e.slice(1), r = t.shapeInfo.texShape, o = [\n                    Math.ceil(r[0] / 2),\n                    Math.ceil(r[1] / 2)\n                ], a = Ya();\n                return \"\\n    vec4 \" + n + \"(int index) {\\n      vec2 uv = packedUVfrom1D(\\n        \" + o[0] + \", \" + o[1] + \", index);\\n      return \" + a.texture2D + \"(\" + e + \", uv);\\n    }\\n  \";\n            }(t);\n        case 2:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = t.shapeInfo.texShape, a = o[0], i = o[1], s = Ya();\n                if (null != o && S(e, o)) return \"\\n      vec4 \" + r + \"(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + i + \".0, \" + a + \".0);\\n\\n        return \" + s.texture2D + \"(\" + n + \", uv);\\n      }\\n    \";\n                var u = [\n                    Math.ceil(o[0] / 2),\n                    Math.ceil(o[1] / 2)\n                ], c = Math.ceil(e[1] / 2);\n                return \"\\n    vec4 \" + r + \"(int row, int col) {\\n      vec2 uv = packedUVfrom2D(\" + c + \", \" + u[0] + \", \" + u[1] + \", row, col);\\n      return \" + s.texture2D + \"(\" + n + \", uv);\\n    }\\n  \";\n            }(t);\n        case 3:\n            return function(t) {\n                var e = t.shapeInfo.logicalShape, n = t.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = t.shapeInfo.texShape, a = [\n                    Math.ceil(o[0] / 2),\n                    Math.ceil(o[1] / 2)\n                ];\n                if (1 === e[0]) {\n                    var i = e.slice(1), s = ci(t, i);\n                    return \"\\n        \" + ei(s) + \"\\n        vec4 \" + r + \"(int b, int row, int col) {\\n          return \" + r + \"(\" + li([\n                        \"b\",\n                        \"row\",\n                        \"col\"\n                    ], [\n                        1,\n                        2\n                    ]) + \");\\n        }\\n      \";\n                }\n                var u = a[0], c = a[1], l = Math.ceil(e[2] / 2), h = l * Math.ceil(e[1] / 2), f = Ya();\n                return \"\\n    vec4 \" + r + \"(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        \" + u + \", \" + c + \", \" + h + \", \" + l + \", b, row, col);\\n      return \" + f.texture2D + \"(\" + n + \", uv);\\n    }\\n  \";\n            }(t);\n        default:\n            return function(t) {\n                for(var e = t.shapeInfo.logicalShape, n = e.length, r = t.name, o = \"get\" + r.charAt(0).toUpperCase() + r.slice(1), a = t.shapeInfo.texShape, i = [\n                    Math.ceil(a[0] / 2),\n                    Math.ceil(a[1] / 2)\n                ], s = i[0], u = i[1], c = Math.ceil(e[n - 1] / 2), l = c * Math.ceil(e[n - 2] / 2), h = \"int b, int row, int col\", f = \"b * \" + l + \" + (row / 2) * \" + c + \" + (col / 2)\", d = 2; d < n - 1; d++)h = \"int b\" + d + \", \" + h, l *= e[n - d - 1], f = \"b\" + d + \" * \" + l + \" + \" + f;\n                var p = Ya();\n                return \"\\n    vec4 \" + o + \"(\" + h + \") {\\n      int index = \" + f + \";\\n      int texR = index / \" + u + \";\\n      int texC = index - texR * \" + u + \";\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + u + \", \" + s + \");\\n      return \" + p.texture2D + \"(\" + r + \", uv);\\n    }\\n  \";\n            }(t);\n    }\n}\nvar ni = \"\\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n  int texelIndex = index / 2;\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\", ri = \"\\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\\n  int texNumC, int row, int col) {\\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\", oi = \"\\nvec2 packedUVfrom3D(int texNumR, int texNumC,\\n    int texelsInBatch, int texelsInLogicalRow, int b,\\n    int row, int col) {\\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\", ai = \"\\n  float getChannel(vec4 frag, vec2 innerDims) {\\n    vec2 modCoord = mod(innerDims, 2.);\\n    return modCoord.x == 0. ?\\n      (modCoord.y == 0. ? frag.r : frag.g) :\\n      (modCoord.y == 0. ? frag.b : frag.a);\\n  }\\n  float getChannel(vec4 frag, int dim) {\\n    float modCoord = mod(float(dim), 2.);\\n    return modCoord == 0. ? frag.r : frag.g;\\n  }\\n\";\nfunction ii(t) {\n    return \"offset\" + t;\n}\nfunction si(t) {\n    var e = t.name, n = k(t.shapeInfo.logicalShape);\n    return n < 2 ? \"return \" + e + \";\" : \"\\n    for (int i = 0; i < \" + n + \"; i++) {\\n      if (i == index) {\\n        return \" + e + \"[i];\\n      }\\n    }\\n  \";\n}\nfunction ui(t) {\n    if (t <= 1) return \"int\";\n    if (2 === t) return \"ivec2\";\n    if (3 === t) return \"ivec3\";\n    if (4 === t) return \"ivec4\";\n    if (5 === t) return \"ivec5\";\n    if (6 === t) return \"ivec6\";\n    throw Error(\"GPU for rank \" + t + \" is not yet supported\");\n}\nfunction ci(t, e) {\n    var n = JSON.parse(JSON.stringify(t));\n    return n.shapeInfo.logicalShape = e, n;\n}\nfunction li(t, e) {\n    return e.map(function(e) {\n        return t[e];\n    }).join(\", \");\n}\nvar hi = function(t, e, n, r) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, C(t.length > 2, function() {\n        return \"Packed arg\" + (n.charAt(0).toUpperCase() + n.slice(1)) + \" supports only inputs with rank above 2.\";\n    });\n    var o = t[t.length - 1], a = Math.ceil(o / e);\n    this.outputShape = t.slice(0, -1), a > 1 && this.outputShape.push(a), r || this.variableNames.push(\"bestIndicesA\");\n    var i, s, u = this.outputShape, c = u.length, l = ui(c), h = Xa(\"coords\", c);\n    if (1 === a) {\n        var f = ui(s = c + 1);\n        i = \"\\n        \" + f + \" sourceLocR = \" + f + \"(\" + h.join() + \", 0);\\n        ++\" + h[c - 1] + \";\\n        \" + f + \" sourceLocG = \" + f + \"(\" + h.join() + \", 0);\\n        ++\" + h[c - 2] + \";\\n        \" + f + \" sourceLocA = \" + f + \"(\" + h.join() + \", 0);\\n        --\" + h[c - 1] + \";\\n        \" + f + \" sourceLocB = \" + f + \"(\" + h.join() + \", 0);\\n        --\" + h[c - 2] + \";\";\n    } else s = c, i = \"\\n        \" + l + \" sourceLocR = coords;\\n        ++\" + h[c - 1] + \";\\n        \" + l + \" sourceLocG = coords;\\n        ++\" + h[c - 2] + \";\\n        \" + l + \" sourceLocA = coords;\\n        --\" + h[c - 1] + \";\\n        \" + l + \" sourceLocB = coords;\\n        --\" + h[c - 2] + \";\";\n    var d = [\n        \"x\",\n        \"y\",\n        \"z\",\n        \"w\",\n        \"u\",\n        \"v\"\n    ].slice(0, s), p = \".\" + d[s - 1], v = d.map(function(t) {\n        return \"int \" + t;\n    }), g = Xa(\"sourceLocR\", s - 1).concat(\"inIdx.r\"), m = Xa(\"sourceLocG\", s - 1).concat(\"inIdx.g\"), y = Xa(\"sourceLocB\", s - 1).concat(\"inIdx.b\"), x = Xa(\"sourceLocA\", s - 1).concat(\"inIdx.a\"), b = \"max\" === n ? \"greaterThan\" : \"lessThan\", w = r ? \"\" : \"\\n          inIdx = round(vec4(getBestIndicesAChannel(\" + g.join() + \"),\\n                             getBestIndicesAChannel(\" + m.join() + \"),\\n                             getBestIndicesAChannel(\" + y.join() + \"),\\n                             getBestIndicesAChannel(\" + x.join() + \")));\", E = \"vec4(\\n            getAChannel(\" + g.join() + \"),\\n            hasNextCol ? getAChannel(\" + m.join() + \") : 0.,\\n            hasNextRow ? getAChannel(\" + y.join() + \") : 0.,\\n            hasNextRow && hasNextCol ? getAChannel(\" + x.join() + \") : 0.)\", R = r ? \"\" : \"\\n      float getBestIndicesAChannel(\" + v.join() + \") {\\n        return getChannel(getBestIndicesA(\" + d.join() + \"),\\n                                          vec2(\" + d.slice(-2).join() + \"));\\n      }\";\n    this.userCode = \"\\n      float getAChannel(\" + v.join() + \") {\\n        return getChannel(getA(\" + d.join() + \"),\\n                               vec2(\" + d.slice(-2).join() + \"));\\n      }\\n      \" + R + \"\\n      void main() {\\n        \" + l + \" coords = getOutputCoords();\\n        bool hasNextCol = \" + h[c - 1] + \" < \" + (u[c - 1] - 1) + \";\\n        bool hasNextRow = \" + h[c - 2] + \" < \" + (u[c - 2] - 1) + \";\\n        \" + i + \"\\n        ivec4 srcIdx = ivec4(sourceLocR\" + p + \", sourceLocG\" + p + \",\\n          sourceLocB\" + p + \", sourceLocA\" + p + \") * \" + e + \";\\n        ivec4 inIdx = srcIdx;\\n        vec4 bestIndex = vec4(inIdx);\\n        vec4 bestValue = \" + E + \";\\n\\n        for (int i = 0; i < \" + e + \"; i++) {\\n          inIdx = srcIdx;\\n          \" + w + \"\\n          vec4 candidate = \" + E + \";\\n          bvec4 nan = isnan(candidate);\\n          bvec4 replace = bvec4(\\n            vec4(\" + b + \"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\\n\\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\\n                           replace.y  ? candidate.y : bestValue.y,\\n                           replace.z  ? candidate.z : bestValue.z,\\n                           replace.w  ? candidate.w : bestValue.w);\\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\\n          srcIdx++;\\n        }\\n        setOutput(bestIndex);\\n      }\\n    \";\n}, fi = function(t) {\n    this.variableNames = [\n        \"dy\"\n    ], this.outputShape = t.inShape;\n    var e = t.filterHeight, n = t.filterWidth, r = t.strideHeight, o = t.strideWidth, a = t.dilationHeight, i = t.dilationWidth, s = t.effectiveFilterHeight, u = t.effectiveFilterWidth, c = s - 1 - t.padInfo.top, l = u - 1 - t.padInfo.left, h = 1 / (e * n);\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + c + \", \" + l + \");\\n      const float avgMultiplier = float(\" + h + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + s + \";\\n            wR += \" + a + \") {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + u + \";\\n            wC+= \" + i + \") {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n\\n            dotProd += dyValue * avgMultiplier;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, di = function(t) {\n    this.variableNames = [\n        \"dy\"\n    ], this.outputShape = t.inShape;\n    var e = t.filterDepth, n = t.filterHeight, r = t.filterWidth, o = t.strideDepth, a = t.strideHeight, i = t.strideWidth, s = t.dilationDepth, u = t.dilationHeight, c = t.dilationWidth, l = t.effectiveFilterDepth, h = t.effectiveFilterHeight, f = t.effectiveFilterWidth, d = l - 1 - t.padInfo.front, p = h - 1 - t.padInfo.top, v = f - 1 - t.padInfo.left, g = 1 / (e * n * r);\n    this.userCode = \"\\n      const ivec3 pads = ivec3(\" + d + \", \" + p + \", \" + v + \");\\n      const float avgMultiplier = float(\" + g + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyDCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\\n        // dx(xD, xR, xC, ch).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int wD = 0; wD < \" + l + \";\\n            wD += \" + s + \") {\\n          float dyD = float(dyDCorner + wD) / \" + o + \".0;\\n\\n          if (dyD < 0.0 || dyD >= \" + t.outDepth + \".0 || fract(dyD) > 0.0) {\\n            continue;\\n          }\\n          int idyD = int(dyD);\\n\\n          for (int wR = 0; wR < \" + h + \";\\n              wR += \" + u + \") {\\n            float dyR = float(dyRCorner + wR) / \" + a + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 ||\\n                fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            for (int wC = 0; wC < \" + f + \";\\n                wC += \" + c + \") {\\n              float dyC = float(dyCCorner + wC) / \" + i + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\\n\\n              dotProd += dyValue * avgMultiplier;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, pi = function(t, e, n, r, o, a) {\n    this.outputShape = [], this.variableNames = [\n        \"x\",\n        \"mean\",\n        \"variance\"\n    ], Pr(t, e), Pr(t, n);\n    var i = \"0.0\";\n    null != r && (Pr(t, r), this.variableNames.push(\"offset\"), i = \"getOffsetAtOutCoords()\");\n    var s = \"1.0\";\n    null != o && (Pr(t, o), this.variableNames.push(\"scale\"), s = \"getScaleAtOutCoords()\"), this.outputShape = t, this.userCode = \"\\n      void main() {\\n        float x = getXAtOutCoords();\\n        float mean = getMeanAtOutCoords();\\n        float variance = getVarianceAtOutCoords();\\n        float offset = \" + i + \";\\n        float scale = \" + s + \";\\n        float inv = scale * inversesqrt(variance + float(\" + a + \"));\\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\\n      }\\n    \";\n}, vi = function(t, e, n, r, o, a) {\n    this.packedInputs = !0, this.packedOutput = !0, this.variableNames = [\n        \"x\",\n        \"mean\",\n        \"variance\"\n    ], Pr(t, e), Pr(t, n);\n    var i = \"vec4(0.0)\";\n    null != r && (Pr(t, r), this.variableNames.push(\"offset\"), i = \"getOffsetAtOutCoords()\");\n    var s = \"vec4(1.0)\";\n    null != o && (Pr(t, o), this.variableNames.push(\"scale\"), s = \"getScaleAtOutCoords()\"), this.outputShape = t, this.userCode = \"\\n      void main() {\\n        vec4 offset = \" + i + \";\\n        vec4 scale = \" + s + \";\\n\\n        vec4 x = getXAtOutCoords();\\n        vec4 mean = getMeanAtOutCoords();\\n        vec4 variance = getVarianceAtOutCoords();\\n\\n        vec4 inv = scale * inversesqrt(variance + vec4(\" + a + \"));\\n\\n        setOutput((x - mean) * inv + offset);\\n      }\\n    \";\n}, gi = \"return areal * breal - aimag * bimag;\", mi = \"return areal * bimag + aimag * breal;\", yi = function(t, e, n) {\n    this.variableNames = [\n        \"AReal\",\n        \"AImag\",\n        \"BReal\",\n        \"BImag\"\n    ], this.outputShape = Pr(e, n), this.userCode = \"\\n      float binaryOpComplex(\\n          float areal, float aimag, float breal, float bimag) {\\n        \" + t + \"\\n      }\\n\\n      void main() {\\n        float areal = getARealAtOutCoords();\\n        float aimag = getAImagAtOutCoords();\\n        float breal = getBRealAtOutCoords();\\n        float bimag = getBImagAtOutCoords();\\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\\n      }\\n    \";\n}, xi = \"return a + b;\", bi = \"return a - b;\", wi = \"return a * b;\", Ci = \"\\nif (a == b) {\\n  return 1.0;\\n};\\nreturn a / b;\", Ei = \"return (a < 0.) ? b * a : a;\", Ri = function(t, e, n) {\n    this.variableNames = [\n        \"A\",\n        \"B\"\n    ], this.outputShape = Pr(e, n), this.userCode = \"\\n      float binaryOperation(float a, float b) {\\n        \" + t + \"\\n      }\\n\\n      void main() {\\n        float a = getAAtOutCoords();\\n        float b = getBAtOutCoords();\\n        setOutput(binaryOperation(a, b));\\n      }\\n    \";\n}, Ii = \"\\n  // vec4 one = vec4(equal(a, b));\\n  // return one + (vec4(1.0) - one) * a / b;\\n  vec4 result = a / b;\\n  if(a.x == b.x) {\\n    result.x = 1.;\\n  }\\n  if(a.y == b.y) {\\n    result.y = 1.;\\n  }\\n  if(a.z == b.z) {\\n    result.z = 1.;\\n  }\\n  if(a.w == b.w) {\\n    result.w = 1.;\\n  }\\n\\n  return result;\\n\", ki = \"\\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\\n\", Si = function(t, e, n, r) {\n    void 0 === r && (r = !1), this.variableNames = [\n        \"A\",\n        \"B\"\n    ], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = Pr(e, n);\n    var o = this.outputShape.length, a = \"\";\n    if (r) if (0 === o || 1 === k(this.outputShape)) a = \"\\n          result.y = 0.;\\n          result.z = 0.;\\n          result.w = 0.;\\n        \";\n    else if (a = \"\\n          \" + ui(o) + \" coords = getOutputCoords();\\n        \", 1 === o) a += \"\\n            result.y = (coords + 1) >= \" + this.outputShape[0] + \" ? 0. : result.y;\\n            result.z = 0.;\\n            result.w = 0.;\\n          \";\n    else {\n        var i = Xa(\"coords\", o);\n        a += \"\\n            bool nextRowOutOfBounds =\\n              (\" + i[o - 2] + \" + 1) >= \" + this.outputShape[o - 2] + \";\\n            bool nextColOutOfBounds =\\n              (\" + i[o - 1] + \" + 1) >= \" + this.outputShape[o - 1] + \";\\n            result.y = nextColOutOfBounds ? 0. : result.y;\\n            result.z = nextRowOutOfBounds ? 0. : result.z;\\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\\n          \";\n    }\n    this.userCode = \"\\n      vec4 binaryOperation(vec4 a, vec4 b) {\\n        \" + t + \"\\n      }\\n\\n      void main() {\\n        vec4 a = getAAtOutCoords();\\n        vec4 b = getBAtOutCoords();\\n\\n        vec4 result = binaryOperation(a, b);\\n        \" + a + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n}, Ai = function() {\n    function t(t) {\n        this.variableNames = [\n            \"A\"\n        ], this.outputShape = t, this.userCode = \"\\n      uniform float minVal;\\n      uniform float maxVal;\\n\\n      void main() {\\n        float value = getAAtOutCoords();\\n        if (isnan(value)) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, minVal, maxVal));\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t, e) {\n        var n = this;\n        return function(r, o) {\n            null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, \"minVal\"), n.maxLoc = r.getUniformLocationNoThrow(o, \"maxVal\")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);\n        };\n    }, t;\n}(), Ti = function() {\n    function t(t) {\n        this.variableNames = [\n            \"A\"\n        ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = \"\\n      uniform float minVal;\\n      uniform float maxVal;\\n\\n      void main() {\\n        vec4 value = getAAtOutCoords();\\n\\n        if (any(isnan(value))) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t, e) {\n        var n = this;\n        return function(r, o) {\n            null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, \"minVal\"), n.maxLoc = r.getUniformLocationNoThrow(o, \"maxVal\")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);\n        };\n    }, t;\n}(), Di = function(t) {\n    this.variableNames = [\n        \"real\",\n        \"imag\"\n    ], this.outputShape = t, this.userCode = \"\\n      void main() {\\n        float re = abs(getRealAtOutCoords());\\n        float im = abs(getImagAtOutCoords());\\n        float mx = max(re, im);\\n\\n        // sadly the length function in glsl is not underflow-safe\\n        // (at least not on Intel GPUs). So the safe solution is\\n        // to ensure underflow-safety in all cases.\\n        setOutput(\\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\\n        );\\n      }\\n    \";\n}, Ni = function(t) {\n    this.outputShape = [], this.outputShape = Sn(t, 1), this.variableNames = t.map(function(t, e) {\n        return \"T\" + e;\n    });\n    var e = new Array(t.length - 1);\n    e[0] = t[0][1];\n    for(var n = 1; n < e.length; n++)e[n] = e[n - 1] + t[n][1];\n    var r = [\n        \"if (yC < \" + e[0] + \") setOutput(getT0(yR, yC));\"\n    ];\n    for(n = 1; n < e.length; n++){\n        var o = e[n - 1];\n        r.push(\"else if (yC < \" + e[n] + \") setOutput(getT\" + n + \"(yR, yC-\" + o + \"));\");\n    }\n    var a = e.length, i = e[e.length - 1];\n    r.push(\"else setOutput(getT\" + a + \"(yR, yC-\" + i + \"));\"), this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int yR = coords.x;\\n        int yC = coords.y;\\n\\n        \" + r.join(\"\\n        \") + \"\\n      }\\n    \";\n}, Fi = function(t, e) {\n    this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = Sn(t, e);\n    var n = this.outputShape, r = n.length, o = ui(r), a = Xa(\"coords\", r), i = [\n        \"x\",\n        \"y\",\n        \"z\",\n        \"w\",\n        \"u\",\n        \"v\"\n    ].slice(0, r);\n    this.variableNames = t.map(function(t, e) {\n        return \"T\" + e;\n    });\n    var s = new Array(t.length - 1);\n    s[0] = t[0][e];\n    for(var u = 1; u < s.length; u++)s[u] = s[u - 1] + t[u][e];\n    var c = i[e], l = i.slice(-2), h = i.join(), f = \"if (\" + c + \" < \" + s[0] + \") {\\n        return getChannel(\\n            getT0(\" + h + \"), vec2(\" + l.join() + \"));\\n        }\";\n    for(u = 1; u < s.length; u++){\n        var d = s[u - 1];\n        f += \"\\n        if (\" + c + \" < \" + s[u] + \"  && \" + c + \" >= \" + s[u - 1] + \") {\\n          return getChannel(\\n            getT\" + u + \"(\" + _i(i, c, d) + \"),\\n            vec2(\" + _i(l, c, d) + \"));\\n        }\";\n    }\n    var p = s.length, v = s[s.length - 1];\n    f += \"\\n        return getChannel(\\n          getT\" + p + \"(\" + _i(i, c, v) + \"),\\n          vec2(\" + _i(l, c, v) + \"));\", this.userCode = \"\\n      float getValue(\" + i.map(function(t) {\n        return \"int \" + t;\n    }) + \") {\\n        \" + f + \"\\n      }\\n\\n      void main() {\\n        \" + o + \" coords = getOutputCoords();\\n        vec4 result = vec4(getValue(\" + a + \"), 0., 0., 0.);\\n\\n        \" + a[r - 1] + \" = \" + a[r - 1] + \" + 1;\\n        if (\" + a[r - 1] + \" < \" + n[r - 1] + \") {\\n          result.g = getValue(\" + a + \");\\n        }\\n\\n        \" + a[r - 2] + \" = \" + a[r - 2] + \" + 1;\\n        if (\" + a[r - 2] + \" < \" + n[r - 2] + \") {\\n          result.a = getValue(\" + a + \");\\n        }\\n\\n        \" + a[r - 1] + \" = \" + a[r - 1] + \" - 1;\\n        if (\" + a[r - 2] + \" < \" + n[r - 2] + \" &&\\n            \" + a[r - 1] + \" < \" + n[r - 1] + \") {\\n          result.b = getValue(\" + a + \");\\n        }\\n        setOutput(result);\\n      }\\n    \";\n};\nfunction _i(t, e, n) {\n    var r = t.indexOf(e);\n    return t.map(function(t, e) {\n        return e === r ? t + \" - \" + n : t;\n    }).join();\n}\nvar Oi = function(t) {\n    this.variableNames = [\n        \"x\",\n        \"dy\"\n    ], this.outputShape = t.filterShape;\n    var e = t.strideHeight, n = t.strideWidth, r = t.padInfo.top, o = t.padInfo.left, a = \"channelsLast\" === t.dataFormat;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int d2 = coords.w;\\n\\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \" + t.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + t.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + e + \" - \" + r + \";\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + t.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + n + \" - \" + o + \";\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              if (\" + a + \") {\\n                float dyValue = getDy(b, yR, yC, d2);\\n                float xValue = getX(b, xR, xC, d1);\\n                dotProd += (xValue * dyValue);\\n              } else {\\n                float dyValue = getDy(b, d2, yR, yC);\\n                float xValue = getX(b, d1, xR, xC);\\n                dotProd += (xValue * dyValue);\\n              }\\n\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Mi = function(t) {\n    this.variableNames = [\n        \"dy\",\n        \"W\"\n    ], this.outputShape = t.inShape;\n    var e = t.filterHeight, n = t.filterWidth, r = t.strideHeight, o = t.strideWidth, a = \"channelsLast\" === t.dataFormat, i = e - 1 - t.padInfo.top, s = n - 1 - t.padInfo.left, u = a ? 1 : 2, c = a ? 2 : 3, l = a ? 3 : 1;\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + i + \", \" + s + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[\" + l + \"];\\n\\n        ivec2 dyCorner = ivec2(coords[\" + u + \"], coords[\" + c + \"]) - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + e + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + e + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + n + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + n + \" - 1 - wC;\\n\\n            for (int d2 = 0; d2 < \" + t.outChannels + \"; d2++) {\\n\\n              if (\" + a + \") {\\n                float xValue = getDy(batch, idyR, idyC, d2);\\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              } else {\\n                float xValue = getDy(batch, d2, idyR, idyC);\\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              }\\n\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Bi = function(t) {\n    this.variableNames = [\n        \"x\",\n        \"dy\"\n    ], this.outputShape = t.filterShape;\n    var e = t.strideDepth, n = t.strideHeight, r = t.strideWidth, o = t.padInfo.front, a = t.padInfo.top, i = t.padInfo.left;\n    this.userCode = \"\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int wF = coords.x;\\n        int wR = coords.y;\\n        int wC = coords.z;\\n        int d1 = coords.w;\\n        int d2 = coords.u;\\n\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \" + t.batchSize + \"; b++) {\\n          for (int yF = 0; yF < \" + t.outDepth + \"; yF++) {\\n            int xF = wF + yF * \" + e + \" - \" + o + \";\\n\\n            if (xF < 0 || xF >= \" + t.inDepth + \") {\\n              continue;\\n            }\\n\\n            for (int yR = 0; yR < \" + t.outHeight + \"; yR++) {\\n              int xR = wR + yR * \" + n + \" - \" + a + \";\\n\\n              if (xR < 0 || xR >= \" + t.inHeight + \") {\\n                continue;\\n              }\\n\\n              for (int yC = 0; yC < \" + t.outWidth + \"; yC++) {\\n                int xC = wC + yC * \" + r + \" - \" + i + \";\\n\\n                if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                  continue;\\n                }\\n\\n                float dyValue = getDy(b, yF, yR, yC, d2);\\n                float xValue = getX(b, xF, xR, xC, d1);\\n                dotProd += (xValue * dyValue);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Pi = function(t) {\n    this.variableNames = [\n        \"dy\",\n        \"W\"\n    ], this.outputShape = t.inShape;\n    var e = t.filterDepth, n = t.filterHeight, r = t.filterWidth, o = t.strideDepth, a = t.strideHeight, i = t.strideWidth, s = e - 1 - t.padInfo.front, u = n - 1 - t.padInfo.top, c = r - 1 - t.padInfo.left;\n    this.userCode = \"\\n      const ivec3 pads = ivec3(\" + s + \", \" + u + \", \" + c + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d1 = coords.u;\\n\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyFCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < \" + e + \"; wF++) {\\n          float dyF = float(dyFCorner + wF) / \" + o + \".0;\\n\\n          if (dyF < 0.0 || dyF >= \" + t.outDepth + \".0 || fract(dyF) > 0.0) {\\n            continue;\\n          }\\n          int idyF = int(dyF);\\n\\n          int wFPerm = \" + e + \" - 1 - wF;\\n\\n          for (int wR = 0; wR < \" + n + \"; wR++) {\\n            float dyR = float(dyRCorner + wR) / \" + a + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 ||\\n              fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            int wRPerm = \" + n + \" - 1 - wR;\\n\\n            for (int wC = 0; wC < \" + r + \"; wC++) {\\n              float dyC = float(dyCCorner + wC) / \" + i + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              int wCPerm = \" + r + \" - 1 - wC;\\n\\n              for (int d2 = 0; d2 < \" + t.outChannels + \"; d2++) {\\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Li = function(t) {\n    this.variableNames = [\n        \"x\",\n        \"dy\"\n    ], this.outputShape = t.filterShape;\n    var e = t.strideHeight, n = t.strideWidth, r = t.padInfo.top, o = t.padInfo.left, a = t.outChannels / t.inChannels;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int dm = coords.w;\\n        int d2 = d1 * \" + a + \" + dm;\\n\\n        float dotProd = 0.0;\\n\\n        // TO DO: Vec4 over the batch size\\n        for (int b = 0; b < \" + t.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + t.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + e + \" - \" + r + \";\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + t.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + n + \" - \" + o + \";\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              float dyValue = getDy(b, yR, yC, d2);\\n              float xValue = getX(b, xR, xC, d1);\\n              dotProd += (xValue * dyValue);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Wi = function(t) {\n    this.variableNames = [\n        \"dy\",\n        \"W\"\n    ], this.outputShape = t.inShape;\n    var e = t.filterHeight, n = t.filterWidth, r = t.strideHeight, o = t.strideWidth, a = e - 1 - t.padInfo.top, i = n - 1 - t.padInfo.left, s = t.outChannels / t.inChannels;\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + a + \", \" + i + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[3];\\n        ivec2 dyCorner = coords.yz - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        float dotProd = 0.0;\\n\\n        for (int wR = 0; wR < \" + e + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + e + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + n + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + n + \" - 1 - wC;\\n\\n            // TO DO: Vec4 over the channelMul\\n            for (int dm = 0; dm < \" + s + \"; dm++) {\\n              int d2 = d1 * \" + s + \" + dm;\\n              float xValue = getDy(batch, idyR, idyC, d2);\\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\\n              dotProd += xValue * wValue;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Ui = function(t, e, n, r) {\n    void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = [\n        \"x\",\n        \"W\"\n    ], this.outputShape = t.outShape;\n    var o = t.padInfo.top, a = t.padInfo.left, i = t.strideHeight, s = t.strideWidth, u = t.dilationHeight, c = t.dilationWidth, l = t.filterHeight, h = t.filterWidth, f = 4 * Math.floor(t.inChannels / 4), d = t.inChannels % 4, p = \"channelsLast\" === t.dataFormat, v = p ? 1 : 2, g = p ? 2 : 3, m = p ? 3 : 1, y = \"\", x = \"\";\n    n && (y = r ? \"float activation(float a) {\\n          float b = getPreluActivationWeightsAtOutCoords();\\n          \" + n + \"\\n        }\" : \"\\n          float activation(float x) {\\n            \" + n + \"\\n          }\\n        \", x = \"result = activation(result);\");\n    var b = e ? \"result += getBiasAtOutCoords();\" : \"\";\n    e && this.variableNames.push(\"bias\"), r && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + y + \"\\n\\n      const ivec2 strides = ivec2(\" + i + \", \" + s + \");\\n      const ivec2 pads = ivec2(\" + o + \", \" + a + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d2 = coords[\" + m + \"];\\n\\n        ivec2 xRCCorner =\\n            ivec2(coords[\" + v + \"], coords[\" + g + \"]) * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + l + \"; wR++) {\\n          int xR = xRCorner + wR * \" + u + \";\\n\\n          if (xR < 0 || xR >= \" + t.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + h + \"; wC++) {\\n            int xC = xCCorner + wC * \" + c + \";\\n\\n            if (xC < 0 || xC >= \" + t.inWidth + \") {\\n              continue;\\n            }\\n\\n            for (int d1 = 0; d1 < \" + f + \"; d1 += 4) {\\n              vec4 wValues = vec4(\\n                getW(wR, wC, d1, d2),\\n                getW(wR, wC, d1 + 1, d2),\\n                getW(wR, wC, d1 + 2, d2),\\n                getW(wR, wC, d1 + 3, d2)\\n              );\\n\\n              if (\" + p + \") {\\n                vec4 xValues = vec4(\\n                  getX(batch, xR, xC, d1),\\n                  getX(batch, xR, xC, d1 + 1),\\n                  getX(batch, xR, xC, d1 + 2),\\n                  getX(batch, xR, xC, d1 + 3)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec4 xValues = vec4(\\n                  getX(batch, d1, xR, xC),\\n                  getX(batch, d1 + 1, xR, xC),\\n                  getX(batch, d1 + 2, xR, xC),\\n                  getX(batch, d1 + 3, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n            }\\n\\n            if (\" + (1 === d) + \") {\\n\\n              if (\" + p + \") {\\n                dotProd +=\\n                    getX(batch, xR, xC, \" + f + \") *\\n                    getW(wR, wC, \" + f + \", d2);\\n              } else {\\n                dotProd +=\\n                    getX(batch, \" + f + \", xR, xC) *\\n                    getW(wR, wC, \" + f + \", d2);\\n              }\\n\\n            } else if (\" + (2 === d) + \") {\\n              vec2 wValues = vec2(\\n                getW(wR, wC, \" + f + \", d2),\\n                getW(wR, wC, \" + f + \" + 1, d2)\\n              );\\n\\n              if (\" + p + \") {\\n                vec2 xValues = vec2(\\n                  getX(batch, xR, xC, \" + f + \"),\\n                  getX(batch, xR, xC, \" + f + \" + 1)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec2 xValues = vec2(\\n                  getX(batch, \" + f + \", xR, xC),\\n                  getX(batch, \" + f + \" + 1, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n            } else if (\" + (3 === d) + \") {\\n              vec3 wValues = vec3(\\n                getW(wR, wC, \" + f + \", d2),\\n                getW(wR, wC, \" + f + \" + 1, d2),\\n                getW(wR, wC, \" + f + \" + 2, d2)\\n              );\\n\\n              if (\" + p + \") {\\n                vec3 xValues = vec3(\\n                  getX(batch, xR, xC, \" + f + \"),\\n                  getX(batch, xR, xC, \" + f + \" + 1),\\n                  getX(batch, xR, xC, \" + f + \" + 2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec3 xValues = vec3(\\n                  getX(batch, \" + f + \", xR, xC),\\n                  getX(batch, \" + f + \" + 1, xR, xC),\\n                  getX(batch, \" + f + \" + 2, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n            }\\n          }\\n        }\\n\\n        float result = dotProd;\\n        \" + b + \"\\n        \" + x + \"\\n        setOutput(result);\\n      }\\n    \";\n}, Vi = function(t) {\n    this.variableNames = [\n        \"x\",\n        \"W\"\n    ], this.outputShape = t.outShape;\n    var e = t.padInfo.front, n = t.padInfo.top, r = t.padInfo.left, o = t.strideDepth, a = t.strideHeight, i = t.strideWidth, s = t.dilationDepth, u = t.dilationHeight, c = t.dilationWidth, l = t.filterDepth, h = t.filterHeight, f = t.filterWidth, d = 4 * Math.floor(t.inChannels / 4), p = t.inChannels % 4;\n    this.userCode = \"\\n      const ivec3 strides = ivec3(\" + o + \", \" + a + \", \" + i + \");\\n      const ivec3 pads = ivec3(\" + e + \", \" + n + \", \" + r + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d2 = coords.u;\\n\\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xFCorner = xFRCCorner.x;\\n        int xRCorner = xFRCCorner.y;\\n        int xCCorner = xFRCCorner.z;\\n\\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\\n        // values in that axis.\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < \" + l + \"; wF++) {\\n          int xF = xFCorner + wF * \" + s + \";\\n\\n          if (xF < 0 || xF >= \" + t.inDepth + \") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \" + h + \"; wR++) {\\n            int xR = xRCorner + wR * \" + u + \";\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + f + \"; wC++) {\\n              int xC = xCCorner + wC * \" + c + \";\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              for (int d1 = 0; d1 < \" + d + \"; d1 += 4) {\\n                vec4 xValues = vec4(\\n                  getX(batch, xF, xR, xC, d1),\\n                  getX(batch, xF, xR, xC, d1 + 1),\\n                  getX(batch, xF, xR, xC, d1 + 2),\\n                  getX(batch, xF, xR, xC, d1 + 3)\\n                );\\n                vec4 wValues = vec4(\\n                  getW(wF, wR, wC, d1, d2),\\n                  getW(wF, wR, wC, d1 + 1, d2),\\n                  getW(wF, wR, wC, d1 + 2, d2),\\n                  getW(wF, wR, wC, d1 + 3, d2)\\n                );\\n\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n              if (\" + (1 === p) + \") {\\n                dotProd +=\\n                  getX(batch, xF, xR, xC, \" + d + \") *\\n                  getW(wF, wR, wC, \" + d + \", d2);\\n              } else if (\" + (2 === p) + \") {\\n                vec2 xValues = vec2(\\n                  getX(batch, xF, xR, xC, \" + d + \"),\\n                  getX(batch, xF, xR, xC, \" + d + \" + 1)\\n                );\\n                vec2 wValues = vec2(\\n                  getW(wF, wR, wC, \" + d + \", d2),\\n                  getW(wF, wR, wC, \" + d + \" + 1, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else if (\" + (3 === p) + \") {\\n                vec3 xValues = vec3(\\n                  getX(batch, xF, xR, xC, \" + d + \"),\\n                  getX(batch, xF, xR, xC, \" + d + \" + 1),\\n                  getX(batch, xF, xR, xC, \" + d + \" + 2)\\n                );\\n                vec3 wValues = vec3(\\n                  getW(wF, wR, wC, \" + d + \", d2),\\n                  getW(wF, wR, wC, \" + d + \" + 1, d2),\\n                  getW(wF, wR, wC, \" + d + \" + 2, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, zi = function(t, e, n, r) {\n    void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = [\n        \"x\",\n        \"W\"\n    ], this.outputShape = t.outShape;\n    var o = t.inHeight, a = t.inWidth, i = t.padInfo.top, s = t.padInfo.left, u = t.strideHeight, c = t.strideWidth, l = t.dilationHeight, h = t.dilationWidth, f = t.filterHeight, d = t.filterWidth, p = t.outChannels / t.inChannels, v = \"\", g = \"\";\n    n && (v = r ? \"float activation(float a) {\\n          float b = getPreluActivationWeightsAtOutCoords();\\n          \" + n + \"\\n        }\" : \"\\n          float activation(float x) {\\n            \" + n + \"\\n          }\\n        \", g = \"result = activation(result);\");\n    var m = e ? \"result += getBiasAtOutCoords();\" : \"\";\n    e && this.variableNames.push(\"bias\"), r && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + v + \"\\n\\n      const ivec2 strides = ivec2(\" + u + \", \" + c + \");\\n      const ivec2 pads = ivec2(\" + i + \", \" + s + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2 / \" + p + \";\\n        int q = d2 - d1 * \" + p + \";\\n\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\\n        for (int wR = 0; wR < \" + f + \"; wR++) {\\n          int xR = xRCorner + wR * \" + l + \";\\n\\n          if (xR < 0 || xR >= \" + o + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + d + \"; wC++) {\\n            int xC = xCCorner + wC * \" + h + \";\\n\\n            if (xC < 0 || xC >= \" + a + \") {\\n              continue;\\n            }\\n\\n            float xVal = getX(batch, xR, xC, d1);\\n            float wVal = getW(wR, wC, d1, q);\\n            dotProd += xVal * wVal;\\n          }\\n        }\\n\\n        float result = dotProd;\\n        \" + m + \"\\n        \" + g + \"\\n        setOutput(result);\\n      }\\n    \";\n}, Gi = function(t, e, n, r) {\n    void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = [\n        \"x\",\n        \"W\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.outShape;\n    for(var o = t.inHeight, a = t.inWidth, i = t.padInfo.top, s = t.padInfo.left, u = t.strideHeight, c = t.strideWidth, l = t.dilationHeight, h = t.dilationWidth, f = t.filterHeight, d = t.filterWidth, p = d, v = \"int xR; int xC; int xCOffset;\", g = 0; g < f; g++)for(var m = 0; m < d; m++)v += \"\\n          vec4 xTexelR\" + g + \"C\" + 2 * m + \" = vec4(0.);\\n          vec4 wR\" + g + \"C\" + m + \" = vec4(0.);\\n          vec4 xR\" + g + \"C\" + m + \" = vec4(0.);\";\n    for(g = 0; g < f; g++)for(var y = 0; y < p; y++){\n        if (v += \"\\n          xR = xRCorner + \" + g * l + \";\\n          xC = xCCorner + \" + (m = 2 * y) * h + \";\\n        \", 1 === c) {\n            if (m < d && (v += s % 2 == 1 ? \"\\n                xCOffset = xC + 1;\\n                if(xR >= 0 && xR < \" + o + \" && xCOffset >= 0 && xCOffset < \" + a + \") {\\n                  xTexelR\" + g + \"C\" + m + \" = getX(batch, xR, xCOffset, d1);\\n\\n                  // Need to manually clear unused channels in case\\n                  // we're reading from recycled texture.\\n                  if(xCOffset + 1 >= \" + a + \") {\\n                    xTexelR\" + g + \"C\" + m + \".zw = vec2(0.);\\n                  }\\n                } else {\\n                  xTexelR\" + g + \"C\" + m + \" = vec4(0.);\\n                }\\n\\n                xCOffset = xC + 1 - 2;\\n                if(xR >= 0 && xR < \" + o + \" && xCOffset >= 0 && xCOffset < \" + a + \") {\\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\\n\\n                  // Need to manually clear unused channels in case\\n                  // we're reading from recycled texture.\\n                  if(xCOffset + 1 >= \" + a + \") {\\n                    previous.zw = vec2(0.);\\n                  }\\n\\n                  xR\" + g + \"C\" + m + \" = vec4(previous.zw, xTexelR\" + g + \"C\" + m + \".xy);\\n                } else {\\n                  xR\" + g + \"C\" + m + \" = vec4(0, 0, xTexelR\" + g + \"C\" + m + \".xy);\\n                }\\n              \" : \"\\n                if(xR >= 0 && xR < \" + o + \" && xC >= 0 && xC < \" + a + \") {\\n                  xTexelR\" + g + \"C\" + m + \" = getX(batch, xR, xC, d1);\\n                } else {\\n                  xTexelR\" + g + \"C\" + m + \" = vec4(0.);\\n                }\\n\\n                xR\" + g + \"C\" + m + \" = xTexelR\" + g + \"C\" + m + \";\\n              \", m + 1 < d)) {\n                var x = s % 2 == 0 ? b(h) : h;\n                h % 2 == 0 && s % 2 == 1 || h % 2 != 0 && s % 2 != 1 ? (v += \"\\n                  xCOffset = xC + \" + s % 2 + \" + \" + x + \";\\n\\n                  if(xR >= 0 && xR < \" + o + \" &&\\n                    xCOffset >= 0 && xCOffset < \" + a + \") {\\n                    xTexelR\" + g + \"C\" + (m + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                  }\\n                \", h > 1 && (v += \"\\n                    xCOffset -= 2;\\n                    if(xR >= 0 && xR < \" + o + \" &&\\n                      xCOffset >= 0 && xCOffset < \" + a + \") {\\n                      xTexelR\" + g + \"C\" + m + \" = getX(batch, xR, xCOffset, d1);\\n                    } else {\\n                      xTexelR\" + g + \"C\" + m + \" = vec4(0.);\\n                    }\\n                  \"), v += \"\\n                  xR\" + g + \"C\" + (m + 1) + \" = vec4(\\n                    xTexelR\" + g + \"C\" + m + \".zw, xTexelR\" + g + \"C\" + (m + 2) + \".xy);\\n                \") : v += \"\\n                  xCOffset = xC + \" + x + \";\\n\\n                  if(xR >= 0 && xR < \" + o + \" &&\\n                    xCOffset >= 0 && xCOffset < \" + a + \") {\\n                    xTexelR\" + g + \"C\" + (m + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                  }\\n\\n                  xR\" + g + \"C\" + (m + 1) + \" = xTexelR\" + g + \"C\" + (m + 2) + \";\\n                \";\n            }\n        } else m < d && (v += \"\\n              if(xR >= 0 && xR < \" + o + \") {\\n            \", s % 2 == 1 ? (v += \"\\n                xCOffset = xC + 1 - \" + c + \";\\n                if(xCOffset >= 0 && xCOffset < \" + a + \") {\\n                  xTexelR\" + g + \"C\" + m + \" = getX(batch, xR, xCOffset, d1);\\n                } else {\\n                  xTexelR\" + g + \"C\" + m + \" = vec4(0.);\\n                }\\n\\n                if(xC + 1 >= 0 && xC + 1 < \" + a + \") {\\n                  xTexelR\" + g + \"C\" + (m + 2) + \" = getX(batch, xR, xC + 1, d1);\\n                } else {\\n                  xTexelR\" + g + \"C\" + (m + 2) + \" = vec4(0.);\\n                }\\n\\n                xR\" + g + \"C\" + m + \" = vec4(\\n                  xTexelR\" + g + \"C\" + m + \".zw, xTexelR\" + g + \"C\" + (m + 2) + \".zw);\\n              \", m + 1 < d && (v += \"\\n                  vec4 final = vec4(0.);\\n                  xCOffset = xC + 1 + \" + c + \";\\n                  if(xCOffset >= 0 && xCOffset < \" + a + \") {\\n                    final = getX(batch, xR, xCOffset, d1);\\n                  }\\n                  xR\" + g + \"C\" + (m + 1) + \" = vec4(xTexelR\" + g + \"C\" + (m + 2) + \".xy, final.xy);\\n                \")) : (v += \"\\n                if(xC >= 0 && xC < \" + a + \") {\\n                  xTexelR\" + g + \"C\" + m + \" = getX(batch, xR, xC, d1);\\n                } else {\\n                  xTexelR\" + g + \"C\" + m + \" = vec4(0.);\\n                }\\n\\n                xCOffset = xC + \" + c + \";\\n                if(xCOffset >= 0 && xCOffset < \" + a + \") {\\n                  xTexelR\" + g + \"C\" + (m + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                } else {\\n                  xTexelR\" + g + \"C\" + (m + 2) + \" = vec4(0.);\\n                }\\n\\n                xR\" + g + \"C\" + m + \" = vec4(\\n                  xTexelR\" + g + \"C\" + m + \".xy, xTexelR\" + g + \"C\" + (m + 2) + \".xy);\\n              \", m + 1 < d && (v += \"\\n                  xR\" + g + \"C\" + (m + 1) + \" = vec4(\\n                    xTexelR\" + g + \"C\" + m + \".zw, xTexelR\" + g + \"C\" + (m + 2) + \".zw);\\n                \")), v += \"}\");\n        m < d && (v += \"\\n            vec4 wTexelR\" + g + \"C\" + m + \" = getW(\" + g + \", \" + m + \", d1, q);\\n            wR\" + g + \"C\" + m + \" = vec4(wTexelR\" + g + \"C\" + m + \".xz, wTexelR\" + g + \"C\" + m + \".xz);\\n          \", m + 1 < d && (v += \"\\n              vec4 wTexelR\" + g + \"C\" + (m + 1) + \" = getW(\" + g + \", \" + (m + 1) + \", d1, q);\\n              wR\" + g + \"C\" + (m + 1) + \" =\\n                vec4(wTexelR\" + g + \"C\" + (m + 1) + \".xz, wTexelR\" + g + \"C\" + (m + 1) + \".xz);\"));\n    }\n    for(g = 0; g < f; g++)for(m = 0; m < d; m++)v += \"dotProd += xR\" + g + \"C\" + m + \" * wR\" + g + \"C\" + m + \";\";\n    var w = \"\", C = \"\";\n    n && (w = r ? \"vec4 activation(vec4 a) {\\n          vec4 b = getPreluActivationWeightsAtOutCoords();\\n          \" + n + \"\\n        }\" : \"vec4 activation(vec4 x) {\\n          \" + n + \"\\n        }\", C = \"result = activation(result);\");\n    var E = e ? \"result += getBiasAtOutCoords();\" : \"\";\n    e && this.variableNames.push(\"bias\"), r && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + w + \"\\n\\n      const ivec2 strides = ivec2(\" + u + \", \" + c + \");\\n      const ivec2 pads = ivec2(\" + i + \", \" + s + \");\\n\\n      void main() {\\n\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2;\\n        int q = 0;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        vec4 dotProd = vec4(0.);\\n\\n        \" + v + \"\\n\\n        vec4 result = dotProd;\\n        \" + E + \"\\n        \" + C + \"\\n        setOutput(result);\\n      }\\n    \";\n}, Hi = function(t, e, n, r, o) {\n    this.variableNames = [\n        \"Image\",\n        \"Boxes\",\n        \"BoxInd\"\n    ], this.outputShape = [];\n    var a = t[0], i = t[1], s = t[2], u = t[3], c = e[0], l = n[0], h = n[1];\n    this.outputShape = [\n        c,\n        l,\n        h,\n        u\n    ];\n    var f = \"bilinear\" === r ? 1 : 0, d = [\n        i - 1 + \".0\",\n        s - 1 + \".0\"\n    ], p = d[0], v = d[1], g = l > 1 ? [\n        \"\" + (i - 1) / (l - 1),\n        \"(y2-y1) * height_ratio\",\n        \"y1*\" + p + \" + float(y)*(height_scale)\"\n    ] : [\n        \"0.0\",\n        \"0.0\",\n        \"0.5 * (y1+y2) * \" + p\n    ], m = g[0], y = g[1], x = g[2], b = h > 1 ? [\n        \"\" + (s - 1) / (h - 1),\n        \"(x2-x1) * width_ratio\",\n        \"x1*\" + v + \" + float(x)*(width_scale)\"\n    ] : [\n        \"0.0\",\n        \"0.0\",\n        \"0.5 * (x1+x2) * \" + v\n    ], w = b[0], C = b[1], E = b[2];\n    this.userCode = \"\\n      const float height_ratio = float(\" + m + \");\\n      const float width_ratio = float(\" + w + \");\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= \" + a + \") {\\n          return;\\n        }\\n\\n        float height_scale = \" + y + \";\\n        float width_scale = \" + C + \";\\n\\n        float in_y = \" + x + \";\\n        if( in_y < 0.0 || in_y > \" + p + \" ) {\\n          setOutput(float(\" + o + \"));\\n          return;\\n        }\\n        float in_x = \" + E + \";\\n        if( in_x < 0.0 || in_x > \" + v + \" ) {\\n          setOutput(float(\" + o + \"));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\\n        if(\" + f + \" == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\\n\\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\\n\\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\\n\\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\\n          float newValue = top + (bottom - top) * fracCR.y;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestCR = ivec2(floor(\\n            sourceFracIndexCR + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    \";\n}, qi = function(t, e, n) {\n    this.variableNames = [\n        \"x\"\n    ], this.outputShape = t;\n    var r = t.length, o = t[t.length - 1], a = n ? \"<\" : \">\";\n    this.userCode = \"\\n      int getIndex(int i) {\\n        \" + (n ? \"return \" + o + \" -i - 1;\" : \"return i;\") + \"\\n      }\\n\\n      void main() {\\n        \" + ui(r) + \" coords = getOutputCoords();\\n        int end = \" + Ki(r, \"coords\") + \";\\n        float val = 0.0;\\n        for (int i = \" + o + \" - 1; i >= 0; i -= 1) {\\n          int idx = getIndex(i);\\n          if (idx \" + a + \" end) {\\n            continue;\\n          }\\n          if (idx == end && \" + e + \") {\\n            continue;\\n          }\\n          \" + Ki(r, \"coords\") + \" = idx;\\n          val += getX(\" + function(t, e) {\n        if (1 === t) return \"\" + e;\n        if (2 === t) return e + \".x, \" + e + \".y\";\n        if (3 === t) return e + \".x, \" + e + \".y, \" + e + \".z\";\n        if (4 === t) return e + \".x, \" + e + \".y, \" + e + \".z, \" + e + \".w\";\n        throw Error(\"Cumulative sum for rank \" + t + \" is not yet supported\");\n    }(r, \"coords\") + \");\\n        }\\n        setOutput(val);\\n      }\\n    \";\n};\nfunction Ki(t, e) {\n    if (1 === t) return \"\" + e;\n    if (2 === t) return e + \".y\";\n    if (3 === t) return e + \".z\";\n    if (4 === t) return e + \".w\";\n    throw Error(\"Cumulative sum for rank \" + t + \" is not yet supported\");\n}\nvar ji = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;\n    var e = Yt(t), n = Ya();\n    this.outputShape = t, this.userCode = \"\\n      ivec3 outCoordsFromFlatIndex(int index) {\\n        \" + $a([\n        \"r\",\n        \"c\",\n        \"d\"\n    ], t) + \"\\n        return ivec3(r, c, d);\\n      }\\n\\n      void main() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n          vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = 4 * (resTexRC.x * \" + e[1] + \" + resTexRC.y);\\n\\n        vec4 result = vec4(0.);\\n\\n        for (int i=0; i<4; i++) {\\n          int flatIndex = index + i;\\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\\n          result[i] = getA(rc.x, rc.y, rc.z);\\n        }\\n\\n        \" + n.output + \" = result;\\n      }\\n    \";\n}, Xi = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Vt.DENSE;\n    var e = Yt(t), n = Ya();\n    this.outputShape = t, this.userCode = \"\\n      ivec3 outCoordsFromFlatIndex(int index) {\\n        \" + $a([\n        \"r\",\n        \"c\",\n        \"d\"\n    ], t) + \"\\n        return ivec3(r, c, d);\\n      }\\n\\n      void main() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n          vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = 4 * (resTexRC.x * \" + e[1] + \" + resTexRC.y);\\n\\n        vec4 result = vec4(0.);\\n\\n        for (int i=0; i<4; i++) {\\n          int flatIndex = index + i;\\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\\n        }\\n\\n        \" + n.output + \" = result;\\n      }\\n    \";\n}, Yi = function() {\n    function t(t, e, n) {\n        this.variableNames = [\n            \"x\"\n        ], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = n, this.userCode = \"\\n    void main() {\\n      ivec4 coords = getOutputCoords();\\n      int b = coords[0];\\n      int h = \" + this.getHeightCoordString() + \";\\n      int w = \" + this.getWidthCoordString() + \";\\n      int d = \" + this.getDepthCoordString() + \";\\n\\n      int in_h = h / \" + e + \";\\n      int offset_h = imod(h, \" + e + \");\\n      int in_w = w / \" + e + \";\\n      int offset_w = imod(w, \" + e + \");\\n      int offset_d = (offset_h * \" + e + \" + offset_w) *\\n        \" + this.getOutputDepthSize() + \";\\n      int in_d = d + offset_d;\\n\\n      float result = \" + this.getInputSamplingString() + \";\\n      setOutput(result);\\n    }\\n  \";\n    }\n    return t.prototype.getHeightCoordString = function() {\n        return \"NHWC\" === this.dataFormat ? \"coords[1]\" : \"coords[2]\";\n    }, t.prototype.getWidthCoordString = function() {\n        return \"NHWC\" === this.dataFormat ? \"coords[2]\" : \"coords[3]\";\n    }, t.prototype.getDepthCoordString = function() {\n        return \"NHWC\" === this.dataFormat ? \"coords[3]\" : \"coords[1]\";\n    }, t.prototype.getOutputDepthSize = function() {\n        return \"NHWC\" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];\n    }, t.prototype.getInputSamplingString = function() {\n        return \"NHWC\" === this.dataFormat ? \"getX(b, in_h, in_w, in_d)\" : \"getX(b, in_d, in_h, in_w)\";\n    }, t;\n}(), $i = function(t) {\n    this.variableNames = [\n        \"X\"\n    ], this.outputShape = [\n        t,\n        t\n    ], this.userCode = \"\\n      void main() {\\n          ivec2 coords = getOutputCoords();\\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\\n          setOutput(val);\\n      }\\n    \";\n}, Qi = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.outTexUsage = zt.DOWNLOAD;\n    var e = Ya();\n    this.outputShape = t, this.userCode = \"\\n      \" + Ja + \"\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        \" + e.output + \" = encode_float(x);\\n      }\\n    \";\n}, Ji = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = zt.DOWNLOAD;\n    var e = Ya();\n    this.outputShape = t, this.userCode = \"\\n      \" + Ja + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\\n        \" + e.output + \" = encode_float(x);\\n      }\\n    \";\n}, Zi = function(t, e, n) {\n    void 0 === n && (n = !1), this.variableNames = [\n        \"A\"\n    ];\n    var r = Ya(), o = e[0], a = e[1];\n    this.outputShape = t;\n    var i = \"result\";\n    n && (i = \"floor(result * 255. + 0.5)\"), this.userCode = \"\\n      \" + Qa(t) + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n\\n        int flatIndex = getFlatIndex(coords);\\n        int offset = imod(flatIndex, 4);\\n\\n        flatIndex = idiv(flatIndex, 4, 1.);\\n        \\n        int r = flatIndex / \" + a + \";\\n        int c = imod(flatIndex, \" + a + \");\\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(\" + a + \".0, \" + o + \".0);\\n        vec4 values = \" + r.texture2D + \"(A, uv);\\n\\n        float result;\\n\\n        if(offset == 0) {\\n          result = values[0];\\n        } else if(offset == 1) {\\n          result = values[1];\\n        } else if(offset == 2) {\\n          result = values[2];\\n        } else {\\n          result = values[3];\\n        }\\n\\n        \" + r.output + \" = vec4(\" + i + \", 0., 0., 0.);\\n      }\\n    \";\n}, ts = function(t, e, n) {\n    void 0 === n && (n = !1), this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !1, this.packedOutput = !0;\n    var r = Ya(), o = e[0], a = e[1];\n    this.outputShape = t;\n    var i = \"\", s = \"result\";\n    n && (s = \"floor(result * 255. + 0.5)\");\n    for(var u = 0; u <= 1; u++)for(var c = 0; c <= 1; c++){\n        var l = 2 * u + c;\n        i += \"\\n          localCoords = coords;\\n          if(localCoords[2] + \" + c + \" < \" + t[2] + \") {\\n            localCoords[2] += \" + c + \";\\n            if(localCoords[1] + \" + u + \" < \" + t[1] + \") {\\n              localCoords[1] += \" + u + \";\\n\\n              flatIndex = getFlatIndex(localCoords);\\n              offset = imod(flatIndex, 4);\\n\\n              flatIndex = idiv(flatIndex, 4, 1.);\\n\\n              r = flatIndex / \" + a + \";\\n              c = imod(flatIndex, \" + a + \");\\n              uv = (vec2(c, r) + halfCR) / vec2(\" + a + \".0, \" + o + \".0);\\n              values = \" + r.texture2D + \"(A, uv);\\n\\n              if(offset == 0) {\\n                result[\" + l + \"] = values[0];\\n              } else if(offset == 1) {\\n                result[\" + l + \"] = values[1];\\n              } else if(offset == 2) {\\n                result[\" + l + \"] = values[2];\\n              } else {\\n                result[\" + l + \"] = values[3];\\n              }\\n            }\\n          }\\n        \";\n    }\n    this.userCode = \"\\n      \" + Qa(t) + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n\\n        vec4 result = vec4(0.);\\n        int flatIndex, r, c, offset;\\n        ivec3 localCoords;\\n        vec2 uv;\\n        vec4 values;\\n\\n        \" + i + \"\\n\\n        \" + r.output + \" = \" + s + \";\\n      }\\n    \";\n}, es = \"return real * expR - imag * expI;\", ns = \"return real * expI + imag * expR;\", rs = function(t, e, n) {\n    this.variableNames = [\n        \"real\",\n        \"imag\"\n    ];\n    var r = e[1];\n    this.outputShape = e;\n    var o = n ? \"2.0 * \" + Math.PI : \"-2.0 * \" + Math.PI, a = n ? r + \".0\" : \"1.0\";\n    this.userCode = \"\\n      const float exponentMultiplier = \" + o + \";\\n\\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\\n        \" + t + \"\\n      }\\n\\n      float mulMatDFT(int batch, int index) {\\n        float indexRatio = float(index) / float(\" + r + \");\\n        float exponentMultiplierTimesIndexRatio =\\n            exponentMultiplier * indexRatio;\\n\\n        float result = 0.0;\\n\\n        for (int i = 0; i < \" + r + \"; i++) {\\n          // x = (-2|2 * PI / N) * index * i;\\n          float x = exponentMultiplierTimesIndexRatio * float(i);\\n          float expR = cos(x);\\n          float expI = sin(x);\\n          float real = getReal(batch, i);\\n          float imag = getImag(batch, i);\\n\\n          result +=\\n              unaryOpComplex(real, expR, imag, expI) / \" + a + \";\\n        }\\n\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        setOutput(mulMatDFT(coords[0], coords[1]));\\n      }\\n    \";\n}, os = function() {\n    function t(t, e) {\n        this.outputShape = [], this.variableNames = [\n            \"x\"\n        ], this.outputShape = t, this.userCode = \"\\n      uniform float value;\\n      void main() {\\n        // Input can be obtained from uniform value.\\n        setOutput(value);\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t) {\n        var e = this;\n        return function(n, r) {\n            null == e.valueLoc && (e.valueLoc = n.getUniformLocationNoThrow(r, \"value\")), n.gl.uniform1f(e.valueLoc, t);\n        };\n    }, t;\n}(), as = function(t, e, n) {\n    this.variableNames = [\n        \"A\",\n        \"indices\"\n    ];\n    var r = t.slice();\n    r[n] = e, this.outputShape = r, this.rank = r.length;\n    var o = ui(this.rank), a = function(t, e) {\n        var n = t.length;\n        if (n > 4) throw Error(\"Gather for rank \" + n + \" is not yet supported\");\n        if (1 === n) return \"int(getIndices(resRC))\";\n        for(var r = [\n            \"resRC.x\",\n            \"resRC.y\",\n            \"resRC.z\",\n            \"resRC.w\"\n        ], o = [], a = 0; a < t.length; a++)a === e ? o.push(\"int(getIndices(\" + r[a] + \"))\") : o.push(\"\" + r[a]);\n        return o.join();\n    }(t, n);\n    this.userCode = \"\\n      void main() {\\n        \" + o + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + a + \"));\\n      }\\n    \";\n};\nvar is = function(t, e, n) {\n    this.sliceDim = t, this.strides = e, this.variableNames = [\n        \"x\",\n        \"indices\"\n    ], this.outputShape = n;\n    var r = ui(e.length), o = ui(n.length), a = this.sliceDim > 1 ? \"strides[j]\" : \"strides\";\n    this.userCode = \"\\n        \" + r + \" strides = \" + r + \"(\" + this.strides + \");\\n         void main() {\\n          \" + o + \" coords = getOutputCoords();\\n          int flattenIndex = 0;\\n          for (int j = 0; j < \" + this.sliceDim + \"; j++) {\\n            int index = round(getIndices(coords[0], j));\\n            flattenIndex += index * \" + a + \";\\n          }\\n          setOutput(getX(flattenIndex, coords[1]));\\n        }\\n      \";\n};\nfunction ss(t, e) {\n    var n = Ya();\n    return oe(t, e, n.version + \"\\n    precision highp float;\\n    \" + n.attribute + \" vec3 clipSpacePos;\\n    \" + n.attribute + \" vec2 uv;\\n    \" + n.varyingVs + \" vec2 resultUV;\\n\\n    void main() {\\n      gl_Position = vec4(clipSpacePos, 1);\\n      resultUV = uv;\\n    }\");\n}\nfunction us(t, e) {\n    return fe(t, e, new Float32Array([\n        -1,\n        1,\n        0,\n        0,\n        1,\n        -1,\n        -1,\n        0,\n        0,\n        0,\n        1,\n        1,\n        0,\n        1,\n        1,\n        1,\n        -1,\n        0,\n        1,\n        0\n    ]));\n}\nfunction cs(t, e) {\n    return de(t, e, new Uint16Array([\n        0,\n        1,\n        2,\n        2,\n        1,\n        3\n    ]));\n}\nfunction ls(t, e, n, r, o, a, i) {\n    ve(n, r);\n    var s = pe(t, e), u = t.TEXTURE_2D;\n    return Jt(t, e, function() {\n        return t.bindTexture(u, s);\n    }), Jt(t, e, function() {\n        return t.texParameteri(u, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE);\n    }), Jt(t, e, function() {\n        return t.texParameteri(u, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);\n    }), Jt(t, e, function() {\n        return t.texParameteri(u, t.TEXTURE_MIN_FILTER, t.NEAREST);\n    }), Jt(t, e, function() {\n        return t.texParameteri(u, t.TEXTURE_MAG_FILTER, t.NEAREST);\n    }), Jt(t, e, function() {\n        return t.texImage2D(u, 0, o, n, r, 0, a, i, null);\n    }), Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, null);\n    }), s;\n}\nfunction hs(t, e, n, r, o) {\n    var a = Xt(n, r);\n    return ls(t, e, a[0], a[1], o.internalFormatFloat, o.textureFormatFloat, t.FLOAT);\n}\nfunction fs(t, e, n, r, o) {\n    var a = Xt(n, r);\n    return ls(t, e, a[0], a[1], o.internalFormatHalfFloat, o.textureFormatFloat, o.textureTypeHalfFloat);\n}\nfunction ds(t, e, n, r, o) {\n    var a = Xt(n, r);\n    return ls(t, e, a[0], a[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE);\n}\nfunction ps(t, e, n, r, o) {\n    var a = $t(n, r);\n    return ls(t, e, a[0], a[1], o.internalFormatPackedFloat, t.RGBA, t.FLOAT);\n}\nfunction vs(t, e, n, r, o) {\n    var a = $t(n, r);\n    return ls(t, e, a[0], a[1], o.internalFormatPackedHalfFloat, t.RGBA, o.textureTypeHalfFloat);\n}\nfunction gs(t, e, n, r) {\n    return Jt(t, e, function() {\n        return t.bindBuffer(t.ARRAY_BUFFER, r);\n    }), me(t, e, n, \"clipSpacePos\", r, 3, 20, 0) && me(t, e, n, \"uv\", r, 2, 20, 12);\n}\nfunction ms(t, e, n, r, o, a, i) {\n    var s, u, c;\n    Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, n);\n    }), a instanceof Uint8Array ? (s = new Uint8Array(r * o * 4), u = t.UNSIGNED_BYTE, c = t.RGBA) : (s = new Float32Array(r * o * 4), u = t.FLOAT, c = i.internalFormatPackedFloat), s.set(a), Jt(t, e, function() {\n        return t.texImage2D(t.TEXTURE_2D, 0, c, r, o, 0, t.RGBA, u, s);\n    }), Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, null);\n    });\n}\nfunction ys(t, e, n, r) {\n    Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, n);\n    }), r.data instanceof Uint8Array ? Jt(t, e, function() {\n        return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, r.width, r.height, 0, t.RGBA, t.UNSIGNED_BYTE, r.data);\n    }) : Jt(t, e, function() {\n        return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r);\n    }), Jt(t, e, function() {\n        return t.bindTexture(t.TEXTURE_2D, null);\n    });\n}\nfunction xs(t, e, n, r, o) {\n    var a = t.createBuffer();\n    Jt(t, e, function() {\n        return t.bindBuffer(t.PIXEL_PACK_BUFFER, a);\n    });\n    var i = 16 * n * r;\n    return Jt(t, e, function() {\n        return t.bufferData(t.PIXEL_PACK_BUFFER, i, t.STREAM_READ);\n    }), Jt(t, e, function() {\n        return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0);\n    }), Jt(t, e, function() {\n        return t.bindBuffer(t.PIXEL_PACK_BUFFER, null);\n    }), a;\n}\nfunction bs(t, e, n) {\n    var r = t, o = new Float32Array(n);\n    return r.bindBuffer(r.PIXEL_PACK_BUFFER, e), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, o), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), o;\n}\nfunction ws(t, e, n, r, o) {\n    var a = Xt(n, r), i = a[0], s = a[1], u = new Uint8Array(n * r * 4);\n    return Jt(t, e, function() {\n        return t.readPixels(0, 0, i, s, o.downloadTextureFormat, t.UNSIGNED_BYTE, u);\n    }), new Float32Array(u.buffer);\n}\nfunction Cs(t, e, n, r, o, a, i, s) {\n    var u = t, c = new Float32Array(function(t, e) {\n        var n = $t(t, e);\n        return n[0] * n[1] * 4;\n    }(a, i));\n    return u.bindBuffer(u.PIXEL_PACK_BUFFER, e), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, c), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), c;\n}\nfunction Es(t, e, n, r) {\n    var o = new Float32Array(n * r * 4);\n    return Jt(t, e, function() {\n        return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, o);\n    }), o;\n}\nvar Rs = Object.freeze({\n    createVertexShader: ss,\n    createVertexBuffer: us,\n    createIndexBuffer: cs,\n    createFloat32MatrixTexture: hs,\n    createFloat16MatrixTexture: fs,\n    createUnsignedBytesMatrixTexture: ds,\n    createPackedMatrixTexture: ps,\n    createFloat16PackedMatrixTexture: vs,\n    bindVertexProgramAttributeStreams: gs,\n    uploadDenseMatrixToTexture: ms,\n    uploadPixelDataToTexture: ys,\n    createBufferFromOutputTexture: xs,\n    downloadFloat32MatrixFromBuffer: bs,\n    downloadByteEncodedFloatMatrixFromOutputTexture: ws,\n    downloadPackedMatrixFromBuffer: Cs,\n    downloadMatrixFromPackedOutputTexture: Es\n}), Is = function() {\n    function t(t) {\n        this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];\n        var e = i().getNumber(\"WEBGL_VERSION\");\n        null != t ? (this.gl = t, Kt(e, t)) : this.gl = jt(e);\n        var n = \"WEBGL_color_buffer_float\";\n        if (1 === i().getNumber(\"WEBGL_VERSION\")) {\n            if (this.textureFloatExtension = re(this.gl, this.debug, \"OES_texture_float\"), Pe(this.gl, \"OES_texture_half_float\")) this.textureHalfFloatExtension = re(this.gl, this.debug, \"OES_texture_half_float\");\n            else if (i().get(\"WEBGL_FORCE_F16_TEXTURES\")) throw new Error(\"GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.\");\n            if (this.colorBufferFloatExtension = this.gl.getExtension(n), Pe(this.gl, \"EXT_color_buffer_half_float\")) this.colorBufferHalfFloatExtension = re(this.gl, this.debug, \"EXT_color_buffer_half_float\");\n            else if (i().get(\"WEBGL_FORCE_F16_TEXTURES\")) throw new Error(\"GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.\");\n        } else if (n = \"EXT_color_buffer_float\", Pe(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n);\n        else {\n            if (!Pe(this.gl, \"EXT_color_buffer_half_float\")) throw new Error(\"GL context does not support color renderable floats\");\n            this.colorBufferHalfFloatExtension = this.gl.getExtension(\"EXT_color_buffer_half_float\");\n        }\n        this.vertexBuffer = us(this.gl, this.debug), this.indexBuffer = cs(this.gl, this.debug), this.framebuffer = ge(this.gl, this.debug), this.textureConfig = Qt(this.gl, this.textureHalfFloatExtension);\n    }\n    return Object.defineProperty(t.prototype, \"debug\", {\n        get: function() {\n            return i().getBool(\"DEBUG\");\n        },\n        enumerable: !0,\n        configurable: !0\n    }), t.prototype.dispose = function() {\n        var t = this;\n        if (!this.disposed) {\n            null != this.program && console.warn(\"Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.\"), null != this.outputTexture && console.warn(\"Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.\");\n            var e = this.gl;\n            Jt(e, this.debug, function() {\n                return e.finish();\n            }), Jt(e, this.debug, function() {\n                return e.bindFramebuffer(e.FRAMEBUFFER, null);\n            }), Jt(e, this.debug, function() {\n                return e.deleteFramebuffer(t.framebuffer);\n            }), Jt(e, this.debug, function() {\n                return e.bindBuffer(e.ARRAY_BUFFER, null);\n            }), Jt(e, this.debug, function() {\n                return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null);\n            }), Jt(e, this.debug, function() {\n                return e.deleteBuffer(t.indexBuffer);\n            }), this.disposed = !0;\n        }\n    }, t.prototype.createFloat32MatrixTexture = function(t, e) {\n        return this.throwIfDisposed(), hs(this.gl, this.debug, t, e, this.textureConfig);\n    }, t.prototype.createFloat16MatrixTexture = function(t, e) {\n        return this.throwIfDisposed(), fs(this.gl, this.debug, t, e, this.textureConfig);\n    }, t.prototype.createUnsignedBytesMatrixTexture = function(t, e) {\n        return this.throwIfDisposed(), ds(this.gl, this.debug, t, e, this.textureConfig);\n    }, t.prototype.uploadPixelDataToTexture = function(t, e) {\n        this.throwIfDisposed(), ys(this.gl, this.debug, t, e);\n    }, t.prototype.uploadDenseMatrixToTexture = function(t, e, n, r) {\n        this.throwIfDisposed(), ms(this.gl, this.debug, t, e, n, r, this.textureConfig);\n    }, t.prototype.createFloat16PackedMatrixTexture = function(t, e) {\n        return this.throwIfDisposed(), vs(this.gl, this.debug, t, e, this.textureConfig);\n    }, t.prototype.createPackedMatrixTexture = function(t, e) {\n        return this.throwIfDisposed(), ps(this.gl, this.debug, t, e, this.textureConfig);\n    }, t.prototype.deleteMatrixTexture = function(t) {\n        var e = this;\n        this.throwIfDisposed(), this.outputTexture === t && (Ee(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Jt(this.gl, this.debug, function() {\n            return e.gl.deleteTexture(t);\n        });\n    }, t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function(t, e, n) {\n        var r = this;\n        return this.downloadMatrixDriver(t, function() {\n            return ws(r.gl, r.debug, e, n, r.textureConfig);\n        });\n    }, t.prototype.downloadPackedMatrixFromBuffer = function(t, e, n, r, o, a) {\n        return Cs(this.gl, t, 0, 0, 0, o, a, this.textureConfig);\n    }, t.prototype.downloadFloat32MatrixFromBuffer = function(t, e) {\n        return bs(this.gl, t, e);\n    }, t.prototype.createBufferFromTexture = function(t, e, n) {\n        this.bindTextureToFrameBuffer(t);\n        var r = xs(this.gl, this.debug, e, n, this.textureConfig);\n        return this.unbindTextureToFrameBuffer(), r;\n    }, t.prototype.createAndWaitForFence = function() {\n        var t = this.createFence(this.gl);\n        return this.pollFence(t);\n    }, t.prototype.createFence = function(t) {\n        var e, n, r = this;\n        if (i().getBool(\"WEBGL_FENCE_API_ENABLED\")) {\n            var o = t, a = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            t.flush(), n = function() {\n                var t = o.clientWaitSync(a, 0, 0);\n                return t === o.ALREADY_SIGNALED || t === o.CONDITION_SATISFIED;\n            }, e = a;\n        } else i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? (e = this.beginQuery(), this.endQuery(), n = function() {\n            return r.isQueryAvailable(e, i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"));\n        }) : n = function() {\n            return !0;\n        };\n        return {\n            query: e,\n            isFencePassed: n\n        };\n    }, t.prototype.downloadMatrixFromPackedTexture = function(t, e, n) {\n        var r = this;\n        return this.downloadMatrixDriver(t, function() {\n            return Es(r.gl, r.debug, e, n);\n        });\n    }, t.prototype.createProgram = function(t) {\n        this.throwIfDisposed();\n        var e = this.gl, n = ae(e, this.debug, t), r = ss(e, this.debug), o = ce(e, this.debug);\n        return Jt(e, this.debug, function() {\n            return e.attachShader(o, r);\n        }), Jt(e, this.debug, function() {\n            return e.attachShader(o, n);\n        }), le(e, this.debug, o), this.debug && he(e, this.debug, o), this.vertexAttrsAreBound || (this.setProgram(o), this.vertexAttrsAreBound = gs(e, this.debug, this.program, this.vertexBuffer)), o;\n    }, t.prototype.deleteProgram = function(t) {\n        var e = this;\n        this.throwIfDisposed(), t === this.program && (this.program = null), null != t && Jt(this.gl, this.debug, function() {\n            return e.gl.deleteProgram(t);\n        });\n    }, t.prototype.setProgram = function(t) {\n        var e = this;\n        this.throwIfDisposed(), this.program = t, null != this.program && this.debug && he(this.gl, this.debug, this.program), Jt(this.gl, this.debug, function() {\n            return e.gl.useProgram(t);\n        });\n    }, t.prototype.getUniformLocation = function(t, e, n) {\n        return void 0 === n && (n = !0), this.throwIfDisposed(), n ? xe(this.gl, this.debug, t, e) : be(this.gl, t, e);\n    }, t.prototype.getAttributeLocation = function(t, e) {\n        var n = this;\n        return this.throwIfDisposed(), Jt(this.gl, this.debug, function() {\n            return n.gl.getAttribLocation(t, e);\n        });\n    }, t.prototype.getUniformLocationNoThrow = function(t, e) {\n        return this.throwIfDisposed(), this.gl.getUniformLocation(t, e);\n    }, t.prototype.setInputMatrixTexture = function(t, e, n) {\n        this.throwIfDisposed(), this.throwIfNoProgram(), we(this.gl, this.debug, this.program, t, e, n);\n    }, t.prototype.setOutputMatrixTexture = function(t, e, n) {\n        this.setOutputMatrixTextureDriver(t, n, e);\n    }, t.prototype.setOutputPackedMatrixTexture = function(t, e, n) {\n        this.throwIfDisposed();\n        var r = $t(e, n), o = r[0], a = r[1];\n        this.setOutputMatrixTextureDriver(t, o, a);\n    }, t.prototype.setOutputMatrixWriteRegion = function(t, e, n, r) {\n        this.setOutputMatrixWriteRegionDriver(n, t, r, e);\n    }, t.prototype.setOutputPackedMatrixWriteRegion = function(t, e, n, r) {\n        throw new Error(\"setOutputPackedMatrixWriteRegion not implemented.\");\n    }, t.prototype.debugValidate = function() {\n        null != this.program && he(this.gl, this.debug, this.program), Re(this.gl);\n    }, t.prototype.executeProgram = function() {\n        this.throwIfDisposed(), this.throwIfNoProgram();\n        var t = this.gl;\n        this.debug && this.debugValidate(), Jt(t, this.debug, function() {\n            return t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0);\n        });\n    }, t.prototype.blockUntilAllProgramsCompleted = function() {\n        var t = this;\n        this.throwIfDisposed(), Jt(this.gl, this.debug, function() {\n            return t.gl.finish();\n        });\n    }, t.prototype.getQueryTimerExtension = function() {\n        return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = re(this.gl, this.debug, 2 === i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") ? \"EXT_disjoint_timer_query_webgl2\" : \"EXT_disjoint_timer_query\")), this.disjointQueryTimerExtension;\n    }, t.prototype.getQueryTimerExtensionWebGL2 = function() {\n        return this.getQueryTimerExtension();\n    }, t.prototype.getQueryTimerExtensionWebGL1 = function() {\n        return this.getQueryTimerExtension();\n    }, t.prototype.beginQuery = function() {\n        if (2 === i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")) {\n            var t = this.gl, e = this.getQueryTimerExtensionWebGL2(), n = t.createQuery();\n            return t.beginQuery(e.TIME_ELAPSED_EXT, n), n;\n        }\n        var r = this.getQueryTimerExtensionWebGL1(), o = r.createQueryEXT();\n        return r.beginQueryEXT(r.TIME_ELAPSED_EXT, o), o;\n    }, t.prototype.endQuery = function() {\n        if (2 !== i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")) {\n            var t = this.getQueryTimerExtensionWebGL1();\n            t.endQueryEXT(t.TIME_ELAPSED_EXT);\n        } else {\n            var e = this.gl, n = this.getQueryTimerExtensionWebGL2();\n            e.endQuery(n.TIME_ELAPSED_EXT);\n        }\n    }, t.prototype.waitForQueryAndGetTime = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e = this;\n            return r(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        return [\n                            4,\n                            F(function() {\n                                return e.disposed || e.isQueryAvailable(t, i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"));\n                            })\n                        ];\n                    case 1:\n                        return n.sent(), [\n                            2,\n                            this.getQueryTime(t, i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))\n                        ];\n                }\n            });\n        });\n    }, t.prototype.getQueryTime = function(t, e) {\n        if (0 === e) return null;\n        if (2 === e) {\n            var n = this.gl;\n            return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6;\n        }\n        var r = this.getQueryTimerExtensionWebGL1();\n        return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6;\n    }, t.prototype.isQueryAvailable = function(t, e) {\n        if (0 === e) return !0;\n        if (2 === e) {\n            var n = this.gl, r = this.getQueryTimerExtensionWebGL2(), o = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);\n            return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;\n        }\n        o = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t, r.QUERY_RESULT_AVAILABLE_EXT);\n        return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;\n    }, t.prototype.pollFence = function(t) {\n        var e = this;\n        return new Promise(function(n) {\n            e.addItemToPoll(function() {\n                return t.isFencePassed();\n            }, function() {\n                return n();\n            });\n        });\n    }, t.prototype.pollItems = function() {\n        for(var t = function(t) {\n            for(var e = 0; e < t.length; ++e){\n                if (!t[e]()) break;\n            }\n            return e - 1;\n        }(this.itemsToPoll.map(function(t) {\n            return t.isDoneFn;\n        })), e = 0; e <= t; ++e){\n            (0, this.itemsToPoll[e].resolveFn)();\n        }\n        this.itemsToPoll = this.itemsToPoll.slice(t + 1);\n    }, t.prototype.addItemToPoll = function(t, e) {\n        var n = this;\n        this.itemsToPoll.push({\n            isDoneFn: t,\n            resolveFn: e\n        }), this.itemsToPoll.length > 1 || F(function() {\n            return n.pollItems(), 0 === n.itemsToPoll.length;\n        });\n    }, t.prototype.bindTextureToFrameBuffer = function(t) {\n        this.throwIfDisposed(), Ce(this.gl, this.debug, t, this.framebuffer), this.debug && Re(this.gl);\n    }, t.prototype.unbindTextureToFrameBuffer = function() {\n        null != this.outputTexture ? (Ce(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && Re(this.gl)) : Ee(this.gl, this.debug, this.framebuffer);\n    }, t.prototype.downloadMatrixDriver = function(t, e) {\n        this.bindTextureToFrameBuffer(t);\n        var n = e();\n        return this.unbindTextureToFrameBuffer(), n;\n    }, t.prototype.setOutputMatrixTextureDriver = function(t, e, n) {\n        this.throwIfDisposed();\n        var r = this.gl;\n        Ce(r, this.debug, t, this.framebuffer), this.debug && Re(r), this.outputTexture = t, Jt(r, this.debug, function() {\n            return r.viewport(0, 0, e, n);\n        }), Jt(r, this.debug, function() {\n            return r.scissor(0, 0, e, n);\n        });\n    }, t.prototype.setOutputMatrixWriteRegionDriver = function(t, e, n, r) {\n        var o = this;\n        this.throwIfDisposed(), Jt(this.gl, this.debug, function() {\n            return o.gl.scissor(t, e, n, r);\n        });\n    }, t.prototype.throwIfDisposed = function() {\n        if (this.disposed) throw new Error(\"Attempted to use disposed GPGPUContext.\");\n    }, t.prototype.throwIfNoProgram = function() {\n        if (null == this.program) throw new Error(\"No GPU program is currently set.\");\n    }, t;\n}();\nfunction ks(t, e) {\n    if (t.length !== e.length) throw Error(\"Binary was compiled with \" + t.length + \" inputs, but was executed with \" + e.length + \" inputs\");\n    t.forEach(function(t, n) {\n        var r = t.logicalShape, o = e[n], a = o.shape;\n        if (!S(r, a)) throw Error(\"Binary was compiled with different shapes than the current args. Shapes \" + r + \" and \" + a + \" must match\");\n        if (!t.isUniform || !o.isUniform) {\n            var i = t.texShape, s = o.isUniform ? null : o.texData.texShape;\n            if (!S(i, s)) throw Error(\"Binary was compiled with different texture shapes than the current args. Shape \" + i + \" and \" + s + \" must match\");\n        }\n    });\n}\nvar Ss = function(t, e, n) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;\n    for(var r = n.filterWidth, o = n.inChannels, a = n.strideWidth, i = n.strideHeight, s = n.padInfo, u = n.outWidth, c = n.dilationWidth, l = n.dilationHeight, h = n.dataFormat, f = s.left, d = s.top, p = o * r, v = Ya(), g = \"channelsLast\" === h, m = g ? 0 : 1, y = g ? 1 : 2, x = \"\", b = 0; b <= 1; b++)for(var w = 0; w <= 1; w++)x += \"\\n          blockIndex = rc.y + \" + w + \";\\n          pos = rc.x + \" + b + \";\\n\\n          if(blockIndex < \" + t[1] + \" && pos < \" + t[0] + \") {\\n            offsetY = int(blockIndex / (\" + u + \")) * \" + i + \" - \" + d + \";\\n            d0 = offsetY + \" + l + \" * (pos / \" + p + \");\\n\\n            if(d0 < \" + e[m] + \" && d0 >= 0) {\\n\\n              offsetX = int(mod(float(blockIndex), \" + u + \".) * \" + a + \". - \" + f + \".);\\n              d1 = offsetX + \" + c + \" * (int(mod(float(pos), \" + p + \".) / \" + o + \".));\\n\\n              if(d1 < \" + e[y] + \" && d1 >= 0) {\\n\\n                ch = int(mod(float(pos), \" + o + \".));\\n\\n                if (\" + g + \") {\\n                  innerDims = vec2(d1, ch);\\n                  result[\" + (2 * b + w) + \"] = getChannel(\\n                    getA(d0, int(innerDims.x),\\n                    int(innerDims.y)), innerDims);\\n                } else {\\n                  innerDims = vec2(d0, d1);\\n                  result[\" + (2 * b + w) + \"] = getChannel(\\n                    getA(ch, int(innerDims.x),\\n                    int(innerDims.y)), innerDims);\\n                }\\n              }\\n            }\\n          }\\n        \";\n    this.userCode = \"\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0);\\n\\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\\n        vec2 innerDims;\\n\\n        \" + x + \"\\n\\n        \" + v.output + \" = result;\\n      }\\n    \";\n}, As = function(t, e, n, r, o) {\n    this.variableNames = [\n        \"x\"\n    ], this.outputShape = [];\n    var a, i = e, s = t[3] - 1;\n    this.outputShape = t;\n    var u = \"float(\" + n + \") + float(\" + r + \") * sum\";\n    a = .5 === o ? \"inversesqrt(\" + u + \")\" : 1 === o ? \"1.0/(\" + u + \")\" : \"exp(log(\" + u + \") * float(-\" + o + \"));\", this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n        int d = coords[3];\\n        float x = getX(b, r, c, d);\\n        float sum = 0.0;\\n        for (int j = -\" + i + \"; j <= \" + i + \"; j++) {\\n          int idx = d + j;\\n          if (idx >= 0 && idx <=  \" + s + \") {\\n            float z = getX(b, r, c, idx);\\n            sum += z * z;\\n          }\\n        }\\n        float val = x * \" + a + \";\\n        setOutput(val);\\n      }\\n    \";\n}, Ts = function(t, e, n, r, o) {\n    this.variableNames = [\n        \"inputImage\",\n        \"outputImage\",\n        \"dy\"\n    ], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = n, this.alpha = r, this.beta = o, this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float result = 0.0;\\n        for (int d = 0; d < \" + this.depth + \"; ++d) {\\n          int depthBegin = int(max(0.0, float(d - \" + e + \")));\\n          int depthEnd = int(min(float(\" + this.depth + \"),\\n              float(d + \" + e + \" + 1)));\\n\\n          const int MIN_DEPTH_BEGIN = 0;\\n          const int MAX_DEPTH_END = \" + this.depth + \";\\n\\n          float norm = 0.0;\\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd) {\\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n\\n          norm = float(\" + r + \") * norm + float(\" + n + \");\\n\\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd){\\n              float dyi = -2.0 * float(\" + r + \")\\n                * float(\" + o + \")\\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\\n                / norm;\\n              if (k == d) {\\n                dyi += pow(norm, -1.0 * \" + o + \");\\n              }\\n              if (k == coords[3]) {\\n                dyi *= getDy(b, r, c, d);\\n                result += dyi;\\n              }\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n      }\\n      setOutput(result);\\n      }\\n    \";\n}, Ds = function(t, e, n, r, o) {\n    this.variableNames = [\n        \"x\"\n    ], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;\n    var a, i = e, s = t[3] - 1;\n    this.outputShape = t;\n    var u = \"float(\" + n + \") + float(\" + r + \") * sum\";\n    a = .5 === o ? \"inversesqrt(\" + u + \")\" : 1 === o ? \"1.0/(\" + u + \")\" : \"exp(log(\" + u + \") * float(-\" + o + \"));\", this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords.x;\\n        int r = coords.y;\\n        int c = coords.z;\\n        int d = coords.w;\\n\\n        bool hasNextCol = d < \" + this.outputShape[3] + \";\\n        bool hasNextRow = c < \" + this.outputShape[2] + \";\\n\\n        vec4 sum = vec4(0.);\\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\\n\\n        vec4 xAtOutputCoords = vec4(\\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\\n          hasNextCol ?\\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\\n          hasNextRow ?\\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\\n        );\\n\\n        int firstChannel = d - \" + i + \";\\n        vec2 cache = vec2(0.);\\n        if(firstChannel >= 0){\\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\\n            if(hasNextRow){\\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\\n            }\\n        }\\n\\n        ivec2 depth = ivec2(d, d + 1);\\n        for (int j = - \" + i + \"; j <= \" + i + \"; j++) {\\n          ivec2 idx = depth + j;\\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(\" + s + \"));\\n\\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\\n\\n          if(depthInRange || depthPlusOneInRange){\\n            vec4 z = vec4(0.);\\n            vec4 xFragAtCurrentDepth;\\n            z.xz = cache.xy;\\n            if(depthPlusOneInRange && hasNextCol){\\n              xFragAtCurrentDepth = idx.y != d ?\\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\\n              if(hasNextRow){\\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\\n              }\\n            }\\n            cache.xy = z.yw;\\n            sum += z * z;\\n          }\\n        }\\n        vec4 result = xAtOutputCoords * \" + a + \";\\n        setOutput(result);\\n      }\\n    \";\n}, Ns = function(t) {\n    this.variableNames = [\n        \"dy\",\n        \"maxPos\"\n    ], this.outputShape = t.inShape;\n    var e = t.strideHeight, n = t.strideWidth, r = t.dilationHeight, o = t.effectiveFilterHeight, a = t.effectiveFilterWidth, i = o - 1 - t.padInfo.top, s = a - 1 - t.padInfo.left, u = o * a - 1;\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + i + \", \" + s + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + o + \";\\n          wR += \" + r + \") {\\n          float dyR = float(dyRCorner + wR) / \" + e + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + a + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + n + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n            int maxPosValue = \" + u + \" - int(getMaxPos(b, idyR, idyC, d));\\n\\n            // Get the current value, check it against the value from the\\n            // position matrix.\\n            int curPosValue = wR * \" + a + \" + wC;\\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n            dotProd += dyValue * mask;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, Fs = function(t) {\n    this.variableNames = [\n        \"dy\",\n        \"maxPos\"\n    ], this.outputShape = t.inShape;\n    var e = t.strideDepth, n = t.strideHeight, r = t.strideWidth, o = t.dilationDepth, a = t.dilationHeight, i = t.dilationWidth, s = t.effectiveFilterDepth, u = t.effectiveFilterHeight, c = t.effectiveFilterWidth, l = s - 1 - t.padInfo.front, h = u - 1 - t.padInfo.top, f = c - 1 - t.padInfo.left, d = s * u * c - 1;\n    this.userCode = \"\\n      const ivec3 pads = ivec3(\" + l + \", \" + h + \", \" + f + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyDCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\\n        // dx(xD, xR, xC, ch).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int wD = 0; wD < \" + s + \";\\n           wD += \" + o + \") {\\n          float dyD = float(dyDCorner + wD) / \" + e + \".0;\\n\\n          if (dyD < 0.0 || dyD >= \" + t.outDepth + \".0 || fract(dyD) > 0.0) {\\n            continue;\\n          }\\n          int idyD = int(dyD);\\n\\n          for (int wR = 0; wR < \" + u + \";\\n              wR += \" + a + \") {\\n            float dyR = float(dyRCorner + wR) / \" + n + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 ||\\n                fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            for (int wC = 0; wC < \" + c + \";\\n                wC += \" + i + \") {\\n              float dyC = float(dyCCorner + wC) / \" + r + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\\n              int maxPosValue = \" + d + \" -\\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\\n\\n              // Get the current value, check it against the value from the\\n              // position matrix.\\n              int curPosValue =\\n                  wD * \" + u + \" * \" + c + \" +\\n                  wR * \" + c + \" + wC;\\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n              dotProd += dyValue * mask;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n}, _s = function(t, e, n, r, o, a, i) {\n    void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === a && (a = null), void 0 === i && (i = !1), this.variableNames = [\n        \"matrixA\",\n        \"matrixB\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;\n    var s = n ? t[1] : t[2], u = Math.ceil(s / 2), c = n ? \"i * 2, rc.y\" : \"rc.y, i * 2\", l = r ? \"rc.z, i * 2\" : \"i * 2, rc.z\", h = n ? [\n        \"a.xxyy\",\n        \"a.zzww\"\n    ] : [\n        \"a.xxzz\",\n        \"a.yyww\"\n    ], f = r ? [\n        \"b.xzxz\",\n        \"b.ywyw\"\n    ] : [\n        \"b.xyxy\",\n        \"b.zwzw\"\n    ], d = \"\", p = \"\";\n    a && (d = i ? \"vec4 activation(vec4 a) {\\n          vec4 b = getPreluActivationWeightsAtOutCoords();\\n          \" + a + \"\\n        }\" : \"vec4 activation(vec4 x) {\\n          \" + a + \"\\n        }\", p = \"result = activation(result);\");\n    var v = o ? \"result += getBiasAtOutCoords();\" : \"\";\n    o && this.variableNames.push(\"bias\"), i && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + d + \"\\n\\n      const float sharedDimension = \" + u + \".0;\\n\\n      vec4 dot2x2ARowBCol(ivec3 rc) {\\n        vec4 result = vec4(0);\\n        for (int i = 0; i < \" + u + \"; i++) {\\n          vec4 a = getMatrixA(rc.x, \" + c + \");\\n          vec4 b = getMatrixB(rc.x, \" + l + \");\\n\\n          // These swizzled products need to be separately added.\\n          // See: https://github.com/tensorflow/tfjs/issues/1735\\n          result += (\" + h[0] + \" * \" + f[0] + \");\\n          result += (\" + h[1] + \" * \" + f[1] + \");\\n        }\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n        vec4 result = dot2x2ARowBCol(rc);\\n\\n        \" + v + \"\\n\\n        \" + p + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n}, Os = function() {\n    function t(t, e, n) {\n        this.variableNames = [\n            \"probs\"\n        ], this.outputShape = [\n            t,\n            n\n        ], this.userCode = \"\\n      uniform float seed;\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n\\n        float r = random(seed);\\n        float cdf = 0.0;\\n\\n        for (int i = 0; i < \" + (e - 1) + \"; i++) {\\n          cdf += getProbs(batch, i);\\n\\n          if (r < cdf) {\\n            setOutput(float(i));\\n            return;\\n          }\\n        }\\n\\n        // If no other event happened, last event happened.\\n        setOutput(float(\" + (e - 1) + \"));\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t) {\n        var e = this;\n        return function(n, r) {\n            null == e.seedLoc && (e.seedLoc = n.getUniformLocation(r, \"seed\")), n.gl.uniform1f(e.seedLoc, t);\n        };\n    }, t;\n}(), Ms = function(t, e, n, r) {\n    this.variableNames = [\n        \"indices\"\n    ], this.outputShape = [\n        t,\n        e\n    ], this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int index = round(getIndices(coords.x));\\n        setOutput(mix(float(\" + r + \"), float(\" + n + \"),\\n                      float(index == coords.y)));\\n      }\\n    \";\n}, Bs = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t;\n    var e = t.length;\n    if (0 === e) this.userCode = \"\\n        void main() {\\n          setOutput(vec4(getA(), 0., 0., 0.));\\n        }\\n      \";\n    else {\n        var n = Xa(\"rc\", e), r = ui(e), o = function(t, e, n) {\n            if (1 === t) return \"rc > \" + e[0];\n            for(var r = \"\", o = t - 2; o < t; o++)r += n[o] + \" >= \" + e[o], o < t - 1 && (r += \"||\");\n            return r;\n        }(e, t, n), a = function(t, e, n, r) {\n            if (1 === t) return \"\";\n            var o = r.slice(-2);\n            return \"\\n    int r = \" + o[0] + \";\\n    int c = \" + o[1] + \";\\n    int rp1 = r + 1;\\n    int cp1 = c + 1;\\n\\n    bool cEdge = cp1 >= \" + e + \";\\n    bool rEdge = rp1 >= \" + n + \";\\n  \";\n        }(e, t[t.length - 1], t[t.length - 2], n), i = function(t, e) {\n            var n = t.length, r = function(t, e) {\n                for(var n = [], r = 0; r <= 1; r++)for(var o = 0; o <= 1; o++){\n                    for(var a = (0 === r ? \"r\" : \"rp1\") + \", \" + (0 === o ? \"c\" : \"cp1\"), i = 2; i < t; i++)a = e[e.length - 1 - i] + \",\" + a;\n                    n.push(a);\n                }\n                return n;\n            }(n, e);\n            return 1 === n ? \"getA(rc),\\n            rc + 1 >= \" + t[0] + \" ? 0. : getA(rc + 1),\\n            0, 0\" : \"getA(\" + r[0] + \"),\\n          cEdge ? 0. : getA(\" + r[1] + \"),\\n          rEdge ? 0. : getA(\" + r[2] + \"),\\n          rEdge || cEdge ? 0. : getA(\" + r[3] + \")\";\n        }(t, n);\n        this.userCode = \"\\n        void main() {\\n          \" + r + \" rc = getOutputCoords();\\n\\n          if(\" + o + \") {\\n            setOutput(vec4(0));\\n          } else {\\n            \" + a + \"\\n\\n            setOutput(vec4(\" + i + \"));\\n          }\\n        }\\n      \";\n    }\n};\nvar Ps = function(t, e, n) {\n    this.variableNames = [\n        \"x\"\n    ], this.outputShape = e.map(function(e, n) {\n        return e[0] + t[n] + e[1];\n    });\n    var r = t.length, o = ui(r), a = e.map(function(t) {\n        return t[0];\n    }).join(\",\"), i = e.map(function(e, n) {\n        return e[0] + t[n];\n    }).join(\",\"), s = [\n        \"coords[0]\",\n        \"coords[1]\",\n        \"coords[2]\",\n        \"coords[3]\"\n    ].slice(0, r);\n    this.userCode = 1 !== r ? \"\\n      \" + o + \" start = \" + o + \"(\" + a + \");\\n      \" + o + \" end = \" + o + \"(\" + i + \");\\n\\n      void main() {\\n        \" + o + \" outC = getOutputCoords();\\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\\n          setOutput(float(\" + n + \"));\\n        } else {\\n          \" + o + \" coords = outC - start;\\n          setOutput(getX(\" + s + \"));\\n        }\\n      }\\n    \" : \"\\n        int start = \" + a + \";\\n        int end = \" + i + \";\\n\\n        void main() {\\n          int outC = getOutputCoords();\\n          if (outC < start || outC >= end) {\\n            setOutput(float(\" + n + \"));\\n          } else {\\n            setOutput(getX(outC - start));\\n          }\\n        }\\n      \";\n}, Ls = function(t, e, n) {\n    this.variableNames = [\n        \"x\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.map(function(e, n) {\n        return e[0] + t[n] + e[1];\n    });\n    for(var r = t.length, o = ui(r), a = e.map(function(t) {\n        return t[0];\n    }).join(\",\"), i = e.map(function(e, n) {\n        return e[0] + t[n];\n    }).join(\",\"), s = Xa(\"rc\", r), u = Xa(\"source\", r), c = s[r - 1] + \" < \" + this.outputShape[r - 1], l = 1 === r ? \"source\" : \"vec2(\" + u.slice(-2).join() + \")\", h = [\n        o + \" rc = outputLoc;\",\n        s[r - 1] + \" += 1;\\n       if(\" + c + \") {\\n      \",\n        1 === r ? \"\" : \"}\\n       rc = outputLoc;\\n       \" + s[r - 2] + \" += 1;\\n       if(\" + s[r - 2] + \" < \" + this.outputShape[r - 2] + \") {\",\n        1 === r ? \"\" : \"  \" + s[r - 1] + \" += 1;\\n         if(\" + c + \") {\"\n    ], f = 1 === r ? \"rc < start || rc >= end\" : \"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))\", d = \"\", p = 0, v = 1 === r ? 2 : 4; p < v; p++)d += \"\\n        \" + h[p] + \"\\n        if (\" + f + \") {\\n          result[\" + p + \"] = float(\" + n + \");\\n        } else {\\n          \" + o + \" source = rc - start;\\n          result[\" + p + \"] = getChannel(getX(\" + u.join() + \"), \" + l + \");\\n        }\\n      \";\n    d += 1 === r ? \"} \" : \"}}\", this.userCode = \"\\n      const \" + o + \" start = \" + o + \"(\" + a + \");\\n      const \" + o + \" end = \" + o + \"(\" + i + \");\\n\\n      void main() {\\n        \" + o + \" outputLoc = getOutputCoords();\\n        vec4 result = vec4(0.);\\n        \" + d + \"\\n        setOutput(result);\\n      }\\n    \";\n}, Ws = function(t, e, n, r, o) {\n    if (void 0 === r && (r = !1), void 0 === o && (o = !1), this.variableNames = [\n        \"x\"\n    ], \"avg\" === e && n) throw new Error(\"Cannot compute positions for average pool.\");\n    var a = t.filterWidth, i = t.strideHeight, s = t.strideWidth, u = t.dilationHeight, c = t.dilationWidth, l = t.effectiveFilterHeight, h = t.effectiveFilterWidth, f = t.padInfo.top, d = t.padInfo.left;\n    this.outputShape = t.outShape;\n    var p = \"avg\" === e, v = \"((batch  * \" + t.inHeight + \" + xR) * \" + t.inWidth + \" + xC) * \" + t.inChannels + \" + d\", g = \"(xR * \" + t.inWidth + \" + xC) * \" + t.inChannels + \" + d\", m = \"0.0\";\n    if (p || (m = \"-1.0 / 1e-20\"), n) this.userCode = \"\\n        const ivec2 strides = ivec2(\" + i + \", \" + s + \");\\n        const ivec2 pads = ivec2(\" + f + \", \" + d + \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \" + l + \";\\n              wR += \" + u + \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + h + \";\\n                wC += \" + c + \") {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value >= currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = \" + (r ? o ? v : g : \"wR * \" + h + \" + wC\") + \";\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";\n    else {\n        var y = e + \"(\" + e + \"(\" + e + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\n        \"avg\" === e && (y = \"avgValue / count\");\n        var x = 4 * Math.floor(a / 4), b = a % 4, w = \"\\n      if (\" + p + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = max(values, minMaxValue);\\n      }\\n    \";\n        this.userCode = \"\\n      const ivec2 strides = ivec2(\" + i + \", \" + s + \");\\n      const ivec2 pads = ivec2(\" + f + \", \" + d + \");\\n      const float initializationValue = \" + m + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \" + t.inWidth + \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + m + \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < \" + l + \";\\n            wR += \" + u + \") {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \" + t.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + x + \"; wC += 4) {\\n            int xC = xCCorner + wC * \" + c + \";\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + c + \", d),\\n              getValue(batch, xR, xC + 2 * \" + c + \", d),\\n              getValue(batch, xR, xC + 3 * \" + c + \", d)\\n            );\\n\\n            \" + w + \"\\n          }\\n\\n          int xC = xCCorner + \" + x + \";\\n          if (\" + (1 === b) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + w + \"\\n          } else if (\" + (2 === b) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + c + \", d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + w + \"\\n          } else if (\" + (3 === b) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + c + \", d),\\n              getValue(batch, xR, xC + 2 * \" + c + \", d),\\n              initializationValue\\n            );\\n\\n            \" + w + \"\\n          }\\n        }\\n        setOutput(\" + y + \");\\n      }\\n    \";\n    }\n}, Us = function(t, e, n, r, o) {\n    if (void 0 === r && (r = !1), void 0 === o && (o = !1), this.variableNames = [\n        \"x\"\n    ], \"avg\" === e && n) throw new Error(\"Cannot compute positions for average pool.\");\n    var a = t.filterWidth, i = t.strideDepth, s = t.strideHeight, u = t.strideWidth, c = t.dilationDepth, l = t.dilationHeight, h = t.dilationWidth, f = t.effectiveFilterDepth, d = t.effectiveFilterHeight, p = t.effectiveFilterWidth, v = t.padInfo.front, g = t.padInfo.top, m = t.padInfo.left;\n    this.outputShape = t.outShape;\n    var y = \"avg\" === e, x = \"0.0\";\n    if (y || (x = \"-1.0 / 1e-20\"), n) this.userCode = \"\\n        const ivec3 strides =\\n            ivec3(\" + i + \", \" + s + \", \" + u + \");\\n        const ivec3 pads = ivec3(\" + v + \", \" + g + \", \" + m + \");\\n\\n        void main() {\\n          ivec5 coords = getOutputCoords();\\n          int batch = coords.x;\\n          int ch = coords.u;\\n\\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n          int xDCorner = xCorner.x;\\n          int xRCorner = xCorner.y;\\n          int xCCorner = xCorner.z;\\n\\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n\\n          for (int wD = 0; wD < \" + f + \";\\n              wD += \" + c + \") {\\n            int xD = xDCorner + wD;\\n\\n            if (xD < 0 || xD >= \" + t.inDepth + \") {\\n              continue;\\n            }\\n\\n            for (int wR = 0; wR < \" + d + \";\\n                wR += \" + l + \") {\\n              int xR = xRCorner + wR;\\n\\n              if (xR < 0 || xR >= \" + t.inHeight + \") {\\n                continue;\\n              }\\n\\n              for (int wC = 0; wC < \" + p + \";\\n                  wC += \" + h + \") {\\n                int xC = xCCorner + wC;\\n\\n                if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                  continue;\\n                }\\n\\n                float value = getX(batch, xD, xR, xC, ch);\\n\\n                // If a min / max value has already been found, use it. If not,\\n                // use the current value.\\n                float currMinMaxValue = mix(\\n                    value, minMaxValue, minMaxValueFound);\\n                if (value >= currMinMaxValue) {\\n                  minMaxValue = value;\\n                  minMaxValueFound = 1.0;\\n                  minMaxPosition = \" + (r ? o ? \"(((batch * \" + t.inDepth + \" + xD) * \" + t.inHeight + \" + xR) * \" + t.inWidth + \" + xC) * \" + t.inChannels + \" + ch\" : \"((xD * \" + t.inHeight + \" + xR) * \" + t.inWidth + \" + xC) * \" + t.inChannels + \" + ch\" : \"wD * \" + d + \" * \" + p + \" +\\n                      wR * \" + p + \" + wC\") + \";\\n                }\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";\n    else {\n        var b = e + \"(\" + e + \"(\" + e + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\n        \"avg\" === e && (b = \"avgValue / count\");\n        var w = 4 * Math.floor(a / 4), C = a % 4, E = \"\\n      if (\" + y + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = max(values, minMaxValue);\\n      }\\n    \";\n        this.userCode = \"\\n      const ivec3 strides =\\n        ivec3(\" + i + \", \" + s + \", \" + u + \");\\n      const ivec3 pads = ivec3(\" + v + \", \" + g + \", \" + m + \");\\n      const float initializationValue = \" + x + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\\n        if (xC < 0 || xC >= \" + t.inWidth + \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xD, xR, xC, ch);\\n      }\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xDCorner = xCorner.x;\\n        int xRCorner = xCorner.y;\\n        int xCCorner = xCorner.z;\\n\\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + x + \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wD = 0; wD < \" + f + \";\\n            wD += \" + c + \") {\\n          int xD = xDCorner + wD;\\n\\n          if (xD < 0 || xD >= \" + t.inDepth + \") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \" + d + \";\\n            wR += \" + l + \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + w + \"; wC += 4) {\\n              int xC = xCCorner + wC * \" + h + \";\\n\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + h + \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \" + h + \", ch),\\n                getValue(batch, xD, xR, xC + 3 * \" + h + \", ch)\\n              );\\n\\n              \" + E + \"\\n            }\\n\\n            int xC = xCCorner + \" + w + \";\\n            if (\" + (1 === C) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                initializationValue,\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \" + E + \"\\n            } else if (\" + (2 === C) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + h + \", ch),\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \" + E + \"\\n            } else if (\" + (3 === C) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + h + \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \" + h + \", ch),\\n                initializationValue\\n              );\\n\\n              \" + E + \"\\n            }\\n          }\\n          setOutput(\" + b + \");\\n        }\\n      }\\n    \";\n    }\n}, Vs = function(t, e) {\n    this.variableNames = [\n        \"x\"\n    ];\n    var n = t.windowSize, r = t.batchSize, o = t.inSize, a = Math.ceil(o / n);\n    this.outputShape = [\n        r,\n        a\n    ];\n    var i = \"0.0\", s = \"\";\n    \"prod\" === e ? i = \"1.0\" : \"min\" === e ? (i = \"1.0 / 1e-20\", s = \"min\") : \"max\" === e && (i = \"-1.0 / 1e-20\", s = \"max\");\n    var u = e + \"(\" + e + \"(\" + e + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\n    \"sum\" === e ? u = \"sumValue\" : \"prod\" === e ? u = \"prodValue\" : \"all\" === e ? u = \"allValue\" : \"any\" === e && (u = \"anyValue\");\n    var c = 4 * Math.floor(n / 4), l = n % 4, h = \"\\n      if (\" + (\"sum\" === e) + \") {\\n        sumValue += dot(values, ones);\\n      } else if (\" + (\"prod\" === e) + \") {\\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\\n        prodValue *= tmp[0] * tmp[1];\\n      } else {\\n        minMaxValue = \" + s + \"(values, minMaxValue);\\n      }\\n    \", f = \"vec4\";\n    \"all\" === e ? (i = \"1.0\", h = \"\\n        bool reducedAllValue = all(values);\\n        float floatedReducedAllValue = float(reducedAllValue);\\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\\n      \", f = \"bvec4\") : \"any\" === e && (i = \"0.0\", h = \"\\n        bool reducedAnyValue = any(values);\\n        float floatedReducedAnyValue = float(reducedAnyValue);\\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\\n      \", f = \"bvec4\");\n    var d = \"\";\n    o % n > 0 && (d = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return initializationValue;\\n        }\\n      \"), this.userCode = \"\\n      const float initializationValue = \" + i + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + d + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + n + \";\\n\\n        vec4 minMaxValue = vec4(\" + i + \");\\n        float prodValue = 1.0;\\n        float sumValue = 0.0;\\n        float allValue = 1.0;\\n        float anyValue = 0.0;\\n\\n        for (int i = 0; i < \" + c + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          \" + f + \" values = \" + f + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          \" + h + \"\\n        }\\n\\n        int inIdx = inOffset + \" + c + \";\\n        if (\" + (1 === l) + \") {\\n          \" + f + \" values = \" + f + \"(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + h + \"\\n        } else if (\" + (2 === l) + \") {\\n          \" + f + \" values = \" + f + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + h + \"\\n        } else if (\" + (3 === l) + \") {\\n          \" + f + \" values = \" + f + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          \" + h + \"\\n        }\\n        setOutput(\" + u + \");\\n      }\\n    \";\n}, zs = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;\n    for(var n = \"\", r = 0; r < 4; r++){\n        var o = \"thisRC = rc;\";\n        r % 2 == 1 && (o += \"thisRC.z += 1;\"), r > 1 && (o += \"thisRC.y += 1;\"), n += \"\\n        \" + o + \"\\n        \" + (r > 0 ? \"if(thisRC.y < rows && thisRC.z < cols){\" : \"\") + \"\\n          int flatIndex = getFlatIndex(thisRC);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[\" + r + \"] =\\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\\n        \" + (r > 0 ? \"}\" : \"\") + \"\\n      \";\n    }\n    this.userCode = \"\\n      \\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      \" + $a([\n        \"r\",\n        \"c\",\n        \"d\"\n    ], e) + \"\\n      return ivec3(r, c, d);\\n    }\\n  \\n      \" + Qa(t) + \"\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.);\\n\\n        ivec3 thisRC;\\n        int rows = \" + t[1] + \";\\n        int cols = \" + t[2] + \";\\n\\n        \" + n + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n};\nvar Gs = function(t, e, n) {\n    this.variableNames = [\n        \"dy\"\n    ], this.outputShape = [], this.outputShape = e.shape;\n    var r = e.shape, o = r[1], a = r[2], i = t.shape, s = i[1], u = i[2], c = [\n        n && s > 1 ? o - 1 : o,\n        n && u > 1 ? a - 1 : a\n    ], l = [\n        n && s > 1 ? s - 1 : s,\n        n && u > 1 ? u - 1 : u\n    ], h = c[0] / l[0], f = c[1] / l[1], d = 1 / h, p = 1 / f, v = 2 * Math.ceil(d) + 2, g = 2 * Math.ceil(p) + 2;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + h + \");\\n        const float widthScale = float(\" + f + \");\\n\\n        const float invHeightScale = float(\" + d + \");\\n        const float invWidthScale = float(\" + p + \");\\n\\n        const int winHeight = int(\" + v + \");\\n        const int winWidth = int(\" + g + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(startRLerp - float(winHeight / 2));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(startCLerp - float(winWidth / 2));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + s + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + u + \") {\\n              continue;\\n            }\\n\\n            float dxR = float(dyR) * heightScale;\\n            int topDxRIndex = int(floor(dxR));\\n            int bottomDxRIndex = int(min(ceil(dxR), \" + (o - 1) + \".0));\\n            float dxRLerp = dxR - float(topDxRIndex);\\n            float inverseDxRLerp = 1.0 - dxRLerp;\\n\\n            float dxC = float(dyC) * widthScale;\\n            int leftDxCIndex = int(floor(dxC));\\n            int rightDxCIndex = int(min(ceil(dxC), \" + (a - 1) + \".0));\\n            float dxCLerp = dxC - float(leftDxCIndex);\\n            float inverseDxCLerp = 1.0 - dxCLerp;\\n\\n            if (r == topDxRIndex && c == leftDxCIndex) {\\n              // topLeft\\n              accumulator +=\\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == topDxRIndex && c == rightDxCIndex) {\\n              // topRight\\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\\n              // bottomLeft\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\\n              // bottomRight\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n}, Hs = function(t, e, n, r) {\n    this.variableNames = [\n        \"A\"\n    ], this.outputShape = [];\n    var o = t[0], a = t[1], i = t[2], s = t[3];\n    this.outputShape = [\n        o,\n        e,\n        n,\n        s\n    ];\n    var u = [\n        r && e > 1 ? a - 1 : a,\n        r && n > 1 ? i - 1 : i\n    ], c = [\n        r && e > 1 ? e - 1 : e,\n        r && n > 1 ? n - 1 : n\n    ];\n    this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + u[0] / c[0] + \",\\n          \" + u[1] / c[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + a + \".0, \" + i + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the four integer indices.\\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n        ivec2 sourceCeilRC = ivec2(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n        float newValue = top + (bottom - top) * fracRC.x;\\n\\n        setOutput(newValue);\\n      }\\n    \";\n}, qs = function(t, e, n, r) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];\n    var o = t[0], a = t[1], i = t[2], s = t[3];\n    this.outputShape = [\n        o,\n        e,\n        n,\n        s\n    ];\n    var u = [\n        r && e > 1 ? a - 1 : a,\n        r && n > 1 ? i - 1 : i\n    ], c = [\n        r && e > 1 ? e - 1 : e,\n        r && n > 1 ? n - 1 : n\n    ];\n    this.userCode = \"\\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\\n          \" + u[0] / c[0] + \",\\n          \" + u[1] / c[1] + \",\\n          \" + u[1] / c[1] + \");\\n      const vec3 inputShapeRC = vec3(\" + a + \".0, \" + i + \".0,\\n                                     \" + i + \".0);\\n\\n      float getAValue(int b, int r, int c, int d) {\\n        return getChannel(getA(b, r, c, d), vec2(c, d));\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        // Calculate values for next column in yRC.z.\\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\\n\\n        // Fractional source index.\\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the four integer indices.\\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\\n        ivec3 sourceCeilRC = ivec3(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        // Should we calculate next column and row elements in 2x2 packed cell.\\n        bool hasNextCol = d < \" + (s - 1) + \";\\n        bool hasNextRow = coords.z < \" + (n - 1) + \";\\n\\n        // In parallel, construct four corners for all four components in\\n        // packed 2x2 cell.\\n        vec4 topLeft = vec4(\\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\\n\\n        vec4 bottomLeft = vec4(\\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\\n\\n        vec4 topRight = vec4(\\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\\n\\n        vec4 bottomRight = vec4(\\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\\n\\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\\n\\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\\n        vec4 newValue = mix(top, bottom, fracRC.x);\\n\\n        setOutput(newValue);\\n      }\\n    \";\n}, Ks = function(t, e, n) {\n    this.variableNames = [\n        \"dy\"\n    ], this.outputShape = [], this.outputShape = e.shape;\n    var r = e.shape, o = r[1], a = r[2], i = t.shape, s = i[1], u = i[2], c = [\n        n && s > 1 ? o - 1 : o,\n        n && u > 1 ? a - 1 : a\n    ], l = [\n        n && s > 1 ? s - 1 : s,\n        n && u > 1 ? u - 1 : u\n    ], h = c[0] / l[0], f = c[1] / l[1], d = 1 / h, p = 1 / f, v = 2 * Math.ceil(d) + 2, g = 2 * Math.ceil(p) + 2;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + h + \");\\n        const float widthScale = float(\" + f + \");\\n\\n        const float invHeightScale = float(\" + d + \");\\n        const float invWidthScale = float(\" + p + \");\\n\\n        const int winHeight = int(\" + v + \");\\n        const int winWidth = int(\" + g + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + s + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + u + \") {\\n              continue;\\n            }\\n\\n            float sourceFracRow =\\n              float(\" + c[0] + \") *\\n                (float(dyR) / float(\" + l[0] + \"));\\n\\n            float sourceFracCol =\\n                float(\" + c[1] + \") *\\n                  (float(dyC) / float(\" + l[1] + \"));\\n\\n            int sourceNearestRow = int(min(\\n                float(int(\" + o + \") - 1),\\n                \" + n + \" ? float(round(sourceFracRow)) :\\n                                  float(floor(sourceFracRow))));\\n\\n            int sourceNearestCol = int(min(\\n                float(int(\" + a + \") - 1),\\n                \" + n + \" ? float(round(sourceFracCol)) :\\n                                  float(floor(sourceFracCol))));\\n\\n            if (r == sourceNearestRow && c == sourceNearestCol) {\\n              accumulator += getDy(b, dyR, dyC, d);\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n}, js = function(t, e, n, r) {\n    this.variableNames = [\n        \"A\"\n    ], this.outputShape = [];\n    var o = t[0], a = t[1], i = t[2], s = t[3];\n    this.outputShape = [\n        o,\n        e,\n        n,\n        s\n    ];\n    var u = [\n        r && e > 1 ? a - 1 : a,\n        r && n > 1 ? i - 1 : i\n    ], c = [\n        r && e > 1 ? e - 1 : e,\n        r && n > 1 ? n - 1 : n\n    ], l = r ? \"0.5\" : \"0.0\";\n    this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + u[0] / c[0] + \",\\n          \" + u[1] / c[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + a + \".0, \" + i + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the coordinators of nearest neighbor point.\\n        ivec2 sourceNearestRC = ivec2(\\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + \" + l + \")));\\n\\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\\n\\n        setOutput(newValue);\\n      }\\n    \";\n}, Xs = function(t, e) {\n    this.variableNames = [\n        \"x\"\n    ];\n    var n = t.length;\n    if (n > 4) throw new Error(\"WebGL backend: Reverse of rank-\" + n + \" tensor is not yet supported\");\n    if (this.outputShape = t, 1 !== n) {\n        var r = t.map(function(n, r) {\n            return function(n) {\n                return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + \" - coords[\" + n + \"] - 1\" : \"coords[\" + n + \"]\";\n            }(r);\n        }).join(\",\"), o = ui(n);\n        this.userCode = \"\\n      void main() {\\n        \" + o + \" coords = getOutputCoords();\\n        setOutput(getX(\" + r + \"));\\n      }\\n    \";\n    } else this.userCode = \"\\n        void main() {\\n          int coord = getOutputCoords();\\n          setOutput(getX(\" + t[0] + \" - coord - 1));\\n        }\\n      \";\n}, Ys = function(t, e) {\n    this.variableNames = [\n        \"x\"\n    ], this.packedInputs = !0, this.packedOutput = !0;\n    var n = t.length;\n    if (n > 4) throw new Error(\"WebGL backend: Reverse of rank-\" + n + \" tensor is not yet supported\");\n    this.outputShape = t;\n    var r = Xa(\"rc\", n), o = r[n - 1] + \" + 1 < \" + this.outputShape[n - 1], a = r[n - 2] + \" + 1 < \" + this.outputShape[n - 2], i = ui(n);\n    function s(n) {\n        var r = t.map(function(r, o) {\n            return function(n, r) {\n                return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + \" - \" + r[n] + \" - 1\" : \"\" + r[n];\n            }(o, n);\n        });\n        return \"getChannel(getX(\" + r.join(\",\") + \"), vec2(\" + r.slice(-2).join(\",\") + \"))\";\n    }\n    this.userCode = 1 === n ? \"\\n        void main(){\\n          int rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = getChannel(getX(\" + t[0] + \" - rc - 1),\\n            \" + t[0] + \" - rc - 1);\\n          if(\" + o + \"){\\n              result.g = getChannel(getX(\" + t[0] + \" - (rc  + 1) - 1),\\n                \" + t[0] + \" - (rc  + 1) - 1);\\n          }\\n          setOutput(result);\\n        }\\n      \" : \"\\n        void main() {\\n          \" + i + \" rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = \" + function(t) {\n        return s(t);\n    }(r.slice()) + \";\\n          if(\" + o + \"){\\n            result.g = \" + function(t) {\n        return t[n - 1] = \"(\" + t[n - 1] + \" + 1)\", s(t);\n    }(r.slice()) + \";\\n          }\\n          if(\" + a + \") {\\n            result.b = \" + function(t) {\n        return t[n - 2] = \"(\" + t[n - 2] + \" + 1)\", s(t);\n    }(r.slice()) + \";\\n            if(\" + o + \") {\\n              result.a = \" + function(t) {\n        return t[n - 1] = \"(\" + t[n - 1] + \" + 1)\", t[n - 2] = \"(\" + t[n - 2] + \" + 1)\", s(t);\n    }(r.slice()) + \";\\n            }\\n          }\\n          setOutput(result);\\n        }\\n    \";\n}, $s = function(t, e, n, r, o, a, i) {\n    void 0 === i && (i = !0), this.variableNames = [\n        \"updates\",\n        \"indices\",\n        \"defaultValue\"\n    ], this.outputShape = a;\n    var s = ui(o.length), u = ui(a.length), c = \"\";\n    1 === n ? c = \"i\" : 2 === n && (c = \"i, j\");\n    var l = \"getIndices(\" + c + \")\", h = \"\";\n    1 === r ? h = \"i\" : 2 === r && (h = \"i, coords[1]\");\n    var f = \"getUpdates(\" + h + \")\", d = e > 1 ? \"strides[j]\" : \"strides\";\n    this.userCode = \"\\n        \" + s + \" strides = \" + s + \"(\" + o + \");\\n\\n        void main() {\\n          \" + u + \" coords = getOutputCoords();\\n          float sum = 0.0;\\n          bool found = false;\\n          for (int i = 0; i < \" + t + \"; i++) {\\n            int flattenedIndex = 0;\\n            for (int j = 0; j < \" + e + \"; j++) {\\n              int index = round(\" + l + \");\\n              flattenedIndex += index * \" + d + \";\\n            }\\n            if (flattenedIndex == coords[0]) {\\n              sum += \" + f + \";\\n              found = true;\\n            }\\n          }\\n          setOutput(mix(getDefaultValue(), sum, float(found)));\\n        }\\n      \";\n}, Qs = function(t, e) {\n    this.variableNames = [\n        \"x\",\n        \"segmentIds\"\n    ];\n    var n = t.windowSize, r = t.batchSize, o = t.inSize, a = t.numSegments, i = a * Math.ceil(o / n);\n    this.outputShape = [\n        r,\n        i\n    ];\n    var s = 4 * Math.floor(n / 4), u = n % 4, c = \"\\n        sumValue += dot(values, segFilter);\\n    \", l = \"\";\n    o % n > 0 && (l = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return initializationValue;\\n        }\\n      \");\n    var h = \"\";\n    o % n > 0 && (h = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return -1.0;\\n        }\\n      \"), this.userCode = \"\\n      const float initializationValue = 0.0;\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + l + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      float getSegmentIdAtIndex(int inIdx) {\\n        \" + h + \"\\n        return getSegmentIds(inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = int(floor(float(outIdx) / float(\\n          \" + a + \")) * float(\" + n + \"));\\n        int currentSeg = int(mod(float(outIdx), float(\" + a + \")));\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \" + s + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\\n          );\\n\\n          \" + c + \"\\n        }\\n\\n        int inIdx = inOffset + \" + s + \";\\n        if (\" + (1 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            0,\\n            0,\\n            0\\n          );\\n\\n          \" + c + \"\\n        } else if (\" + (2 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n              0,\\n              0\\n          );\\n\\n          \" + c + \"\\n        } else if (\" + (3 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            0\\n          );\\n\\n          \" + c + \"\\n        }\\n        setOutput(sumValue);\\n      }\\n    \";\n}, Js = function(t, e, n) {\n    var r, o;\n    if (this.variableNames = [\n        \"c\",\n        \"a\",\n        \"b\"\n    ], this.outputShape = e, n > 4) throw Error(\"Where for rank \" + n + \" is not yet supported\");\n    if (1 === n) o = \"resRC\", r = \"resRC\";\n    else {\n        for(var a = [\n            \"resRC.x\",\n            \"resRC.y\",\n            \"resRC.z\",\n            \"resRC.w\"\n        ], i = [], s = [], u = 0; u < e.length; u++)s.push(\"\" + a[u]), u < t && i.push(\"\" + a[u]);\n        r = i.join(), o = s.join();\n    }\n    var c = ui(n);\n    this.userCode = \"\\n      void main() {\\n        \" + c + \" resRC = getOutputCoords();\\n        float cVal = getC(\" + r + \");\\n        if (cVal >= 1.0) {\\n          setOutput(getA(\" + o + \"));\\n        } else {\\n          setOutput(getB(\" + o + \"));\\n        }\\n      }\\n    \";\n}, Zs = function() {\n    function t(t) {\n        this.variableNames = [\n            \"source\"\n        ], this.outputShape = t, this.rank = t.length;\n        var e, n = ui(this.rank), r = \"uniform int start[\" + this.rank + \"];\", o = function(t) {\n            if (1 === t) return \"sourceLoc\";\n            if (t <= 6) return tu.slice(0, t).map(function(t) {\n                return \"sourceLoc.\" + t;\n            }).join(\",\");\n            throw Error(\"Slicing for rank \" + t + \" is not yet supported\");\n        }(this.rank);\n        e = \"\\n        \" + n + \" sourceLoc;\\n        \" + n + \" coords = getOutputCoords();\\n        \" + t.map(function(t, e) {\n            return \"sourceLoc.\" + tu[e] + \" = start[\" + e + \"] + coords.\" + tu[e] + \";\";\n        }).join(\"\\n\") + \"\\n      \", this.userCode = \"\\n      \" + r + \"\\n      void main() {\\n        \" + e + \"\\n        setOutput(getSource(\" + o + \"));\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t) {\n        var e = this;\n        if (t.length !== this.rank) throw Error(\"The rank (\" + this.rank + \") of the program must match the length of start (\" + t.length + \")\");\n        return function(n, r) {\n            null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, \"start\"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);\n        };\n    }, t;\n}(), tu = [\n    \"x\",\n    \"y\",\n    \"z\",\n    \"w\",\n    \"u\",\n    \"v\"\n];\nvar eu = function() {\n    function t(t) {\n        this.variableNames = [\n            \"source\"\n        ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.rank = t.length;\n        var e = ui(this.rank), n = Xa(\"coords\", this.rank), r = Xa(\"sourceLoc\", this.rank), o = 1 === this.rank ? \"sourceLoc\" : \"vec2(\" + r.slice(-2).join() + \")\", a = \"getChannel(getSource(\" + r.join() + \"), \" + o + \")\", i = \"\\n      result.x = \" + a + \";\\n      if (++\" + n[this.rank - 1] + \" < \" + t[this.rank - 1] + \") {\\n        ++\" + r[this.rank - 1] + \";\\n        result.y = \" + a + \";\\n        --\" + r[this.rank - 1] + \";\\n      }\\n    \", s = 1 === this.rank ? \"\" : \"\\n      --\" + n[this.rank - 1] + \";\\n      if (++\" + n[this.rank - 2] + \" < \" + t[this.rank - 2] + \") {\\n        ++\" + r[this.rank - 2] + \";\\n        result.z = \" + a + \";\\n        if (++\" + n[this.rank - 1] + \" < \" + t[this.rank - 1] + \") {\\n          ++\" + r[this.rank - 1] + \";\\n          result.w = \" + a + \";\\n        }\\n      }\\n    \", u = this.rank <= 4 ? \"sourceLoc = coords +\\n            \" + e + \"(\" + t.map(function(t, e) {\n            return \"start[\" + e + \"]\";\n        }).join() + \");\" : t.map(function(t, e) {\n            return r[e] + \" = \" + n[e] + \" + start[\" + e + \"];\";\n        }).join(\"\\n\");\n        this.userCode = \"\\n      uniform int start[\" + this.rank + \"];\\n      void main() {\\n        \" + e + \" coords = getOutputCoords();\\n        \" + e + \" sourceLoc;\\n        \" + u + \"\\n        vec4 result = vec4(0.);\\n        \" + i + \"\\n        \" + s + \"\\n        setOutput(result);\\n      }\\n    \";\n    }\n    return t.prototype.getCustomSetupFunc = function(t) {\n        var e = this;\n        if (t.length !== this.rank) throw Error(\"The rank (\" + this.rank + \") of the program must match the length of start (\" + t.length + \")\");\n        return function(n, r) {\n            null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, \"start\"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);\n        };\n    }, t;\n}(), nu = function(t, e, n) {\n    this.variableNames = [\n        \"x\"\n    ], this.outputShape = n;\n    var r = n.length, o = ui(n.length), a = ui(n.length), i = \"\";\n    if (1 === r) i = \"coords * strides + begin\";\n    else {\n        var s = 0;\n        i = n.map(function(t, e) {\n            return s++, 1 === n.length ? \"coords * strides[\" + e + \"] + begin[\" + e + \"]\" : \"coords[\" + (s - 1) + \"] * strides[\" + e + \"] + begin[\" + e + \"]\";\n        }).join(\",\");\n    }\n    this.userCode = \"\\n      \" + o + \" begin = \" + o + \"(\" + t + \");\\n      \" + o + \" strides = \" + o + \"(\" + e + \");\\n\\n      void main() {\\n        \" + a + \" coords = getOutputCoords();\\n        setOutput(getX(\" + i + \"));\\n      }\\n    \";\n}, ru = function() {\n    function t(t) {\n        this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};\n    }\n    return t.prototype.acquireTexture = function(t, e, n) {\n        var r, o = ou(e, n), a = au(t, o, n);\n        if (a in this.freeTextures || (this.freeTextures[a] = []), a in this.usedTextures || (this.usedTextures[a] = []), this.freeTextures[a].length > 0) {\n            this.numFreeTextures--, this.numUsedTextures++, this.log();\n            var i = this.freeTextures[a].shift();\n            return this.usedTextures[a].push(i), i;\n        }\n        return this.numUsedTextures++, this.log(), o === Gt.PACKED_2X2_FLOAT32 ? r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : o === Gt.PACKED_2X2_FLOAT16 ? r = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : o === Gt.UNPACKED_FLOAT32 ? r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : o === Gt.UNPACKED_FLOAT16 ? r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : o === Gt.PACKED_4X1_UNSIGNED_BYTE && (r = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[a].push(r), r;\n    }, t.prototype.releaseTexture = function(t, e, n, r) {\n        if (null != this.freeTextures) {\n            var o = au(e, ou(n, r), r);\n            o in this.freeTextures || (this.freeTextures[o] = []), this.freeTextures[o].push(t), this.numFreeTextures++, this.numUsedTextures--;\n            var a = this.usedTextures[o], i = a.indexOf(t);\n            if (i < 0) throw new Error(\"Cannot release a texture that was never provided by this texture manager\");\n            a.splice(i, 1), this.log();\n        }\n    }, t.prototype.log = function() {\n        if (this.logEnabled) {\n            var t = this.numFreeTextures + this.numUsedTextures;\n            console.log(\"Free/Used\", this.numFreeTextures + \" / \" + this.numUsedTextures, \"(\" + t + \")\");\n        }\n    }, t.prototype.getNumUsedTextures = function() {\n        return this.numUsedTextures;\n    }, t.prototype.getNumFreeTextures = function() {\n        return this.numFreeTextures;\n    }, t.prototype.dispose = function() {\n        var t = this;\n        if (null != this.freeTextures) {\n            for(var e in this.freeTextures)this.freeTextures[e].forEach(function(e) {\n                t.gpgpu.deleteMatrixTexture(e);\n            });\n            for(var e in this.usedTextures)this.usedTextures[e].forEach(function(e) {\n                t.gpgpu.deleteMatrixTexture(e);\n            });\n            this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;\n        }\n    }, t;\n}();\nfunction ou(t, e) {\n    if (t === zt.UPLOAD) return Gt.PACKED_2X2_FLOAT32;\n    if (t === zt.RENDER || null == t) return function(t) {\n        return i().getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\") ? t ? Gt.PACKED_2X2_FLOAT32 : Gt.UNPACKED_FLOAT32 : t ? Gt.PACKED_2X2_FLOAT16 : Gt.UNPACKED_FLOAT16;\n    }(e);\n    if (t === zt.DOWNLOAD || t === zt.PIXELS) return Gt.PACKED_4X1_UNSIGNED_BYTE;\n    throw new Error(\"Unknown logical texture type \" + t);\n}\nfunction au(t, e, n) {\n    return t[0] + \"_\" + t[1] + \"_\" + e + \"_\" + n;\n}\nvar iu = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ];\n    for(var n = new Array(t.length), r = 0; r < n.length; r++)n[r] = t[r] * e[r];\n    this.outputShape = n, this.rank = n.length;\n    var o = ui(this.rank), a = function(t) {\n        var e = t.length;\n        if (e > 5) throw Error(\"Tile for rank \" + e + \" is not yet supported\");\n        if (1 === e) return \"imod(resRC, \" + t[0] + \")\";\n        for(var n = [\n            \"resRC.x\",\n            \"resRC.y\",\n            \"resRC.z\",\n            \"resRC.w\",\n            \"resRC.u\"\n        ], r = [], o = 0; o < t.length; o++)r.push(\"imod(\" + n[o] + \", \" + t[o] + \")\");\n        return r.join();\n    }(t);\n    this.userCode = \"\\n      void main() {\\n        \" + o + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + a + \"));\\n      }\\n    \";\n};\nvar su = 1.7580993408473768, uu = 1.0507009873554805, cu = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ], this.outputShape = t, this.userCode = \"\\n      float unaryOperation(float x) {\\n        \" + e + \"\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        float y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n}, lu = \"if (isnan(x)) return x;\", hu = \"return x;\", fu = \"return abs(x);\", du = lu + \"\\n  return (x < 0.0) ? 0.0 : x;\\n\", pu = lu + \"\\n  return (x < 0.0) ? 0.0 : min(6.0, x);\\n\", vu = \"return (x >= 0.0) ? x : (exp(x) - 1.0);\", gu = \"\\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\\n  // see: https://arxiv.org/abs/1706.02515\\n  float scaleAlpha = \" + su + \";\\n  float scale = \" + uu + \";\\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\\n\";\nvar mu = \"return -x;\", yu = \"return ceil(x);\", xu = \"return floor(x);\", bu = \"return exp(x);\", wu = \"return exp(x) - 1.0;\", Cu = lu + \"\\n  return sin(x);\\n\", Eu = lu + \"\\n  return cos(x);\\n\", Ru = lu + \"\\n  if (abs(x) > 1.) {\\n    return NAN;\\n  }\\n  return asin(x);\\n\", Iu = lu + \"\\n  if (abs(x) > 1.) {\\n    return NAN;\\n  }\\n  return acos(x);\\n\", ku = lu + \"\\n  return atan(x);\\n\", Su = lu + \"return log(x + sqrt(x * x + 1.0));\", Au = lu + \"\\n  if (x < 1.0) return NAN;\\n  return log(x + sqrt(x * x - 1.0));\", Tu = lu + \"\\n  if ((x < -1.0) || (x > 1.0)) return NAN;\\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;\", Du = \"return x;\", Nu = \"return x;\", Fu = \"\\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\\n  bvec4 isNaN = isnan(x);\\n\\n  result.r = isNaN.r ? x.r : result.r;\\n  result.g = isNaN.g ? x.g : result.g;\\n  result.b = isNaN.b ? x.b : result.b;\\n  result.a = isNaN.a ? x.a : result.a;\\n\\n  return result;\\n\", _u = \"\\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\\n  bvec4 isNaN = isnan(x);\\n\\n  result.r = isNaN.r ? x.r : result.r;\\n  result.g = isNaN.g ? x.g : result.g;\\n  result.b = isNaN.b ? x.b : result.b;\\n  result.a = isNaN.a ? x.a : result.a;\\n\\n  return result;\\n\", Ou = \"\\n  vec4 result;\\n\\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\\n\\n  return result;\\n\", Mu = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = \"\\n      vec4 unaryOperation(vec4 x) {\\n        \" + e + \"\\n      }\\n\\n      void main() {\\n        vec4 x = getAAtOutCoords();\\n        vec4 y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n}, Bu = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t;\n    var e = t.length, n = Xa(\"rc\", e), r = ui(e), o = function(t, e) {\n        if (1 === t) return \"rc\";\n        for(var n = \"\", r = 0; r < t; r++)n += e[r], r < t - 1 && (n += \",\");\n        return n;\n    }(e, n), a = n.slice(-2), i = e <= 1 ? \"rc\" : \"vec2(\" + a.join(\",\") + \")\";\n    this.userCode = \"\\n      void main() {\\n        \" + r + \" rc = getOutputCoords();\\n        vec4 packedInput = getA(\" + o + \");\\n\\n        setOutput(getChannel(packedInput, \" + i + \"));\\n      }\\n    \";\n}, Pu = {};\nfunction Lu(t, e) {\n    if (void 0 === e && (e = !1), \"linear\" === t) return e ? Nu : hu;\n    if (\"relu\" === t) return e ? Fu : du;\n    if (\"elu\" === t) return e ? Ou : vu;\n    if (\"relu6\" === t) return e ? _u : pu;\n    if (\"prelu\" === t) return e ? ki : Ei;\n    throw new Error(\"Activation \" + t + \" has not been implemented for the WebGL backend.\");\n}\nvar Wu = 600;\nvar Uu = function(t) {\n    function o(e) {\n        var n, r = t.call(this) || this;\n        if (r.pendingRead = new WeakMap, r.pendingDisposal = new WeakSet, r.dataRefCount = new WeakMap, r.numBytesInGPU = 0, r.uploadWaitMs = 0, r.downloadWaitMs = 0, r.warnedAboutMemory = !1, r.pendingDeletes = 0, r.disposed = !1, !i().getBool(\"HAS_WEBGL\")) throw new Error(\"WebGL is not supported on this device\");\n        if (null == e) {\n            var o = jt(i().getNumber(\"WEBGL_VERSION\"));\n            r.binaryCache = (n = i().getNumber(\"WEBGL_VERSION\")) in Pu ? Pu[n] : (Pu[n] = {}, Pu[n]), r.gpgpu = new Is(o), r.canvas = o.canvas, r.gpgpuCreatedLocally = !0;\n        } else r.gpgpu = e, r.binaryCache = {}, r.gpgpuCreatedLocally = !1, r.canvas = e.gl.canvas;\n        return r.textureManager = new ru(r.gpgpu), r.numMBBeforeWarning = null == i().global.screen ? 1024 : i().global.screen.height * i().global.screen.width * window.devicePixelRatio * Wu / 1024 / 1024, r.texData = new ca(r, Lt), r;\n    }\n    return e(o, t), o.prototype.numDataIds = function() {\n        return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;\n    }, o.prototype.write = function(t, e, n) {\n        if (i().getBool(\"DEBUG\") && this.checkNumericalProblems(t), \"complex64\" === n && null != t) throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");\n        var r = {};\n        return this.texData.set(r, {\n            shape: e,\n            dtype: n,\n            values: t,\n            usage: zt.UPLOAD\n        }), r;\n    }, o.prototype.move = function(t, e, n, r) {\n        if (i().getBool(\"DEBUG\") && this.checkNumericalProblems(e), \"complex64\" === r) throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");\n        this.texData.set(t, {\n            shape: n,\n            dtype: r,\n            values: e,\n            usage: zt.UPLOAD\n        });\n    }, o.prototype.readSync = function(t) {\n        var e = this.texData.get(t), n = e.values, r = e.dtype, o = e.complexTensors, a = e.slice, i = e.shape, s = e.isPacked;\n        if (null != a) {\n            var u = void 0;\n            u = s ? new Mu(i, Du) : new cu(i, Du);\n            var c = this.runWebGLProgram(u, [\n                {\n                    dataId: t,\n                    shape: i,\n                    dtype: r\n                }\n            ], r), l = this.readSync(c.dataId);\n            return this.disposeData(c.dataId), l;\n        }\n        if (null != n) return this.convertAndCacheOnCPU(t);\n        if (\"string\" === r) return n;\n        var h, f, d = null != this.activeTimers;\n        (d && (h = et()), \"complex64\" === r) ? f = Aa(o.real.dataSync(), o.imag.dataSync()) : f = this.getValuesFromTexture(t);\n        return d && (this.downloadWaitMs += et() - h), this.convertAndCacheOnCPU(t, f);\n    }, o.prototype.read = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o, a, s, u, c, l, h, f, d, p, v, g, m, y, x, b, w, C, E, R;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (this.pendingRead.has(t)) return e = this.pendingRead.get(t), [\n                            2,\n                            new Promise(function(t) {\n                                return e.push(t);\n                            })\n                        ];\n                        if (n = this.texData.get(t), o = n.values, a = n.shape, s = n.slice, u = n.dtype, c = n.complexTensors, l = n.isPacked, null != s) return h = void 0, h = l ? new Mu(a, Du) : new cu(a, Du), f = this.runWebGLProgram(h, [\n                            {\n                                dataId: t,\n                                shape: a,\n                                dtype: u\n                            }\n                        ], u), d = this.read(f.dataId), this.disposeData(f.dataId), [\n                            2,\n                            d\n                        ];\n                        if (null != o) return [\n                            2,\n                            this.convertAndCacheOnCPU(t)\n                        ];\n                        if (!i().getBool(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\") && 2 === i().getNumber(\"WEBGL_VERSION\")) throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.\");\n                        return p = null, \"complex64\" !== u && i().get(\"WEBGL_BUFFER_SUPPORTED\") && (v = this.decode(t), g = this.texData.get(v.dataId), p = (R = this.gpgpu).createBufferFromTexture.apply(R, [\n                            g.texture\n                        ].concat(Yt(a)))), this.pendingRead.set(t, []), \"complex64\" === u ? [\n                            3,\n                            2\n                        ] : [\n                            4,\n                            this.gpgpu.createAndWaitForFence()\n                        ];\n                    case 1:\n                        r.sent(), r.label = 2;\n                    case 2:\n                        return \"complex64\" !== u ? [\n                            3,\n                            4\n                        ] : [\n                            4,\n                            Promise.all([\n                                c.real.data(),\n                                c.imag.data()\n                            ])\n                        ];\n                    case 3:\n                        return y = r.sent(), x = y[0], b = y[1], m = Aa(x, b), [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        null == p ? m = this.getValuesFromTexture(t) : (w = k(a), m = this.gpgpu.downloadFloat32MatrixFromBuffer(p, w)), r.label = 5;\n                    case 5:\n                        return null != v && this.disposeData(v.dataId), C = this.convertAndCacheOnCPU(t, m), E = this.pendingRead.get(t), this.pendingRead.delete(t), E.forEach(function(t) {\n                            return t(C);\n                        }), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), [\n                            2,\n                            C\n                        ];\n                }\n            });\n        });\n    }, o.prototype.checkNumericalProblems = function(t) {\n        if (null != t) for(var e = 0; e < t.length; e++){\n            var n = t[e];\n            if (!ee(n)) {\n                if (i().getBool(\"WEBGL_RENDER_FLOAT32_CAPABLE\")) throw Error(\"The value \" + n + \" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'\");\n                throw Error(\"The value \" + n + \" cannot be represented on this device.\");\n            }\n        }\n    }, o.prototype.getValuesFromTexture = function(t) {\n        var e, n = this.texData.get(t), r = n.shape, o = n.dtype, a = n.isPacked, s = k(r);\n        if (i().getBool(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\")) {\n            var u = this.decode(t), c = this.texData.get(u.dataId), l = (e = this.gpgpu).downloadMatrixFromPackedTexture.apply(e, [\n                c.texture\n            ].concat(Yt(r))).subarray(0, s);\n            return this.disposeData(u.dataId), l;\n        }\n        var h = i().getBool(\"WEBGL_PACK\") && !0 === a, f = h ? De(r) : r, d = h ? new Ji(f) : new Qi(f), p = this.runWebGLProgram(d, [\n            {\n                shape: f,\n                dtype: o,\n                dataId: t\n            }\n        ], \"float32\"), v = this.texData.get(p.dataId), g = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(v.texture, v.texShape[0], v.texShape[1]).subarray(0, s);\n        return this.disposeData(p.dataId), g;\n    }, o.prototype.time = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o, a, s, u, c;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        return e = this.activeTimers, n = [], o = !1, null == this.programTimersStack ? (this.programTimersStack = n, o = !0) : this.activeTimers.push(n), this.activeTimers = n, t(), a = I(this.activeTimers.map(function(t) {\n                            return t.query;\n                        })).filter(function(t) {\n                            return null != t;\n                        }), s = I(this.activeTimers.map(function(t) {\n                            return t.name;\n                        })).filter(function(t) {\n                            return null != t;\n                        }), this.activeTimers = e, o && (this.programTimersStack = null), u = {\n                            uploadWaitMs: this.uploadWaitMs,\n                            downloadWaitMs: this.downloadWaitMs,\n                            kernelMs: null,\n                            wallMs: null\n                        }, i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\") > 0 ? [\n                            4,\n                            Promise.all(a)\n                        ] : [\n                            3,\n                            2\n                        ];\n                    case 1:\n                        return c = r.sent(), u.kernelMs = w(c), u.getExtraProfileInfo = function() {\n                            return c.map(function(t, e) {\n                                return {\n                                    name: s[e],\n                                    ms: t\n                                };\n                            }).map(function(t) {\n                                return t.name + \": \" + t.ms;\n                            }).join(\", \");\n                        }, [\n                            3,\n                            3\n                        ];\n                    case 2:\n                        u.kernelMs = {\n                            error: \"WebGL query timers are not supported in this environment.\"\n                        }, r.label = 3;\n                    case 3:\n                        return this.uploadWaitMs = 0, this.downloadWaitMs = 0, [\n                            2,\n                            u\n                        ];\n                }\n            });\n        });\n    }, o.prototype.memory = function() {\n        return {\n            unreliable: !1,\n            numBytesInGPU: this.numBytesInGPU\n        };\n    }, o.prototype.startTimer = function() {\n        return i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\") > 0 ? this.gpgpu.beginQuery() : {\n            startMs: et(),\n            endMs: null\n        };\n    }, o.prototype.endTimer = function(t) {\n        return i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = et(), t);\n    }, o.prototype.getQueryTime = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                return i().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\") > 0 ? [\n                    2,\n                    this.gpgpu.waitForQueryAndGetTime(t)\n                ] : [\n                    2,\n                    (e = t).endMs - e.startMs\n                ];\n            });\n        });\n    }, o.prototype.disposeData = function(t) {\n        if (!this.pendingDisposal.has(t)) {\n            if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++;\n            if (this.texData.has(t)) {\n                this.releaseGPUData(t);\n                var e = this.texData.get(t).complexTensors;\n                null != e && (e.real.dispose(), e.imag.dispose()), this.texData.delete(t);\n            }\n        }\n    }, o.prototype.releaseGPUData = function(t) {\n        var e = this.texData.get(t), n = e.texture, r = e.dtype, o = e.texShape, a = e.usage, i = e.isPacked, s = e.slice, u = s && s.origDataId || t, c = this.dataRefCount.get(u);\n        c > 1 ? this.dataRefCount.set(u, c - 1) : (this.dataRefCount.delete(u), null != n && (this.numBytesInGPU -= this.computeBytes(o, r), this.textureManager.releaseTexture(n, o, a, i)));\n        var l = this.texData.get(t);\n        l.texture = null, l.texShape = null, l.isPacked = !1, l.slice = null;\n    }, o.prototype.getTexture = function(t) {\n        return this.uploadToGPU(t), this.texData.get(t).texture;\n    }, o.prototype.getDataInfo = function(t) {\n        return this.texData.get(t);\n    }, o.prototype.getCPUBackend = function() {\n        return i().getBool(\"WEBGL_CPU_FORWARD\") ? (null == this.cpuBackend && (this.cpuBackend = Lt.findBackend(\"cpu\")), this.cpuBackend) : null;\n    }, o.prototype.shouldExecuteOnCPU = function(t, e) {\n        var n = this;\n        return void 0 === e && (e = 128), null != this.getCPUBackend() && t.every(function(t) {\n            return null == n.texData.get(t.dataId).texture && k(t.shape) < e;\n        });\n    }, o.prototype.getGPGPUContext = function() {\n        return this.gpgpu;\n    }, o.prototype.complex = function(t, e) {\n        var n = this.makeOutput(t.shape, \"complex64\");\n        return this.texData.get(n.dataId).complexTensors = {\n            real: Lt.keep(t.clone()),\n            imag: Lt.keep(e.clone())\n        }, n;\n    }, o.prototype.real = function(t) {\n        return this.texData.get(t.dataId).complexTensors.real.clone();\n    }, o.prototype.imag = function(t) {\n        return this.texData.get(t.dataId).complexTensors.imag.clone();\n    }, o.prototype.slice = function(t, e, n) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.slice(t, e, n);\n        if (0 === k(n)) return Fn([], n, t.dtype);\n        var r = this.texData.get(t.dataId).isPacked, o = $o(t.shape, e, n);\n        if (r || !o) {\n            var a = i().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new eu(n) : new Zs(n), s = a.getCustomSetupFunc(e);\n            return this.compileAndRun(a, [\n                t\n            ], null, s);\n        }\n        return this.uploadToGPU(t.dataId), this.shallowSlice(t, e, n);\n    }, o.prototype.shallowSlice = function(t, e, n) {\n        var r = this.texData.get(t.dataId), o = this.makeOutput(n, t.dtype), a = this.texData.get(o.dataId);\n        Object.assign(a, r), a.shape = n, a.dtype = t.dtype;\n        var i = Qo(e, t.strides);\n        r.slice && (i += r.slice.flatOffset), a.slice = {\n            flatOffset: i,\n            origDataId: r.slice && r.slice.origDataId || t.dataId\n        };\n        var s = this.dataRefCount.get(a.slice.origDataId) || 1;\n        return this.dataRefCount.set(a.slice.origDataId, s + 1), o;\n    }, o.prototype.stridedSlice = function(t, e, n, r) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.stridedSlice(t, e, n, r);\n        var o = jo(e, n, r);\n        if (o.some(function(t) {\n            return 0 === t;\n        })) return Fn([], o);\n        var a = new nu(e, r, o);\n        return this.compileAndRun(a, [\n            t\n        ]);\n    }, o.prototype.reverse = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new Ys(t.shape, e) : new Xs(t.shape, e);\n        return this.compileAndRun(n, [\n            t\n        ]);\n    }, o.prototype.concat = function(t, e) {\n        if (\"complex64\" === t[0].dtype) {\n            var n = t.map(function(t) {\n                return Dn(t);\n            }), r = t.map(function(t) {\n                return Nn(t);\n            });\n            return Tn(this.concat(n, e), this.concat(r, e));\n        }\n        if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, e);\n        if (1 === t.length) return t[0];\n        if (t.length > i().getNumber(\"WEBGL_MAX_TEXTURES_IN_SHADER\")) {\n            var o = Math.floor(t.length / 2), a = this.concat(t.slice(0, o), e), s = this.concat(t.slice(o), e);\n            return this.concat([\n                a,\n                s\n            ], e);\n        }\n        if (i().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") && t[0].rank > 1) {\n            var u = new Fi(t.map(function(t) {\n                return t.shape;\n            }), e);\n            return this.compileAndRun(u, t);\n        }\n        var c = Sn(t.map(function(t) {\n            return t.shape;\n        }), e), l = t.map(function(t) {\n            return t.as2D(-1, k(t.shape.slice(e)));\n        }), h = new Ni(l.map(function(t) {\n            return t.shape;\n        }));\n        return this.compileAndRun(h, l).reshape(c);\n    }, o.prototype.neg = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.neg(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, mu, t.dtype);\n        var e = new cu(t.shape, mu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.batchMatMul = function(t, e, n, r) {\n        var o = n ? t.shape[2] : t.shape[1], a = r ? e.shape[1] : e.shape[2], i = n ? t.shape[1] : t.shape[2], s = t.shape[0];\n        if ((1 === o || 1 === a) && i > 1e3) {\n            n && (t = ua(t, [\n                0,\n                2,\n                1\n            ])), r && (e = ua(e, [\n                0,\n                2,\n                1\n            ]));\n            var u = 1 === a ? t : t.as3D(s, i, 1), c = 1 === a ? 2 : 1, l = 1 === a ? e.as3D(s, 1, i) : e;\n            return this.multiply(u, l).sum(c, !0);\n        }\n        var h = Tt(t.dtype, e.dtype), f = new _s(t.shape, [\n            s,\n            o,\n            a\n        ], n, r);\n        return this.compileAndRun(f, [\n            t,\n            e\n        ], h);\n    }, o.prototype.fusedBatchMatMul = function(t) {\n        var e = t.a, n = t.b, r = t.transposeA, o = t.transposeB, a = t.bias, i = t.activation, s = t.preluActivationWeights, u = r ? e.shape[2] : e.shape[1], c = o ? n.shape[1] : n.shape[2], l = e.shape[0], h = Tt(e.dtype, n.dtype), f = null != a, d = null != s, p = i ? Lu(i, !0) : null, v = new _s(e.shape, [\n            l,\n            u,\n            c\n        ], r, o, f, p, d), g = [\n            e,\n            n\n        ];\n        return a && g.push(a), s && g.push(s), this.compileAndRun(v, g, h);\n    }, o.prototype.multiply = function(t, e) {\n        if (\"complex64\" === t.dtype) {\n            var n = this.texData.get(t.dataId), r = this.texData.get(e.dataId), o = new yi(gi, t.shape, e.shape), a = new yi(mi, t.shape, e.shape), s = [\n                this.makeComplexComponentTensorInfo(t, n.complexTensors.real),\n                this.makeComplexComponentTensorInfo(t, n.complexTensors.imag),\n                this.makeComplexComponentTensorInfo(e, r.complexTensors.real),\n                this.makeComplexComponentTensorInfo(e, r.complexTensors.imag)\n            ], u = this.compileAndRun(o, s), c = this.compileAndRun(a, s), l = this.complex(u, c);\n            return u.dispose(), c.dispose(), l;\n        }\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.multiply(t, e);\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, wi, t.dtype);\n        var h = new Ri(wi, t.shape, e.shape);\n        return this.compileAndRun(h, [\n            t,\n            e\n        ], t.dtype);\n    }, o.prototype.batchNormalization = function(t, e, n, r, o, a) {\n        var s = [\n            t,\n            e,\n            n\n        ], u = null;\n        null != a && (u = a.shape, s.push(a));\n        var c = null;\n        if (null != o && (c = o.shape, s.push(o)), i().getBool(\"WEBGL_PACK_NORMALIZATION\")) {\n            var l = new vi(t.shape, e.shape, n.shape, u, c, r);\n            return this.compileAndRun(l, s);\n        }\n        var h = new pi(t.shape, e.shape, n.shape, u, c, r);\n        return this.compileAndRun(h, s);\n    }, o.prototype.localResponseNormalization4D = function(t, e, n, r, o) {\n        var a = i().getBool(\"WEBGL_PACK_NORMALIZATION\") ? new Ds(t.shape, e, n, r, o) : new As(t.shape, e, n, r, o);\n        return this.compileAndRun(a, [\n            t\n        ]);\n    }, o.prototype.LRNGrad = function(t, e, n, r, o, a, i) {\n        var s = new Ts(e.shape, r, o, a, i);\n        return this.compileAndRun(s, [\n            e,\n            n,\n            t\n        ]);\n    }, o.prototype.tile = function(t, e) {\n        if (\"string\" === t.dtype) {\n            var n = this.readSync(t.dataId).map(function(t) {\n                return ot(t);\n            });\n            return Va(er(t.shape, t.dtype, n), e);\n        }\n        var r = new iu(t.shape, e);\n        return this.compileAndRun(r, [\n            t\n        ]);\n    }, o.prototype.pad = function(t, e, n) {\n        var r = i().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new Ls(t.shape, e, n) : new Ps(t.shape, e, n);\n        return this.compileAndRun(r, [\n            t\n        ]);\n    }, o.prototype.gather = function(t, e, n) {\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.gather(t, e, n);\n        var r = new as(t.shape, e.size, n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.batchToSpaceND = function(t, e, n) {\n        C(t.rank <= 4, function() {\n            return \"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet\";\n        });\n        var r = e.reduce(function(t, e) {\n            return t * e;\n        }), o = pr(t.shape, e, r), a = vr(o.length, e.length), i = gr(t.shape, e, r), s = mr(n, e.length), u = yr(i, n, e.length);\n        return ua(t.reshape(o), a).reshape(i).slice(s, u);\n    }, o.prototype.spaceToBatchND = function(t, e, n) {\n        C(t.rank <= 4, function() {\n            return \"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet\";\n        });\n        var r = e.reduce(function(t, e) {\n            return t * e;\n        }), o = [\n            [\n                0,\n                0\n            ]\n        ];\n        o.push.apply(o, n);\n        for(var a = 1 + e.length; a < t.shape.length; ++a)o.push([\n            0,\n            0\n        ]);\n        var i = t.pad(o), s = pr(i.shape, e, r, !1), u = vr(s.length, e.length, !1), c = gr(i.shape, e, r, !1);\n        return ua(i.reshape(s), u).reshape(c);\n    }, o.prototype.reduce = function(t, e, n) {\n        var r = t.shape[0], o = t.shape[1], a = Uo(o), i = new Vs({\n            windowSize: a,\n            inSize: o,\n            batchSize: r\n        }, e), s = this.compileAndRun(i, [\n            t\n        ], n);\n        return 1 === s.shape[1] ? s : this.reduce(s, e, n);\n    }, o.prototype.argReduce = function(t, e, n) {\n        void 0 === n && (n = null);\n        var r = t.shape[0], o = t.shape[1];\n        null != n && (r = n.shape[0], o = n.shape[1]);\n        var a = Uo(o), i = new Ka({\n            windowSize: a,\n            inSize: o,\n            batchSize: r\n        }, e, null == n), s = [\n            t\n        ];\n        null != n && s.push(n);\n        var u = this.compileAndRun(i, s, \"int32\");\n        return 1 === u.shape[1] ? u : this.argReduce(t, e, u);\n    }, o.prototype.argReducePacked = function(t, e, n) {\n        void 0 === n && (n = null);\n        var r = null != n ? n.shape : t.shape, o = Uo(r[r.length - 1]), a = new hi(r, o, e, null == n), i = null == n ? [\n            t\n        ] : [\n            t,\n            n\n        ], s = this.compileAndRun(a, i, \"int32\");\n        return s.rank === t.rank ? this.argReducePacked(t, e, s) : s;\n    }, o.prototype.sum = function(t, e) {\n        Cn(\"sum\", e, t.rank);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o), i = Dt(t.dtype);\n        return this.reduce(a, \"sum\", i).reshape(r);\n    }, o.prototype.prod = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.prod(t, e);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o), i = Dt(t.dtype);\n        return this.reduce(a, \"prod\", i).reshape(r);\n    }, o.prototype.unsortedSegmentSum = function(t, e, n) {\n        var r = 0, o = En([\n            r\n        ], t.rank), a = t;\n        null != o && (a = ua(t, o), r = In(1, t.rank)[0]);\n        var i = function(t, e, n) {\n            for(var r = [], o = t.length, a = 0; a < o; a++)a !== e ? r.push(t[a]) : r.push(n);\n            return r;\n        }(a.shape, r, n), s = k([\n            a.shape[r]\n        ]), u = a.as2D(-1, s), c = Dt(t.dtype), l = this.segOpCompute(u, \"unsortedSegmentSum\", e, c, n).reshape(i);\n        return null != o && (l = ua(l, Rn(o))), l;\n    }, o.prototype.segOpCompute = function(t, e, n, r, o) {\n        var a = t.shape[0], i = t.shape[1], s = function(t, e) {\n            var n, r = !1;\n            for(t <= Wo ? (n = t, r = !0) : n = Y(t, Math.floor(Math.sqrt(t))); !r;)n > e || n === t ? r = !0 : n = Y(t, n + 1);\n            return n;\n        }(i, o), u = new Qs({\n            windowSize: s,\n            inSize: i,\n            batchSize: a,\n            numSegments: o\n        }, e), c = this.compileAndRun(u, [\n            t,\n            n\n        ], r);\n        return c.shape[1] === o ? c : (n = Kn(0, o).tile([\n            i / s\n        ]), this.segOpCompute(c, e, n, r, o));\n    }, o.prototype.argMinMaxReduce = function(t, e, n) {\n        var r = [\n            e\n        ];\n        if (Cn(\"arg\" + n.charAt(0).toUpperCase() + n.slice(1), r, t.rank), !i().getBool(\"WEBGL_PACK_REDUCE\") || t.rank <= 2) {\n            var o = bn(t.shape, r), a = o[0], s = k(o[1]), u = t.as2D(-1, s);\n            return this.argReduce(u, n).reshape(a);\n        }\n        return this.argReducePacked(t, n);\n    }, o.prototype.argMin = function(t, e) {\n        return this.argMinMaxReduce(t, e, \"min\");\n    }, o.prototype.argMax = function(t, e) {\n        return this.argMinMaxReduce(t, e, \"max\");\n    }, o.prototype.cumsum = function(t, e, n, r) {\n        if (e !== t.rank - 1) throw new Error(\"WebGL cumsum shader expects an inner-most axis=\" + (t.rank - 1) + \" but got axis=\" + e);\n        var o = new qi(t.shape, n, r);\n        return this.compileAndRun(o, [\n            t\n        ]);\n    }, o.prototype.equal = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(equal(a, b));\\n\", \"bool\");\n        var n = new Ri(\"return float(a == b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.notEqual = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(notEqual(a, b));\\n\", \"bool\");\n        var n = new Ri(\"return float(a != b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.less = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.less(t, e);\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(lessThan(a, b));\\n\", \"bool\");\n        var n = new Ri(\"return float(a < b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.lessEqual = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(lessThanEqual(a, b));\\n\", \"bool\");\n        var n = new Ri(\"return float(a <= b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.greater = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.greater(t, e);\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(greaterThan(a, b));\\n\", \"bool\");\n        var n = new Ri(\"return float(a > b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.greaterEqual = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(greaterThanEqual(a, b));\\n\", \"bool\");\n        var n = new Ri(\"return float(a >= b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.logicalNot = function(t) {\n        var e = new cu(t.shape, \"return float(!(x >= 1.0));\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.logicalAnd = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(\\n    vec4(greaterThanEqual(a, vec4(1.0))) *\\n    vec4(greaterThanEqual(b, vec4(1.0))));\\n\", \"bool\");\n        var n = new Ri(\"return float(a >= 1.0 && b >= 1.0);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.logicalOr = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return min(\\n    vec4(greaterThanEqual(a, vec4(1.0))) +\\n    vec4(greaterThanEqual(b, vec4(1.0))),\\n    vec4(1.0));\\n\", \"bool\");\n        var n = new Ri(\"return float(a >= 1.0 || b >= 1.0);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"bool\");\n    }, o.prototype.select = function(t, e, n) {\n        var r = new Js(t.rank, e.shape, e.rank);\n        return this.compileAndRun(r, [\n            t,\n            e,\n            n\n        ], Tt(e.dtype, n.dtype));\n    }, o.prototype.where = function(t) {\n        dn(\"tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead\");\n        var e = t.dataSync();\n        return Ga(t.shape, e);\n    }, o.prototype.topk = function(t, e, n) {\n        return za(t.dataSync(), t.shape, t.dtype, e);\n    }, o.prototype.min = function(t, e) {\n        Cn(\"min\", e, t.rank);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o);\n        return this.reduce(a, \"min\", a.dtype).reshape(r);\n    }, o.prototype.minimum = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.minimum(t, e);\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Si(\"\\n  vec4 result = vec4(min(a, b));\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new Ri(\"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\\n  return min(a, b);\\n\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.mod = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Si(\"\\n  vec4 result = mod(a, b);\\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new Ri(\"if (b == 0.0) return NAN;\\n  return mod(a, b);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.max = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.max(t, e);\n        Cn(\"max\", e, t.rank);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o);\n        return this.reduce(a, \"max\", a.dtype).reshape(r);\n    }, o.prototype.maximum = function(t, e) {\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.maximum(t, e);\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Si(\"\\n  vec4 result = vec4(max(a, b));\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new Ri(\"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\\n  return max(a, b);\\n\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.all = function(t, e) {\n        Cn(\"all\", e, t.rank);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o);\n        return this.reduce(a, \"all\", a.dtype).reshape(r);\n    }, o.prototype.any = function(t, e) {\n        Cn(\"any\", e, t.rank);\n        var n = bn(t.shape, e), r = n[0], o = k(n[1]), a = t.as2D(-1, o);\n        return this.reduce(a, \"any\", a.dtype).reshape(r);\n    }, o.prototype.floorDiv = function(t, e) {\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  ivec4 ia = round(a);\\n  ivec4 ib = round(b);\\n  bvec4 cond = notEqual(ib, ivec4(0));\\n  ivec4 result = ivec4(0);\\n  vec4 s = sign(a) * sign(b);\\n\\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\\n  if (cond[0]) {\\n    result[0] = idiv(ia[0], ib[0], s[0]);\\n  }\\n  if (cond[1]) {\\n    result[1] = idiv(ia[1], ib[1], s[1]);\\n  }\\n  if (cond[2]) {\\n    result[2] = idiv(ia[2], ib[2], s[2]);\\n  }\\n  if (cond[3]) {\\n    result[3] = idiv(ia[3], ib[3], s[3]);\\n  }\\n  return vec4(result);\\n\", \"int32\");\n        var n = new Ri(\"\\n  float s = sign(a) * sign(b);\\n  int ia = round(a);\\n  int ib = round(b);\\n  if (ib != 0) {\\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\\n    return float(idiv(ia, ib, s));\\n  } else {\\n    return NAN;\\n  }\\n\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], \"int32\");\n    }, o.prototype.add = function(t, e) {\n        if (\"complex64\" === t.dtype && \"complex64\" === e.dtype) return this.complexSeparableBinaryOp(t, e, xi);\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.add(t, e);\n        var n = Tt(t.dtype, e.dtype);\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, xi, n);\n        var r = new Ri(xi, t.shape, e.shape);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ], n);\n    }, o.prototype.packedUnaryOp = function(t, e, n) {\n        var r = new Mu(t.shape, e);\n        return this.compileAndRun(r, [\n            t\n        ], n);\n    }, o.prototype.packedBinaryOp = function(t, e, n, r, o) {\n        void 0 === o && (o = !1);\n        var a = new Si(n, t.shape, e.shape, o);\n        return this.compileAndRun(a, [\n            t,\n            e\n        ], r);\n    }, o.prototype.complexSeparableBinaryOp = function(t, e, n) {\n        var r = this, o = this.texData.get(t.dataId), a = this.texData.get(e.dataId), i = [\n            [\n                o.complexTensors.real,\n                a.complexTensors.real\n            ],\n            [\n                o.complexTensors.imag,\n                a.complexTensors.imag\n            ]\n        ].map(function(o) {\n            var a = o[0], i = o[1], s = r.makeComplexComponentTensorInfo(t, a), u = r.makeComplexComponentTensorInfo(e, i), c = new Ri(n, t.shape, e.shape);\n            return r.compileAndRun(c, [\n                s,\n                u\n            ], Tt(a.dtype, i.dtype));\n        }), s = i[0], u = i[1], c = this.complex(s, u);\n        return s.dispose(), u.dispose(), c;\n    }, o.prototype.makeComplexComponentTensorInfo = function(t, e) {\n        return {\n            dataId: e.dataId,\n            dtype: e.dtype,\n            shape: t.shape\n        };\n    }, o.prototype.addN = function(t) {\n        if (1 === t.length) return t[0];\n        if (t.length > i().get(\"WEBGL_MAX_TEXTURES_IN_SHADER\")) {\n            var e = Math.floor(t.length / 2), n = this.addN(t.slice(0, e)), r = this.addN(t.slice(e));\n            return this.addN([\n                n,\n                r\n            ]);\n        }\n        var o = t.map(function(t) {\n            return t.dtype;\n        }).reduce(function(t, e) {\n            return Tt(t, e);\n        }), a = t.map(function(t) {\n            return t.shape;\n        }), s = i().getBool(\"WEBGL_PACK\") ? new qa(t[0].shape, a) : new Ha(t[0].shape, a);\n        return this.compileAndRun(s, t, o);\n    }, o.prototype.subtract = function(t, e) {\n        if (\"complex64\" === t.dtype && \"complex64\" === e.dtype) return this.complexSeparableBinaryOp(t, e, bi);\n        if (this.shouldExecuteOnCPU([\n            t,\n            e\n        ])) return this.cpuBackend.subtract(t, e);\n        var n = Tt(t.dtype, e.dtype);\n        if (i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, bi, t.dtype);\n        var r = new Ri(bi, t.shape, e.shape);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ], n);\n    }, o.prototype.pow = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Si(\"\\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\\n  vec4 result = multiplier * pow(abs(a), b);\\n\\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\\n  bvec4 isExpZero = equal(b, vec4(0.0));\\n  result.r = isExpZero.r ? 1.0 : result.r;\\n  result.g = isExpZero.g ? 1.0 : result.g;\\n  result.b = isExpZero.b ? 1.0 : result.b;\\n  result.a = isExpZero.a ? 1.0 : result.a;\\n\\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new Ri(\"\\nif(a < 0.0 && floor(b) < b){\\n  return NAN;\\n}\\nif (b == 0.0) {\\n  return 1.0;\\n}\\nreturn (round(mod(b, 2.0)) != 1) ?\\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\\n\", t.shape, e.shape), r = Tt(t.dtype, e.dtype);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ], r);\n    }, o.prototype.ceil = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.ceil(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, yu, t.dtype);\n        var e = new cu(t.shape, yu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.floor = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.floor(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, xu, t.dtype);\n        var e = new cu(t.shape, xu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.sign = function(t) {\n        var e = new cu(t.shape, \"\\n  if (isnan(x)) { return 0.0; }\\n  return sign(x);\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.isNaN = function(t) {\n        var e = new cu(t.shape, \"return float(isnan(x));\");\n        return this.compileAndRun(e, [\n            t\n        ], \"bool\");\n    }, o.prototype.isInf = function(t) {\n        var e = new cu(t.shape, \"return float(isinf(x));\");\n        return this.compileAndRun(e, [\n            t\n        ], \"bool\");\n    }, o.prototype.isFinite = function(t) {\n        var e = new cu(t.shape, \"return float(!isnan(x) && !isinf(x));\");\n        return this.compileAndRun(e, [\n            t\n        ], \"bool\");\n    }, o.prototype.round = function(t) {\n        var e = new cu(t.shape, \"\\n  // OpenGL ES does not support round function.\\n  // The algorithm is based on banker's rounding.\\n  float base = floor(x);\\n  if ((x - base) < 0.5) {\\n    return floor(x);\\n  } else if ((x - base) > 0.5) {\\n    return ceil(x);\\n  } else {\\n    if (mod(base, 2.0) == 0.0) {\\n      return base;\\n    } else {\\n      return base + 1.0;\\n    }\\n  }\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.exp = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.exp(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, bu, t.dtype);\n        var e = new cu(t.shape, bu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.expm1 = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.expm1(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, wu, t.dtype);\n        var e = new cu(t.shape, wu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.softmax = function(t, e) {\n        var n = O([\n            e\n        ], t.shape), r = this.max(t, n), o = wn(r.shape, n), a = this.subtract(t, r.reshape(o)), i = this.exp(a), s = this.sum(i, n).reshape(o);\n        return Bo(i, s);\n    }, o.prototype.log = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.log(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, \"\\n  vec4 result = log(x);\\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\\n\\n  return result;\\n\", t.dtype);\n        var e = new cu(t.shape, \"if (x < 0.0) return NAN;\\n  return log(x);\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.log1p = function(t) {\n        var e = new cu(t.shape, \"return log(1.0 + x);\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.sqrt = function(t) {\n        var e = new cu(t.shape, \"return sqrt(x);\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.rsqrt = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.rsqrt(t);\n        var e = new cu(t.shape, \"return inversesqrt(x);\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.reciprocal = function(t) {\n        var e = new cu(t.shape, \"return 1.0 / x;\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.relu = function(t) {\n        var e;\n        return e = i().getBool(\"WEBGL_PACK\") ? new Mu(t.shape, Fu) : new cu(t.shape, du), this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.relu6 = function(t) {\n        var e;\n        return e = i().getBool(\"WEBGL_PACK\") ? new Mu(t.shape, _u) : new cu(t.shape, pu), this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.prelu = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Si(ki, t.shape, e.shape) : new Ri(Ei, t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.elu = function(t) {\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Ou, t.dtype);\n        var e = new cu(t.shape, vu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.eluDer = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Si(\"\\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\\n\", t.shape, e.shape) : new Ri(\"return (b >= 1.0) ? a : a * (b + 1.0);\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.selu = function(t) {\n        var e = new cu(t.shape, gu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.int = function(t) {\n        var e = new cu(t.shape, \"return float(int(x));\");\n        return this.compileAndRun(e, [\n            t\n        ], \"int32\");\n    }, o.prototype.clip = function(t, e, n) {\n        var r, o = (r = i().getBool(\"WEBGL_PACK_CLIP\") ? new Ti(t.shape) : new Ai(t.shape)).getCustomSetupFunc(e, n);\n        return this.compileAndRun(r, [\n            t\n        ], null, o);\n    }, o.prototype.abs = function(t) {\n        if (this.shouldExecuteOnCPU([\n            t\n        ])) return this.cpuBackend.abs(t);\n        if (i().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, fu, t.dtype);\n        var e = new cu(t.shape, fu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.complexAbs = function(t) {\n        var e = this.texData.get(t.dataId), n = new Di(t.shape), r = [\n            this.makeComplexComponentTensorInfo(t, e.complexTensors.real),\n            this.makeComplexComponentTensorInfo(t, e.complexTensors.imag)\n        ];\n        return this.compileAndRun(n, r);\n    }, o.prototype.sigmoid = function(t) {\n        var e = new cu(t.shape, \"return 1.0 / (1.0 + exp(-1.0 * x));\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.softplus = function(t) {\n        var e = new cu(t.shape, \"\\n  float epsilon = 1.1920928955078125e-7;\\n  float threshold = log(epsilon) + 2.0;\\n\\n  bool too_large = x > -threshold;\\n  bool too_small = x < threshold;\\n\\n  float result;\\n  float exp_x = exp(x);\\n\\n  if (too_large){\\n    result = x;\\n  }\\n  else if (too_small){\\n    result = exp_x;\\n  }\\n  else{\\n    result = log(exp_x + 1.0);\\n  }\\n  return result;\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.sin = function(t) {\n        var e = new cu(t.shape, Cu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.cos = function(t) {\n        var e = new cu(t.shape, Eu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.tan = function(t) {\n        var e = new cu(t.shape, \"return tan(x);\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.asin = function(t) {\n        var e = new cu(t.shape, Ru);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.acos = function(t) {\n        var e = new cu(t.shape, Iu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.atan = function(t) {\n        var e = new cu(t.shape, ku);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.atan2 = function(t, e) {\n        var n = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Si(\"\\n  vec4 result = atan(a, b);\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new Ri(\"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\\n  return atan(a, b);\\n\", t.shape, e.shape);\n        return this.compileAndRun(n, [\n            t,\n            e\n        ]);\n    }, o.prototype.sinh = function(t) {\n        var e = new cu(t.shape, \"\\n  float e2x = exp(x);\\n  return (e2x - 1.0 / e2x) / 2.0;\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.cosh = function(t) {\n        var e = new cu(t.shape, \"\\n  float e2x = exp(-x);\\n  return (e2x + 1.0 / e2x) / 2.0;\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.tanh = function(t) {\n        var e = new cu(t.shape, \"\\n  float e2x = exp(-2.0 * abs(x));\\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\\n\");\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.asinh = function(t) {\n        var e = new cu(t.shape, Su);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.acosh = function(t) {\n        var e = new cu(t.shape, Au);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.atanh = function(t) {\n        var e = new cu(t.shape, Tu);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.erf = function(t) {\n        var e = new cu(t.shape, '\\n  // Error function is calculated approximately with elementary function.\\n  // See \"Handbook of Mathematical Functions with Formulas,\\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\\n  float p = 0.3275911;\\n  float a1 = 0.254829592;\\n  float a2 = -0.284496736;\\n  float a3 = 1.421413741;\\n  float a4 = -1.453152027;\\n  float a5 = 1.061405429;\\n\\n  float sign = sign(x);\\n  x = abs(x);\\n  float t = 1.0 / (1.0 + p * x);\\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\\n');\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.step = function(t, e) {\n        var n = new cu(t.shape, function(t) {\n            return void 0 === t && (t = 0), lu + \"\\n    return x > 0.0 ? 1.0 : float(\" + t + \");\\n  \";\n        }(e));\n        return this.compileAndRun(n, [\n            t\n        ]);\n    }, o.prototype.conv2dByMatMul = function(t, e, n, r, o, a) {\n        var s = t.shape, u = this.texData.get(t.dataId), c = n.inChannels, l = s[0] * s[1] * s[2], h = n.outChannels, f = \"channelsLast\" === n.dataFormat, d = (1 === l || 1 === h) && c > 1e3, p = s[2] % 2 != 0 && !!u.isPacked;\n        if (d || !i().getBool(\"WEBGL_LAZILY_UNPACK\") || !i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") || !p) {\n            var v = f ? s[0] * s[1] * s[2] : s[0] * s[2] * s[3], g = this.reshape(t, [\n                1,\n                v,\n                n.inChannels\n            ]), m = this.reshape(e, [\n                1,\n                n.inChannels,\n                n.outChannels\n            ]);\n            return this.reshape(this.fusedBatchMatMul({\n                a: g,\n                b: m,\n                transposeA: !1,\n                transposeB: !1,\n                bias: r,\n                activation: o,\n                preluActivationWeights: a\n            }), n.outShape);\n        }\n        var y = f ? s[0] * s[1] * (s[2] + 1) : s[0] * s[2] * (s[3] + 1), x = {\n            dataId: t.dataId,\n            shape: [\n                1,\n                y,\n                n.inChannels\n            ],\n            dtype: t.dtype\n        }, b = u.shape;\n        u.shape = u.shape.slice(), u.shape[u.shape.length - 2]++, C(_e(u.shape, x.shape), function() {\n            return \"packed reshape \" + u.shape + \" to \" + x.shape + \" isn't free\";\n        });\n        var w = this.reshape(e, [\n            1,\n            n.inChannels,\n            n.outChannels\n        ]), E = this.fusedBatchMatMul({\n            a: x,\n            b: w,\n            transposeA: !1,\n            transposeB: !1,\n            bias: r,\n            activation: o,\n            preluActivationWeights: a\n        }), R = this.texData.get(E.dataId);\n        return C(R.isPacked, function() {\n            return \"batchMatMul result is expected to be packed\";\n        }), u.shape = b, R.shape = n.outShape, Lt.makeTensorFromDataId(E.dataId, n.outShape, E.dtype);\n    }, o.prototype.conv2dWithIm2Row = function(t, e, n, r, o, a) {\n        var i = n.filterWidth, s = n.filterHeight, u = n.inChannels, c = n.outWidth, l = n.outHeight, h = \"channelsLast\" === n.dataFormat, f = i * s * u, d = l * c, p = [\n            f,\n            d\n        ], v = t.squeeze([\n            0\n        ]), g = e.reshape([\n            1,\n            f,\n            -1\n        ]), m = new Ss(p, v.shape, n), y = this.compileAndRun(m, [\n            v\n        ]).reshape([\n            1,\n            p[0],\n            p[1]\n        ]), x = null != r, b = null != a, w = o ? Lu(o, !0) : null, C = new _s(y.shape, [\n            1,\n            d,\n            n.outChannels\n        ], !0, !1, x, w, b), E = [\n            y,\n            g\n        ];\n        r && E.push(r), b && E.push(a);\n        var R = this.compileAndRun(C, E);\n        return h ? R.reshape([\n            1,\n            l,\n            c,\n            n.outChannels\n        ]) : R.reshape([\n            1,\n            n.outChannels,\n            l,\n            c\n        ]);\n    }, o.prototype.fusedConv2d = function(t) {\n        var e = t.input, n = t.filter, r = t.convInfo, o = t.bias, a = t.activation, s = t.preluActivationWeights;\n        if (1 === r.filterHeight && 1 === r.filterWidth && 1 === r.dilationHeight && 1 === r.dilationWidth && 1 === r.strideHeight && 1 === r.strideWidth && (\"SAME\" === r.padInfo.type || \"VALID\" === r.padInfo.type)) return this.conv2dByMatMul(e, n, r, o, a, s);\n        if (i().getBool(\"WEBGL_CONV_IM2COL\") && 1 === e.shape[0]) return this.conv2dWithIm2Row(e, n, r, o, a, s);\n        var u = null != o, c = null != s, l = a ? Lu(a, !1) : null, h = new Ui(r, u, l, c), f = [\n            e,\n            n\n        ];\n        return o && f.push(o), s && f.push(s), this.compileAndRun(h, f);\n    }, o.prototype.conv2d = function(t, e, n) {\n        if (1 === n.filterHeight && 1 === n.filterWidth && 1 === n.dilationHeight && 1 === n.dilationWidth && 1 === n.strideHeight && 1 === n.strideWidth && (\"SAME\" === n.padInfo.type || \"VALID\" === n.padInfo.type)) return this.conv2dByMatMul(t, e, n);\n        if (i().getBool(\"WEBGL_CONV_IM2COL\") && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, e, n);\n        var r = new Ui(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.conv2dDerInput = function(t, e, n) {\n        var r = new Mi(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.conv2dDerFilter = function(t, e, n) {\n        var r = new Oi(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.fusedDepthwiseConv2D = function(t) {\n        var e, n = t.input, r = t.filter, o = t.convInfo, a = t.bias, s = t.activation, u = t.preluActivationWeights, c = i().getBool(\"WEBGL_PACK_DEPTHWISECONV\") && o.strideWidth <= 2 && o.outChannels / o.inChannels == 1, l = s ? Lu(s, c) : null, h = [\n            n,\n            r\n        ], f = null != a, d = null != u;\n        return f && h.push(a), d && h.push(u), c ? (e = new Gi(o, f, l, d), this.compileAndRun(e, h)) : (e = new zi(o, f, l, d), this.compileAndRun(e, h));\n    }, o.prototype.depthwiseConv2D = function(t, e, n) {\n        var r;\n        return i().getBool(\"WEBGL_PACK_DEPTHWISECONV\") && n.strideWidth <= 2 && n.outChannels / n.inChannels == 1 ? (r = new Gi(n), this.compileAndRun(r, [\n            t,\n            e\n        ])) : (r = new zi(n), this.compileAndRun(r, [\n            t,\n            e\n        ]));\n    }, o.prototype.depthwiseConv2DDerInput = function(t, e, n) {\n        var r = new Wi(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.depthwiseConv2DDerFilter = function(t, e, n) {\n        var r = new Li(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.conv3d = function(t, e, n) {\n        var r = new Vi(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.conv3dDerInput = function(t, e, n) {\n        var r = new Pi(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.conv3dDerFilter = function(t, e, n) {\n        var r = new Bi(n);\n        return this.compileAndRun(r, [\n            t,\n            e\n        ]);\n    }, o.prototype.maxPool = function(t, e) {\n        var n = new Ws(e, \"max\", !1);\n        return this.compileAndRun(n, [\n            t\n        ]);\n    }, o.prototype.avgPool = function(t, e) {\n        var n = new Ws(e, \"avg\", !1);\n        return this.compileAndRun(n, [\n            t\n        ], \"float32\");\n    }, o.prototype.maxPoolBackprop = function(t, e, n, r) {\n        var o = new Ws(r, \"max\", !0), a = this.compileAndRun(o, [\n            e\n        ]), i = new Ns(r), s = this.compileAndRun(i, [\n            t,\n            a\n        ], e.dtype);\n        return a.dispose(), s;\n    }, o.prototype.avgPoolBackprop = function(t, e, n) {\n        var r = new fi(n);\n        return this.compileAndRun(r, [\n            t\n        ], e.dtype);\n    }, o.prototype.cast = function(t, e) {\n        return Ra(t, e, this);\n    }, o.prototype.unstack = function(t, e) {\n        for(var n = t.shape[e], r = new Array(t.rank - 1), o = 0, a = 0; a < t.rank; a++)a !== e && (r[o++] = t.shape[a]);\n        var i = new Array(t.rank).fill(0), s = t.shape.slice();\n        s[e] = 1;\n        var u = new Array(n);\n        for(a = 0; a < u.length; a++)i[e] = a, u[a] = this.slice(t, i, s).reshape(r);\n        return u;\n    }, o.prototype.avgPool3d = function(t, e) {\n        var n = new Us(e, \"avg\", !1);\n        return this.compileAndRun(n, [\n            t\n        ], \"float32\");\n    }, o.prototype.avgPool3dBackprop = function(t, e, n) {\n        var r = new di(n);\n        return this.compileAndRun(r, [\n            t\n        ], e.dtype);\n    }, o.prototype.maxPool3d = function(t, e) {\n        var n = new Us(e, \"max\", !1);\n        return this.compileAndRun(n, [\n            t\n        ], \"float32\");\n    }, o.prototype.maxPool3dBackprop = function(t, e, n, r) {\n        var o = new Us(r, \"max\", !0), a = this.compileAndRun(o, [\n            e\n        ]), i = new Fs(r), s = this.compileAndRun(i, [\n            t,\n            a\n        ], e.dtype);\n        return a.dispose(), s;\n    }, o.prototype.reshape = function(t, e) {\n        var n = this.texData.get(t.dataId);\n        if (n.isPacked && !_e(t.shape, e) && (null === n.texture || !_e(n.shape, e))) {\n            var r = this.packedReshape(t, e);\n            return Lt.makeTensorFromDataId(r.dataId, r.shape, r.dtype);\n        }\n        return Ia(t, e);\n    }, o.prototype.resizeBilinear = function(t, e, n, r) {\n        var o = i().getBool(\"WEBGL_PACK_IMAGE_OPERATIONS\") ? new qs(t.shape, e, n, r) : new Hs(t.shape, e, n, r);\n        return this.compileAndRun(o, [\n            t\n        ], \"float32\");\n    }, o.prototype.resizeBilinearBackprop = function(t, e, n) {\n        var r = new Gs(t, e, n);\n        return this.compileAndRun(r, [\n            t\n        ]);\n    }, o.prototype.resizeNearestNeighbor = function(t, e, n, r) {\n        var o = new js(t.shape, e, n, r);\n        return this.compileAndRun(o, [\n            t\n        ]);\n    }, o.prototype.resizeNearestNeighborBackprop = function(t, e, n) {\n        var r = new Ks(t, e, n);\n        return this.compileAndRun(r, [\n            t\n        ]);\n    }, o.prototype.multinomial = function(t, e, n, r) {\n        var o = e ? t : ia(t), a = o.shape[0], i = o.shape[1], s = new Os(a, i, n), u = s.getCustomSetupFunc(r);\n        return this.compileAndRun(s, [\n            o\n        ], \"int32\", u);\n    }, o.prototype.oneHot = function(t, e, n, r) {\n        var o = new Ms(t.size, e, n, r);\n        return this.compileAndRun(o, [\n            t\n        ]);\n    }, o.prototype.diag = function(t) {\n        var e = new $i(t.size);\n        return this.compileAndRun(e, [\n            t\n        ]);\n    }, o.prototype.nonMaxSuppression = function(t, e, n, r, o) {\n        return dn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\"), Oa(t.dataSync(), e.dataSync(), n, r, o);\n    }, o.prototype.cropAndResize = function(t, e, n, r, o, a) {\n        var i = new Hi(t.shape, e.shape, r, o, a);\n        return this.compileAndRun(i, [\n            t,\n            e,\n            n\n        ], \"float32\");\n    }, o.prototype.depthToSpace = function(t, e, n) {\n        C(e > 1, function() {\n            return \"blockSize should be > 1 for depthToSpace, but was: \" + e;\n        });\n        var r = t.shape[0], o = \"NHWC\" === n ? t.shape[1] : t.shape[2], a = \"NHWC\" === n ? t.shape[2] : t.shape[3], i = \"NHWC\" === n ? t.shape[3] : t.shape[1], s = o * e, u = a * e, c = i / (e * e), l = new Yi(\"NHWC\" === n ? [\n            r,\n            s,\n            u,\n            c\n        ] : [\n            r,\n            c,\n            s,\n            u\n        ], e, n);\n        return this.compileAndRun(l, [\n            t\n        ]);\n    }, o.prototype.split = function(t, e, n) {\n        return Ua(t, e, n);\n    }, o.prototype.scatterND = function(t, e, n) {\n        var r = Go(0, t, n), o = r.sliceRank, a = r.numUpdates, i = r.sliceSize, s = r.strides, u = r.outputSize, c = [\n            u / i,\n            i\n        ], l = t.reshape([\n            a,\n            o\n        ]), h = e.reshape([\n            a,\n            i\n        ]);\n        if (0 === u) return Ia(Fn([]), n);\n        var f = On(0), d = new $s(a, o, l.rank, h.rank, s, c);\n        return this.compileAndRun(d, [\n            h,\n            l,\n            f\n        ]).reshape(n);\n    }, o.prototype.sparseToDense = function(t, e, n, r) {\n        var o = Go(0, t, n), a = o.sliceRank, i = o.numUpdates, s = o.strides, u = o.outputSize, c = new $s(i, a, t.rank, e.rank, s, [\n            u,\n            1\n        ], !1);\n        return this.compileAndRun(c, [\n            e,\n            t,\n            r\n        ]).reshape(n);\n    }, o.prototype.fft = function(t) {\n        return this.fftImpl(t, !1);\n    }, o.prototype.ifft = function(t) {\n        return this.fftImpl(t, !0);\n    }, o.prototype.fftImpl = function(t, e) {\n        var n = this.texData.get(t.dataId), r = new rs(es, t.shape, e), o = new rs(ns, t.shape, e), a = [\n            this.makeComplexComponentTensorInfo(t, n.complexTensors.real),\n            this.makeComplexComponentTensorInfo(t, n.complexTensors.imag)\n        ], i = this.compileAndRun(r, a), s = this.compileAndRun(o, a), u = this.complex(i, s).as2D(t.shape[0], t.shape[1]);\n        return i.dispose(), s.dispose(), u;\n    }, o.prototype.gatherND = function(t, e) {\n        var n = e.shape, r = n[n.length - 1], o = Po(t, e), a = o[0], i = o[1], s = o[2], u = o[3], c = e.reshape([\n            i,\n            r\n        ]), l = t.reshape([\n            t.size / s,\n            s\n        ]), h = new is(r, u, [\n            i,\n            s\n        ]);\n        return this.compileAndRun(h, [\n            l,\n            c\n        ]).reshape(a);\n    }, o.prototype.fill = function(t, e, n) {\n        if (\"string\" === (n = n || j(e))) {\n            var r = P(n, k(t));\n            return r.fill(e), Lt.makeTensor(r, t, n, this);\n        }\n        var o = new os(t, e), a = o.getCustomSetupFunc(e);\n        return this.compileAndRun(o, [], n, a);\n    }, o.prototype.onesLike = function(t) {\n        if (\"string\" === t.dtype) throw new Error(\"onesLike is not supported under string dtype\");\n        return this.fill(t.shape, 1, t.dtype);\n    }, o.prototype.zerosLike = function(t) {\n        return this.fill(t.shape, \"string\" === t.dtype ? \"\" : 0, t.dtype);\n    }, o.prototype.linspace = function(t, e, n) {\n        return ka(t, e, n);\n    }, o.prototype.makeTensorInfo = function(t, e) {\n        var n = this.write(null, t, e);\n        return this.texData.get(n).usage = null, {\n            dataId: n,\n            shape: t,\n            dtype: e\n        };\n    }, o.prototype.makeOutput = function(t, e) {\n        var n = this.makeTensorInfo(t, e).dataId;\n        return Lt.makeTensorFromDataId(n, t, e, this);\n    }, o.prototype.unpackTensor = function(t) {\n        var e = new Bu(t.shape);\n        return this.runWebGLProgram(e, [\n            t\n        ], t.dtype);\n    }, o.prototype.packTensor = function(t) {\n        var e = new Bs(t.shape);\n        return this.runWebGLProgram(e, [\n            t\n        ], t.dtype, null, !0);\n    }, o.prototype.packedReshape = function(t, e) {\n        var n = [\n            Ae(t.shape)\n        ].concat(Te(t.shape)), r = {\n            dtype: t.dtype,\n            shape: n,\n            dataId: t.dataId\n        }, o = [\n            Ae(e)\n        ].concat(Te(e)), a = new zs(o, n), i = this.runWebGLProgram(a, [\n            r\n        ], t.dtype, null, !0);\n        return {\n            dataId: i.dataId,\n            shape: e,\n            dtype: i.dtype\n        };\n    }, o.prototype.decode = function(t) {\n        var e, n = this.texData.get(t), r = n.isPacked, o = n.shape, a = n.dtype, i = De(o);\n        e = r ? new Xi(i) : new ji(i);\n        return {\n            dtype: a,\n            shape: o,\n            dataId: this.runWebGLProgram(e, [\n                {\n                    shape: i,\n                    dtype: a,\n                    dataId: t\n                }\n            ], a, null, !0).dataId\n        };\n    }, o.prototype.runWebGLProgram = function(t, e, n, r, o) {\n        var a = this;\n        void 0 === o && (o = !1);\n        var s = this.makeTensorInfo(t.outputShape, n), u = this.texData.get(s.dataId);\n        if (t.packedOutput && (u.isPacked = !0), t.outPackingScheme === Vt.DENSE) {\n            var c = Yt(t.outputShape);\n            u.texShape = c.map(function(t) {\n                return 2 * t;\n            });\n        }\n        if (null != t.outTexUsage && (u.usage = t.outTexUsage), 0 === k(s.shape)) return u.values = B(s.dtype, 0), s;\n        var l = [], h = e.map(function(e) {\n            if (\"complex64\" === e.dtype) throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.\");\n            var n = a.texData.get(e.dataId);\n            if (null == n.texture) {\n                if (!t.packedInputs && k(e.shape) <= i().getNumber(\"WEBGL_SIZE_UPLOAD_UNIFORM\")) return {\n                    shape: e.shape,\n                    texData: null,\n                    isUniform: !0,\n                    uniformValues: n.values\n                };\n                t.packedInputs && (n.isPacked = !0, n.shape = e.shape);\n            } else if (!!n.isPacked != !!t.packedInputs) e = n.isPacked ? a.unpackTensor(e) : a.packTensor(e), l.push(e), n = a.texData.get(e.dataId);\n            else if (n.isPacked && !_e(n.shape, e.shape)) {\n                var r = e, o = e.shape;\n                e.shape = n.shape, e = a.packedReshape(e, o), l.push(e), n = a.texData.get(e.dataId), r.shape = o;\n            }\n            return a.uploadToGPU(e.dataId), {\n                shape: e.shape,\n                texData: n,\n                isUniform: !1\n            };\n        });\n        this.uploadToGPU(s.dataId);\n        var f, d = {\n            shape: s.shape,\n            texData: u,\n            isUniform: !1\n        }, p = function(t, e, n) {\n            var r = \"\";\n            e.concat(n).forEach(function(t) {\n                var e = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0, n = t.isUniform ? \"uniform\" : t.texData.texShape;\n                r += t.shape + \"_\" + n + \"_\" + e;\n            });\n            var o = t.userCode, a = t.constructor.name;\n            return a += \"_\" + r + \"_\" + o;\n        }(t, h, d), v = this.getAndSaveBinary(p, function() {\n            return function(t, e, n, r) {\n                var o = e.userCode, a = n.map(function(t, n) {\n                    var r = {\n                        logicalShape: t.shape,\n                        texShape: t.isUniform ? null : t.texData.texShape,\n                        isUniform: t.isUniform,\n                        isPacked: !t.isUniform && t.texData.isPacked,\n                        flatOffset: null\n                    };\n                    return null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0 && (r.flatOffset = t.texData.slice.flatOffset), {\n                        name: e.variableNames[n],\n                        shapeInfo: r\n                    };\n                }), s = a.map(function(t) {\n                    return t.shapeInfo;\n                }), u = {\n                    logicalShape: r.shape,\n                    texShape: r.texData.texShape,\n                    isUniform: !1,\n                    isPacked: r.texData.isPacked,\n                    flatOffset: null\n                }, c = Za(a, u, o, e.packedInputs), l = t.createProgram(c), h = null, f = t.getUniformLocation(l, \"NAN\", !1);\n                1 === i().getNumber(\"WEBGL_VERSION\") && (h = t.getUniformLocation(l, \"INFINITY\", !1));\n                for(var d = {}, p = 0; p < e.variableNames.length; p++){\n                    var v = e.variableNames[p];\n                    d[v] = t.getUniformLocation(l, v, !1), d[\"offset\" + v] = t.getUniformLocation(l, \"offset\" + v, !1);\n                }\n                return {\n                    program: e,\n                    source: c,\n                    webGLProgram: l,\n                    uniformLocations: d,\n                    inShapeInfos: s,\n                    outShapeInfo: u,\n                    infLoc: h,\n                    nanLoc: f\n                };\n            }(a.gpgpu, t, h, d);\n        }), g = null != this.activeTimers;\n        if (g && (f = this.startTimer()), function(t, e, n, r, o) {\n            ks(e.inShapeInfos, n), ks([\n                e.outShapeInfo\n            ], [\n                r\n            ]);\n            var a = r.texData.texture, s = r.texData.texShape;\n            r.texData.isPacked ? t.setOutputPackedMatrixTexture(a, s[0], s[1]) : t.setOutputMatrixTexture(a, s[0], s[1]), t.setProgram(e.webGLProgram), 1 === i().getNumber(\"WEBGL_VERSION\") && null !== e.infLoc && t.gl.uniform1f(e.infLoc, 1 / 0), null !== e.nanLoc && t.gl.uniform1f(e.nanLoc, NaN), n.forEach(function(n, r) {\n                var o = e.program.variableNames[r], a = e.uniformLocations[o], i = e.uniformLocations[\"offset\" + o];\n                if (null != a) if (n.isUniform) if (k(n.shape) < 2) t.gl.uniform1f(a, n.uniformValues[0]);\n                else {\n                    var s = n.uniformValues;\n                    s instanceof Float32Array || (s = new Float32Array(s)), t.gl.uniform1fv(a, s);\n                }\n                else null != n.texData.slice && null != i && t.gl.uniform1i(i, n.texData.slice.flatOffset), t.setInputMatrixTexture(n.texData.texture, a, r);\n            }), null != o && o(t, e.webGLProgram), t.executeProgram();\n        }(this.gpgpu, v, h, d, r), l.forEach(function(t) {\n            return a.disposeData(t.dataId);\n        }), g && (f = this.endTimer(f), this.activeTimers.push({\n            name: t.constructor.name,\n            query: this.getQueryTime(f)\n        })), !i().getBool(\"WEBGL_LAZILY_UNPACK\") && u.isPacked && !1 === o) {\n            var m = this.unpackTensor(s);\n            return this.disposeData(s.dataId), m;\n        }\n        return s;\n    }, o.prototype.compileAndRun = function(t, e, n, r, o) {\n        void 0 === o && (o = !1), n = n || e[0].dtype;\n        var a = this.runWebGLProgram(t, e, n, r, o);\n        return Lt.makeTensorFromDataId(a.dataId, a.shape, a.dtype);\n    }, o.prototype.getAndSaveBinary = function(t, e) {\n        return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t];\n    }, o.prototype.getTextureManager = function() {\n        return this.textureManager;\n    }, o.prototype.dispose = function() {\n        var t = this;\n        if (!this.disposed) {\n            if (!i().getBool(\"IS_TEST\")) Object.keys(this.binaryCache).forEach(function(e) {\n                t.gpgpu.deleteProgram(t.binaryCache[e].webGLProgram), delete t.binaryCache[e];\n            });\n            this.textureManager.dispose(), null != this.canvas && \"undefined\" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0;\n        }\n    }, o.prototype.floatPrecision = function() {\n        var t = this;\n        return null == this.floatPrecisionValue && (this.floatPrecisionValue = Ze(function() {\n            if (!i().get(\"WEBGL_RENDER_FLOAT32_ENABLED\")) {\n                var e = i().getBool(\"DEBUG\");\n                i().set(\"DEBUG\", !1);\n                var n = t.abs(On(1e-8)).dataSync()[0];\n                if (i().set(\"DEBUG\", e), n > 0) return 32;\n            }\n            return 16;\n        })), this.floatPrecisionValue;\n    }, o.prototype.epsilon = function() {\n        return 32 === this.floatPrecision() ? 1e-7 : 1e-4;\n    }, o.prototype.uploadToGPU = function(t) {\n        var e, n = this.texData.get(t), r = n.shape, o = n.dtype, a = n.values, i = n.texture, s = n.usage, u = n.isPacked;\n        if (null == i) {\n            var c, l = null != this.activeTimers;\n            l && (c = et());\n            var h = n.texShape;\n            if (null == h && (h = Ne(r, u), n.texShape = h), null != a) {\n                var f = De(r), d = void 0, p = h[1], v = h[0], g = a instanceof Uint8Array;\n                u ? (p = (e = $t(h[0], h[1]))[0], v = e[1], d = new ts(f, [\n                    v,\n                    p\n                ], g)) : d = new Zi(f, [\n                    v,\n                    p\n                ], g);\n                var m = this.makeTensorInfo([\n                    v,\n                    p\n                ], o);\n                this.texData.get(m.dataId).usage = g ? zt.PIXELS : zt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(m.dataId), p, v, a);\n                var y = this.runWebGLProgram(d, [\n                    m\n                ], o, null, !0), x = this.texData.get(y.dataId);\n                n.texture = x.texture, n.texShape = x.texShape, n.isPacked = x.isPacked, n.usage = x.usage, this.disposeData(m.dataId), this.texData.delete(y.dataId), n.values = null, l && (this.uploadWaitMs += et() - c);\n            } else {\n                var b = this.acquireTexture(h, s, o, u);\n                n.texture = b;\n            }\n        }\n    }, o.prototype.convertAndCacheOnCPU = function(t, e) {\n        var n = this.texData.get(t), r = n.dtype;\n        return this.releaseGPUData(t), null != e && (n.values = function(t, e) {\n            if (\"float32\" === e || \"complex64\" === e) return t;\n            if (\"int32\" === e || \"bool\" === e) {\n                for(var n = \"int32\" === e ? new Int32Array(t.length) : new Uint8Array(t.length), r = 0; r < n.length; ++r)n[r] = Math.round(t[r]);\n                return n;\n            }\n            throw new Error(\"Unknown dtype \" + e);\n        }(e, r)), n.values;\n    }, o.prototype.acquireTexture = function(t, e, n, r) {\n        if (this.numBytesInGPU += this.computeBytes(t, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {\n            var o = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n            this.warnedAboutMemory = !0, console.warn(\"High memory usage in GPU: \" + o + \" MB, most likely due to a memory leak\");\n        }\n        return this.textureManager.acquireTexture(t, e, r);\n    }, o.prototype.computeBytes = function(t, e) {\n        return t[0] * t[1] * z(e);\n    }, o;\n}(la);\nWt() && Lt.registerBackend(\"webgl\", function() {\n    return new Uu;\n}, 2);\n\"undefined\" != typeof globalThis ? globalThis :  false ? 0 : \"undefined\" != typeof global ? global : \"undefined\" != typeof self && self;\nfunction Vu(t, e) {\n    return t(e = {\n        exports: {}\n    }, e.exports), e.exports;\n}\nvar zu = Vu(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e, n = this, r = (e = 4022871197, function(t) {\n                t = t.toString();\n                for(var n = 0; n < t.length; n++){\n                    var r = .02519603282416938 * (e += t.charCodeAt(n));\n                    r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e);\n                }\n                return 2.3283064365386963e-10 * (e >>> 0);\n            });\n            n.next = function() {\n                var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;\n                return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t);\n            }, n.c = 1, n.s0 = r(\" \"), n.s1 = r(\" \"), n.s2 = r(\" \"), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null;\n        }\n        function o(t, e) {\n            return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e;\n        }\n        function a(t, e) {\n            var n = new r(t), a = e && e.state, i = n.next;\n            return i.int32 = function() {\n                return 4294967296 * n.next() | 0;\n            }, i.double = function() {\n                return i() + 11102230246251565e-32 * (2097152 * i() | 0);\n            }, i.quick = i, a && (\"object\" == typeof a && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.alea = a;\n    }(0, t, !1);\n}), Gu = Vu(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e = this, n = \"\";\n            e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function() {\n                var t = e.x ^ e.x << 11;\n                return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8;\n            }, t === (0 | t) ? e.x = t : n += t;\n            for(var r = 0; r < n.length + 64; r++)e.x ^= 0 | n.charCodeAt(r), e.next();\n        }\n        function o(t, e) {\n            return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e;\n        }\n        function a(t, e) {\n            var n = new r(t), a = e && e.state, i = function() {\n                return (n.next() >>> 0) / 4294967296;\n            };\n            return i.double = function() {\n                do {\n                    var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n                }while (0 === t);\n                return t;\n            }, i.int32 = n.next, i.quick = i, a && (\"object\" == typeof a && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.xor128 = a;\n    }(0, t, !1);\n}), Hu = Vu(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e = this, n = \"\";\n            e.next = function() {\n                var t = e.x ^ e.x >>> 2;\n                return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0;\n            }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t;\n            for(var r = 0; r < n.length + 64; r++)e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next();\n        }\n        function o(t, e) {\n            return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e;\n        }\n        function a(t, e) {\n            var n = new r(t), a = e && e.state, i = function() {\n                return (n.next() >>> 0) / 4294967296;\n            };\n            return i.double = function() {\n                do {\n                    var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n                }while (0 === t);\n                return t;\n            }, i.int32 = n.next, i.quick = i, a && (\"object\" == typeof a && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.xorwow = a;\n    }(0, t, !1);\n}), qu = Vu(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e = this;\n            e.next = function() {\n                var t, n, r = e.x, o = e.i;\n                return t = r[o], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[o + 1 & 7]) ^ t >>> 10, n ^= (t = r[o + 3 & 7]) ^ t >>> 3, n ^= (t = r[o + 4 & 7]) ^ t << 7, t = r[o + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[o] = n, e.i = o + 1 & 7, n;\n            }, function(t, e) {\n                var n, r = [];\n                if (e === (0 | e)) r[0] = e;\n                else for(e = \"\" + e, n = 0; n < e.length; ++n)r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13;\n                for(; r.length < 8;)r.push(0);\n                for(n = 0; n < 8 && 0 === r[n]; ++n);\n                for(8 == n ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n)t.next();\n            }(e, t);\n        }\n        function o(t, e) {\n            return e.x = t.x.slice(), e.i = t.i, e;\n        }\n        function a(t, e) {\n            null == t && (t = +new Date);\n            var n = new r(t), a = e && e.state, i = function() {\n                return (n.next() >>> 0) / 4294967296;\n            };\n            return i.double = function() {\n                do {\n                    var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n                }while (0 === t);\n                return t;\n            }, i.int32 = n.next, i.quick = i, a && (a.x && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.xorshift7 = a;\n    }(0, t, !1);\n}), Ku = Vu(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e = this;\n            e.next = function() {\n                var t, n, r = e.w, o = e.X, a = e.i;\n                return e.w = r = r + 1640531527 | 0, n = o[a + 34 & 127], t = o[a = a + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = o[a] = n ^ t, e.i = a, n + (r ^ r >>> 16) | 0;\n            }, function(t, e) {\n                var n, r, o, a, i, s = [], u = 128;\n                for(e === (0 | e) ? (r = e, e = null) : (e += \"\\x00\", r = 0, u = Math.max(u, e.length)), o = 0, a = -32; a < u; ++a)e && (r ^= e.charCodeAt((a + 32) % e.length)), 0 === a && (i = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, a >= 0 && (i = i + 1640531527 | 0, o = 0 == (n = s[127 & a] ^= r + i) ? o + 1 : 0);\n                for(o >= 128 && (s[127 & (e && e.length || 0)] = -1), o = 127, a = 512; a > 0; --a)r = s[o + 34 & 127], n = s[o = o + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[o] = r ^ n;\n                t.w = i, t.X = s, t.i = o;\n            }(e, t);\n        }\n        function o(t, e) {\n            return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e;\n        }\n        function a(t, e) {\n            null == t && (t = +new Date);\n            var n = new r(t), a = e && e.state, i = function() {\n                return (n.next() >>> 0) / 4294967296;\n            };\n            return i.double = function() {\n                do {\n                    var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n                }while (0 === t);\n                return t;\n            }, i.int32 = n.next, i.quick = i, a && (a.X && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.xor4096 = a;\n    }(0, t, !1);\n}), ju = Vu(function(t) {\n    !function(t, e, n) {\n        function r(t) {\n            var e = this, n = \"\";\n            e.next = function() {\n                var t = e.b, n = e.c, r = e.d, o = e.a;\n                return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ o, o = o - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ o, e.a = o - t | 0;\n            }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t;\n            for(var r = 0; r < n.length + 20; r++)e.b ^= 0 | n.charCodeAt(r), e.next();\n        }\n        function o(t, e) {\n            return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e;\n        }\n        function a(t, e) {\n            var n = new r(t), a = e && e.state, i = function() {\n                return (n.next() >>> 0) / 4294967296;\n            };\n            return i.double = function() {\n                do {\n                    var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n                }while (0 === t);\n                return t;\n            }, i.int32 = n.next, i.quick = i, a && (\"object\" == typeof a && o(a, n), i.state = function() {\n                return o(n, {});\n            }), i;\n        }\n        e && e.exports ? e.exports = a : n && n.amd ? n(function() {\n            return a;\n        }) : this.tychei = a;\n    }(0, t, !1);\n}), Xu = Vu(function(t) {\n    !function(e, n) {\n        var r, o = this, a = 256, i = 6, s = \"random\", u = n.pow(a, i), c = n.pow(2, 52), l = 2 * c, h = a - 1;\n        function f(t, h, f) {\n            var m = [], y = v(function t(e, n) {\n                var r, o = [], a = typeof e;\n                if (n && \"object\" == a) for(r in e)try {\n                    o.push(t(e[r], n - 1));\n                } catch (t) {}\n                return o.length ? o : \"string\" == a ? e : e + \"\\x00\";\n            }((h = 1 == h ? {\n                entropy: !0\n            } : h || {}).entropy ? [\n                t,\n                g(e)\n            ] : null == t ? function() {\n                try {\n                    var t;\n                    return r && (t = r.randomBytes) ? t = t(a) : (t = new Uint8Array(a), (o.crypto || o.msCrypto).getRandomValues(t)), g(t);\n                } catch (t) {\n                    var n = o.navigator, i = n && n.plugins;\n                    return [\n                        +new Date,\n                        o,\n                        i,\n                        o.screen,\n                        g(e)\n                    ];\n                }\n            }() : t, 3), m), x = new d(m), b = function() {\n                for(var t = x.g(i), e = u, n = 0; t < c;)t = (t + n) * a, e *= a, n = x.g(1);\n                for(; t >= l;)t /= 2, e /= 2, n >>>= 1;\n                return (t + n) / e;\n            };\n            return b.int32 = function() {\n                return 0 | x.g(4);\n            }, b.quick = function() {\n                return x.g(4) / 4294967296;\n            }, b.double = b, v(g(x.S), e), (h.pass || f || function(t, e, r, o) {\n                return o && (o.S && p(o, x), t.state = function() {\n                    return p(x, {});\n                }), r ? (n[s] = t, e) : t;\n            })(b, y, \"global\" in h ? h.global : this == n, h.state);\n        }\n        function d(t) {\n            var e, n = t.length, r = this, o = 0, i = r.i = r.j = 0, s = r.S = [];\n            for(n || (t = [\n                n++\n            ]); o < a;)s[o] = o++;\n            for(o = 0; o < a; o++)s[o] = s[i = h & i + t[o % n] + (e = s[o])], s[i] = e;\n            (r.g = function(t) {\n                for(var e, n = 0, o = r.i, i = r.j, s = r.S; t--;)e = s[o = h & o + 1], n = n * a + s[h & (s[o] = s[i = h & i + e]) + (s[i] = e)];\n                return r.i = o, r.j = i, n;\n            })(a);\n        }\n        function p(t, e) {\n            return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e;\n        }\n        function v(t, e) {\n            for(var n, r = t + \"\", o = 0; o < r.length;)e[h & o] = h & (n ^= 19 * e[h & o]) + r.charCodeAt(o++);\n            return g(e);\n        }\n        function g(t) {\n            return String.fromCharCode.apply(0, t);\n        }\n        if (n[\"seed\" + s] = f, v(n.random(), e), t.exports) {\n            t.exports = f;\n            try {\n                r = __webpack_require__(/*! crypto */ \"crypto\");\n            } catch (t) {}\n        }\n    }([], Math);\n});\nXu.alea = zu, Xu.xor128 = Gu, Xu.xorwow = Hu, Xu.xorshift7 = qu, Xu.xor4096 = Ku, Xu.tychei = ju;\nvar Yu = Xu.alea;\nvar $u = An({\n    addN_: function(t) {\n        C(Array.isArray(t), function() {\n            return \"The argument passed to tf.addN() must be a list of tensors\";\n        }), C(t.length >= 1, function() {\n            return \"Must pass at least one tensor to tf.addN(), but got \" + t.length;\n        });\n        var e = t.map(function(t, e) {\n            return gn(t, \"tensors\" + e, \"addN\");\n        }), n = e[0];\n        e.forEach(function(t) {\n            if (t.dtype !== n.dtype) throw new Error(\"All tensors passed to tf.addN() must have the same dtype\");\n        }), e.forEach(function(t) {\n            if (!S(t.shape, n.shape)) throw new Error(\"All tensors passed to tf.addN() must have the same shape\");\n        });\n        var r = e;\n        return Lt.runKernelFunc(function(t, n) {\n            return t.addN(e);\n        }, r, null, \"AddN\");\n    }\n});\nfunction Qu() {\n    Xe(\"tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon\");\n}\nfunction Ju(t) {\n    return 0 === t.rank || 1 === t.rank ? t.as4D(1, 1, 1, t.size) : 2 === t.rank ? t.as4D(1, 1, t.shape[0], t.shape[1]) : 3 === t.rank ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2]) : t;\n}\nfunction Zu(t, e, n, r, o, a) {\n    null == a && (a = .001);\n    var i, s, u = gn(t, \"x\", \"batchNorm\"), c = gn(e, \"mean\", \"batchNorm\"), l = gn(n, \"variance\", \"batchNorm\");\n    null != o && (i = gn(o, \"scale\", \"batchNorm\")), null != r && (s = gn(r, \"offset\", \"batchNorm\")), C(c.rank === l.rank, function() {\n        return \"Batch normalization gradient requires mean and variance to have equal ranks.\";\n    }), C(null == s || c.rank === s.rank, function() {\n        return \"Batch normalization gradient requires mean and offset to have equal ranks.\";\n    }), C(null == i || c.rank === i.rank, function() {\n        return \"Batch normalization gradient requires mean and scale to have equal ranks.\";\n    });\n    var h = {\n        x: u,\n        scale: i,\n        offset: s,\n        mean: c,\n        variance: l\n    }, f = {\n        varianceEpsilon: a\n    };\n    return Lt.runKernelFunc(function(t, e) {\n        var n = Ju(u), r = t.batchNormalization(n, tc(c), tc(l), a, tc(i), tc(s));\n        return e([\n            u,\n            c,\n            l,\n            i\n        ]), r;\n    }, h, null, \"FusedBatchNorm\", f).reshape(u.shape);\n}\nfunction tc(t) {\n    return null == t ? null : 0 === t.rank ? t.as1D() : 1 === t.rank ? t : 2 === t.rank ? t.as4D(1, 1, t.shape[0], t.shape[1]) : 3 === t.rank ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2]) : t;\n}\nvar ec = An({\n    batchNormalization_: function(t, e, n, r, o, a) {\n        return void 0 === r && (r = .001), Qu(), Zu(t, e, n, a, o, r);\n    }\n}), nc = An({\n    batchNorm_: Zu\n});\nfunction rc(t, e, n, r, o, a) {\n    var i, s, u = gn(t, \"x\", \"batchNorm\"), c = gn(e, \"mean\", \"batchNorm\"), l = gn(n, \"variance\", \"batchNorm\");\n    return null != o && (i = gn(o, \"scale\", \"batchNorm\")), null != r && (s = gn(r, \"offset\", \"batchNorm\")), C(2 === u.rank, function() {\n        return \"Error in batchNorm3D: x must be rank 3 but got rank \" + u.rank + \".\";\n    }), C(2 === c.rank || 1 === c.rank, function() {\n        return \"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank \" + c.rank + \".\";\n    }), C(2 === l.rank || 1 === l.rank, function() {\n        return \"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank \" + l.rank + \".\";\n    }), null != i && C(2 === i.rank || 1 === i.rank, function() {\n        return \"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank \" + i.rank + \".\";\n    }), null != s && C(2 === s.rank || 1 === s.rank, function() {\n        return \"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank \" + s.rank + \".\";\n    }), nc(u, c, l, s, i, a);\n}\nvar oc = An({\n    batchNormalization2d_: function(t, e, n, r, o, a) {\n        return void 0 === r && (r = .001), Qu(), rc(t, e, n, a, o, r);\n    }\n}), ac = An({\n    batchNorm2d_: rc\n});\nfunction ic(t, e, n, r, o, a) {\n    var i, s, u = gn(t, \"x\", \"batchNorm\"), c = gn(e, \"mean\", \"batchNorm\"), l = gn(n, \"variance\", \"batchNorm\");\n    return null != o && (i = gn(o, \"scale\", \"batchNorm\")), null != r && (s = gn(r, \"offset\", \"batchNorm\")), C(3 === u.rank, function() {\n        return \"Error in batchNorm3D: x must be rank 3 but got rank \" + u.rank + \".\";\n    }), C(3 === c.rank || 1 === c.rank, function() {\n        return \"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank \" + c.rank + \".\";\n    }), C(3 === l.rank || 1 === l.rank, function() {\n        return \"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank \" + l.rank + \".\";\n    }), null != i && C(3 === i.rank || 1 === i.rank, function() {\n        return \"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank \" + i.rank + \".\";\n    }), null != s && C(3 === s.rank || 1 === s.rank, function() {\n        return \"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank \" + s.rank + \".\";\n    }), nc(u, c, l, s, i, a);\n}\nvar sc = An({\n    batchNormalization3d_: function(t, e, n, r, o, a) {\n        return void 0 === r && (r = .001), Qu(), ic(t, e, n, a, o, r);\n    }\n}), uc = An({\n    batchNorm3d_: ic\n});\nfunction cc(t, e, n, r, o, a) {\n    var i, s, u = gn(t, \"x\", \"batchNorm\"), c = gn(e, \"mean\", \"batchNorm\"), l = gn(n, \"variance\", \"batchNorm\");\n    return null != o && (i = gn(o, \"scale\", \"batchNorm\")), null != r && (s = gn(r, \"offset\", \"batchNorm\")), C(4 === u.rank, function() {\n        return \"Error in batchNorm4D: x must be rank 4 but got rank \" + u.rank + \".\";\n    }), C(4 === c.rank || 1 === c.rank, function() {\n        return \"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank \" + c.rank + \".\";\n    }), C(4 === l.rank || 1 === l.rank, function() {\n        return \"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank \" + l.rank + \".\";\n    }), null != i && C(4 === i.rank || 1 === i.rank, function() {\n        return \"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank \" + i.rank + \".\";\n    }), null != s && C(4 === s.rank || 1 === s.rank, function() {\n        return \"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank \" + s.rank + \".\";\n    }), nc(u, c, l, s, i, a);\n}\nvar lc = An({\n    batchNormalization4d_: function(t, e, n, r, o, a) {\n        return void 0 === r && (r = .001), Qu(), cc(t, e, n, a, o, r);\n    }\n}), hc = An({\n    batchNorm4d_: cc\n});\nvar fc = An({\n    broadcastTo_: function(t, e) {\n        var n = gn(t, \"broadcastTo\", \"x\"), r = n.shape;\n        if (e.some(function(t) {\n            return !(t > 0) || t % 1 != 0;\n        })) throw new Error(\"broadcastTo(): Invalid broadcast shape [\" + e + \"].\");\n        if (e.length < n.rank) throw new Error(\"broadcastTo(): shape.length=\" + e.length + \" < input.rank=\" + n.rank + \".\");\n        if (e.length > n.rank) {\n            for(var o = n.shape.slice(); o.length < e.length;)o.unshift(1);\n            n = n.reshape(o);\n        }\n        for(var a = n.shape, i = Array.from(e), s = e.length - 1; s >= 0; s--)if (a[s] === e[s]) i[s] = 1;\n        else if (1 !== n.shape[s]) throw new Error(\"broadcastTo(): [\" + r + \"] cannot be broadcast to [\" + e + \"].\");\n        var u = i.map(function(t, e) {\n            return t > 1 ? e : -1;\n        }).filter(function(t) {\n            return t >= 0;\n        });\n        if (0 === u.length) return n.clone();\n        var c = {\n            x: n\n        }, l = {\n            shape: e,\n            inputShape: a\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.tile(n, i);\n        }, c, function(t) {\n            return {\n                x: function() {\n                    return t.sum(u, !0);\n                }\n            };\n        }, Sr, l);\n    }\n});\nvar dc = An({\n    clone_: function(t) {\n        var e = gn(t, \"x\", \"clone\", null);\n        return Lt.runKernelFunc(function() {\n            return Lt.makeTensorFromDataId(e.dataId, e.shape, e.dtype);\n        }, {\n            x: e\n        }, null, Tr);\n    }\n});\nvar pc = An({\n    logicalAnd_: function(t, e) {\n        var n = gn(t, \"a\", \"logicalAnd\", \"bool\"), r = gn(e, \"b\", \"logicalAnd\", \"bool\");\n        return Pr(n.shape, r.shape), Lt.runKernelFunc(function(t) {\n            return t.logicalAnd(n, r);\n        }, {\n            a: n,\n            b: r\n        }, null, \"LogicalAnd\");\n    }\n}), vc = An({\n    logicalNot_: function(t) {\n        var e = gn(t, \"x\", \"logicalNot\", \"bool\");\n        return Lt.runKernelFunc(function(t) {\n            return t.logicalNot(e);\n        }, {\n            $x: e\n        });\n    }\n}), gc = An({\n    logicalOr_: function(t, e) {\n        var n = gn(t, \"a\", \"logicalOr\", \"bool\"), r = gn(e, \"b\", \"logicalOr\", \"bool\");\n        return Pr(n.shape, r.shape), Lt.runKernelFunc(function(t) {\n            return t.logicalOr(n, r);\n        }, {\n            $a: n,\n            $b: r\n        });\n    }\n}), mc = An({\n    logicalXor_: function(t, e) {\n        var n = gn(t, \"a\", \"logicalXor\", \"bool\"), r = gn(e, \"b\", \"logicalXor\", \"bool\");\n        return Pr(n.shape, r.shape), gc(t, e).logicalAnd(pc(t, e).logicalNot());\n    }\n}), yc = An({\n    where_: function(t, e, n) {\n        var r = gn(e, \"a\", \"where\"), o = gn(n, \"b\", \"where\"), a = gn(t, \"condition\", \"where\", \"bool\");\n        return E(r.shape, o.shape, \"Error in where: \"), 1 === a.rank ? C(a.shape[0] === r.shape[0], function() {\n            return \"The first dimension of `a` must match the size of `condition`.\";\n        }) : E(a.shape, o.shape, \"Error in where: \"), Lt.runKernelFunc(function(t, e) {\n            var n = t.select(a, r, o);\n            return e([\n                a\n            ]), n;\n        }, {\n            $condition: a,\n            $a: r,\n            $b: o\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $condition: function() {\n                    return Xn(n).toFloat();\n                },\n                $a: function() {\n                    return t.mul(n.cast(t.dtype));\n                },\n                $b: function() {\n                    return t.mul(n.logicalNot().cast(t.dtype));\n                }\n            };\n        });\n    }\n}), xc = function(t) {\n    return n(this, void 0, void 0, function() {\n        var e, n, o;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return [\n                        4,\n                        (e = gn(t, \"condition\", \"whereAsync\", \"bool\")).data()\n                    ];\n                case 1:\n                    return n = r.sent(), o = Ga(e.shape, n), t !== e && e.dispose(), [\n                        2,\n                        o\n                    ];\n            }\n        });\n    });\n};\nvar bc = An({\n    divNoNan_: function(t, e) {\n        var n, r = gn(t, \"a\", \"div\"), o = gn(e, \"b\", \"div\");\n        r = (n = Nt(r, o))[0], o = n[1];\n        var a = Bo(r, o), i = Xn(a), s = o.equal(i);\n        return yc(s, i, a);\n    }\n});\nvar wc = An({\n    tile_: function(t, e) {\n        var n = gn(t, \"x\", \"tile\", null);\n        C(n.rank === e.length, function() {\n            return \"Error in transpose: rank of input \" + n.rank + \" must match length of reps \" + e + \".\";\n        });\n        var r = [\n            n\n        ], o = {\n            x: n\n        }, a = {\n            reps: e\n        };\n        return Lt.runKernelFunc(function(t, r) {\n            var o = t.tile(n, e);\n            return r([\n                n\n            ]), o;\n        }, o, null, Dr, a, r);\n    }\n});\nvar Cc = An({\n    eye_: function(t, e, n, r) {\n        void 0 === r && (r = \"float32\"), null == e && (e = t);\n        for(var o = er([\n            t,\n            e\n        ], r), a = t <= e ? t : e, i = 0; i < a; ++i)o.set(1, i, i);\n        var s = o.toTensor().as2D(t, e);\n        if (null == n) return s;\n        if (1 === n.length) return wc(sr(s, 0), [\n            n[0],\n            1,\n            1\n        ]);\n        if (2 === n.length) return wc(sr(sr(s, 0), 0), [\n            n[0],\n            n[1],\n            1,\n            1\n        ]);\n        if (3 === n.length) return wc(sr(sr(sr(s, 0), 0), 0), [\n            n[0],\n            n[1],\n            n[2],\n            1,\n            1\n        ]);\n        throw new Error(\"eye() currently supports only 1D and 2D batchShapes, but received \" + n.length + \"D.\");\n    }\n});\nvar Ec = An({\n    multinomial_: function(t, e, n, r) {\n        void 0 === r && (r = !1);\n        var o = gn(t, \"logits\", \"multinomial\"), a = o.size, i = o.rank;\n        if (a < 2) throw new Error(\"Error in multinomial: you need at least 2 outcomes, but got \" + a + \".\");\n        if (i > 2) throw new Error(\"Rank of probabilities must be 1 or 2, but is \" + i);\n        n = n || Math.random();\n        var s = 1 === i ? o.as2D(1, -1) : o, u = Lt.runKernelFunc(function(t) {\n            return t.multinomial(s, r, e, n);\n        }, {\n            logits2D: s\n        });\n        return 1 === i ? u.as1D() : u;\n    }\n});\nvar Rc = An({\n    oneHot_: function(t, e, n, r) {\n        if (void 0 === n && (n = 1), void 0 === r && (r = 0), e < 2) throw new Error(\"Error in oneHot: depth must be >=2, but it is \" + e);\n        var o = gn(t, \"indices\", \"oneHot\", \"int32\"), a = o.shape.concat([\n            e\n        ]), i = {\n            indices: o = o.flatten()\n        }, s = {\n            depth: e,\n            onValue: n,\n            offValue: r\n        };\n        return Lt.runKernelFunc(function(t, a) {\n            return a([\n                o\n            ]), t.oneHot(o, e, n, r);\n        }, i, null, Ar, s).reshape(a);\n    }\n});\nvar Ic = An({\n    pad_: function(t, e, n) {\n        void 0 === n && (n = 0);\n        var r = gn(t, \"x\", \"pad\");\n        if (0 === r.rank) throw new Error(\"pad(scalar) is not defined. Pass non-scalar to pad\");\n        var o = {\n            paddings: e,\n            constantValue: n\n        }, a = {\n            x: r\n        };\n        return Lt.runKernelFunc(function(t, o) {\n            return o([\n                r\n            ]), t.pad(r, e, n);\n        }, a, null, Nr, o);\n    }\n});\nvar kc = An({\n    pad1d_: function(t, e, n) {\n        return void 0 === n && (n = 0), C(2 === e.length, function() {\n            return \"Invalid number of paddings. Must be length of 2.\";\n        }), Ic(t, [\n            e\n        ], n);\n    }\n});\nvar Sc = An({\n    pad2d_: function(t, e, n) {\n        return void 0 === n && (n = 0), C(2 === e.length && 2 === e[0].length && 2 === e[1].length, function() {\n            return \"Invalid number of paddings. Must be length of 2 each.\";\n        }), Ic(t, e, n);\n    }\n});\nvar Ac = An({\n    pad3d_: function(t, e, n) {\n        return void 0 === n && (n = 0), C(3 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length, function() {\n            return \"Invalid number of paddings. Must be length of 2 each.\";\n        }), Ic(t, e, n);\n    }\n});\nvar Tc = An({\n    pad4d_: function(t, e, n) {\n        return void 0 === n && (n = 0), C(4 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length && 2 === e[3].length, function() {\n            return \"Invalid number of paddings. Must be length of 2 each.\";\n        }), Ic(t, e, n);\n    }\n});\nvar Dc = An({\n    rand_: function(t, e, n) {\n        var r = k(t), o = null;\n        if (null == n || \"float32\" === n) o = new Float32Array(r);\n        else if (\"int32\" === n) o = new Int32Array(r);\n        else {\n            if (\"bool\" !== n) throw new Error(\"Unknown data type \" + n);\n            o = new Uint8Array(r);\n        }\n        for(var a = 0; a < r; a++)o[a] = e();\n        return Lt.makeTensor(o, t, n);\n    }\n}), Nc = .001, Fc = .1;\nfunction _c() {\n    return 32 === Lt.backend.floatPrecision() ? Nc : Fc;\n}\nfunction Oc(t, e, n) {\n    var r = !0;\n    if ((V(t) || V(e)) && (r = !1), V(t) && V(e) && (r = !0), r) {\n        var o = t.constructor.name, a = e.constructor.name;\n        if (o !== a) throw new Error(\"Arrays are of different type. Actual: \" + o + \". Expected: \" + a);\n    }\n    if (Array.isArray(t) && Array.isArray(e)) {\n        var i = pn(t), s = pn(e);\n        if (!S(i, s)) throw new Error(\"Arrays have different shapes. Actual: [\" + i + \"]. Expected: [\" + s + \"]\");\n    }\n    var u = V(t) ? t : I(t), c = V(e) ? e : I(e);\n    if (u.length !== c.length) throw new Error(\"Arrays have different lengths actual: \" + u.length + \" vs expected: \" + c.length + \".\\nActual:   \" + u + \".\\nExpected: \" + c + \".\");\n    for(var l = 0; l < c.length; ++l){\n        var h = u[l], f = c[l];\n        if (!n(h, f)) throw new Error(\"Arrays differ: actual[\" + l + \"] = \" + h + \", expected[\" + l + \"] = \" + f + \".\\nActual:   \" + u + \".\\nExpected: \" + c + \".\");\n    }\n}\nfunction Mc(t, e, n) {\n    return !isFinite(t) && !isFinite(e) || !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n);\n}\nvar Bc = Object.freeze({\n    TEST_EPSILON_FLOAT16: Fc,\n    expectArraysClose: function(t, e, n) {\n        return null == n && (n = _c()), Oc(t, e, function(t, e) {\n            return Mc(t, e, n);\n        });\n    },\n    testEpsilon: _c,\n    expectPromiseToFail: function(t, e) {\n        t().then(function() {\n            return e.fail();\n        }, function() {\n            return e();\n        });\n    },\n    expectArraysEqual: function(t, e) {\n        var n = \"string\" == typeof e || \"number\" == typeof e || \"boolean\" == typeof e ? [\n            e\n        ] : e;\n        return H(t) || H(t[0]) || H(e) || H(e[0]) ? Oc(t, n, function(t, e) {\n            return t == e;\n        }) : Oc(t, e, function(t, e) {\n            return Mc(t, e, 0);\n        });\n    },\n    expectNumbersClose: function(t, e, n) {\n        if (null == n && (n = _c()), !Mc(t, e, n)) throw new Error(\"Numbers differ: actual === \" + t + \", expected === \" + e);\n    },\n    expectValuesInRange: function(t, e, n) {\n        for(var r = 0; r < t.length; r++)if (t[r] < e || t[r] > n) throw new Error(\"Value out of range:\" + t[r] + \" low: \" + e + \", high: \" + n);\n    },\n    expectArrayBuffersEqual: function(t, e) {\n        expect(new Float32Array(t)).toEqual(new Float32Array(e));\n    }\n}), Pc = function() {\n    function t(t, e, n, r, o) {\n        this.mean = t, this.stdDev = e, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);\n        var a = o || Math.random();\n        this.random = Yu(a.toString());\n    }\n    return t.prototype.nextValue = function() {\n        if (!isNaN(this.nextVal)) {\n            var t = this.nextVal;\n            return this.nextVal = NaN, t;\n        }\n        for(var e, n, r = !1; !r;){\n            var o = void 0, a = void 0, i = void 0;\n            do {\n                i = (o = 2 * this.random() - 1) * o + (a = 2 * this.random() - 1) * a;\n            }while (i >= 1 || 0 === i);\n            var s = Math.sqrt(-2 * Math.log(i) / i);\n            e = this.mean + this.stdDev * o * s, n = this.mean + this.stdDev * a * s, this.truncated && !this.isValidTruncated(e) || (r = !0);\n        }\n        return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(e);\n    }, t.prototype.convertValue = function(t) {\n        return null == this.dtype || \"float32\" === this.dtype ? t : Math.round(t);\n    }, t.prototype.isValidTruncated = function(t) {\n        return t <= this.upper && t >= this.lower;\n    }, t;\n}(), Lc = function() {\n    function t(t, e, n, r) {\n        this.alpha = t, this.beta = 1 / e, this.dtype = n;\n        var o = r || Math.random();\n        this.randu = Yu(o.toString()), this.randn = new Pc(0, 1, n, !1, this.randu()), this.d = t < 1 ? t + 2 / 3 : t - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);\n    }\n    return t.prototype.nextValue = function() {\n        for(var t, e, n, r, o, a;;){\n            do {\n                r = this.randn.nextValue(), a = 1 + this.c * r;\n            }while (a <= 0);\n            if (a *= a * a, e = 1 - .331 * (t = r * r) * t, n = .5 * t + this.d * (1 - a + Math.log(a)), (o = this.randu()) < e || Math.log(o) < n) break;\n        }\n        return a = 1 / this.beta * this.d * a, this.alpha < 1 && (a *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(a);\n    }, t.prototype.convertValue = function(t) {\n        return \"float32\" === this.dtype ? t : Math.round(t);\n    }, t;\n}(), Wc = function() {\n    function t(t, e, n, r) {\n        var o = this;\n        if (void 0 === t && (t = 0), void 0 === e && (e = 1), this.canReturnFloat = function() {\n            return null == o.dtype || \"float32\" === o.dtype;\n        }, this.min = t, this.range = e - t, this.dtype = n, null == r && (r = Math.random()), \"number\" == typeof r && (r = r.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error(\"The difference between \" + t + \" - \" + e + \" <= 1 and dtype is not float\");\n        this.random = Yu(r);\n    }\n    return t.prototype.convertValue = function(t) {\n        return this.canReturnFloat() ? t : Math.round(t);\n    }, t.prototype.nextValue = function() {\n        return this.convertValue(this.min + this.range * this.random());\n    }, t;\n}();\nvar Uc = An({\n    randomGamma_: function(t, e, n, r, o) {\n        if (void 0 === n && (n = 1), void 0 === r && (r = \"float32\"), null == n && (n = 1), null == r && (r = \"float32\"), \"float32\" !== r && \"int32\" !== r) throw new Error(\"Unsupported data type \" + r);\n        for(var a = new Lc(e, n, r, o), i = er(t, r), s = 0; s < i.values.length; s++)i.values[s] = a.nextValue();\n        return i.toTensor();\n    }\n});\nvar Vc = An({\n    randomNormal_: function(t, e, n, r, o) {\n        if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && \"bool\" === r) throw new Error(\"Unsupported data type \" + r);\n        for(var a = new Pc(e, n, r, !1, o), i = er(t, r), s = 0; s < i.values.length; s++)i.values[s] = a.nextValue();\n        return i.toTensor();\n    }\n});\nvar zc = An({\n    randomUniform_: function(t, e, n, r, o) {\n        void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = \"float32\");\n        for(var a = er(t, r), i = new Wc(e, n, null, o), s = 0; s < a.values.length; s++)a.values[s] = i.nextValue();\n        return a.toTensor();\n    }\n});\nvar Gc = An({\n    square_: function(t) {\n        var e = gn(t, \"x\", \"square\"), n = [\n            e\n        ];\n        return Lt.runKernelFunc(function(t, n) {\n            return n([\n                e\n            ]), t.square(e);\n        }, {\n            x: e\n        }, null, \"Square\", {}, n, []);\n    }\n});\nvar Hc = An({\n    squaredDifference_: function(t, e) {\n        var n, r = gn(t, \"a\", \"squaredDifference\"), o = gn(e, \"b\", \"squaredDifference\");\n        n = Nt(r, o), r = n[0], o = n[1], Pr(r.shape, o.shape);\n        var a = {\n            a: r,\n            b: o\n        }, i = [\n            r,\n            o\n        ];\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.squaredDifference(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, a, function(t, e) {\n            var n = e[0], r = e[1], o = On(2);\n            return {\n                a: function() {\n                    return t.mul(n.sub(r).mul(o));\n                },\n                b: function() {\n                    return t.mul(r.sub(n).mul(o));\n                }\n            };\n        }, Er, {}, i, []);\n    }\n});\nvar qc = An({\n    truncatedNormal_: function(t, e, n, r, o) {\n        if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && \"bool\" === r) throw new Error(\"Unsupported data type $ { dtype }\");\n        for(var a = new Pc(e, n, r, !0, o), i = er(t, r), s = 0; s < i.values.length; s++)i.values[s] = a.nextValue();\n        return i.toTensor();\n    }\n});\nvar Kc = An({\n    equal_: function(t, e) {\n        var n, r = gn(t, \"a\", \"equal\"), o = gn(e, \"b\", \"equal\");\n        return n = Nt(r, o), r = n[0], o = n[1], Pr(r.shape, o.shape), Lt.runKernelFunc(function(t) {\n            return t.equal(r, o);\n        }, {\n            $a: r,\n            $b: o\n        });\n    }\n}), jc = An({\n    equalStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"equalStrict\"), r = gn(e, \"b\", \"equalStrict\");\n        return E(n.shape, r.shape, \"Error in equalStrict: \"), n.equal(r);\n    }\n}), Xc = An({\n    greater_: function(t, e) {\n        var n, r = gn(t, \"a\", \"greater\"), o = gn(e, \"b\", \"greater\");\n        return n = Nt(r, o), r = n[0], o = n[1], Pr(r.shape, o.shape), Lt.runKernelFunc(function(t) {\n            return t.greater(r, o);\n        }, {\n            a: r,\n            b: o\n        }, null, \"Greater\");\n    }\n}), Yc = An({\n    greaterEqual_: function(t, e) {\n        var n, r = gn(t, \"a\", \"greaterEqual\"), o = gn(e, \"b\", \"greaterEqual\");\n        return n = Nt(r, o), r = n[0], o = n[1], Pr(r.shape, o.shape), Lt.runKernelFunc(function(t, e) {\n            var n = t.greaterEqual(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, function(t, e) {\n            var n = e[0], r = e[1];\n            return {\n                a: function() {\n                    return Xn(n);\n                },\n                b: function() {\n                    return Xn(r);\n                }\n            };\n        }, \"GreaterEqual\");\n    }\n}), $c = An({\n    greaterEqualStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"greaterEqualStrict\"), r = gn(e, \"b\", \"greaterEqualStrict\");\n        return E(n.shape, r.shape, \"Error in greaterEqualStrict: \"), n.greaterEqual(r);\n    }\n}), Qc = An({\n    greaterStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"greaterStrict\"), r = gn(e, \"b\", \"greaterStrict\");\n        return E(n.shape, r.shape, \"Error in greaterStrict: \"), n.greater(r);\n    }\n}), Jc = An({\n    less_: function(t, e) {\n        var n, r = gn(t, \"a\", \"less\"), o = gn(e, \"b\", \"less\");\n        return n = Nt(r, o), r = n[0], o = n[1], Pr(r.shape, o.shape), Lt.runKernelFunc(function(t) {\n            return t.less(r, o);\n        }, {\n            a: r,\n            b: o\n        }, null, \"Less\");\n    }\n}), Zc = An({\n    lessEqual_: function(t, e) {\n        var n, r = gn(t, \"a\", \"lessEqual\"), o = gn(e, \"b\", \"lessEqual\");\n        return n = Nt(r, o), r = n[0], o = n[1], Pr(r.shape, o.shape), Lt.runKernelFunc(function(t, e) {\n            var n = t.lessEqual(r, o);\n            return e([\n                r,\n                o\n            ]), n;\n        }, {\n            a: r,\n            b: o\n        }, null, \"LessEqual\");\n    }\n}), tl = An({\n    lessEqualStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"lessEqualStrict\"), r = gn(e, \"b\", \"lessEqualStrict\");\n        return E(n.shape, r.shape, \"Error in lessEqualStrict: \"), n.lessEqual(r);\n    }\n}), el = An({\n    lessStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"lessStrict\"), r = gn(e, \"b\", \"lessStrict\");\n        return E(n.shape, r.shape, \"Error in lessStrict: \"), n.less(r);\n    }\n}), nl = An({\n    notEqual_: function(t, e) {\n        var n, r = gn(t, \"a\", \"notEqual\"), o = gn(e, \"b\", \"notEqual\");\n        return n = Nt(r, o), r = n[0], o = n[1], Pr(r.shape, o.shape), Lt.runKernelFunc(function(t) {\n            return t.notEqual(r, o);\n        }, {\n            a: r,\n            b: o\n        }, null, \"NotEqual\");\n    }\n}), rl = An({\n    notEqualStrict_: function(t, e) {\n        var n = gn(t, \"a\", \"notEqualStrict\"), r = gn(e, \"b\", \"notEqualStrict\");\n        return E(n.shape, r.shape, \"Error in notEqualStrict: \"), n.notEqual(r);\n    }\n});\nfunction ol(t, e) {\n    for(var n = [], r = t; r < e; ++r)n.push(r);\n    return n;\n}\nfunction al(t) {\n    for(var e = [], n = 0; n < t.length; ++n)for(var r = 0; r < t[n].length; ++r)e.push(t[n][r]);\n    return e;\n}\nvar il = An({\n    gather_: function(t, e, n) {\n        void 0 === n && (n = 0);\n        var r = gn(t, \"x\", \"gather\"), o = gn(e, \"indices\", \"gather\", \"int32\");\n        n = O(n, r.shape)[0];\n        var a = function(t, e, n) {\n            for(var r = t.shape[n], o = [], a = 1, i = 1, s = 0; s < n; s++)o.push(t.shape[s]), a *= t.shape[s];\n            for(s = 0; s < e.rank; s++)o.push(e.shape[s]);\n            for(s = n + 1; s < t.rank; s++)o.push(t.shape[s]), i *= t.shape[s];\n            return {\n                batchSize: a,\n                sliceSize: i,\n                dimSize: r,\n                outputShape: o\n            };\n        }(r, o, n);\n        return Lt.runKernelFunc(function(t, e) {\n            var a = t.gather(r, o.flatten(), n);\n            return e([\n                o\n            ]), a;\n        }, {\n            x: r,\n            indices: o\n        }, function(t, e) {\n            var o = e[0];\n            return {\n                x: function() {\n                    var e = r.shape, a = o.size, i = e.slice(0, n), s = i.length, u = e.slice(n, e.length).slice(1), c = u.length, l = ol(0, s), h = ol(s + 1, s + 1 + c), f = al([\n                        i,\n                        [\n                            a\n                        ],\n                        u\n                    ]), d = t.reshape(f), p = o.reshape([\n                        a\n                    ]), v = al([\n                        [\n                            s\n                        ],\n                        l,\n                        h\n                    ]), g = d.transpose(v), m = sl(g, p, r.shape[n]), y = Rn(v);\n                    return m = m.transpose(y);\n                },\n                indices: function() {\n                    return o;\n                }\n            };\n        }, \"Gather\", {\n            axis: n\n        }).reshape(a.outputShape);\n    }\n}), sl = An({\n    unsortedSegmentSum_: function(t, e, n) {\n        var r = gn(t, \"x\", \"unsortedSegmentSum\"), o = gn(e, \"segmentIds\", \"unsortedSegmentSum\", \"int32\");\n        return C(A(n), function() {\n            return \"numSegments must be of dtype int\";\n        }), Lt.runKernelFunc(function(t, e) {\n            var a = t.unsortedSegmentSum(r, o, n);\n            return e([\n                o\n            ]), a;\n        }, {\n            $x: r\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return function(t, e) {\n                        for(var n = Eo(e, Xn(e)), r = il(t, n), o = Yc(e, On(0, \"int32\")), a = r.rank - o.rank, i = 0; i < a; ++i)o = sr(o, i + 1);\n                        o = pc(o, zn(r.shape, \"bool\"));\n                        var s = Xn(r);\n                        return yc(o, r, s);\n                    }(t, n);\n                }\n            };\n        });\n    }\n});\nvar ul = function(t, e, o) {\n    return n(this, void 0, void 0, function() {\n        var n, a, i, s, u, c, l, h, f, d, p, v, g;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    for(n = gn(t, \"tensor\", \"boolMask\"), a = gn(e, \"mask\", \"boolMask\", \"bool\"), i = null == o ? 0 : o, s = a.rank, u = n.shape, C(s > 0, function() {\n                        return \"mask cannot be scalar\";\n                    }), E(u.slice(i, i + s), a.shape, \"mask's shape must match the first K dimensions of tensor's shape,\"), c = 1, l = i; l < i + s; l++)c *= u[l];\n                    return h = u.slice(0, i).concat([\n                        c\n                    ], u.slice(i + s)), f = n.reshape(h), d = a.reshape([\n                        -1\n                    ]), [\n                        4,\n                        xc(d)\n                    ];\n                case 1:\n                    return p = r.sent(), v = p.squeeze([\n                        1\n                    ]), g = il(f, v, i), t !== n && n.dispose(), e !== a && a.dispose(), v.dispose(), f.dispose(), d.dispose(), p.dispose(), [\n                        2,\n                        g\n                    ];\n            }\n        });\n    });\n};\nfunction cl(t, e, n, r, o, a, i) {\n    void 0 === a && (a = \"NHWC\"), C(t.length === e.rank, function() {\n        return \"Length of inShape (\" + t.length + \") and rank of dy (\" + e.rank + \") must match\";\n    });\n    var s = t, u = e, c = !1;\n    3 === e.rank && (c = !0, u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]), s = [\n        1,\n        t[0],\n        t[1],\n        t[2]\n    ]), C(4 === s.length, function() {\n        return \"Error in conv2dDerInput: inShape must be length 4, but got length \" + s.length + \".\";\n    }), C(4 === u.rank, function() {\n        return \"Error in conv2dDerInput: dy must be rank 4, but got rank \" + u.rank;\n    }), C(4 === n.rank, function() {\n        return \"Error in conv2dDerInput: filter must be rank 4, but got rank \" + n.rank;\n    });\n    var l = \"NHWC\" === a ? s[3] : s[1], h = \"NHWC\" === a ? u.shape[3] : u.shape[1];\n    C(l === n.shape[2], function() {\n        return \"Error in conv2dDerInput: depth of input (\" + l + \") must match input depth for filter \" + n.shape[2] + \".\";\n    }), C(h === n.shape[3], function() {\n        return \"Error in conv2dDerInput: depth of output (\" + h + \") must match output depth for filter \" + n.shape[3] + \".\";\n    }), null != i && C(A(o), function() {\n        return \"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + o + \".\";\n    });\n    var f = Ea(a), d = pa(s, n.shape, r, 1, o, i, !1, f), p = Lt.runKernelFunc(function(t, e) {\n        var r = t.conv2dDerInput(u, n, d);\n        return e([\n            n,\n            u\n        ]), r;\n    }, {\n        dy4D: u,\n        filter: n\n    }, function(t, e) {\n        var n = e[0], s = e[1];\n        return {\n            dy4D: function() {\n                return dl(t, n, r, o, a, 1, i);\n            },\n            filter: function() {\n                return vl(t, s, n.shape, r, o, a, i);\n            }\n        };\n    });\n    return c ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;\n}\nfunction ll(t) {\n    var e = function(t) {\n        return \"number\" == typeof t ? [\n            t,\n            t,\n            t\n        ] : 2 === t.length ? [\n            t[0],\n            t[1],\n            1\n        ] : t;\n    }(t), n = e[0], r = e[1], o = e[2];\n    return 1 === n && 1 === r && 1 === o;\n}\nfunction hl(t, e, n, r, o) {\n    C(t.length === e.rank, function() {\n        return \"Length of inShape (\" + t.length + \") and rank of dy (\" + e.rank + \") must match\";\n    });\n    var a = t, i = e, s = !1;\n    4 === e.rank && (s = !0, i = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]), a = [\n        1,\n        t[0],\n        t[1],\n        t[2],\n        t[3]\n    ]);\n    var u = a[4], c = i.shape[4];\n    C(5 === a.length, function() {\n        return \"Error in conv3dDerInput: inShape must be length 5, but got length \" + a.length + \".\";\n    }), C(5 === i.rank, function() {\n        return \"Error in conv3dDerInput: dy must be rank 5, but got rank \" + i.rank;\n    }), C(5 === n.rank, function() {\n        return \"Error in conv3dDerInput: filter must be rank 5, but got rank \" + n.rank;\n    }), C(u === n.shape[3], function() {\n        return \"Error in conv3dDerInput: depth of input (\" + u + \") must match input depth for filter \" + n.shape[3] + \".\";\n    }), C(c === n.shape[4], function() {\n        return \"Error in conv3dDerInput: depth of output (\" + c + \") must match output depth for filter \" + n.shape[4] + \".\";\n    });\n    var l = va(a, n.shape, r, 1, o), h = Lt.runKernelFunc(function(t) {\n        return t.conv3dDerInput(i, n, l);\n    }, {\n        dy5D: i\n    });\n    return s ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n}\nvar fl = An({\n    conv1d_: function(t, e, n, r, o, a, i) {\n        void 0 === o && (o = \"NWC\"), void 0 === a && (a = 1);\n        var s = gn(t, \"x\", \"conv1d\"), u = gn(e, \"filter\", \"conv1d\"), c = s, l = !1;\n        2 === s.rank && (l = !0, c = s.as3D(1, s.shape[0], s.shape[1])), C(3 === c.rank, function() {\n            return \"Error in conv1d: input must be rank 3, but got rank \" + c.rank + \".\";\n        }), C(3 === u.rank, function() {\n            return \"Error in conv1d: filter must be rank 3, but got rank \" + u.rank + \".\";\n        }), null != i && C(A(r), function() {\n            return \"Error in conv1d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + r + \".\";\n        }), C(c.shape[2] === u.shape[1], function() {\n            return \"Error in conv1d: depth of input (\" + c.shape[2] + \") must match input depth for filter \" + u.shape[1] + \".\";\n        }), C(Ca(n, a), function() {\n            return \"Error in conv1D: Either stride or dilation must be 1. Got stride \" + n + \" and dilation '\" + a + \"'\";\n        }), C(\"NWC\" === o, function() {\n            return \"Error in conv1d: got dataFormat of \" + o + \" but only NWC is currently supported.\";\n        });\n        var h = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]), f = c.as4D(c.shape[0], 1, c.shape[1], c.shape[2]), d = dl(f, h, [\n            1,\n            n\n        ], r, \"NHWC\", [\n            1,\n            a\n        ], i);\n        return l ? d.as2D(d.shape[2], d.shape[3]) : d.as3D(d.shape[0], d.shape[2], d.shape[3]);\n    }\n}), dl = An({\n    conv2d_: function(t, e, n, r, o, a, i) {\n        void 0 === o && (o = \"NHWC\"), void 0 === a && (a = [\n            1,\n            1\n        ]);\n        var s = gn(t, \"x\", \"conv2d\"), u = gn(e, \"filter\", \"conv2d\"), c = s, l = !1;\n        3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), C(4 === c.rank, function() {\n            return \"Error in conv2d: input must be rank 4, but got rank \" + c.rank + \".\";\n        }), C(4 === u.rank, function() {\n            return \"Error in conv2d: filter must be rank 4, but got rank \" + u.rank + \".\";\n        }), null != i && C(A(r), function() {\n            return \"Error in conv2d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + r + \".\";\n        });\n        var h = \"NHWC\" === o ? c.shape[3] : c.shape[1];\n        C(h === u.shape[2], function() {\n            return \"Error in conv2d: depth of input (\" + h + \") must match input depth for filter \" + u.shape[2] + \".\";\n        }), C(Ca(n, a), function() {\n            return \"Error in conv2D: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + a + \"'\";\n        });\n        var f = Ea(o), d = pa(c.shape, u.shape, n, a, r, i, !1, f), p = [\n            u,\n            c\n        ], v = Lt.runKernelFunc(function(t, e) {\n            var n = t.conv2d(c, u, d);\n            return e([\n                u,\n                c\n            ]), n;\n        }, {\n            x: c,\n            filter: u\n        }, function(t, e) {\n            var i = e, s = i[0], u = i[1];\n            return C(wa(a), function() {\n                return \"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '\" + a + \"'\";\n            }), {\n                x: function() {\n                    return gl(u.shape, t, s, n, r, o);\n                },\n                filter: function() {\n                    return vl(u, t, s.shape, n, r, o);\n                }\n            };\n        }, \"Conv2D\", d, p);\n        return l ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;\n    }\n}), pl = An({\n    conv3d_: function(t, e, n, r, o, a) {\n        void 0 === o && (o = \"NDHWC\"), void 0 === a && (a = [\n            1,\n            1,\n            1\n        ]);\n        var i = gn(t, \"x\", \"conv3d\"), s = gn(e, \"filter\", \"conv3d\"), u = i, c = !1;\n        4 === i.rank && (c = !0, u = i.as5D(1, i.shape[0], i.shape[1], i.shape[2], i.shape[3])), C(5 === u.rank, function() {\n            return \"Error in conv3d: input must be rank 5, but got rank \" + u.rank + \".\";\n        }), C(5 === s.rank, function() {\n            return \"Error in conv3d: filter must be rank 5, but got rank \" + s.rank + \".\";\n        }), C(u.shape[4] === s.shape[3], function() {\n            return \"Error in conv3d: depth of input (\" + u.shape[4] + \") must match input depth for filter \" + s.shape[3] + \".\";\n        }), C(function(t, e) {\n            return ll(t) || ll(e);\n        }(n, a), function() {\n            return \"Error in conv3D: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + a + \"'\";\n        }), C(\"NDHWC\" === o, function() {\n            return \"Error in conv3d: got dataFormat of \" + o + \" but only NDHWC is currently supported.\";\n        });\n        var l = va(u.shape, s.shape, n, a, r), h = Lt.runKernelFunc(function(t, e) {\n            var n = t.conv3d(u, s, l);\n            return e([\n                u,\n                s\n            ]), n;\n        }, {\n            x: u,\n            $filter: s\n        }, function(t, e) {\n            C(ll(a), function() {\n                return \"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '\" + a + \"'\";\n            });\n            var o = e[0], i = e[1];\n            return {\n                x: function() {\n                    return hl(o.shape, t, i, n, r);\n                },\n                $filter: function() {\n                    return function(t, e, n, r, o) {\n                        var a = t;\n                        4 === t.rank && (a = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]));\n                        var i = e;\n                        4 === i.rank && (i = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]));\n                        C(5 === a.rank, function() {\n                            return \"Error in conv3dDerFilter: input must be rank 5, but got shape \" + a.shape + \".\";\n                        }), C(5 === i.rank, function() {\n                            return \"Error in conv3dDerFilter: dy must be rank 5, but got shape \" + i.shape + \".\";\n                        }), C(5 === n.length, function() {\n                            return \"Error in conv3dDerFilter: filterShape must be length 5, but got \" + n + \".\";\n                        }), C(a.shape[4] === n[3], function() {\n                            return \"Error in conv3dDerFilter: depth of input \" + a.shape[4] + \") must match input depth in filter (\" + n[3] + \".\";\n                        }), C(i.shape[4] === n[4], function() {\n                            return \"Error in conv3dDerFilter: depth of dy (\" + i.shape[4] + \") must match output depth for filter (\" + n[4] + \").\";\n                        });\n                        var s = va(a.shape, n, r, 1, o);\n                        return Lt.runKernelFunc(function(t) {\n                            return t.conv3dDerFilter(a, i, s);\n                        }, {\n                            x5D: a,\n                            dy5D: i\n                        });\n                    }(o, t, i.shape, n, r);\n                }\n            };\n        });\n        return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n    }\n}), vl = An({\n    conv2dDerFilter_: function(t, e, n, r, o, a, i) {\n        void 0 === a && (a = \"NHWC\");\n        var s = t;\n        3 === t.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));\n        var u = e;\n        3 === u.rank && (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), C(4 === s.rank, function() {\n            return \"Error in conv2dDerFilter: input must be rank 4, but got shape \" + s.shape + \".\";\n        }), C(4 === u.rank, function() {\n            return \"Error in conv2dDerFilter: dy must be rank 4, but got shape \" + u.shape + \".\";\n        }), C(4 === n.length, function() {\n            return \"Error in conv2dDerFilter: filterShape must be length 4, but got \" + n + \".\";\n        });\n        var c = \"NHWC\" === a ? s.shape[3] : s.shape[1], l = \"NHWC\" === a ? u.shape[3] : u.shape[1];\n        C(c === n[2], function() {\n            return \"Error in conv2dDerFilter: depth of input \" + c + \") must match input depth in filter (\" + n[2] + \".\";\n        }), C(l === n[3], function() {\n            return \"Error in conv2dDerFilter: depth of dy (\" + l + \") must match output depth for filter (\" + n[3] + \").\";\n        }), null != i && C(A(o), function() {\n            return \"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + o + \".\";\n        });\n        var h = Ea(a), f = pa(s.shape, n, r, 1, o, i, !1, h);\n        return Lt.runKernelFunc(function(t) {\n            return t.conv2dDerFilter(s, u, f);\n        }, {\n            x4D: s,\n            dy4D: u\n        });\n    }\n}), gl = An({\n    conv2dDerInput_: cl\n}), ml = An({\n    depthwiseConv2d_: function(t, e, n, r, o, a, i) {\n        void 0 === o && (o = \"NHWC\"), void 0 === a && (a = [\n            1,\n            1\n        ]);\n        var s = gn(t, \"x\", \"depthwiseConv2d\"), u = gn(e, \"filter\", \"depthwiseConv2d\"), c = s, l = !1;\n        3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), C(4 === c.rank, function() {\n            return \"Error in depthwiseConv2d: input must be rank 4, but got rank \" + c.rank + \".\";\n        }), C(4 === u.rank, function() {\n            return \"Error in depthwiseConv2d: filter must be rank 4, but got rank \" + u.rank + \".\";\n        }), C(c.shape[3] === u.shape[2], function() {\n            return \"Error in depthwiseConv2d: number of input channels (\" + c.shape[3] + \") must match the inChannels dimension in filter \" + u.shape[2] + \".\";\n        }), null == a && (a = [\n            1,\n            1\n        ]), C(Ca(n, a), function() {\n            return \"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + a + \"'\";\n        }), null != i && C(A(r), function() {\n            return \"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + r + \".\";\n        });\n        var h = pa(c.shape, u.shape, n, a, r, i, !0), f = [\n            c,\n            u\n        ], d = Lt.runKernelFunc(function(t, e) {\n            var n = t.depthwiseConv2D(c, u, h);\n            return e([\n                c,\n                u\n            ]), n;\n        }, {\n            x: c,\n            filter: u\n        }, function(t, e) {\n            C(wa(a), function() {\n                return \"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '\" + a + \"'\";\n            });\n            var n = e[0], r = e[1];\n            return {\n                x: function() {\n                    return yl(n.shape, t, r, h);\n                },\n                filter: function() {\n                    return xl(n, t, r.shape, h);\n                }\n            };\n        }, \"DepthwiseConv2dNative\", h, f);\n        return l ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;\n    }\n}), yl = An({\n    depthwiseConv2dDerInput_: function(t, e, n, r) {\n        var o = e, a = !1;\n        3 === e.rank && (a = !0, o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));\n        var i = Lt.runKernelFunc(function(t) {\n            return t.depthwiseConv2DDerInput(o, n, r);\n        }, {\n            dy4D: o\n        });\n        return a ? i.as3D(i.shape[1], i.shape[2], i.shape[3]) : i;\n    }\n}), xl = An({\n    depthwiseConv2dDerFilter_: function(t, e, n, r) {\n        var o = t;\n        3 === t.rank && (o = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));\n        var a = e;\n        return 3 === a.rank && (a = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), Lt.runKernelFunc(function(t) {\n            return t.depthwiseConv2DDerFilter(o, a, r);\n        }, {\n            x4D: o,\n            dy4D: a\n        });\n    }\n}), bl = An({\n    separableConv2d_: function(t, e, n, r, o, a, i) {\n        void 0 === a && (a = [\n            1,\n            1\n        ]), void 0 === i && (i = \"NHWC\");\n        var s = gn(t, \"x\", \"separableConv2d\"), u = gn(e, \"depthwiseFilter\", \"separableConv2d\"), c = gn(n, \"pointwiseFilter\", \"separableConv2d\"), l = s, h = !1;\n        if (3 === s.rank && (h = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), \"NCHW\" === i) throw new Error(\"separableConv2d currently does not support dataFormat NCHW; only NHWC is supported\");\n        C(4 === l.rank, function() {\n            return \"Error in separableConv2d: input must be rank 4, but got rank \" + l.rank + \".\";\n        }), C(4 === u.rank, function() {\n            return \"Error in separableConv2d: depthwise filter must be rank 4, but got rank \" + u.rank + \".\";\n        }), C(4 === c.rank, function() {\n            return \"Error in separableConv2d: pointwise filter must be rank 4, but got rank \" + u.rank + \".\";\n        }), C(1 === c.shape[0], function() {\n            return \"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got \" + c.shape[0] + \".\";\n        }), C(1 === c.shape[1], function() {\n            return \"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got \" + c.shape[1] + \".\";\n        });\n        var f = u.shape[2], d = u.shape[3];\n        C(c.shape[2] === f * d, function() {\n            return \"Error in separableConv2d: the third dimension of pointwise filter must be \" + f * d + \", but got \" + c.shape[2] + \".\";\n        });\n        var p = ml(l, u, r, o, i, a), v = dl(p, c, 1, \"valid\", i);\n        return h ? v.as3D(v.shape[1], v.shape[2], v.shape[3]) : v;\n    }\n}), wl = An({\n    conv2dTranspose_: function(t, e, n, r, o, a) {\n        return cl(n, gn(t, \"x\", \"conv2dTranspose\"), gn(e, \"filter\", \"conv2dTranspose\"), r, o, \"NHWC\", a);\n    }\n}), Cl = An({\n    conv3dTranspose_: function(t, e, n, r, o) {\n        return hl(n, gn(t, \"x\", \"conv3dTranspose\"), gn(e, \"filter\", \"conv3dTranspose\"), r, o);\n    }\n});\nvar El = An({\n    matMul_: function(t, e, n, r) {\n        var o;\n        void 0 === n && (n = !1), void 0 === r && (r = !1);\n        var a = gn(t, \"a\", \"matMul\"), i = gn(e, \"b\", \"matMul\");\n        o = Nt(a, i), a = o[0], i = o[1];\n        var s = n ? a.shape[a.rank - 2] : a.shape[a.rank - 1], u = r ? i.shape[i.rank - 1] : i.shape[i.rank - 2], c = n ? a.shape[a.rank - 1] : a.shape[a.rank - 2], l = r ? i.shape[i.rank - 2] : i.shape[i.rank - 1], h = a.shape.slice(0, -2), f = i.shape.slice(0, -2), d = k(h), p = k(f);\n        C(a.rank >= 2 && i.rank >= 2 && a.rank === i.rank, function() {\n            return \"Error in matMul: inputs must have the same rank of at least 2, got ranks \" + a.rank + \" and \" + i.rank + \".\";\n        }), C(S(h, f), function() {\n            return \"Error in matMul: outer dimensions (\" + h + \") and (\" + f + \") of Tensors with shapes \" + a.shape + \" and \" + i.shape + \" must match.\";\n        }), C(s === u, function() {\n            return \"Error in matMul: inner shapes (\" + s + \") and (\" + u + \") of Tensors with shapes \" + a.shape + \" and \" + i.shape + \" and transposeA=\" + n + \" and transposeB=\" + r + \" must match.\";\n        });\n        var v = a.shape.slice(0, -2).concat([\n            c,\n            l\n        ]), g = n ? a.as3D(d, s, c) : a.as3D(d, c, s), m = r ? i.as3D(p, l, u) : i.as3D(p, u, l), y = {\n            transposeA: n,\n            transposeB: r\n        };\n        return Lt.runKernelFunc(function(t, e) {\n            var o = t.batchMatMul(g, m, n, r);\n            return e([\n                g,\n                m\n            ]), o;\n        }, {\n            a: g,\n            b: m\n        }, function(t, e) {\n            var o = e, a = o[0], i = o[1];\n            return n || r ? !n && r ? {\n                a: function() {\n                    return t.matMul(i, !1, !1);\n                },\n                b: function() {\n                    return t.matMul(a, !0, !1);\n                }\n            } : n && !r ? {\n                a: function() {\n                    return i.matMul(t, !1, !0);\n                },\n                b: function() {\n                    return a.matMul(t, !1, !1);\n                }\n            } : {\n                a: function() {\n                    return i.matMul(t, !0, !0);\n                },\n                b: function() {\n                    return t.matMul(a, !0, !0);\n                }\n            } : {\n                a: function() {\n                    return t.matMul(i, !1, !0);\n                },\n                b: function() {\n                    return a.matMul(t, !0, !1);\n                }\n            };\n        }, \"BatchMatMul\", y).reshape(v);\n    }\n}), Rl = An({\n    dot_: function(t, e) {\n        var n = gn(t, \"t1\", \"dot\"), r = gn(e, \"t2\", \"dot\");\n        C(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), function() {\n            return \"Error in dot: inputs must all be rank 1 or 2, but got ranks \" + n.rank + \" and \" + r.rank + \".\";\n        });\n        var o = 1 === n.rank ? n.size : n.shape[1], a = 1 === r.rank ? r.size : r.shape[0];\n        return C(o === a, function() {\n            return \"Error in dot: inner dimensions of inputs must match, but got \" + o + \" and \" + a + \".\";\n        }), 1 === n.rank && 1 === r.rank ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : 1 === n.rank && 2 === r.rank ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : 2 === n.rank && 1 === r.rank ? n.matMul(r.as2D(-1, 1)).as1D() : n.matMul(r.as2D(r.shape[0], r.shape[1]));\n    }\n}), Il = An({\n    outerProduct_: function(t, e) {\n        var n = gn(t, \"v1\", \"outerProduct\"), r = gn(e, \"v2\", \"outerProduct\");\n        return C(1 === n.rank && 1 === r.rank, function() {\n            return \"Error in outerProduct: inputs must be rank 1, but got ranks \" + n.rank + \" and \" + r.rank + \".\";\n        }), n.as2D(-1, 1).matMul(r.as2D(1, -1));\n    }\n});\nvar kl = An({\n    reverse_: function(t, e) {\n        var n = gn(t, \"x\", \"reverse\");\n        if (0 === n.rank) return n.clone();\n        var r = O(e, n.shape);\n        return Lt.runKernelFunc(function(t) {\n            return t.reverse(n, r);\n        }, {\n            $x: n\n        }, function(t) {\n            return {\n                $x: function() {\n                    return t.reverse(r);\n                }\n            };\n        }).reshapeAs(n);\n    }\n}), Sl = An({\n    reverse1d_: function(t) {\n        var e = gn(t, \"x\", \"reverse\");\n        return C(1 === e.rank, function() {\n            return \"Error in reverse1D: x must be rank 1 but got rank \" + e.rank + \".\";\n        }), kl(e, 0);\n    }\n}), Al = An({\n    reverse2d_: function(t, e) {\n        var n = gn(t, \"x\", \"reverse\");\n        return C(2 === n.rank, function() {\n            return \"Error in reverse2D: x must be rank 2 but got rank \" + n.rank + \".\";\n        }), kl(n, e);\n    }\n}), Tl = An({\n    reverse3d_: function(t, e) {\n        var n = gn(t, \"x\", \"reverse\");\n        return C(3 === n.rank, function() {\n            return \"Error in reverse3D: x must be rank 3 but got rank \" + n.rank + \".\";\n        }), kl(n, e);\n    }\n}), Dl = An({\n    reverse4d_: function(t, e) {\n        var n = gn(t, \"x\", \"reverse\");\n        return C(4 === n.rank, function() {\n            return \"Error in reverse4D: x must be rank 4 but got rank \" + n.rank + \".\";\n        }), kl(n, e);\n    }\n});\nfunction Nl(t, e, n, r, o, a) {\n    var i = gn(t, \"x\", \"maxPool\"), s = i, u = !1;\n    3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), null == r && (r = [\n        1,\n        1\n    ]), C(4 === s.rank, function() {\n        return \"Error in maxPool: input must be rank 4 but got rank \" + s.rank + \".\";\n    }), C(Ca(n, r), function() {\n        return \"Error in maxPool: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + r + \"'\";\n    }), null != a && C(A(o), function() {\n        return \"Error in maxPool: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\";\n    });\n    var c = fa(s.shape, e, n, r, o, a);\n    if (1 === c.filterWidth && 1 === c.filterHeight && S(c.inShape, c.outShape)) return i.clone();\n    var l = [\n        s\n    ], h = Lt.runKernelFunc(function(t, e) {\n        var n = t.maxPool(s, c);\n        return e([\n            s,\n            n\n        ]), n;\n    }, {\n        x: s\n    }, function(t, a) {\n        var i = a[0], s = a[1];\n        return {\n            x: function() {\n                return function(t, e, n, r, o, a, i, s) {\n                    var u = gn(t, \"dy\", \"maxPoolBackprop\"), c = gn(e, \"input\", \"maxPoolBackprop\"), l = gn(n, \"output\", \"maxPoolBackprop\");\n                    C(c.rank === u.rank, function() {\n                        return \"Rank of input (\" + c.rank + \") does not match rank of dy (\" + u.rank + \")\";\n                    }), null == a && (a = [\n                        1,\n                        1\n                    ]);\n                    C(Ca(o, a), function() {\n                        return \"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides \" + o + \" and dilations '\" + a + \"'\";\n                    }), C(4 === u.rank, function() {\n                        return \"Error in maxPoolBackprop: dy must be rank 4 but got rank \" + u.rank + \".\";\n                    }), C(4 === c.rank, function() {\n                        return \"Error in maxPoolBackprop: input must be rank 4 but got rank \" + c.rank + \".\";\n                    }), null != s && C(A(i), function() {\n                        return \"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode \" + s + \" but got pad \" + i + \".\";\n                    });\n                    var h = fa(c.shape, r, o, a, i, s);\n                    return Lt.runKernelFunc(function(t) {\n                        return t.maxPoolBackprop(u, c, l, h);\n                    }, {\n                        $dy: u,\n                        $input: c\n                    });\n                }(t, i, s, e, n, r, o);\n            }\n        };\n    }, \"MaxPool\", c, l);\n    return u ? h.as3D(h.shape[1], h.shape[2], h.shape[3]) : h;\n}\nfunction Fl(t, e, n, r, o, a) {\n    var i = gn(t, \"x\", \"avgPool\", \"float32\");\n    null == r && (r = [\n        1,\n        1\n    ]), C(Ca(n, r), function() {\n        return \"Error in avgPool: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + r + \"'\";\n    });\n    var s = i, u = !1;\n    3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), C(4 === s.rank, function() {\n        return \"Error in avgPool: x must be rank 4 but got rank \" + s.rank + \".\";\n    }), null != a && C(A(o), function() {\n        return \"Error in avgPool: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\";\n    });\n    var c = fa(s.shape, e, n, r, o, a);\n    if (1 === c.filterWidth && 1 === c.filterHeight && S(c.inShape, c.outShape)) return i.clone();\n    var l = Lt.runKernelFunc(function(t) {\n        return t.avgPool(s, c);\n    }, {\n        x: s\n    }, function(t) {\n        return {\n            x: function() {\n                return function(t, e, n, r, o, a) {\n                    var i = gn(t, \"dy\", \"avgPoolBackprop\"), s = gn(e, \"input\", \"avgPoolBackprop\");\n                    C(s.rank === i.rank, function() {\n                        return \"Rank of input (\" + s.rank + \") does not match rank of dy (\" + i.rank + \")\";\n                    }), null == o && (o = [\n                        1,\n                        1\n                    ]);\n                    C(Ca(r, o), function() {\n                        return \"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + o + \"'\";\n                    });\n                    var u = s, c = i, l = !1;\n                    3 === s.rank && (l = !0, u = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]), c = i.as4D(1, i.shape[0], i.shape[1], i.shape[2]));\n                    C(4 === c.rank, function() {\n                        return \"Error in avgPoolBackprop: dy must be rank 4 but got rank \" + c.rank + \".\";\n                    }), C(4 === u.rank, function() {\n                        return \"Error in avgPoolBackprop: input must be rank 4 but got rank \" + u.rank + \".\";\n                    });\n                    var h = fa(u.shape, n, r, o, a), f = Lt.runKernelFunc(function(t) {\n                        return t.avgPoolBackprop(c, u, h);\n                    }, {\n                        dy4D: c,\n                        input4D: u\n                    });\n                    if (l) return f.as3D(f.shape[1], f.shape[2], f.shape[3]);\n                    return f;\n                }(t, s, e, n, r, o);\n            }\n        };\n    }, \"AvgPool\", c);\n    return l = l.cast(i.dtype), u ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;\n}\nvar _l = An({\n    maxPool_: function(t, e, n, r, o) {\n        return Nl(t, e, n, 1, r, o);\n    }\n}), Ol = An({\n    avgPool_: function(t, e, n, r, o) {\n        return Fl(t, e, n, 1, r, o);\n    }\n}), Ml = An({\n    pool_: function(t, e, n, r, o, a) {\n        null == o && (o = [\n            1,\n            1\n        ]), null == a && (a = 1), 0 === r && (r = \"valid\");\n        var i = gn(t, \"x\", \"maxPool\"), s = i, u = !1;\n        3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), C(Ca(a, o), function() {\n            return \"Error in pool: Either strides or dilations must be 1. Got strides \" + a + \" and dilations '\" + o + \"'\";\n        });\n        var c, l = fa(s.shape, e, a, o, r), h = [\n            l.dilationHeight,\n            l.dilationWidth\n        ];\n        c = \"same\" === r ? function(t, e) {\n            var n = t.map(function(t, n) {\n                return t + (t - 1) * (e[n] - 1);\n            }).map(function(t) {\n                return t - 1;\n            }), r = n.map(function(t) {\n                return Math.floor(t / 2);\n            }), o = n.map(function(t, e) {\n                return t - r[e];\n            });\n            return n.map(function(t, e) {\n                return [\n                    r[e],\n                    o[e]\n                ];\n            });\n        }([\n            l.filterHeight,\n            l.filterWidth\n        ], h) : [\n            [\n                0,\n                0\n            ],\n            [\n                0,\n                0\n            ]\n        ];\n        var f = 1 === h[0] && 1 === h[1], d = function(t, e, n) {\n            var r = n.map(function(t) {\n                return t[0];\n            }), o = n.map(function(t) {\n                return t[1];\n            }), a = t.concat(r, o), i = e.map(function(t, e) {\n                return (t - a[e] % t) % t;\n            }), s = o.map(function(t, e) {\n                return t + i[e];\n            }), u = e.map(function(t, e) {\n                return [\n                    r[e],\n                    s[e]\n                ];\n            }), c = e.map(function(t, e) {\n                return [\n                    0,\n                    i[e]\n                ];\n            });\n            return [\n                u,\n                c\n            ];\n        }([\n            l.inHeight,\n            l.inWidth\n        ], h, c), p = d[0], v = d[1], g = f ? r : \"valid\", m = f ? s : cr(s, h, p), y = (\"avg\" === n ? function() {\n            return Fl(m, e, a, 1, g);\n        } : function() {\n            return Nl(m, e, a, 1, g);\n        })(), x = f ? y : rr(y, h, v);\n        return u ? x.as3D(x.shape[1], x.shape[2], x.shape[3]) : x;\n    }\n}), Bl = An({\n    maxPool3d_: function(t, e, n, r, o, a, i) {\n        void 0 === a && (a = \"NDHWC\");\n        var s = gn(t, \"x\", \"maxPool3d\"), u = s, c = !1;\n        4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == i && (i = [\n            1,\n            1,\n            1\n        ]), C(5 === u.rank, function() {\n            return \"Error in maxPool3d: x must be rank 5 but got rank \" + u.rank + \".\";\n        }), C(\"NDHWC\" === a, function() {\n            return \"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of \" + a;\n        }), C(Ca(n, i), function() {\n            return \"Error in maxPool3d: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + i + \"'\";\n        }), null != o && C(A(r), function() {\n            return \"Error in maxPool3d: pad must be an integer when using, dimRoundingMode \" + o + \" but got pad \" + r + \".\";\n        });\n        var l = da(u.shape, e, n, i, r, o, a), h = Lt.runKernelFunc(function(t, e) {\n            var n = t.maxPool3d(u, l);\n            return e([\n                u,\n                n\n            ]), n;\n        }, {\n            x: u\n        }, function(t, a) {\n            var s = a[0], u = a[1];\n            return {\n                x: function() {\n                    return function(t, e, n, r, o, a, i, s) {\n                        var u = gn(t, \"dy\", \"maxPool3dBackprop\"), c = gn(e, \"input\", \"maxPool3dBackprop\"), l = gn(n, \"output\", \"maxPool3dBackprop\"), h = u, f = c, d = l, p = !1;\n                        4 === c.rank && (p = !0, h = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]), f = c.as5D(1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]), d = l.as5D(1, l.shape[0], l.shape[1], l.shape[2], l.shape[3]));\n                        C(5 === h.rank, function() {\n                            return \"Error in maxPool3dBackprop: dy must be rank 5 but got rank \" + h.rank + \".\";\n                        }), C(5 === f.rank, function() {\n                            return \"Error in maxPool3dBackprop: input must be rank 5 but got rank \" + f.rank + \".\";\n                        }), C(5 === d.rank, function() {\n                            return \"Error in maxPool3dBackprop: output must be rank 5 but got rank \" + d.rank + \".\";\n                        }), null == a && (a = [\n                            1,\n                            1,\n                            1\n                        ]);\n                        C(Ca(o, a), function() {\n                            return \"Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides \" + o + \" and dilations '\" + a + \"'\";\n                        }), null != s && C(A(i), function() {\n                            return \"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode \" + s + \" but got pad \" + i + \".\";\n                        });\n                        var v = da(f.shape, r, o, a, i, s), g = Lt.runKernelFunc(function(t) {\n                            return t.maxPool3dBackprop(h, f, d, v);\n                        }, {\n                            dy5D: h,\n                            input5D: f\n                        });\n                        if (p) return g.as4D(g.shape[1], g.shape[2], g.shape[3], g.shape[4]);\n                        return g;\n                    }(t, s, u, e, n, i, r, o);\n                }\n            };\n        });\n        return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n    }\n}), Pl = An({\n    avgPool3d_: function(t, e, n, r, o, a, i) {\n        void 0 === a && (a = \"NDHWC\");\n        var s = gn(t, \"x\", \"avgPool3d\", \"float32\"), u = s, c = !1;\n        4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == i && (i = [\n            1,\n            1,\n            1\n        ]), C(5 === u.rank, function() {\n            return \"Error in avgPool3d: x must be rank 5 but got rank \" + u.rank + \".\";\n        }), C(\"NDHWC\" === a, function() {\n            return \"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of \" + a;\n        }), C(Ca(n, i), function() {\n            return \"Error in avgPool3d: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + i + \"'\";\n        }), null != o && C(A(r), function() {\n            return \"Error in avgPool3d: pad must be an integer when using, dimRoundingMode \" + o + \" but got pad \" + r + \".\";\n        });\n        var l = da(u.shape, e, n, i, r, o, a), h = Lt.runKernelFunc(function(t) {\n            return t.avgPool3d(u, l);\n        }, {\n            x: u\n        }, function(t) {\n            return {\n                x: function() {\n                    return function(t, e, n, r, o, a, i) {\n                        var s = gn(t, \"dy\", \"avgPool3dBackprop\"), u = gn(e, \"input\", \"avgPool3dBackprop\"), c = s, l = u, h = !1;\n                        4 === u.rank && (h = !0, c = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]), l = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]));\n                        C(5 === c.rank, function() {\n                            return \"Error in avgPool3dBackprop: dy must be rank 5 but got rank \" + c.rank + \".\";\n                        }), C(5 === l.rank, function() {\n                            return \"Error in avgPool3dBackprop: input must be rank 5 but got rank \" + l.rank + \".\";\n                        }), null == o && (o = [\n                            1,\n                            1,\n                            1\n                        ]);\n                        C(Ca(r, o), function() {\n                            return \"Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + o + \"'\";\n                        }), null != i && C(A(a), function() {\n                            return \"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + a + \".\";\n                        });\n                        var f = da(l.shape, n, r, o, a, i), d = Lt.runKernelFunc(function(t) {\n                            return t.avgPool3dBackprop(c, l, f);\n                        }, {\n                            dy5D: c,\n                            input5D: l\n                        });\n                        if (h) return d.as4D(d.shape[1], d.shape[2], d.shape[3], d.shape[4]);\n                        return d;\n                    }(t, u, e, n, i, r, o);\n                }\n            };\n        });\n        return h = h.cast(u.dtype), c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n    }\n}), Ll = An({\n    maxPoolWithArgmax_: function(t, e, n, r, o) {\n        void 0 === o && (o = !1);\n        var a = gn(t, \"x\", \"maxPoolWithArgmax\"), i = {\n            filterSize: e,\n            strides: n,\n            pad: r,\n            includeBatchInIndex: o\n        }, s = Lt.runKernel(\"MaxPoolWithArgmax\", {\n            x: a\n        }, i);\n        return {\n            result: s[0],\n            indexes: s[1]\n        };\n    }\n});\nvar Wl = An({\n    slice_: function(t, e, n) {\n        var r, o, a = gn(t, \"x\", \"slice\");\n        if (0 === a.rank) throw new Error(\"Slicing scalar is not possible\");\n        (r = \"number\" == typeof e ? [\n            e\n        ].concat(new Array(a.rank - 1).fill(0)) : e.length < a.rank ? e.concat(new Array(a.rank - e.length).fill(0)) : e.slice()).forEach(function(t) {\n            C(-1 !== t, function() {\n                return \"slice() does not support negative begin indexing.\";\n            });\n        }), o = (o = null == n ? new Array(a.rank).fill(-1) : \"number\" == typeof n ? [\n            n\n        ].concat(new Array(a.rank - 1).fill(-1)) : n.length < a.rank ? n.concat(new Array(a.rank - n.length).fill(-1)) : n).map(function(t, e) {\n            return t >= 0 ? t : (C(-1 === t, function() {\n                return \"Negative size values should be exactly -1 but got \" + t + \" for the slice() size at index \" + e + \".\";\n            }), a.shape[e] - r[e]);\n        }), qo(a, r, o);\n        var i = a.shape, s = {\n            begin: r,\n            size: o\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.slice(a, r, o);\n        }, {\n            x: a\n        }, function(t) {\n            for(var e = [], n = 0; n < t.rank; n++)e.push([\n                r[n],\n                i[n] - r[n] - o[n]\n            ]);\n            return {\n                x: function() {\n                    return Ic(t, e);\n                }\n            };\n        }, \"Slice\", s);\n    }\n}), Ul = An({\n    slice1d_: function(t, e, n) {\n        var r = gn(t, \"x\", \"slice1d\");\n        return C(1 === r.rank, function() {\n            return \"slice1d expects a rank-1 tensor, but got a rank-\" + r.rank + \" tensor\";\n        }), Wl(r, [\n            e\n        ], [\n            n\n        ]);\n    }\n}), Vl = An({\n    slice2d_: function(t, e, n) {\n        var r = gn(t, \"x\", \"slice2d\");\n        return C(2 === r.rank, function() {\n            return \"slice2d expects a rank-2 tensor, but got a rank-\" + r.rank + \" tensor\";\n        }), Wl(r, e, n);\n    }\n}), zl = An({\n    slice3d_: function(t, e, n) {\n        var r = gn(t, \"x\", \"slice3d\");\n        return C(3 === r.rank, function() {\n            return \"slice3d expects a rank-3 tensor, but got a rank-\" + r.rank + \" tensor\";\n        }), Wl(r, e, n);\n    }\n}), Gl = An({\n    slice4d_: function(t, e, n) {\n        var r = gn(t, \"x\", \"slice4d\");\n        return C(4 === r.rank, function() {\n            return \"slice4d expects a rank-4 tensor, but got a rank-\" + r.rank + \" tensor\";\n        }), Wl(r, e, n);\n    }\n});\nfunction Hl(t, e, n, r, o) {\n    return e.rank < n.rank && (e = e.reshape(wn(e.shape, r))), t.rank < n.rank && (t = t.reshape(wn(t.shape, r))), {\n        x: function() {\n            var r = t.mul(n.equal(e).cast(t.dtype));\n            return null == o ? r : r.transpose(o);\n        }\n    };\n}\nvar ql = An({\n    all_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = gn(t, \"x\", \"all\", \"bool\"), o = O(e, r.shape), a = o, i = En(a, r.rank);\n        null != i && (r = r.transpose(i), a = In(a.length, r.rank));\n        var s = Lt.runKernelFunc(function(t) {\n            return t.all(r, a);\n        }, {\n            $x: r\n        });\n        if (n) {\n            var u = wn(s.shape, o);\n            return s.reshape(u);\n        }\n        return s;\n    }\n}), Kl = An({\n    any_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = gn(t, \"x\", \"any\", \"bool\"), o = O(e, r.shape), a = o, i = En(a, r.rank);\n        null != i && (r = r.transpose(i), a = In(a.length, r.rank));\n        var s = Lt.runKernelFunc(function(t) {\n            return t.any(r, a);\n        }, {\n            $x: r\n        });\n        if (n) {\n            var u = wn(s.shape, o);\n            return s.reshape(u);\n        }\n        return s;\n    }\n}), jl = An({\n    argMax_: function(t, e) {\n        void 0 === e && (e = 0);\n        var n = gn(t, \"x\", \"argMax\");\n        null == e && (e = 0);\n        var r = O(e, n.shape), o = En(r, n.rank);\n        null != o && (n = n.transpose(o), r = In(r.length, n.rank));\n        var a = {\n            axis: r[0]\n        }, i = [\n            n\n        ];\n        return Lt.runKernelFunc(function(t, e) {\n            var o = t.argMax(n, r[0]);\n            return e([\n                n\n            ]), o;\n        }, {\n            x: n\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return Xn(n);\n                }\n            };\n        }, \"ArgMax\", a, i);\n    }\n}), Xl = An({\n    argMin_: function(t, e) {\n        void 0 === e && (e = 0);\n        var n = gn(t, \"x\", \"argMin\");\n        null == e && (e = 0);\n        var r = O(e, n.shape), o = En(r, n.rank);\n        return null != o && (n = n.transpose(o), r = In(r.length, n.rank)), Lt.runKernelFunc(function(t, e) {\n            var o = t.argMin(n, r[0]);\n            return e([\n                n\n            ]), o;\n        }, {\n            $x: n\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return Xn(n);\n                }\n            };\n        });\n    }\n}), Yl = An({\n    logSumExp_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = gn(t, \"x\", \"logSumExp\"), o = O(e, r.shape), a = r.max(o, !0), i = r.sub(a).exp().sum(o).log(), s = a.reshape(i.shape).add(i);\n        if (n) {\n            var u = wn(s.shape, o);\n            return s.reshape(u);\n        }\n        return s;\n    }\n}), $l = An({\n    max_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = gn(t, \"x\", \"max\"), o = r, a = O(e, r.shape), i = a, s = En(i, r.rank);\n        null != s && (r = r.transpose(s), i = In(i.length, r.rank));\n        var u = [\n            r\n        ], c = Lt.runKernelFunc(function(t, e) {\n            var n = t.max(r, i);\n            return e([\n                o,\n                n\n            ]), n;\n        }, {\n            x: r\n        }, function(t, e) {\n            return Hl(t, e[1], e[0], a, s);\n        }, \"Max\", {\n            axes: i\n        }, u, [\n            !0\n        ]);\n        if (n) {\n            var l = wn(c.shape, a);\n            c = c.reshape(l);\n        }\n        return c;\n    }\n}), Ql = An({\n    mean_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = gn(t, \"x\", \"mean\"), o = O(e, r.shape), a = k(bn(r.shape, o)[1]);\n        return oa(function(t) {\n            var r = On(a);\n            return {\n                value: (r.dtype === t.dtype ? t : t.cast(r.dtype)).div(r).sum(e, n),\n                gradFunc: function(e) {\n                    var n = t.shape.slice();\n                    return o.forEach(function(t) {\n                        n[t] = 1;\n                    }), e.reshape(n).mul(zn(t.shape, \"float32\")).div(a);\n                }\n            };\n        })(r);\n    }\n}), Jl = An({\n    min_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = gn(t, \"x\", \"min\"), o = r, a = O(e, r.shape), i = a, s = En(i, r.rank);\n        null != s && (r = r.transpose(s), i = In(i.length, r.rank));\n        var u = [\n            r\n        ], c = Lt.runKernelFunc(function(t, e) {\n            var n = t.min(r, i);\n            return e([\n                o,\n                n\n            ]), n;\n        }, {\n            x: r\n        }, function(t, e) {\n            return Hl(t, e[1], e[0], a, s);\n        }, \"Min\", {\n            axes: i\n        }, u, [\n            !0\n        ]);\n        if (n) {\n            var l = wn(c.shape, a);\n            c = c.reshape(l);\n        }\n        return c;\n    }\n}), Zl = An({\n    moments_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = O(e, (t = gn(t, \"x\", \"moments\")).shape), o = t.mean(r, n), a = o.shape;\n        n || (a = wn(o.shape, r));\n        var i = t.toFloat().sub(o.reshape(a)).square();\n        return {\n            mean: o,\n            variance: i.mean(r, n)\n        };\n    }\n}), th = An({\n    sum_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = gn(t, \"x\", \"sum\");\n        \"bool\" === r.dtype && (r = r.toInt());\n        var o = O(e, r.shape);\n        return oa(function(t) {\n            var e = En(o, t.rank), r = o, a = t;\n            null != e && (a = t.transpose(e), r = In(r.length, t.rank));\n            var i = function(e) {\n                var n = t.shape.slice();\n                return o.forEach(function(t) {\n                    n[t] = 1;\n                }), e.reshape(n).mul(zn(t.shape, \"float32\"));\n            }, s = {\n                axes: r\n            }, u = Lt.runKernelFunc(function(t) {\n                return t.sum(a, r);\n            }, {\n                x: a\n            }, function(t) {\n                return {\n                    x: function() {\n                        return i(t);\n                    }\n                };\n            }, \"Sum\", s);\n            if (n) {\n                var c = wn(u.shape, o);\n                u = u.reshape(c);\n            }\n            return {\n                value: u,\n                gradFunc: i\n            };\n        })(r);\n    }\n}), eh = An({\n    prod_: function(t, e, n) {\n        void 0 === e && (e = null), void 0 === n && (n = !1);\n        var r = gn(t, \"x\", \"prod\");\n        \"bool\" === r.dtype && (r = r.toInt());\n        var o = O(e, r.shape), a = En(o, r.rank), i = o, s = r;\n        null != a && (s = r.transpose(a), i = In(i.length, r.rank));\n        var u = Lt.runKernelFunc(function(t) {\n            return t.prod(s, i);\n        }, {\n            permutedX: s\n        });\n        if (n) {\n            var c = wn(u.shape, o);\n            u = u.reshape(c);\n        }\n        return u;\n    }\n});\nvar nh = An({\n    elu_: function(t) {\n        var e = gn(t, \"x\", \"elu\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.elu(e);\n            return n([\n                r\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    return Lt.runKernelFunc(function(e) {\n                        return e.eluDer(t, n);\n                    }, {\n                        dy: t,\n                        y: n\n                    });\n                }\n            };\n        });\n    }\n}), rh = An({\n    leakyRelu_: function(t, e) {\n        void 0 === e && (e = .2);\n        var n = gn(t, \"x\", \"leakyRelu\");\n        return Eo(On(e).mul(n), n);\n    }\n}), oh = An({\n    prelu_: function(t, e) {\n        var n = gn(t, \"x\", \"prelu\"), r = gn(e, \"alpha\", \"prelu\");\n        return Lt.runKernelFunc(function(t, e) {\n            var o = t.prelu(n, r);\n            return e([\n                n,\n                r\n            ]), o;\n        }, {\n            x: n,\n            alpha: r\n        }, function(t, e) {\n            var n = e[0], r = e[1], o = n.greater(0);\n            return {\n                x: function() {\n                    return yc(o, t, t.mul(r));\n                },\n                alpha: function() {\n                    var e = yc(o, Xn(t), t.mul(n)), a = Br(r.shape, t.shape);\n                    return a.length > 0 && (e = e.sum(a)), e.reshape(r.shape);\n                }\n            };\n        }, \"Prelu\");\n    }\n}), ah = An({\n    relu_: function(t) {\n        var e = gn(t, \"x\", \"relu\");\n        return \"bool\" === e.dtype ? e.toInt() : Lt.runKernelFunc(function(t, n) {\n            var r = t.relu(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.mulStrict(n.step().toFloat());\n                }\n            };\n        }, \"Relu\");\n    }\n}), ih = An({\n    relu6_: function(t) {\n        var e = gn(t, \"x\", \"relu6\");\n        return \"bool\" === e.dtype ? e.toInt() : Lt.runKernelFunc(function(t, n) {\n            var r = t.relu6(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            x: e\n        }, function(t, e) {\n            var n = e[0], r = n.lessEqual(6).mul(n.step());\n            return {\n                x: function() {\n                    return t.mulStrict(r.toFloat());\n                }\n            };\n        }, \"Relu6\");\n    }\n}), sh = An({\n    selu_: function(t) {\n        var e = gn(t, \"x\", \"selu\");\n        return Lt.runKernelFunc(function(t, n) {\n            var r = t.selu(e);\n            return n([\n                e\n            ]), r;\n        }, {\n            $x: e\n        }, function(t, e) {\n            var n = e[0];\n            return {\n                $x: function() {\n                    var e = n.greater(On(0)), r = On(su), o = On(uu), a = t.mul(o), i = t.mul(r).mul(n.toFloat().exp());\n                    return yc(e, a, i);\n                }\n            };\n        });\n    }\n});\nvar uh = An({\n    localResponseNormalization_: function(t, e, n, r, o) {\n        void 0 === e && (e = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === o && (o = .5);\n        var a = gn(t, \"x\", \"localResponseNormalization\");\n        C(4 === a.rank || 3 === a.rank, function() {\n            return \"Error in localResponseNormalization: x must be rank 3 or 4 but got\\n               rank \" + a.rank + \".\";\n        }), C(A(e), function() {\n            return \"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius \" + e + \".\";\n        });\n        var i = a, s = !1;\n        3 === a.rank && (s = !0, i = a.as4D(1, a.shape[0], a.shape[1], a.shape[2]));\n        var u = Lt.runKernelFunc(function(t, a) {\n            var s = t.localResponseNormalization4D(i, e, n, r, o);\n            return a([\n                i,\n                s\n            ]), s;\n        }, {\n            x4D: i\n        }, function(t, a) {\n            var i = a[0], s = a[1];\n            return {\n                x4D: function() {\n                    return Lt.runKernelFunc(function(a) {\n                        return a.LRNGrad(t, i, s, e, n, r, o);\n                    }, {});\n                }\n            };\n        });\n        return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n    }\n});\nvar ch = An({\n    norm_: function(t, e, n, r) {\n        void 0 === e && (e = \"euclidean\"), void 0 === n && (n = null), void 0 === r && (r = !1);\n        var o = function t(e, n, r) {\n            void 0 === r && (r = null);\n            if (0 === e.rank) return e.abs();\n            if (1 !== e.rank && null === r) return t(e.reshape([\n                -1\n            ]), n, r);\n            if (1 === e.rank || \"number\" == typeof r || Array.isArray(r) && 1 === r.length) {\n                if (1 === n) return e.abs().sum(r);\n                if (n === 1 / 0) return e.abs().max(r);\n                if (n === -1 / 0) return e.abs().min(r);\n                if (\"euclidean\" === n || 2 === n) return e.abs().pow(On(2, \"int32\")).sum(r).sqrt();\n                throw new Error(\"Error in norm: invalid ord value: \" + n);\n            }\n            if (Array.isArray(r) && 2 === r.length) {\n                if (1 === n) return e.abs().sum(r[0]).max(r[1] - 1);\n                if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0]);\n                if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0]);\n                if (\"fro\" === n || \"euclidean\" === n) return e.square().sum(r).sqrt();\n                throw new Error(\"Error in norm: invalid ord value: \" + n);\n            }\n            throw new Error(\"Error in norm: invalid axis: \" + r);\n        }(t = gn(t, \"x\", \"norm\"), e, n), a = o.shape;\n        if (r) {\n            var i = O(n, t.shape);\n            a = wn(o.shape, i);\n        }\n        return o.reshape(a);\n    }\n});\nvar lh = An({\n    basicLSTMCell_: function(t, e, n, r, o, a) {\n        var i = gn(t, \"forgetBias\", \"basicLSTMCell\"), s = gn(e, \"lstmKernel\", \"basicLSTMCell\"), u = gn(n, \"lstmBias\", \"basicLSTMCell\"), c = gn(r, \"data\", \"basicLSTMCell\"), l = gn(o, \"c\", \"basicLSTMCell\"), h = gn(a, \"h\", \"basicLSTMCell\"), f = c.concat(h, 1).matMul(s).add(u), d = f.shape[0], p = f.shape[1] / 4, v = [\n            d,\n            p\n        ], g = f.slice([\n            0,\n            0\n        ], v), m = f.slice([\n            0,\n            p\n        ], v), y = f.slice([\n            0,\n            2 * p\n        ], v), x = f.slice([\n            0,\n            3 * p\n        ], v), b = g.sigmoid().mulStrict(m.tanh()).addStrict(l.mulStrict(i.add(y).sigmoid())), w = b.tanh().mulStrict(x.sigmoid());\n        return [\n            b,\n            w\n        ];\n    }\n}), hh = An({\n    multiRNNCell_: function(t, e, n, r) {\n        for(var o = gn(e, \"data\", \"multiRNNCell\"), a = mn(n, \"c\", \"multiRNNCell\"), i = mn(r, \"h\", \"multiRNNCell\"), s = o, u = [], c = 0; c < t.length; c++){\n            var l = t[c](s, a[c], i[c]);\n            u.push(l[0]), u.push(l[1]), s = l[1];\n        }\n        var h = [], f = [];\n        for(c = 0; c < u.length; c += 2)h.push(u[c]), f.push(u[c + 1]);\n        return [\n            h,\n            f\n        ];\n    }\n});\nvar fh = An({\n    movingAverage_: function(t, e, n, r, o) {\n        void 0 === o && (o = !0);\n        var a = gn(t, \"v\", \"movingAverage\"), i = gn(e, \"x\", \"movingAverage\"), s = gn(n, \"decay\", \"movingAverage\");\n        Ft(a, i), C(S(a.shape, i.shape), function() {\n            return \"Shape mismatch in v and x\";\n        });\n        var u = On(1), c = u.sub(s), l = i.sub(a).mul(c);\n        if (o) {\n            C(null != r, function() {\n                return \"When using zeroDebias: true, step is required.\";\n            });\n            var h = gn(r, \"step\", \"movingAverage\");\n            l = l.div(u.sub(No(s, h)));\n        }\n        return a.add(l);\n    }\n});\nvar dh = An({\n    stridedSlice_: function(t, e, n, r, o, a, i, s, u) {\n        if (void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), null == r && (r = new Array(e.length)), 0 !== i) throw new Error(\"ellipsis mask is not yet supported\");\n        var c = gn(t, \"x\", \"stridedSlice\"), l = Ko(s), h = c.shape.slice();\n        l.forEach(function(t) {\n            e[t] = 0, n[t] = 1, h.splice(t, 0, 1);\n        }), c = c.reshape(h);\n        for(var f = 0; f < c.rank; f++)e[f] = Xo(o, e, r, c.shape, f), n[f] = Yo(a, n, r, c.shape, f), r[f] = r[f] || 1;\n        var d = Ko(u);\n        d.forEach(function(t) {\n            n[t] = e[t] + 1, r[t] = 1;\n        });\n        var p = jo(e, n, r), v = p.filter(function(t, e) {\n            return -1 === d.indexOf(e);\n        });\n        return r.every(function(t) {\n            return 1 === t;\n        }) ? Wl(c, e, p).reshape(v) : Lt.runKernelFunc(function(t) {\n            return t.stridedSlice(c, e, n, r);\n        }, {\n            $x: c\n        }).reshape(v);\n    }\n});\nvar ph = An({\n    topk_: function(t, e, n) {\n        void 0 === e && (e = 1), void 0 === n && (n = !0);\n        var r = gn(t, \"x\", \"topk\");\n        if (0 === r.rank) throw new Error(\"topk() expects the input to be of rank 1 or higher\");\n        var o = r.shape[r.shape.length - 1];\n        if (e > o) throw new Error(\"'k' passed to topk() must be <= the last dimension (\" + o + \") but got \" + e);\n        var a = Lt.runKernelFunc(function(t) {\n            return t.topk(r, e, n);\n        }, {\n            $x: r\n        });\n        return {\n            values: a[0],\n            indices: a[1]\n        };\n    }\n});\nvar vh = An({\n    scatterND_: function(t, e, n) {\n        var r = gn(t, \"indices\", \"scatterND\", \"int32\"), o = gn(e, \"updates\", \"scatterND\");\n        return zo(o, r, n), Lt.runKernelFunc(function(t) {\n            return t.scatterND(r, o, n);\n        }, {\n            indices: r,\n            updates: o\n        }, null, \"ScatterNd\", {\n            shape: n\n        });\n    }\n});\nvar gh = An({\n    fft_: function(t) {\n        C(\"complex64\" === t.dtype, function() {\n            return \"The dtype for tf.spectral.fft() must be complex64 but got \" + t.dtype + \".\";\n        });\n        var e = t.shape[t.shape.length - 1], n = t.size / e, r = t.as2D(n, e);\n        return Lt.runKernelFunc(function(t) {\n            return t.fft(r);\n        }, {\n            input: t\n        }).reshape(t.shape);\n    }\n}), mh = An({\n    ifft_: function(t) {\n        C(\"complex64\" === t.dtype, function() {\n            return \"The dtype for tf.spectral.ifft() must be complex64 but got \" + t.dtype + \".\";\n        });\n        var e = t.shape[t.shape.length - 1], n = t.size / e, r = t.as2D(n, e);\n        return Lt.runKernelFunc(function(t) {\n            return t.ifft(r);\n        }, {\n            input: t\n        }).reshape(t.shape);\n    }\n}), yh = An({\n    rfft_: function(t, e) {\n        C(\"float32\" === t.dtype, function() {\n            return \"The dtype for rfft() must be real value but got \" + t.dtype;\n        });\n        var n, r = t.shape[t.shape.length - 1], o = t.size / r;\n        if (null != e && e < r) {\n            var a = t.shape.map(function(t) {\n                return 0;\n            }), i = t.shape.map(function(t) {\n                return t;\n            });\n            i[t.shape.length - 1] = e, n = t.slice(a, i), r = e;\n        } else if (null != e && e > r) {\n            var s = t.shape.map(function(t) {\n                return t;\n            });\n            s[t.shape.length - 1] = e - r, n = t.concat(Gn(s), t.shape.length - 1), r = e;\n        } else n = t;\n        var u = n.zerosLike(), c = Tn(n, u).as2D(o, r), l = gh(c), h = Math.floor(r / 2) + 1, f = Dn(l), d = Nn(l), p = f.split([\n            h,\n            r - h\n        ], f.shape.length - 1), v = d.split([\n            h,\n            r - h\n        ], d.shape.length - 1), g = n.shape.slice();\n        return g[n.shape.length - 1] = h, Tn(p[0], v[0]).reshape(g);\n    }\n}), xh = An({\n    irfft_: function(t) {\n        var e = t.shape[t.shape.length - 1], n = t.size / e;\n        if (e <= 2) {\n            var r = t.as2D(n, e), o = mh(r);\n            return Dn(o);\n        }\n        var a = [\n            n,\n            2 * (e - 1)\n        ], i = Dn(t).as2D(n, e), s = Nn(t).as2D(n, e), u = i.slice([\n            0,\n            1\n        ], [\n            n,\n            e - 2\n        ]).reverse(1), c = s.slice([\n            0,\n            1\n        ], [\n            n,\n            e - 2\n        ]).reverse(1).mul(On(-1)), l = i.concat(u, 1), h = s.concat(c, 1);\n        return r = Tn(l, h).as2D(a[0], a[1]), o = mh(r), Dn(o);\n    }\n}), bh = Object.freeze({\n    fft: gh,\n    ifft: mh,\n    rfft: yh,\n    irfft: xh\n});\nvar wh = An({\n    sparseToDense_: function(t, e, n, r) {\n        void 0 === r && (r = 0);\n        var o = gn(t, \"sparseIndices\", \"sparseToDense\", \"int32\"), a = gn(e, \"sparseValues\", \"sparseToDense\"), i = gn(r, \"defaultValue\", \"sparseToDense\", a.dtype);\n        return function(t, e, n, r) {\n            if (\"int32\" !== t.dtype) throw new Error(\"tf.sparseToDense() expects the indices to be int32 type, but the dtype was \" + t.dtype + \".\");\n            if (t.rank > 2) throw new Error(\"sparseIndices should be a scalar, vector, or matrix, but got shape \" + t.shape + \".\");\n            var o = t.rank > 0 ? t.shape[0] : 1, a = t.rank > 1 ? t.shape[1] : 1;\n            if (n.length !== a) throw new Error(\"outputShape has incorrect number of elements:, \" + n.length + \", should be: \" + a + \".\");\n            var i = e.size;\n            if (0 !== e.rank && (1 !== e.rank || i !== o)) throw new Error(\"sparseValues has incorrect shape \" + e.shape + \", should be [] or [\" + o + \"]\");\n            if (e.dtype !== r.dtype) throw new Error(\"sparseValues.dtype must match defaultValues.dtype\");\n        }(o, a, n, i), Lt.runKernelFunc(function(t) {\n            return t.sparseToDense(o, a, n, i);\n        }, {\n            $sparseIndices: o,\n            $sparseValues: a,\n            $defaultValue: i\n        });\n    }\n});\nvar Ch = An({\n    gatherND_: function(t, e) {\n        var n = gn(e, \"indices\", \"gatherND\", \"int32\"), r = gn(t, \"x\", \"gatherND\");\n        return Lt.runKernelFunc(function(t) {\n            return t.gatherND(r, n);\n        }, {\n            x: r,\n            indices: n\n        }, null, \"GatherNd\");\n    }\n});\nvar Eh = An({\n    diag_: function(t) {\n        var e = gn(t, \"x\", \"diag\").flatten(), n = t.shape.concat(t.shape);\n        return Lt.runKernelFunc(function(t) {\n            return t.diag(e);\n        }, {\n            $x: e\n        }).reshape(n);\n    }\n});\nvar Rh = An({\n    dropout_: function(t, e, n, r) {\n        var o = gn(t, \"x\", \"dropout\");\n        if (C(\"float32\" === o.dtype, function() {\n            return \"x has to be a floating point tensor since it's going to be scaled, but got a \" + o.dtype + \" tensor instead.\";\n        }), C(e >= 0 && e < 1, function() {\n            return \"rate must be a float in the range [0, 1), but got \" + e + \".\";\n        }), 0 === e) return t instanceof wt ? o.clone() : o;\n        var a = function(t, e) {\n            if (null == e) return t.shape.slice();\n            if (S(t.shape, e)) return e;\n            if (t.shape.length === e.length) {\n                for(var n = [], r = 0; r < t.shape.length; r++)null == e[r] && null != t.shape[r] ? n.push(t.shape[r]) : n.push(e[r]);\n                return n;\n            }\n            return e;\n        }(o, n), i = 1 - e, s = zc(a, 0, 1, \"float32\", r).add(i).floor().div(i);\n        return o.mul(s);\n    }\n});\nfunction Ih(t, e, n) {\n    for(var r = 1 - t % 2, o = new Float32Array(t), a = 0; a < t; ++a){\n        var i = 2 * Math.PI * a / (t + r - 1);\n        o[a] = e - n * Math.cos(i);\n    }\n    return Mn(o, \"float32\");\n}\nvar kh = An({\n    hannWindow_: function(t) {\n        return Ih(t, .5, .5);\n    }\n}), Sh = An({\n    hammingWindow_: function(t) {\n        return Ih(t, .54, .46);\n    }\n}), Ah = An({\n    frame_: function(t, e, n, r, o) {\n        void 0 === r && (r = !1), void 0 === o && (o = 0);\n        for(var a = 0, i = []; a + e <= t.size;)i.push(Wl(t, a, e)), a += n;\n        if (r) for(; a < t.size;){\n            var s = a + e - t.size, u = Yn([\n                Wl(t, a, e - s),\n                Hn([\n                    s\n                ], o)\n            ]);\n            i.push(u), a += n;\n        }\n        return 0 === i.length ? Bn([], [\n            0,\n            e\n        ]) : Yn(i).as2D(i.length, e);\n    }\n}), Th = An({\n    stft_: function(t, e, n, r, o) {\n        var a;\n        void 0 === o && (o = kh), null == r && (a = e, r = Math.floor(Math.pow(2, Math.ceil(Math.log(a) / Math.log(2)))));\n        for(var i = Ah(t, e, n), s = To(i, o(e)), u = [], c = 0; c < i.shape[0]; c++)u.push(yh(s.slice([\n            c,\n            0\n        ], [\n            1,\n            e\n        ]), r));\n        return Yn(u);\n    }\n}), Dh = Object.freeze({\n    hannWindow: kh,\n    hammingWindow: Sh,\n    frame: Ah,\n    stft: Th\n});\nvar Nh, Fh = function(t, e, o) {\n    return void 0 === o && (o = 1), n(this, void 0, void 0, function() {\n        var n, a, i, s, u, c, l, h, f, d, p, v, g, m;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return n = gn(t, \"predictions\", \"inTopK\"), a = gn(e, \"targets\", \"inTopK\"), C(n.rank > 1, function() {\n                        return \"inTopK() expects the predictions to be of rank 2 or higher, but got \" + n.rank;\n                    }), C(n.rank - 1 === a.rank, function() {\n                        return \"predictions rank should be 1 larger than targets rank, but got predictions rank \" + n.rank + \" and targets rank \" + a.rank;\n                    }), E(n.shape.slice(0, n.shape.length - 1), a.shape, \"predictions's shape should be align with the targets' shape, except the last dimension.\"), i = n.shape[n.shape.length - 1], C(o > 0 && o <= i, function() {\n                        return \"'k' passed to inTopK() must be > 0 && <= the predictions last dimension (\" + i + \"), but got \" + o;\n                    }), [\n                        4,\n                        n.data()\n                    ];\n                case 1:\n                    return s = r.sent(), [\n                        4,\n                        a.data()\n                    ];\n                case 2:\n                    for(u = r.sent(), c = [\n                        s.length / i,\n                        i\n                    ], h = c[1], f = B(\"bool\", l = c[0]), d = 0; d < l; d++){\n                        for(p = d * h, v = s.subarray(p, p + h), g = [], m = 0; m < v.length; m++)g.push({\n                            value: v[m],\n                            index: m\n                        });\n                        for(g.sort(function(t, e) {\n                            return e.value - t.value;\n                        }), f[d] = 0, m = 0; m < o; m++)if (g[m].index === u[d]) {\n                            f[d] = 1;\n                            break;\n                        }\n                    }\n                    return t !== n && n.dispose(), e !== a && a.dispose(), [\n                        2,\n                        Fn(f, a.shape, \"bool\")\n                    ];\n            }\n        });\n    });\n};\n!function(t) {\n    t[t.NONE = 0] = \"NONE\", t[t.MEAN = 1] = \"MEAN\", t[t.SUM = 2] = \"SUM\", t[t.SUM_BY_NONZERO_WEIGHTS = 3] = \"SUM_BY_NONZERO_WEIGHTS\";\n}(Nh || (Nh = {}));\nvar _h = An({\n    absoluteDifference_: function(t, e, n, r) {\n        void 0 === r && (r = Nh.SUM_BY_NONZERO_WEIGHTS);\n        var o = gn(t, \"labels\", \"absoluteDifference\"), a = gn(e, \"predictions\", \"absoluteDifference\"), i = null;\n        null != n && (i = gn(n, \"weights\", \"absoluteDifference\")), E(o.shape, a.shape, \"Error in absoluteDifference: \");\n        var s = o.sub(a).abs();\n        return Oh(s, i, r);\n    }\n}), Oh = An({\n    computeWeightedLoss_: function(t, e, n) {\n        void 0 === n && (n = Nh.SUM_BY_NONZERO_WEIGHTS);\n        var r = gn(t, \"losses\", \"computeWeightedLoss\"), o = null;\n        null != e && (o = gn(e, \"weights\", \"computeWeightedLoss\"));\n        var a = null == o ? r : r.mul(o);\n        if (n === Nh.NONE) return a;\n        if (n === Nh.SUM) return a.sum();\n        if (n === Nh.MEAN) {\n            if (null == o) return a.mean();\n            var i = r.size / o.size, s = a.sum().div(o.sum());\n            return i > 1 ? s.div(On(i)) : s;\n        }\n        if (n === Nh.SUM_BY_NONZERO_WEIGHTS) {\n            if (null == o) return a.sum().div(On(r.size));\n            var u = o.mul(zn(r.shape)).notEqual(On(0)).sum().toFloat();\n            return a.sum().div(u);\n        }\n        throw Error(\"Unknown reduction: \" + n);\n    }\n}), Mh = An({\n    cosineDistance_: function(t, e, n, r, o) {\n        void 0 === o && (o = Nh.SUM_BY_NONZERO_WEIGHTS);\n        var a = gn(t, \"labels\", \"cosineDistance\"), i = gn(e, \"predictions\", \"cosineDistance\"), s = null;\n        null != r && (s = gn(r, \"weights\", \"cosineDistance\")), E(a.shape, i.shape, \"Error in cosineDistance: \");\n        var u = On(1).sub(a.mul(i).sum(n, !0));\n        return Oh(u, s, o);\n    }\n}), Bh = An({\n    hingeLoss_: function(t, e, n, r) {\n        void 0 === r && (r = Nh.SUM_BY_NONZERO_WEIGHTS);\n        var o = gn(t, \"labels\", \"hingeLoss\"), a = gn(e, \"predictions\", \"hingeLoss\"), i = null;\n        null != n && (i = gn(n, \"weights\", \"hingeLoss\")), E(o.shape, a.shape, \"Error in hingeLoss: \");\n        var s = On(1);\n        o = On(2).mul(o).sub(s);\n        var u = s.sub(o.mul(a)).relu();\n        return Oh(u, i, r);\n    }\n}), Ph = An({\n    huberLoss_: function(t, e, n, r, o) {\n        void 0 === r && (r = 1), void 0 === o && (o = Nh.SUM_BY_NONZERO_WEIGHTS);\n        var a = gn(t, \"labels\", \"huberLoss\"), i = gn(e, \"predictions\", \"huberLoss\"), s = null;\n        null != n && (s = gn(n, \"weights\", \"huberLoss\")), E(a.shape, i.shape, \"Error in huberLoss: \");\n        var u = On(r), c = i.sub(a).abs(), l = Io(c, u), h = c.sub(l), f = On(.5).mul(l.square()).add(u.mul(h));\n        return Oh(f, s, o);\n    }\n}), Lh = An({\n    logLoss_: function(t, e, n, r, o) {\n        void 0 === r && (r = 1e-7), void 0 === o && (o = Nh.SUM_BY_NONZERO_WEIGHTS);\n        var a = gn(t, \"labels\", \"logLoss\"), i = gn(e, \"predictions\", \"logLoss\"), s = null;\n        null != n && (s = gn(n, \"weights\", \"logLoss\")), E(a.shape, i.shape, \"Error in logLoss: \");\n        var u = On(1), c = On(r), l = a.mul(i.add(c).log()).neg().sub(u.sub(a).mul(u.sub(i).add(c).log()));\n        return Oh(l, s, o);\n    }\n}), Wh = An({\n    meanSquaredError_: function(t, e, n, r) {\n        void 0 === r && (r = Nh.SUM_BY_NONZERO_WEIGHTS);\n        var o = gn(t, \"labels\", \"meanSquaredError\"), a = gn(e, \"predictions\", \"meanSquaredError\"), i = null;\n        null != n && (i = gn(n, \"weights\", \"meanSquaredError\")), E(o.shape, a.shape, \"Error in meanSquaredError: \");\n        var s = o.squaredDifference(a);\n        return Oh(s, i, r);\n    }\n}), Uh = An({\n    sigmoidCrossEntropy_: function(t, e, n, r, o) {\n        void 0 === r && (r = 0), void 0 === o && (o = Nh.SUM_BY_NONZERO_WEIGHTS);\n        var a = gn(t, \"multiClassLabels\", \"sigmoidCrossEntropy\"), i = gn(e, \"logits\", \"sigmoidCrossEntropy\"), s = null;\n        if (null != n && (s = gn(n, \"weights\", \"sigmoidCrossEntropy\")), E(a.shape, i.shape, \"Error in sigmoidCrossEntropy: \"), r > 0) {\n            var u = On(r), c = On(1), l = On(.5);\n            a = a.mul(c.sub(u)).add(l.mul(u));\n        }\n        var h = function(t, e) {\n            var n = gn(t, \"labels\", \"sigmoidCrossEntropyWithLogits\"), r = gn(e, \"logits\", \"sigmoidCrossEntropyWithLogits\");\n            E(n.shape, r.shape, \"Error in sigmoidCrossEntropyWithLogits: \");\n            var o = r.relu(), a = r.mul(n), i = r.abs().neg().exp().log1p();\n            return o.sub(a).add(i);\n        }(a, i);\n        return Oh(h, s, o);\n    }\n}), Vh = An({\n    softmaxCrossEntropy_: function(t, e, n, r, o) {\n        void 0 === r && (r = 0), void 0 === o && (o = Nh.SUM_BY_NONZERO_WEIGHTS);\n        var a = gn(t, \"onehotLabels\", \"softmaxCrossEntropy\"), i = gn(e, \"logits\", \"softmaxCrossEntropy\"), s = null;\n        if (null != n && (s = gn(n, \"weights\", \"softmaxCrossEntropy\")), E(a.shape, i.shape, \"Error in softmaxCrossEntropy: \"), r > 0) {\n            var u = On(r), c = On(1), l = On(a.shape[1]);\n            a = a.mul(c.sub(u)).add(u.div(l));\n        }\n        var h = function(t, e, n) {\n            if (void 0 === n && (n = -1), -1 === n && (n = e.rank - 1), n !== e.rank - 1) throw Error(\"Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank \" + e.rank + \" and dim was \" + n);\n            return oa(function(t, e, r) {\n                var o = e.logSumExp([\n                    n\n                ], !0), a = e.toFloat().sub(o);\n                r([\n                    t,\n                    a\n                ]);\n                return {\n                    value: a.mul(t).neg().sum([\n                        n\n                    ]),\n                    gradFunc: function(t, e) {\n                        var r = e[0], o = e[1], a = wn(t.shape, [\n                            n\n                        ]);\n                        return [\n                            t.reshape(a).mul(r.toFloat().sub(o.exp())),\n                            t.reshape(a).mul(o.exp().sub(r.toFloat()))\n                        ];\n                    }\n                };\n            })(t, e);\n        }(a, i);\n        return Oh(h, s, o);\n    }\n}), zh = Object.freeze({\n    get Reduction () {\n        return Nh;\n    },\n    absoluteDifference: _h,\n    computeWeightedLoss: Oh,\n    cosineDistance: Mh,\n    hingeLoss: Bh,\n    huberLoss: Ph,\n    logLoss: Lh,\n    meanSquaredError: Wh,\n    sigmoidCrossEntropy: Uh,\n    softmaxCrossEntropy: Vh\n});\nfunction Gh(t, e) {\n    return void 0 === e && (e = !1), Lt.tidy(function() {\n        if (2 !== t.shape.length) throw new Error(\"qr2d() requires a 2D Tensor, but got a \" + t.shape.length + \"D Tensor.\");\n        for(var n = t.shape[0], r = t.shape[1], o = Cc(n), a = t.clone(), i = Bn([\n            [\n                1\n            ]\n        ], [\n            1,\n            1\n        ]), s = i.clone(), u = n >= r ? r : n, c = function(t) {\n            var e, u = a, c = s, l = o;\n            e = Lt.tidy(function() {\n                var e = a.slice([\n                    t,\n                    t\n                ], [\n                    n - t,\n                    1\n                ]), u = e.norm(), c = a.slice([\n                    t,\n                    t\n                ], [\n                    1,\n                    1\n                ]), l = Bn([\n                    [\n                        -1\n                    ]\n                ]).where(c.greater(0), Bn([\n                    [\n                        1\n                    ]\n                ])), h = c.sub(l.mul(u)), f = e.div(h);\n                s = 1 === f.shape[0] ? i.clone() : i.concat(f.slice([\n                    1,\n                    0\n                ], [\n                    f.shape[0] - 1,\n                    f.shape[1]\n                ]), 0);\n                var d = l.matMul(h).div(u).neg(), p = a.slice([\n                    t,\n                    0\n                ], [\n                    n - t,\n                    r\n                ]), v = d.mul(s), g = s.transpose();\n                if (0 === t) a = p.sub(v.matMul(g.matMul(p)));\n                else {\n                    var m = p.sub(v.matMul(g.matMul(p)));\n                    a = a.slice([\n                        0,\n                        0\n                    ], [\n                        t,\n                        r\n                    ]).concat(m, 0);\n                }\n                var y = v.transpose(), x = o.slice([\n                    0,\n                    t\n                ], [\n                    n,\n                    o.shape[1] - t\n                ]);\n                if (0 === t) o = x.sub(x.matMul(s).matMul(y));\n                else {\n                    var b = x.sub(x.matMul(s).matMul(y));\n                    o = o.slice([\n                        0,\n                        0\n                    ], [\n                        n,\n                        t\n                    ]).concat(b, 1);\n                }\n                return [\n                    s,\n                    a,\n                    o\n                ];\n            }), s = e[0], a = e[1], o = e[2], tn([\n                u,\n                c,\n                l\n            ]);\n        }, l = 0; l < u; ++l)c(l);\n        return !e && n > r && (o = o.slice([\n            0,\n            0\n        ], [\n            n,\n            r\n        ]), a = a.slice([\n            0,\n            0\n        ], [\n            r,\n            r\n        ])), [\n            o,\n            a\n        ];\n    });\n}\nvar Hh = An({\n    bandPart_: function(t, e, n) {\n        if (e % 1 != 0) throw new Error(\"bandPart(): numLower must be an integer, got \" + e + \".\");\n        if (n % 1 != 0) throw new Error(\"bandPart(): numUpper must be an integer, got \" + n + \".\");\n        var r = gn(t, \"a\", \"bandPart\");\n        if (r.rank < 2) throw new Error(\"bandPart(): Rank must be at least 2, got \" + r.rank + \".\");\n        var o = r.shape, a = r.shape.slice(-2), i = a[0], s = a[1];\n        if (!(e <= i)) throw new Error(\"bandPart(): numLower (\" + e + \") must not be greater than the number of rows (\" + i + \").\");\n        if (!(n <= s)) throw new Error(\"bandPart(): numUpper (\" + n + \") must not be greater than the number of columns (\" + s + \").\");\n        e < 0 && (e = i), n < 0 && (n = s);\n        var u = Kn(0, i, 1, \"int32\").reshape([\n            -1,\n            1\n        ]), c = Kn(0, s, 1, \"int32\"), l = Oo(u, c), h = pc(l.lessEqual(On(+e, \"int32\")), l.greaterEqual(On(-n, \"int32\"))), f = Gn([\n            i,\n            s\n        ], r.dtype);\n        return hr(fr(r.reshape([\n            -1,\n            i,\n            s\n        ])).map(function(t) {\n            return yc(h, t, f);\n        })).reshape(o);\n    }\n}), qh = An({\n    gramSchmidt_: function(t) {\n        var e;\n        if (Array.isArray(t)) {\n            e = !1, C(null != t && t.length > 0, function() {\n                return \"Gram-Schmidt process: input must not be null, undefined, or empty\";\n            });\n            for(var n = t[0].shape[0], r = function(e) {\n                C(t[e].shape[0] === n, function() {\n                    return \"Gram-Schmidt: Non-unique lengths found in the input vectors: (\" + t[e].shape[0] + \" vs. \" + n + \")\";\n                });\n            }, o = 1; o < t.length; ++o)r(o);\n        } else e = !0, t = tr(t, t.shape[0], 0).map(function(t) {\n            return lr(t, [\n                0\n            ]);\n        });\n        C(t.length <= t[0].shape[0], function() {\n            return \"Gram-Schmidt: Number of vectors (\" + t.length + \") exceeds number of dimensions (\" + t[0].shape[0] + \").\";\n        });\n        var a = [], i = t, s = function(t) {\n            a.push(Lt.tidy(function() {\n                var e = i[t];\n                if (t > 0) for(var n = 0; n < t; ++n){\n                    var r = th(a[n].mulStrict(e)).mul(a[n]);\n                    e = e.sub(r);\n                }\n                return e.div(ch(e, \"euclidean\"));\n            }));\n        };\n        for(o = 0; o < t.length; ++o)s(o);\n        return e ? hr(a, 0) : a;\n    }\n}), Kh = An({\n    qr_: function(t, e) {\n        if (void 0 === e && (e = !1), t.rank < 2) throw new Error(\"qr() requires input tensor to have a rank >= 2, but got rank \" + t.rank);\n        if (2 === t.rank) return Gh(t, e);\n        var n = t.shape.slice(0, t.shape.length - 2).reduce(function(t, e) {\n            return t * e;\n        }), r = fr(t.reshape([\n            n,\n            t.shape[t.shape.length - 2],\n            t.shape[t.shape.length - 1]\n        ]), 0), o = [], a = [];\n        return r.forEach(function(t) {\n            var n = Gh(t, e), r = n[0], i = n[1];\n            o.push(r), a.push(i);\n        }), [\n            hr(o, 0).reshape(t.shape),\n            hr(a, 0).reshape(t.shape)\n        ];\n    }\n}), jh = Object.freeze({\n    bandPart: Hh,\n    gramSchmidt: qh,\n    qr: Kh\n});\nfunction Xh(t, e, n, r, o, a) {\n    null == r && (r = .5), null == o && (o = Number.NEGATIVE_INFINITY), null == a && (a = 0);\n    var i = t.shape[0];\n    return n = Math.min(n, i), C(0 <= r && r <= 1, function() {\n        return \"iouThreshold must be in [0, 1], but was '\" + r + \"'\";\n    }), C(2 === t.rank, function() {\n        return \"boxes must be a 2D tensor, but was of rank '\" + t.rank + \"'\";\n    }), C(4 === t.shape[1], function() {\n        return \"boxes must have 4 columns, but 2nd dimension was \" + t.shape[1];\n    }), C(1 === e.rank, function() {\n        return \"scores must be a 1D tensor\";\n    }), C(e.shape[0] === i, function() {\n        return \"scores has incompatible shape with boxes. Expected \" + i + \", but was \" + e.shape[0];\n    }), C(0 <= a && a <= 1, function() {\n        return \"softNmsSigma must be in [0, 1], but was '\" + a + \"'\";\n    }), {\n        maxOutputSize: n,\n        iouThreshold: r,\n        scoreThreshold: o,\n        softNmsSigma: a\n    };\n}\nvar Yh = An({\n    resizeBilinear_: function(t, e, n) {\n        void 0 === n && (n = !1);\n        var r = gn(t, \"images\", \"resizeBilinear\");\n        C(3 === r.rank || 4 === r.rank, function() {\n            return \"Error in resizeBilinear: x must be rank 3 or 4, but got rank \" + r.rank + \".\";\n        }), C(2 === e.length, function() {\n            return \"Error in resizeBilinear: new shape must 2D, but got shape \" + e + \".\";\n        });\n        var o = r, a = !1;\n        3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));\n        var i = e[0], s = e[1], u = Lt.runKernelFunc(function(t, e) {\n            return e([\n                o\n            ]), t.resizeBilinear(o, i, s, n);\n        }, {\n            x: o\n        }, function(t, e) {\n            return {\n                x: function() {\n                    return Lt.runKernelFunc(function(r) {\n                        return r.resizeBilinearBackprop(t, e[0], n);\n                    }, {});\n                }\n            };\n        }, \"ResizeBilinear\", {\n            alignCorners: n,\n            newHeight: i,\n            newWidth: s\n        });\n        return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n    }\n}), $h = An({\n    resizeNearestNeighbor_: function(t, e, n) {\n        void 0 === n && (n = !1);\n        var r = gn(t, \"images\", \"resizeNearestNeighbor\");\n        C(3 === r.rank || 4 === r.rank, function() {\n            return \"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank \" + r.rank + \".\";\n        }), C(2 === e.length, function() {\n            return \"Error in resizeNearestNeighbor: new shape must 2D, but got shape \" + e + \".\";\n        }), C(\"float32\" === r.dtype || \"int32\" === r.dtype, function() {\n            return \"`images` must have `int32` or `float32` as dtype\";\n        });\n        var o = r, a = !1;\n        3 === r.rank && (a = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));\n        var i = e[0], s = e[1], u = Lt.runKernelFunc(function(t, e) {\n            return e([\n                o\n            ]), t.resizeNearestNeighbor(o, i, s, n);\n        }, {\n            batchImages: o\n        }, function(t, e) {\n            return {\n                batchImages: function() {\n                    return Lt.runKernelFunc(function(r) {\n                        return r.resizeNearestNeighborBackprop(t, e[0], n);\n                    }, {});\n                }\n            };\n        });\n        return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n    }\n}), Qh = An({\n    nonMaxSuppression_: function(t, e, n, r, o) {\n        void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY);\n        var a = gn(t, \"boxes\", \"nonMaxSuppression\"), i = gn(e, \"scores\", \"nonMaxSuppression\"), s = Xh(a, i, n, r, o);\n        n = s.maxOutputSize, r = s.iouThreshold, o = s.scoreThreshold;\n        var u = {\n            maxOutputSize: n,\n            iouThreshold: r,\n            scoreThreshold: o\n        };\n        return Lt.runKernelFunc(function(t) {\n            return t.nonMaxSuppression(a, i, n, r, o);\n        }, {\n            boxes: a,\n            scores: i\n        }, null, \"NonMaxSuppressionV3\", u);\n    }\n}), Jh = function(t, e, o, a, i) {\n    return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), n(this, void 0, void 0, function() {\n        var n, s, u, c, l, h, f;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return n = gn(t, \"boxes\", \"nonMaxSuppressionAsync\"), s = gn(e, \"scores\", \"nonMaxSuppressionAsync\"), u = Xh(n, s, o, a, i), o = u.maxOutputSize, a = u.iouThreshold, i = u.scoreThreshold, [\n                        4,\n                        Promise.all([\n                            n.data(),\n                            s.data()\n                        ])\n                    ];\n                case 1:\n                    return c = r.sent(), l = c[0], h = c[1], f = Oa(l, h, o, a, i), n !== t && n.dispose(), s !== e && s.dispose(), [\n                        2,\n                        f\n                    ];\n            }\n        });\n    });\n}, Zh = An({\n    nonMaxSuppressionWithScore_: function(t, e, n, r, o, a) {\n        void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY), void 0 === a && (a = 0);\n        var i = gn(t, \"boxes\", \"nonMaxSuppression\"), s = gn(e, \"scores\", \"nonMaxSuppression\"), u = Xh(i, s, n, r, o, a), c = {\n            maxOutputSize: n = u.maxOutputSize,\n            iouThreshold: r = u.iouThreshold,\n            scoreThreshold: o = u.scoreThreshold,\n            softNmsSigma: a = u.softNmsSigma\n        }, l = Lt.runKernel(\"NonMaxSuppressionV5\", {\n            boxes: i,\n            scores: s\n        }, c);\n        return {\n            selectedIndices: l[0],\n            selectedScores: l[1]\n        };\n    }\n}), tf = function(t, e, o, a, i, s) {\n    return void 0 === a && (a = .5), void 0 === i && (i = Number.NEGATIVE_INFINITY), void 0 === s && (s = 0), n(this, void 0, void 0, function() {\n        var n, u, c, l, h, f, d;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return n = gn(t, \"boxes\", \"nonMaxSuppressionAsync\"), u = gn(e, \"scores\", \"nonMaxSuppressionAsync\"), c = Xh(n, u, o, a, i, s), o = c.maxOutputSize, a = c.iouThreshold, i = c.scoreThreshold, s = c.softNmsSigma, [\n                        4,\n                        Promise.all([\n                            n.data(),\n                            u.data()\n                        ])\n                    ];\n                case 1:\n                    return l = r.sent(), h = l[0], f = l[1], d = Ma(h, f, o, a, i, s), n !== t && n.dispose(), u !== e && u.dispose(), [\n                        2,\n                        d\n                    ];\n            }\n        });\n    });\n}, ef = An({\n    cropAndResize_: function(t, e, n, r, o, a) {\n        var i = gn(t, \"image\", \"cropAndResize\"), s = gn(e, \"boxes\", \"cropAndResize\", \"float32\"), u = gn(n, \"boxInd\", \"cropAndResize\", \"int32\");\n        o = o || \"bilinear\", a = a || 0;\n        var c = s.shape[0];\n        return C(4 === i.rank, function() {\n            return \"Error in cropAndResize: image must be rank 4,but got rank \" + i.rank + \".\";\n        }), C(2 === s.rank && 4 === s.shape[1], function() {\n            return \"Error in cropAndResize: boxes must be have size [\" + c + \",4] but had shape \" + s.shape + \".\";\n        }), C(1 === u.rank && u.shape[0] === c, function() {\n            return \"Error in cropAndResize: boxInd must be have size [\" + c + \"] but had shape \" + s.shape + \".\";\n        }), C(2 === r.length, function() {\n            return \"Error in cropAndResize: cropSize must be of length 2, but got length \" + r.length + \".\";\n        }), C(r[0] >= 1 && r[1] >= 1, function() {\n            return \"cropSize must be atleast [1,1], but was \" + r;\n        }), C(\"bilinear\" === o || \"nearest\" === o, function() {\n            return \"method must be bilinear or nearest, but was \" + o;\n        }), Lt.runKernelFunc(function(t, e) {\n            return t.cropAndResize(i, s, u, r, o, a);\n        }, {\n            images: i,\n            boxes: s,\n            boxInd: u\n        }, null, \"CropAndResize\", {\n            method: o,\n            extrapolationValue: a,\n            cropSize: r\n        });\n    }\n}), nf = Object.freeze({\n    resizeBilinear: Yh,\n    resizeNearestNeighbor: $h,\n    nonMaxSuppression: Qh,\n    nonMaxSuppressionAsync: Jh,\n    nonMaxSuppressionWithScore: Zh,\n    nonMaxSuppressionWithScoreAsync: tf,\n    cropAndResize: ef\n}), rf = function(t, e) {\n    return !(t > 0) || \"linear\" === e;\n}, of = function(t, e, n) {\n    if (null == n || \"linear\" === n) return t;\n    if (\"relu\" === n) return t.mul(e.step());\n    throw new Error(\"Gradient for activation \" + n + \" has not been implemented yet.\");\n}, af = function(t, e) {\n    var n = e, r = Br(t.shape, e.shape);\n    return r.length > 0 && (n = n.sum(r)), n.reshape(t.shape);\n}, sf = function(t, e, n) {\n    if (\"linear\" === e) return t;\n    if (\"relu\" === e) return ah(t);\n    if (\"elu\" === e) return nh(t);\n    if (\"relu6\" === e) return ih(t);\n    if (\"prelu\" === e) return oh(t, n);\n    throw new Error(\"Unknown fused activation \" + e + \".\");\n};\nvar uf = An({\n    fusedMatMul_: function(t) {\n        var e, n = t.a, r = t.b, o = t.transposeA, a = void 0 !== o && o, i = t.transposeB, s = void 0 !== i && i, u = t.bias, c = t.activation, l = void 0 === c ? \"linear\" : c, h = t.preluActivationWeights;\n        if (!1 === rf(Lt.state.gradientDepth, l)) {\n            var f = El(n, r, a, s);\n            return null != u && (f = Or(f, u)), sf(f, l, h);\n        }\n        var d = gn(n, \"a\", \"fused matMul\"), p = gn(r, \"b\", \"fused matMul\");\n        e = Nt(d, p), d = e[0], p = e[1];\n        var v = a ? d.shape[d.rank - 2] : d.shape[d.rank - 1], g = s ? p.shape[p.rank - 1] : p.shape[p.rank - 2], m = a ? d.shape[d.rank - 1] : d.shape[d.rank - 2], y = s ? p.shape[p.rank - 2] : p.shape[p.rank - 1], x = d.shape.slice(0, -2), b = p.shape.slice(0, -2), w = k(x), E = k(b);\n        C(d.rank >= 2 && p.rank >= 2 && d.rank === p.rank, function() {\n            return \"Error in fused matMul: inputs must have the same rank of at least 2, got ranks \" + d.rank + \" and \" + p.rank + \".\";\n        }), C(S(x, b), function() {\n            return \"Error in fused matMul: outer dimensions (\" + x + \") and (\" + b + \") of Tensors with shapes \" + d.shape + \" and \" + p.shape + \" must match.\";\n        }), C(v === g, function() {\n            return \"Error in fused matMul: inner shapes (\" + v + \") and (\" + g + \") of Tensors with shapes \" + d.shape + \" and \" + p.shape + \" and transposeA=\" + a + \" and transposeB=\" + s + \" must match.\";\n        });\n        var R, I, A = d.shape.slice(0, -2).concat([\n            m,\n            y\n        ]), T = a ? d.as3D(w, v, m) : d.as3D(w, m, v), D = s ? p.as3D(E, y, g) : p.as3D(E, g, y);\n        null != u && Pr(A, (R = Nt(R = gn(u, \"bias\", \"fused matMul\"), d)[0]).shape), null != h && (I = gn(h, \"prelu weights\", \"fused matMul\"));\n        var N = {\n            a: T,\n            b: D\n        };\n        null != u && (N.bias = R), null != h && (N.preluActivationWeights = I);\n        var F = [\n            T,\n            D\n        ];\n        return Lt.runKernelFunc(function(t, e) {\n            var n = t.fusedBatchMatMul({\n                a: T,\n                b: D,\n                transposeA: a,\n                transposeB: s,\n                bias: R,\n                activation: l,\n                preluActivationWeights: I\n            });\n            return e([\n                T,\n                D,\n                n\n            ]), n;\n        }, N, function(t, e) {\n            var n = e[0], r = e[1], o = e[2], i = of(t, o, l), c = {};\n            return null != u && (c = {\n                bias: function() {\n                    return af(R, i);\n                }\n            }), a || s ? !a && s ? Object.assign({\n                a: function() {\n                    return i.matMul(r, !1, !1);\n                },\n                b: function() {\n                    return i.matMul(n, !0, !1);\n                }\n            }, c) : a && !s ? Object.assign({\n                a: function() {\n                    return r.matMul(i, !1, !0);\n                },\n                b: function() {\n                    return n.matMul(i, !1, !1);\n                }\n            }, c) : Object.assign({\n                a: function() {\n                    return r.matMul(i, !0, !0);\n                },\n                b: function() {\n                    return i.matMul(n, !0, !0);\n                }\n            }, c) : Object.assign({\n                a: function() {\n                    return i.matMul(r, !1, !0);\n                },\n                b: function() {\n                    return n.matMul(i, !0, !1);\n                }\n            }, c);\n        }, \"_FusedMatMul\", {\n            transposeA: a,\n            transposeB: s,\n            activation: l\n        }, F, [\n            !0\n        ]).reshape(A);\n    }\n}), cf = An({\n    fusedConv2d_: function(t) {\n        var e = t.x, n = t.filter, r = t.strides, o = t.pad, a = t.dataFormat, i = void 0 === a ? \"NHWC\" : a, s = t.dilations, u = void 0 === s ? [\n            1,\n            1\n        ] : s, c = t.dimRoundingMode, l = t.bias, h = t.activation, f = void 0 === h ? \"linear\" : h, d = t.preluActivationWeights;\n        if (f = f || \"linear\", !1 === rf(Lt.state.gradientDepth, f)) {\n            var p = dl(e, n, r, o, i, u, c);\n            return null != l && (p = Or(p, l)), sf(p, f, d);\n        }\n        var v = gn(e, \"x\", \"conv2d\"), g = gn(n, \"filter\", \"conv2d\"), m = v, y = !1;\n        3 === v.rank && (y = !0, m = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), C(4 === m.rank, function() {\n            return \"Error in fused conv2d: input must be rank 4, but got rank \" + m.rank + \".\";\n        }), C(4 === g.rank, function() {\n            return \"Error in fused conv2d: filter must be rank 4, but got rank \" + g.rank + \".\";\n        }), null != c && C(A(o), function() {\n            return \"Error in fused conv2d: pad must be an integer when using, dimRoundingMode \" + c + \" but got pad \" + o + \".\";\n        }), C(m.shape[3] === g.shape[2], function() {\n            return \"Error in conv2d: depth of input (\" + m.shape[3] + \") must match input depth for filter \" + g.shape[2] + \".\";\n        }), C(Ca(r, u), function() {\n            return \"Error in conv2D: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + u + \"'\";\n        }), C(\"NHWC\" === i, function() {\n            return \"Error in conv2d: got dataFormat of \" + i + \" but only NHWC is currently supported.\";\n        });\n        var x, b, w = pa(m.shape, g.shape, r, u, o, c);\n        null != l && (x = Nt(x = gn(l, \"bias\", \"fused conv2d\"), v)[0], Pr(w.outShape, x.shape)), null != d && (b = gn(d, \"prelu weights\", \"fused conv2d\"));\n        var E = {\n            x: m,\n            filter: g\n        };\n        null != l && (E.bias = x), null != d && (E.preluActivationWeights = b);\n        var R = [\n            g,\n            m\n        ], I = Lt.runKernelFunc(function(t, e) {\n            var n = t.fusedConv2d({\n                input: m,\n                filter: g,\n                convInfo: w,\n                bias: x,\n                activation: f,\n                preluActivationWeights: b\n            });\n            return e([\n                g,\n                m,\n                n\n            ]), n;\n        }, E, function(t, e) {\n            var n = e, a = n[0], i = n[1], s = n[2], c = of(t, s, f);\n            C(wa(u), function() {\n                return \"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '\" + u + \"'\";\n            });\n            var h = {};\n            return null != l && (h = {\n                bias: function() {\n                    return af(x, c);\n                }\n            }), Object.assign({\n                x: function() {\n                    return gl(i.shape, c, a, r, o);\n                },\n                filter: function() {\n                    return vl(i, c, a.shape, r, o);\n                }\n            }, h);\n        }, \"FusedConv2D\", {\n            convInfo: w,\n            activation: f\n        }, R, [\n            !0\n        ]);\n        return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;\n    }\n}), lf = An({\n    fusedDepthwiseConv2d_: function(t) {\n        var e = t.x, n = t.filter, r = t.strides, o = t.pad, a = t.dataFormat, i = void 0 === a ? \"NHWC\" : a, s = t.dilations, u = void 0 === s ? [\n            1,\n            1\n        ] : s, c = t.dimRoundingMode, l = t.bias, h = t.activation, f = void 0 === h ? \"linear\" : h, d = t.preluActivationWeights;\n        if (!1 === rf(Lt.state.gradientDepth, f)) {\n            var p = ml(e, n, r, o, i, u, c);\n            return null != l && (p = Or(p, l)), sf(p, f, d);\n        }\n        var v = gn(e, \"x\", \"depthwiseConv2d\"), g = gn(n, \"filter\", \"depthwiseConv2d\"), m = v, y = !1;\n        3 === v.rank && (y = !0, m = v.as4D(1, v.shape[0], v.shape[1], v.shape[2])), C(4 === m.rank, function() {\n            return \"Error in fused depthwiseConv2d: input must be rank 4, but got rank \" + m.rank + \".\";\n        }), C(4 === g.rank, function() {\n            return \"Error in fused depthwiseConv2d: filter must be rank 4, but got rank \" + g.rank + \".\";\n        }), C(m.shape[3] === g.shape[2], function() {\n            return \"Error in fused depthwiseConv2d: number of input channels (\" + m.shape[3] + \") must match the inChannels dimension in filter \" + g.shape[2] + \".\";\n        }), null == u && (u = [\n            1,\n            1\n        ]), C(Ca(r, u), function() {\n            return \"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + u + \"'\";\n        }), null != c && C(A(o), function() {\n            return \"Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode \" + c + \" but got pad \" + o + \".\";\n        });\n        var x, b, w = pa(m.shape, g.shape, r, u, o, c, !0);\n        null != l && (x = Nt(x = gn(l, \"bias\", \"fused conv2d\"), v)[0], Pr(w.outShape, x.shape)), null != d && (b = gn(d, \"prelu weights\", \"fused depthwiseConv2d\"));\n        var E = {\n            x: m,\n            filter: g\n        };\n        null != l && (E.bias = x), null != d && (E.preluActivationWeights = b);\n        var R = [\n            g,\n            m\n        ], I = Lt.runKernelFunc(function(t, e) {\n            var n = t.fusedDepthwiseConv2D({\n                input: m,\n                filter: g,\n                convInfo: w,\n                bias: x,\n                activation: f,\n                preluActivationWeights: b\n            });\n            return e([\n                g,\n                m,\n                n\n            ]), n;\n        }, E, function(t, e) {\n            C(wa(u), function() {\n                return \"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '\" + u + \"'\";\n            });\n            var n = e[0], r = e[1], o = e[2], a = of(t, o, f), i = {};\n            return null != l && (i = {\n                bias: function() {\n                    return af(x, a);\n                }\n            }), Object.assign({\n                x: function() {\n                    return yl(r.shape, a, n, w);\n                },\n                filter: function() {\n                    return xl(r, a, n.shape, w);\n                }\n            }, i);\n        }, \"FusedDepthwiseConv2D\", {\n            convInfo: w,\n            activation: f\n        }, R, [\n            !0\n        ]);\n        return y ? I.as3D(I.shape[1], I.shape[2], I.shape[3]) : I;\n    }\n}), hf = Object.freeze({\n    matMul: uf,\n    conv2d: cf,\n    depthwiseConv2d: lf\n}), ff = Object.freeze({\n    image: nf,\n    linalg: jh,\n    losses: zh,\n    spectral: bh,\n    fused: hf,\n    signal: Dh,\n    add: Or,\n    addN: $u,\n    batchNorm: nc,\n    batchNormalization: ec,\n    batchNorm2d: ac,\n    batchNormalization2d: oc,\n    batchNorm3d: uc,\n    batchNormalization3d: sc,\n    batchNorm4d: hc,\n    batchNormalization4d: lc,\n    broadcastTo: fc,\n    clone: dc,\n    div: Bo,\n    divNoNan: bc,\n    eye: Cc,\n    multinomial: Ec,\n    oneHot: Rc,\n    pad: Ic,\n    pad1d: kc,\n    pad2d: Sc,\n    pad3d: Ac,\n    pad4d: Tc,\n    rand: Dc,\n    randomGamma: Uc,\n    randomNormal: Vc,\n    randomUniform: zc,\n    square: Gc,\n    squaredDifference: Hc,\n    tile: wc,\n    truncatedNormal: qc,\n    conv1d: fl,\n    conv2d: dl,\n    conv3d: pl,\n    depthwiseConv2d: ml,\n    separableConv2d: bl,\n    conv2dTranspose: wl,\n    conv3dTranspose: Cl,\n    op: An,\n    booleanMaskAsync: ul,\n    complex: Tn,\n    real: Dn,\n    imag: Nn,\n    concat: Yn,\n    concat1d: $n,\n    concat2d: Qn,\n    concat3d: Jn,\n    concat4d: Zn,\n    split: tr,\n    matMul: El,\n    dot: Rl,\n    outerProduct: Il,\n    reverse: kl,\n    reverse1d: Sl,\n    reverse2d: Al,\n    reverse3d: Tl,\n    reverse4d: Dl,\n    maxPool: _l,\n    avgPool: Ol,\n    pool: Ml,\n    maxPool3d: Bl,\n    avgPool3d: Pl,\n    maxPoolWithArgmax: Ll,\n    slice: Wl,\n    slice1d: Ul,\n    slice2d: Vl,\n    slice3d: zl,\n    slice4d: Gl,\n    abs: Lr,\n    acos: Wr,\n    acosh: Ur,\n    asin: Vr,\n    asinh: zr,\n    atan: Gr,\n    atanh: Hr,\n    ceil: qr,\n    clipByValue: Kr,\n    cos: jr,\n    cosh: Xr,\n    erf: Yr,\n    exp: $r,\n    expm1: Qr,\n    floor: Jr,\n    log: Zr,\n    log1p: to,\n    logSigmoid: eo,\n    neg: no,\n    reciprocal: ro,\n    round: oo,\n    rsqrt: ao,\n    sigmoid: io,\n    sign: so,\n    isNaN: uo,\n    isInf: co,\n    isFinite: lo,\n    sin: ho,\n    sinh: fo,\n    softplus: po,\n    sqrt: vo,\n    step: go,\n    tan: mo,\n    tanh: yo,\n    all: ql,\n    any: Kl,\n    argMax: jl,\n    argMin: Xl,\n    logSumExp: Yl,\n    max: $l,\n    mean: Ql,\n    min: Jl,\n    moments: Zl,\n    sum: th,\n    prod: eh,\n    equal: Kc,\n    equalStrict: jc,\n    greater: Xc,\n    greaterEqual: Yc,\n    greaterEqualStrict: $c,\n    greaterStrict: Qc,\n    less: Jc,\n    lessEqual: Zc,\n    lessEqualStrict: tl,\n    lessStrict: el,\n    notEqual: nl,\n    notEqualStrict: rl,\n    addStrict: xo,\n    atan2: bo,\n    divStrict: wo,\n    floorDiv: Co,\n    maximum: Eo,\n    maximumStrict: Ro,\n    minimum: Io,\n    minimumStrict: ko,\n    mod: So,\n    modStrict: Ao,\n    mul: To,\n    mulStrict: Do,\n    pow: No,\n    powStrict: Fo,\n    squaredDifferenceStrict: _o,\n    sub: Oo,\n    subStrict: Mo,\n    elu: nh,\n    leakyRelu: rh,\n    prelu: oh,\n    relu: ah,\n    relu6: ih,\n    selu: sh,\n    logicalAnd: pc,\n    logicalNot: vc,\n    logicalOr: gc,\n    logicalXor: mc,\n    where: yc,\n    whereAsync: xc,\n    buffer: er,\n    print: nr,\n    batchToSpaceND: rr,\n    cast: or,\n    cumsum: ar,\n    depthToSpace: ir,\n    expandDims: sr,\n    reshape: ur,\n    spaceToBatchND: cr,\n    squeeze: lr,\n    stack: hr,\n    unstack: fr,\n    setdiff1dAsync: dr,\n    fill: Hn,\n    linspace: qn,\n    ones: zn,\n    range: Kn,\n    scalar: On,\n    tensor: Fn,\n    tensor1d: Mn,\n    tensor2d: Bn,\n    tensor3d: Pn,\n    tensor4d: Ln,\n    tensor5d: Wn,\n    tensor6d: Un,\n    variable: Vn,\n    zeros: Gn,\n    onesLike: jn,\n    zerosLike: Xn,\n    transpose: ua,\n    softmax: ia,\n    logSoftmax: sa,\n    localResponseNormalization: uh,\n    norm: ch,\n    gather: il,\n    unsortedSegmentSum: sl,\n    basicLSTMCell: lh,\n    multiRNNCell: hh,\n    movingAverage: fh,\n    stridedSlice: dh,\n    topk: ph,\n    scatterND: vh,\n    fft: gh,\n    ifft: mh,\n    rfft: yh,\n    irfft: xh,\n    sparseToDense: wh,\n    gatherND: Ch,\n    diag: Eh,\n    dropout: Rh,\n    hannWindow: kh,\n    hammingWindow: Sh,\n    frame: Ah,\n    stft: Th,\n    inTopKAsync: Fh\n});\nfunction df(t, e) {\n    Array.isArray(t) || (t = [\n        t\n    ]), t.forEach(function(t) {\n        null != t && C(\"complex64\" !== t.dtype, function() {\n            return e + \" does not support complex64 tensors.\";\n        });\n    });\n}\nfunction pf(t, e, n, r, o, a) {\n    for(var i = o.strideHeight, s = o.strideWidth, u = o.dilationHeight, c = o.dilationWidth, l = o.effectiveFilterHeight, h = o.effectiveFilterWidth, f = o.padInfo.top, d = o.padInfo.left, p = \"max\" === a ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, v = er(o.outShape, n), g = v.values, m = o.outShape[1] * o.outShape[2] * o.outShape[3], y = o.outShape[2] * o.outShape[3], x = o.outShape[3], b = 0; b < o.batchSize; ++b)for(var w = b * m, C = b * r[0], E = 0; E < o.inChannels; ++E)for(var R = 0; R < o.outHeight; ++R)for(var I = R * i - f, k = Math.max(0, I), S = Math.min(o.inHeight, l + I), A = w + R * y, T = 0; T < o.outWidth; ++T){\n        for(var D = T * s - d, N = Math.max(0, D), F = Math.min(o.inWidth, h + D), _ = p, O = 0, M = 0, B = k; B < S; B += u){\n            for(var P = C + B * r[1], L = N; L < F; L += c){\n                var W = t[P + L * r[2] + E];\n                \"max\" === a && W > _ ? _ = W : \"avg\" === a && (O += W, M++);\n            }\n            if (isNaN(_)) break;\n        }\n        g[A + T * x + E] = \"avg\" === a ? O / M : _;\n    }\n    return v;\n}\nfunction vf(t, e, n, r, o, a) {\n    void 0 === o && (o = !1), void 0 === a && (a = !1);\n    for(var i = er(r.outShape, \"int32\"), s = r.strideHeight, u = r.strideWidth, c = r.dilationHeight, l = r.dilationWidth, h = r.effectiveFilterHeight, f = r.effectiveFilterWidth, d = r.padInfo.top, p = r.padInfo.left, v = er(e, n, t), g = 0; g < r.batchSize; ++g)for(var m = 0; m < r.inChannels; ++m)for(var y = 0; y < r.outHeight; ++y){\n        for(var x = y * s - d, b = x; b < 0;)b += c;\n        for(var w = Math.min(r.inHeight, h + x), C = 0; C < r.outWidth; ++C){\n            for(var E = C * u - p, R = E; R < 0;)R += l;\n            for(var I = Math.min(r.inWidth, f + E), k = Number.NEGATIVE_INFINITY, S = -1, A = b; A < w; A += c)for(var T = A - x, D = R; D < I; D += l){\n                var N = D - E, F = v.get(g, A, D, m);\n                F > k && (k = F, S = o ? a ? ((g * r.inHeight + A) * r.inWidth + D) * r.inChannels + m : (A * r.inWidth + D) * r.inChannels + m : T * f + N);\n            }\n            i.set(S, g, y, C, m);\n        }\n    }\n    return i;\n}\nfunction gf(t, e, n, r) {\n    if (\"linear\" === n) return t.linear(e);\n    if (\"relu\" === n) return t.relu(e);\n    if (\"elu\" === n) return t.elu(e);\n    if (\"relu6\" === n) return t.relu6(e);\n    if (\"prelu\" === n) return t.prelu(e, r);\n    throw new Error(\"Activation \" + n + \" has not been implemented for the CPU backend.\");\n}\nvar mf = function(t) {\n    function o() {\n        var e = t.call(this) || this;\n        return e.blockSize = 48, e.firstUse = !0, e.data = new ca(e, Lt), e;\n    }\n    return e(o, t), o.prototype.write = function(t, e, n) {\n        this.firstUse && (this.firstUse = !1, i().get(\"IS_NODE\") && dn(\"\\n============================\\nHi there \\uD83D\\uDC4B. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\\n============================\"));\n        var r = {};\n        return this.data.set(r, {\n            values: t,\n            dtype: n\n        }), r;\n    }, o.prototype.move = function(t, e, n, r) {\n        this.data.set(t, {\n            values: e,\n            dtype: r\n        });\n    }, o.prototype.numDataIds = function() {\n        return this.data.numDataIds();\n    }, o.prototype.read = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                return [\n                    2,\n                    this.readSync(t)\n                ];\n            });\n        });\n    }, o.prototype.readSync = function(t) {\n        var e = this.data.get(t), n = e.dtype, r = e.complexTensors;\n        return \"complex64\" === n ? Aa(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.data.get(t).values;\n    }, o.prototype.bufferSync = function(t) {\n        var e = this.readSync(t.dataId), n = e;\n        if (\"string\" === t.dtype) try {\n            n = e.map(function(t) {\n                return ot(t);\n            });\n        } catch (t) {\n            throw new Error(\"Failed to decode encoded string bytes into utf-8\");\n        }\n        return er(t.shape, t.dtype, n);\n    }, o.prototype.makeOutput = function(t, e, n) {\n        var r = this.write(t, e, n);\n        return Lt.makeTensorFromDataId(r, e, n, this);\n    }, o.prototype.disposeData = function(t) {\n        if (this.data.has(t)) {\n            var e = this.data.get(t).complexTensors;\n            null != e && (e.real.dispose(), e.imag.dispose()), this.data.delete(t);\n        }\n    }, o.prototype.time = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                return e = et(), t(), [\n                    2,\n                    {\n                        kernelMs: et() - e\n                    }\n                ];\n            });\n        });\n    }, o.prototype.memory = function() {\n        return {\n            unreliable: !0,\n            reasons: [\n                \"The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.\"\n            ]\n        };\n    }, o.prototype.complex = function(t, e) {\n        var n = this.makeOutput(null, t.shape, \"complex64\");\n        return this.data.get(n.dataId).complexTensors = {\n            real: Lt.keep(t.clone()),\n            imag: Lt.keep(e.clone())\n        }, n;\n    }, o.prototype.real = function(t) {\n        return this.data.get(t.dataId).complexTensors.real.clone();\n    }, o.prototype.imag = function(t) {\n        return this.data.get(t.dataId).complexTensors.imag.clone();\n    }, o.prototype.slice = function(t, e, n) {\n        if (df(t, \"slice\"), $o(t.shape, e, n)) {\n            var r = Qo(e, t.strides), o = k(n);\n            return Fn(this.readSync(t.dataId).subarray(r, r + o), n, t.dtype);\n        }\n        for(var a = er(n, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; ++s){\n            var u = a.indexToLoc(s).map(function(t, n) {\n                return t + e[n];\n            });\n            a.values[s] = i.get.apply(i, u);\n        }\n        return a.toTensor();\n    }, o.prototype.stridedSlice = function(t, e, n, r) {\n        df(t, \"stridedSlice\");\n        var o = jo(e, n, r);\n        if (o.some(function(t) {\n            return 0 === t;\n        })) return Fn([], o);\n        for(var a = er(o, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; s++){\n            for(var u = a.indexToLoc(s), c = new Array(u.length), l = 0; l < c.length; l++)c[l] = u[l] * r[l] + e[l];\n            a.set.apply(a, [\n                i.get.apply(i, c)\n            ].concat(u));\n        }\n        return a.toTensor();\n    }, o.prototype.diag = function(t) {\n        for(var e = this.readSync(t.dataId), n = er([\n            t.size,\n            t.size\n        ], t.dtype), r = n.values, o = 0; o < e.length; o++)r[o * t.size + o] = e[o];\n        return n.toTensor();\n    }, o.prototype.unstack = function(t, e) {\n        for(var n = t.shape[e], r = new Array(t.rank - 1), o = 0, a = 0; a < t.rank; a++)a !== e && (r[o++] = t.shape[a]);\n        var i = new Array(t.rank).fill(0), s = t.shape.slice();\n        s[e] = 1;\n        var u = new Array(n);\n        for(a = 0; a < u.length; a++)i[e] = a, u[a] = this.slice(t, i, s).reshape(r);\n        return u;\n    }, o.prototype.reverse = function(t, e) {\n        df(t, \"reverse\");\n        for(var n = er(t.shape, t.dtype), r = this.bufferSync(t), o = function(o) {\n            var a = n.indexToLoc(o), i = a.slice();\n            e.forEach(function(e) {\n                return i[e] = t.shape[e] - 1 - i[e];\n            }), n.set.apply(n, [\n                r.get.apply(r, i)\n            ].concat(a));\n        }, a = 0; a < n.size; a++)o(a);\n        return n.toTensor();\n    }, o.prototype.concat = function(t, e) {\n        var n = this;\n        if (\"complex64\" === t[0].dtype) {\n            var r = t.map(function(t) {\n                return Dn(t);\n            }), o = t.map(function(t) {\n                return Nn(t);\n            });\n            return Tn(this.concat(r, e), this.concat(o, e));\n        }\n        var a = t.map(function(t) {\n            var n = k(t.shape.slice(e));\n            return t.as2D(-1, n);\n        }), i = Sn(a.map(function(t) {\n            return t.shape;\n        }), 1), s = er(i, t[0].dtype).values;\n        if (1 === a[0].shape[0]) {\n            var u = 0;\n            a.forEach(function(t) {\n                s.set(n.readSync(t.dataId), u), u += t.size;\n            });\n        } else {\n            var c = 0;\n            a.forEach(function(t) {\n                for(var e = n.readSync(t.dataId), r = 0, o = 0; o < t.shape[0]; ++o)for(var a = o * i[1] + c, u = 0; u < t.shape[1]; ++u)s[a + u] = e[r++];\n                c += t.shape[1];\n            });\n        }\n        var l = Sn(t.map(function(t) {\n            return t.shape;\n        }), e);\n        return Fn(s, l, t[0].dtype);\n    }, o.prototype.neg = function(t) {\n        return df(t, \"neg\"), this.multiply(On(-1), t);\n    }, o.prototype.add = function(t, e) {\n        return \"complex64\" === t.dtype || \"complex64\" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast(\"complex64\"), e.cast(\"complex64\"), function(t, e, n, r) {\n            return {\n                real: t + n,\n                imag: e + r\n            };\n        }) : this.broadcastedBinaryOp(t, e, Tt(t.dtype, e.dtype), function(t, e) {\n            return t + e;\n        });\n    }, o.prototype.addN = function(t) {\n        var e = this;\n        df(t, \"addN\");\n        for(var n = t.map(function(t) {\n            return e.readSync(t.dataId);\n        }), r = er(t[0].shape, t[0].dtype), o = r.values, a = 0; a < t.length; a++)for(var i = n[a], s = 0; s < o.length; s++)o[s] += i[s];\n        return r.toTensor();\n    }, o.prototype.softmax = function(t, e) {\n        var n = O([\n            e\n        ], t.shape), r = this.max(t, n), o = wn(r.shape, n), a = this.subtract(t, r.reshape(o)), i = this.exp(a), s = this.sum(i, n).reshape(o);\n        return Bo(i, s);\n    }, o.prototype.subtract = function(t, e) {\n        return \"complex64\" === t.dtype || \"complex64\" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast(\"complex64\"), e.cast(\"complex64\"), function(t, e, n, r) {\n            return {\n                real: t - n,\n                imag: e - r\n            };\n        }) : this.broadcastedBinaryOp(t, e, Tt(t.dtype, e.dtype), function(t, e) {\n            return t - e;\n        });\n    }, o.prototype.pow = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"pow\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            return Math.pow(t, e);\n        });\n    }, o.prototype.batchMatMul = function(t, e, n, r) {\n        df([\n            t,\n            e\n        ], \"matMul\");\n        for(var o = n ? t.shape[1] : t.shape[2], a = n ? t.shape[2] : t.shape[1], i = r ? e.shape[1] : e.shape[2], s = t.shape[0], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = n ? [\n            t.strides[0],\n            1,\n            t.strides[1]\n        ] : [\n            t.strides[0],\n            t.strides[1],\n            1\n        ], h = l[0], f = l[1], d = l[2], p = r ? [\n            1,\n            e.strides[1],\n            e.strides[0]\n        ] : [\n            e.strides[1],\n            1,\n            e.strides[0]\n        ], v = p[0], g = p[1], m = p[2], y = a * i, x = er([\n            s,\n            a,\n            i\n        ], t.dtype), b = x.values, w = this.blockSize, C = 0; C < s; C++)for(var E = 0; E < a; E += w)for(var R = 0; R < i; R += w)for(var I = 0; I < o; I += w)for(var k = Math.min(E + w, a), S = Math.min(R + w, i), A = Math.min(I + w, o), T = E; T < k; T++)for(var D = R; D < S; D++){\n            for(var N = 0, F = I; F < A; F++)N += u[C * h + T * f + F * d] * c[F * v + D * g + C * m];\n            b[C * y + (T * i + D)] += N;\n        }\n        return x.toTensor();\n    }, o.prototype.fusedBatchMatMul = function(t) {\n        var e = t.a, n = t.b, r = t.transposeA, o = t.transposeB, a = t.bias, i = t.activation, s = t.preluActivationWeights, u = this.batchMatMul(e, n, r, o);\n        return a && (u = this.add(u, a)), i && (u = gf(this, u, i, s)), u;\n    }, o.prototype.multiply = function(t, e) {\n        return \"complex64\" === t.dtype || \"complex64\" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast(\"complex64\"), e.cast(\"complex64\"), function(t, e, n, r) {\n            return {\n                real: t * n - e * r,\n                imag: t * r + e * n\n            };\n        }) : this.broadcastedBinaryOp(t, e, Tt(t.dtype, e.dtype), function(t, e) {\n            return t * e;\n        });\n    }, o.prototype.floorDiv = function(t, e) {\n        df([\n            t,\n            e\n        ], \"floorDiv\");\n        return this.broadcastedBinaryOp(t, e, \"int32\", function(t, e) {\n            return Math.floor(t / e);\n        });\n    }, o.prototype.sum = function(t, e) {\n        df(t, \"sum\"), Cn(\"sum\", e, t.rank);\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, Tt(t.dtype, \"int32\")), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = 0, f = 0; f < i; ++f)h += u[l + f];\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.prod = function(t, e) {\n        df(t, \"sum\");\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, Tt(t.dtype, \"int32\")), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = 1, f = 0; f < i; ++f)h *= u[l + f];\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.unsortedSegmentSum = function(t, e, n) {\n        df(t, \"unsortedSegmentSum\");\n        for(var r = [], o = t.rank - e.rank, a = 0; a < o; ++a)e = e.expandDims(a + 1);\n        for(a = 0; a < n; ++a){\n            var i = On(a, \"int32\"), s = Kc(i, e).asType(\"float32\").mul(t).sum(0);\n            r.push(s);\n        }\n        return hr(r);\n    }, o.prototype.argMin = function(t, e) {\n        df(t, \"argMin\");\n        var n = [\n            e\n        ];\n        Cn(\"argMin\", n, t.rank);\n        for(var r = bn(t.shape, n), o = r[0], a = r[1], i = Gn(o, \"int32\"), s = k(a), u = this.readSync(i.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l){\n            for(var h = l * s, f = c[h], d = 0, p = 0; p < s; ++p){\n                var v = c[h + p];\n                v < f && (f = v, d = p);\n            }\n            u[l] = d;\n        }\n        return i;\n    }, o.prototype.argMax = function(t, e) {\n        df(t, \"argMax\");\n        var n = [\n            e\n        ];\n        Cn(\"argMax\", n, t.rank);\n        for(var r = bn(t.shape, n), o = r[0], a = r[1], i = Gn(o, \"int32\"), s = k(a), u = this.readSync(i.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l){\n            for(var h = l * s, f = c[h], d = 0, p = 0; p < s; ++p){\n                var v = c[h + p];\n                v > f && (f = v, d = p);\n            }\n            u[l] = d;\n        }\n        return i;\n    }, o.prototype.cumsum = function(t, e, n, r) {\n        if (df(t, \"cumsum\"), e !== t.rank - 1) throw new Error(\"backend.cumsum in CPU expects an inner-most axis=\" + (t.rank - 1) + \" but got axis=\" + e);\n        for(var o = Tt(t.dtype, \"int32\"), a = Gn(t.shape, o), i = this.readSync(a.dataId), s = this.readSync(t.dataId), u = t.shape[t.rank - 1], c = r ? function(t, e) {\n            return t + u - e - 1;\n        } : function(t, e) {\n            return t + e;\n        }, l = 0; l < s.length; l += u)for(var h = 0; h < u; h++){\n            var f = c(l, h);\n            if (0 === h) i[f] = n ? 0 : s[f];\n            else {\n                var d = c(l, h - 1);\n                i[f] = n ? s[d] + i[d] : s[f] + i[d];\n            }\n        }\n        return a;\n    }, o.prototype.equal = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"equal\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t === e ? 1 : 0;\n        });\n    }, o.prototype.notEqual = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"notEqual\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t !== e ? 1 : 0;\n        });\n    }, o.prototype.less = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"less\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t < e ? 1 : 0;\n        });\n    }, o.prototype.lessEqual = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"lessEqual\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t <= e ? 1 : 0;\n        });\n    }, o.prototype.greater = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"greater\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t > e ? 1 : 0;\n        });\n    }, o.prototype.greaterEqual = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"greaterEqual\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t >= e ? 1 : 0;\n        });\n    }, o.prototype.logicalNot = function(t) {\n        df(t, \"logicalNot\");\n        for(var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r)n[r] = e[r] ? 0 : 1;\n        return this.makeOutput(n, t.shape, \"bool\");\n    }, o.prototype.logicalAnd = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"logicalAnd\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t && e;\n        });\n    }, o.prototype.logicalOr = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"logicalOr\"), this.broadcastedBinaryOp(t, e, \"bool\", function(t, e) {\n            return t || e;\n        });\n    }, o.prototype.select = function(t, e, n) {\n        df([\n            t,\n            e,\n            n\n        ], \"select\");\n        for(var r = this.readSync(t.dataId), o = this.readSync(e.dataId), a = this.readSync(n.dataId), i = Gn(e.shape, Tt(e.dtype, n.dtype)), s = this.readSync(i.dataId), u = 0, c = 0 === t.rank || t.rank > 1 || 1 === e.rank ? 1 : k(e.shape.slice(1)), l = 0; l < r.length; l++)for(var h = 0; h < c; h++)1 === r[l] ? s[u++] = o[l] : s[u++] = a[l];\n        return i;\n    }, o.prototype.where = function(t) {\n        df([\n            t\n        ], \"where\");\n        var e = this.readSync(t.dataId);\n        return Ga(t.shape, e);\n    }, o.prototype.topk = function(t, e, n) {\n        return df(t, \"topk\"), za(this.readSync(t.dataId), t.shape, t.dtype, e);\n    }, o.prototype.min = function(t, e) {\n        df(t, \"min\"), Cn(\"min\", e, t.rank);\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = u[l], f = 0; f < i; ++f){\n                var d = u[l + f];\n                d < h && (h = d);\n            }\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.minimum = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"minimum\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            return Math.min(t, e);\n        });\n    }, o.prototype.mod = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"mod\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            var n = t % e;\n            return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e;\n        });\n    }, o.prototype.max = function(t, e) {\n        df(t, \"max\"), Cn(\"max\", e, t.rank);\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = u[l], f = 0; f < i; ++f){\n                var d = u[l + f];\n                d > h && (h = d);\n            }\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.maximum = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"maximum\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            return Math.max(t, e);\n        });\n    }, o.prototype.all = function(t, e) {\n        df(t, \"all\"), Cn(\"all\", e, t.rank);\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = u[l], f = 0; f < i; ++f){\n                var d = u[l + f];\n                h = h && d;\n            }\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.any = function(t, e) {\n        df(t, \"any\"), Cn(\"any\", e, t.rank);\n        for(var n = bn(t.shape, e), r = n[0], o = n[1], a = Gn(r, t.dtype), i = k(o), s = this.readSync(a.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c){\n            for(var l = c * i, h = u[l], f = 0; f < i; ++f){\n                var d = u[l + f];\n                h = h || d;\n            }\n            s[c] = h;\n        }\n        return a;\n    }, o.prototype.squaredDifference = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"squaredDifference\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            var n = t - e;\n            return n * n;\n        });\n    }, o.prototype.ceil = function(t) {\n        df(t, \"ceil\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.ceil(e[r]);\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.floor = function(t) {\n        df(t, \"floor\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.floor(e[r]);\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.sign = function(t) {\n        df(t, \"x\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)e[r] < 0 ? n[r] = -1 : e[r] > 0 ? n[r] = 1 : n[r] = 0;\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.isNaN = function(t) {\n        df(t, \"x\");\n        for(var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r)Number.isNaN(e[r]) && (n[r] = 1);\n        return this.makeOutput(n, t.shape, \"bool\");\n    }, o.prototype.isInf = function(t) {\n        df(t, \"x\");\n        for(var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r)Math.abs(e[r]) === 1 / 0 && (n[r] = 1);\n        return this.makeOutput(n, t.shape, \"bool\");\n    }, o.prototype.isFinite = function(t) {\n        df(t, \"x\");\n        for(var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r)Number.isFinite(e[r]) && (n[r] = 1);\n        return this.makeOutput(n, t.shape, \"bool\");\n    }, o.prototype.round = function(t) {\n        df(t, \"round\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r){\n            var o = Math.floor(e[r]);\n            e[r] - o < .5 ? n[r] = Math.floor(e[r]) : e[r] - o > .5 ? n[r] = Math.ceil(e[r]) : n[r] = o % 2 == 0 ? o : o + 1;\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.exp = function(t) {\n        df(t, \"exp\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.exp(e[r]);\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.expm1 = function(t) {\n        df(t, \"expm1\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = Math.expm1(e[r]);\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.log = function(t) {\n        df(t, \"log\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r){\n            var o = e[r];\n            n[r] = Math.log(o);\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.log1p = function(t) {\n        df(t, \"log1p\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r){\n            var o = e[r];\n            n[r] = Math.log1p(o);\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.sqrt = function(t) {\n        df(t, \"sqrt\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r){\n            var o = e[r];\n            n[r] = Math.sqrt(o);\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.rsqrt = function(t) {\n        df(t, \"rsqrt\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r){\n            var o = e[r];\n            n[r] = 1 / Math.sqrt(o);\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.reciprocal = function(t) {\n        df(t, \"reciprocal\");\n        for(var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r)n[r] = 1 / e[r];\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.linear = function(t) {\n        return t;\n    }, o.prototype.relu = function(t) {\n        df(t, \"relu\");\n        for(var e = Gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o)n[o] = Math.max(0, r[o]);\n        return e;\n    }, o.prototype.relu6 = function(t) {\n        df(t, \"relu\");\n        for(var e = Gn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o)n[o] = Math.min(Math.max(0, r[o]), 6);\n        return e;\n    }, o.prototype.prelu = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"prelu\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            return t < 0 ? e * t : t;\n        });\n    }, o.prototype.elu = function(t) {\n        df(t, \"elu\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r){\n            var o = n[r];\n            e[r] = o >= 0 ? o : Math.exp(o) - 1;\n        }\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.eluDer = function(t, e) {\n        df([\n            t,\n            e\n        ], \"eluDer\");\n        for(var n = new Float32Array(e.size), r = this.readSync(e.dataId), o = this.readSync(t.dataId), a = 0; a < r.length; ++a){\n            var i = r[a];\n            n[a] = i >= 1 ? o[a] : o[a] * (i + 1);\n        }\n        return this.makeOutput(n, e.shape, \"float32\");\n    }, o.prototype.selu = function(t) {\n        df(t, \"selu\");\n        for(var e = su, n = uu, r = new Float32Array(t.size), o = this.readSync(t.dataId), a = 0; a < o.length; ++a){\n            var i = o[a];\n            r[a] = i >= 0 ? n * i : e * (Math.exp(i) - 1);\n        }\n        return this.makeOutput(r, t.shape, \"float32\");\n    }, o.prototype.clip = function(t, e, n) {\n        df(t, \"clip\");\n        for(var r = new Float32Array(t.size), o = this.readSync(t.dataId), a = 0; a < o.length; ++a){\n            var i = o[a];\n            r[a] = i > n ? n : i < e ? e : i;\n        }\n        return this.makeOutput(r, t.shape, \"float32\");\n    }, o.prototype.abs = function(t) {\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.abs(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.complexAbs = function(t) {\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < t.size; ++r){\n            var o = n[2 * r], a = n[2 * r + 1];\n            e[r] = Math.hypot(o, a);\n        }\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.int = function(t) {\n        df(t, \"int\");\n        for(var e = new Int32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = n[r];\n        return this.makeOutput(e, t.shape, \"int32\");\n    }, o.prototype.sigmoid = function(t) {\n        df(t, \"sigmoid\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = 1 / (1 + Math.exp(-n[r]));\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.softplus = function(t) {\n        df(t, \"softplus\");\n        for(var e = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o){\n            var a = r[o] > -e, i = r[o] < e, s = Math.exp(r[o]), u = void 0;\n            u = i ? s : a ? r[o] : Math.log(1 + s), n[o] = u;\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.sin = function(t) {\n        df(t, \"sin\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.sin(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.cos = function(t) {\n        df(t, \"cos\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.cos(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.tan = function(t) {\n        df(t, \"tan\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.tan(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.asin = function(t) {\n        df(t, \"asin\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.asin(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.acos = function(t) {\n        df(t, \"acos\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.acos(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.atan = function(t) {\n        df(t, \"atan\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.atan(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.atan2 = function(t, e) {\n        return df([\n            t,\n            e\n        ], \"atan2\"), this.broadcastedBinaryOp(t, e, t.dtype, function(t, e) {\n            return Math.atan2(t, e);\n        });\n    }, o.prototype.sinh = function(t) {\n        df(t, \"sinh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.sinh(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.cosh = function(t) {\n        df(t, \"cosh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.cosh(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.tanh = function(t) {\n        df(t, \"tanh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = T(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.asinh = function(t) {\n        df(t, \"asinh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.asinh(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.acosh = function(t) {\n        df(t, \"acosh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.acosh(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.atanh = function(t) {\n        df(t, \"atanh\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r)e[r] = Math.atanh(n[r]);\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.erf = function(t) {\n        df(t, \"erf\");\n        for(var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r){\n            var o = Math.sign(n[r]), a = Math.abs(n[r]), i = 1 / (1 + .3275911 * a);\n            e[r] = o * (1 - ((((1.061405429 * i - 1.453152027) * i + 1.421413741) * i - .284496736) * i + .254829592) * i * Math.exp(-a * a));\n        }\n        return this.makeOutput(e, t.shape, \"float32\");\n    }, o.prototype.step = function(t, e) {\n        void 0 === e && (e = 0), df(t, \"step\");\n        for(var n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o){\n            var a = r[o];\n            isNaN(a) ? n[o] = NaN : n[o] = a > 0 ? 1 : e;\n        }\n        return this.makeOutput(n, t.shape, \"float32\");\n    }, o.prototype.fusedConv2d = function(t) {\n        var e = t.input, n = t.filter, r = t.convInfo, o = t.bias, a = t.activation, i = t.preluActivationWeights, s = this.conv2d(e, n, r);\n        return o && (s = this.add(s, o)), a && (s = gf(this, s, a, i)), s;\n    }, o.prototype.conv2d = function(t, e, n) {\n        df([\n            t,\n            e\n        ], \"conv2d\");\n        for(var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = \"channelsLast\" === n.dataFormat, l = er(n.outShape, t.dtype), h = t.strides[0], f = c ? t.strides[1] : t.strides[2], d = c ? t.strides[2] : 1, p = c ? 1 : t.strides[1], v = l.strides[0], g = c ? l.strides[1] : l.strides[2], m = c ? l.strides[2] : 1, y = c ? 1 : l.strides[1], x = this.readSync(t.dataId), b = this.readSync(e.dataId), w = l.values, C = 0; C < n.batchSize; ++C)for(var E = C * h, R = C * v, I = 0; I < n.outHeight; ++I)for(var k = R + I * g, S = I * n.strideHeight - u, A = 0; A < r; A++){\n            var T = S + A * a;\n            if (!(T < 0 || T >= n.inHeight)) for(var D = A * e.strides[0], N = E + T * f, F = 0; F < n.outWidth; ++F)for(var _ = k + F * m, O = F * n.strideWidth - s, M = 0; M < o; M++){\n                var B = O + M * i;\n                if (!(B < 0 || B >= n.inWidth)) for(var P = N + B * d, L = D + M * e.strides[1], W = 0; W < n.inChannels; ++W){\n                    for(var U = x[P + W * p], V = 0; V < n.outChannels; ++V)w[_ + V * y] += U * b[L + V];\n                    L += n.outChannels;\n                }\n            }\n        }\n        return l.toTensor();\n    }, o.prototype.conv3d = function(t, e, n) {\n        for(var r = n.filterDepth, o = n.filterHeight, a = n.filterWidth, i = n.dilationDepth, s = n.dilationHeight, u = n.dilationWidth, c = n.padInfo.front, l = n.padInfo.left, h = n.padInfo.top, f = er(n.outShape, t.dtype), d = this.readSync(t.dataId), p = this.readSync(e.dataId), v = f.values, g = 0; g < n.batchSize; ++g)for(var m = g * t.strides[0], y = g * f.strides[0], x = 0; x < n.outDepth; ++x)for(var b = y + x * f.strides[1], w = x * n.strideDepth - c, C = 0; C < r; C++){\n            var E = w + C * i;\n            if (!(E < 0 || E >= n.inDepth)) for(var R = C * e.strides[0], I = m + E * t.strides[1], k = 0; k < n.outHeight; ++k)for(var S = b + k * f.strides[2], A = k * n.strideHeight - h, T = 0; T < o; T++){\n                var D = A + T * s;\n                if (!(D < 0 || D >= n.inHeight)) for(var N = R + T * e.strides[1], F = I + D * t.strides[2], _ = 0; _ < n.outWidth; ++_)for(var O = S + _ * n.outChannels, M = _ * n.strideWidth - l, B = 0; B < a; B++){\n                    var P = M + B * u;\n                    if (!(P < 0 || P >= n.inWidth)) for(var L = N + B * e.strides[2], W = F + P * n.inChannels, U = L, V = 0; V < n.inChannels; ++V){\n                        for(var z = d[W + V], G = 0; G < n.outChannels; ++G)v[O + G] += z * p[U + G];\n                        U += n.outChannels;\n                    }\n                }\n            }\n        }\n        return f.toTensor();\n    }, o.prototype.conv2dDerInput = function(t, e, n) {\n        df([\n            t,\n            e\n        ], \"conv2dDerInput\");\n        for(var r = er(n.inShape, \"float32\"), o = r.values, a = this.readSync(t.dataId), i = this.readSync(e.dataId), s = e.strides, u = s[0], c = s[1], l = s[2], h = n.batchSize, f = n.filterHeight, d = n.filterWidth, p = n.inChannels, v = n.inHeight, g = n.inWidth, m = n.outChannels, y = n.outHeight, x = n.outWidth, b = n.strideHeight, w = n.strideWidth, C = n.dataFormat, E = f - 1 - n.padInfo.top, R = d - 1 - n.padInfo.left, I = \"channelsLast\" === C, k = r.strides[0], S = I ? r.strides[1] : r.strides[2], A = I ? r.strides[2] : 1, T = I ? 1 : r.strides[1], D = t.strides[0], N = I ? t.strides[1] : t.strides[2], F = I ? t.strides[2] : 1, _ = I ? 1 : t.strides[1], O = 0; O < h; ++O)for(var M = 0; M < p; ++M)for(var B = 0; B < v; ++B)for(var P = B - E, L = Math.max(0, Math.ceil(P / b)), W = Math.min(y, (f + P) / b), U = 0; U < g; ++U){\n            for(var V = U - R, z = Math.max(0, Math.ceil(V / w)), G = Math.min(x, (d + V) / w), H = 0, q = L; q < W; ++q)for(var K = q * b - P, j = z; j < G; ++j)for(var X = D * O + N * q + F * j, Y = u * (f - 1 - K) + c * (d - 1 - (j * w - V)) + l * M, $ = 0; $ < m; ++$){\n                H += a[X + _ * $] * i[Y + $];\n            }\n            o[k * O + S * B + A * U + T * M] = H;\n        }\n        return r.toTensor();\n    }, o.prototype.conv3dDerInput = function(t, e, n) {\n        for(var r = er(n.inShape, \"float32\"), o = r.values, a = r.strides, i = a[0], s = a[1], u = a[2], c = a[3], l = this.readSync(t.dataId), h = t.strides, f = h[0], d = h[1], p = h[2], v = h[3], g = this.readSync(e.dataId), m = e.strides, y = m[0], x = m[1], b = m[2], w = m[3], C = n.batchSize, E = n.filterDepth, R = n.filterHeight, I = n.filterWidth, k = n.inChannels, S = n.inDepth, A = n.inHeight, T = n.inWidth, D = n.outChannels, N = n.outDepth, F = n.outHeight, _ = n.outWidth, O = n.strideDepth, M = n.strideHeight, B = n.strideWidth, P = E - 1 - n.padInfo.front, L = R - 1 - n.padInfo.top, W = I - 1 - n.padInfo.left, U = 0; U < C; ++U)for(var V = 0; V < k; ++V)for(var z = 0; z < S; ++z)for(var G = z - P, H = Math.max(0, Math.ceil(G / O)), q = Math.min(N, (E + G) / O), K = 0; K < A; ++K)for(var j = K - L, X = Math.max(0, Math.ceil(j / M)), Y = Math.min(F, (R + j) / M), $ = 0; $ < T; ++$){\n            for(var Q = $ - W, J = Math.max(0, Math.ceil(Q / B)), Z = Math.min(_, (I + Q) / B), tt = 0, et = H; et < q; ++et)for(var nt = et * O - G, rt = X; rt < Y; ++rt)for(var ot = rt * M - j, at = J; at < Z; ++at)for(var it = f * U + d * et + p * rt + v * at, st = y * (E - 1 - nt) + x * (R - 1 - ot) + b * (I - 1 - (at * B - Q)) + w * V, ut = 0; ut < D; ++ut){\n                tt += l[it + ut] * g[st + ut];\n            }\n            o[i * U + s * z + u * K + c * $ + V] = tt;\n        }\n        return r.toTensor();\n    }, o.prototype.conv2dDerFilter = function(t, e, n) {\n        df([\n            t,\n            e\n        ], \"conv2dDerFilter\");\n        for(var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = \"channelsLast\" === n.dataFormat, u = er(n.filterShape, \"float32\"), c = n.padInfo.left, l = n.padInfo.top, h = this.bufferSync(t), f = this.bufferSync(e), d = 0; d < a; ++d)for(var p = Math.max(0, Math.ceil((l - d) / r)), v = Math.min(n.outHeight, (n.inHeight + l - d) / r), g = 0; g < i; ++g)for(var m = Math.max(0, Math.ceil((c - g) / o)), y = Math.min(n.outWidth, (n.inWidth + c - g) / o), x = 0; x < n.inChannels; ++x)for(var b = 0; b < n.outChannels; ++b){\n            for(var w = 0, C = 0; C < n.batchSize; ++C)for(var E = p; E < v; ++E)for(var R = d + E * r - l, I = m; I < y; ++I){\n                var k = g + I * o - c;\n                w += s ? h.get(C, R, k, x) * f.get(C, E, I, b) : h.get(C, x, R, k) * f.get(C, b, E, I);\n            }\n            u.set(w, d, g, x, b);\n        }\n        return u.toTensor();\n    }, o.prototype.conv3dDerFilter = function(t, e, n) {\n        for(var r = n.strideDepth, o = n.strideHeight, a = n.strideWidth, i = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = er(n.filterShape, \"float32\"), l = c.values, h = c.strides, f = h[0], d = h[1], p = h[2], v = h[3], g = this.readSync(e.dataId), m = e.strides, y = m[0], x = m[1], b = m[2], w = m[3], C = this.readSync(t.dataId), E = t.strides, R = E[0], I = E[1], k = E[2], S = E[3], A = n.padInfo.front, T = n.padInfo.left, D = n.padInfo.top, N = 0; N < i; ++N)for(var F = Math.max(0, Math.ceil((A - N) / r)), _ = Math.min(n.outDepth, (n.inDepth + A - N) / r), O = N * f, M = 0; M < s; ++M)for(var B = Math.max(0, Math.ceil((D - M) / o)), P = Math.min(n.outHeight, (n.inHeight + D - M) / o), L = M * d + O, W = 0; W < u; ++W)for(var U = Math.max(0, Math.ceil((T - W) / a)), V = Math.min(n.outWidth, (n.inWidth + T - W) / a), z = W * p + L, G = 0; G < n.inChannels; ++G)for(var H = G * v + z, q = 0; q < n.outChannels; ++q){\n            for(var K = 0, j = 0; j < n.batchSize; ++j)for(var X = j * R, Y = j * y, $ = F; $ < _; ++$)for(var Q = (N + $ * r - A) * I + X, J = $ * x + Y, Z = B; Z < P; ++Z)for(var tt = (M + Z * o - D) * k + Q, et = Z * b + J, nt = U; nt < V; ++nt){\n                var rt = nt * w + et;\n                K += C[(W + nt * a - T) * S + tt + G] * g[rt + q];\n            }\n            l[H + q] = K;\n        }\n        return c.toTensor();\n    }, o.prototype.fusedDepthwiseConv2D = function(t) {\n        var e = t.input, n = t.filter, r = t.convInfo, o = t.bias, a = t.activation, i = t.preluActivationWeights, s = this.depthwiseConv2D(e, n, r);\n        return o && (s = this.add(s, o)), a && (s = gf(this, s, a, i)), s;\n    }, o.prototype.depthwiseConv2D = function(t, e, n) {\n        df([\n            t,\n            e\n        ], \"depthwiseConv2D\");\n        for(var r = n.filterHeight, o = n.filterWidth, a = n.dilationHeight, i = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = n.outChannels / n.inChannels, l = er(n.outShape, t.dtype), h = this.readSync(t.dataId), f = this.readSync(e.dataId), d = l.values, p = 0; p < n.batchSize; ++p)for(var v = p * t.strides[0], g = p * l.strides[0], m = 0; m < n.outHeight; ++m)for(var y = g + m * l.strides[1], x = m * n.strideHeight - s, b = 0; b < r; ++b){\n            var w = x + b * a;\n            if (!(w < 0 || w >= n.inHeight)) for(var C = b * e.strides[0], E = v + w * t.strides[1], R = 0; R < n.outWidth; ++R)for(var I = y + R * l.strides[2], k = R * n.strideWidth - u, S = 0; S < o; ++S){\n                var A = k + S * i;\n                if (!(A < 0 || A >= n.inWidth)) for(var T = C + S * e.strides[1], D = E + A * n.inChannels, N = I, F = T, _ = 0; _ < n.inChannels; ++_){\n                    for(var O = h[D + _], M = 0; M < c; ++M)d[N + M] += O * f[F + M];\n                    N += c, F += c;\n                }\n            }\n        }\n        return l.toTensor();\n    }, o.prototype.depthwiseConv2DDerInput = function(t, e, n) {\n        df([\n            t,\n            e\n        ], \"depthwiseConv2DDerInput\");\n        for(var r = er(n.inShape, \"float32\"), o = r.values, a = r.strides, i = a[0], s = a[1], u = a[2], c = this.readSync(t.dataId), l = t.strides, h = l[0], f = l[1], d = l[2], p = this.readSync(e.dataId), v = e.strides, g = v[0], m = v[1], y = v[2], x = n.batchSize, b = n.filterHeight, w = n.filterWidth, C = n.inChannels, E = n.inHeight, R = n.inWidth, I = n.outChannels, k = n.outHeight, S = n.outWidth, A = n.strideHeight, T = n.strideWidth, D = b - 1 - n.padInfo.top, N = w - 1 - n.padInfo.left, F = I / C, _ = 0; _ < x; ++_)for(var O = 0; O < C; ++O)for(var M = 0; M < E; ++M)for(var B = M - D, P = Math.max(0, Math.ceil(B / A)), L = Math.min(k, (b + B) / A), W = 0; W < R; ++W){\n            for(var U = W - N, V = Math.max(0, Math.ceil(U / T)), z = Math.min(S, (w + U) / T), G = 0, H = P; H < L; ++H)for(var q = H * A - B, K = V; K < z; ++K)for(var j = h * _ + f * H + d * K, X = g * (b - 1 - q) + m * (w - 1 - (K * T - U)) + y * O, Y = 0; Y < F; ++Y){\n                G += c[j + (O * F + Y)] * p[X + Y];\n            }\n            o[i * _ + s * M + u * W + O] = G;\n        }\n        return r.toTensor();\n    }, o.prototype.depthwiseConv2DDerFilter = function(t, e, n) {\n        df([\n            t,\n            e\n        ], \"depthwiseConv2DDerFilter\");\n        for(var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = er(n.filterShape, \"float32\"), u = n.padInfo.left, c = n.padInfo.top, l = n.outChannels / n.inChannels, h = this.bufferSync(t), f = this.bufferSync(e), d = 0; d < a; ++d)for(var p = Math.max(0, Math.ceil((c - d) / r)), v = Math.min(n.outHeight, (n.inHeight + c - d) / r), g = 0; g < i; ++g)for(var m = Math.max(0, Math.ceil((u - g) / o)), y = Math.min(n.outWidth, (n.inWidth + u - g) / o), x = 0; x < n.outChannels; ++x){\n            for(var b = Math.trunc(x / l), w = x % l, C = 0, E = 0; E < n.batchSize; ++E)for(var R = p; R < v; ++R)for(var I = d + R * r - c, k = m; k < y; ++k){\n                var S = g + k * o - u;\n                C += h.get(E, I, S, b) * f.get(E, R, k, x);\n            }\n            s.set(C, d, g, b, w);\n        }\n        return s.toTensor();\n    }, o.prototype.tile = function(t, e) {\n        return df(t, \"tile\"), Va(this.bufferSync(t), e);\n    }, o.prototype.pad = function(t, e, n) {\n        df(t, \"pad\");\n        var r = e.map(function(e, n) {\n            return e[0] + t.shape[n] + e[1];\n        }), o = e.map(function(t) {\n            return t[0];\n        }), a = this.bufferSync(t), i = er(r, t.dtype);\n        0 !== n && i.values.fill(n);\n        for(var s = 0; s < t.size; s++){\n            var u = a.indexToLoc(s), c = u.map(function(t, e) {\n                return t + o[e];\n            });\n            i.set.apply(i, [\n                a.get.apply(a, u)\n            ].concat(c));\n        }\n        return i.toTensor();\n    }, o.prototype.gather = function(t, e, n) {\n        df([\n            t,\n            e\n        ], \"gather\");\n        var r = t.shape.slice(), o = this.readSync(e.dataId);\n        r[n] = o.length;\n        for(var a = er(r, t.dtype), i = this.bufferSync(t), s = 0; s < a.size; ++s){\n            var u = a.indexToLoc(s), c = u.slice();\n            c[n] = o[u[n]];\n            var l = i.locToIndex(c);\n            a.values[s] = i.values[l];\n        }\n        return a.toTensor();\n    }, o.prototype.batchToSpaceND = function(t, e, n) {\n        df([\n            t\n        ], \"batchToSpaceND\");\n        var r = e.reduce(function(t, e) {\n            return t * e;\n        }), o = pr(t.shape, e, r), a = vr(o.length, e.length), i = gr(t.shape, e, r), s = mr(n, e.length), u = yr(i, n, e.length);\n        return ua(t.reshape(o), a).reshape(i).slice(s, u);\n    }, o.prototype.spaceToBatchND = function(t, e, n) {\n        df([\n            t\n        ], \"spaceToBatchND\");\n        var r = e.reduce(function(t, e) {\n            return t * e;\n        }), o = [\n            [\n                0,\n                0\n            ]\n        ];\n        o.push.apply(o, n);\n        for(var a = 1 + e.length; a < t.shape.length; ++a)o.push([\n            0,\n            0\n        ]);\n        var i = t.pad(o), s = pr(i.shape, e, r, !1), u = vr(s.length, e.length, !1), c = gr(i.shape, e, r, !1);\n        return ua(i.reshape(s), u).reshape(c);\n    }, o.prototype.maxPool = function(t, e) {\n        return df(t, \"maxPool\"), pf(this.readSync(t.dataId), t.shape, t.dtype, t.strides, e, \"max\").toTensor();\n    }, o.prototype.maxPoolBackprop = function(t, e, n, r) {\n        df([\n            e,\n            n\n        ], \"maxPoolBackprop\");\n        for(var o = this.readSync(e.dataId), a = er(r.outShape, e.dtype, vf(o, e.shape, e.dtype, r).values), i = r.strideHeight, s = r.strideWidth, u = r.dilationHeight, c = r.dilationWidth, l = r.effectiveFilterHeight, h = r.effectiveFilterWidth, f = h - 1 - r.padInfo.left, d = l - 1 - r.padInfo.top, p = er(e.shape, \"float32\"), v = this.bufferSync(t), g = 0; g < r.batchSize; ++g)for(var m = 0; m < r.inChannels; ++m)for(var y = 0; y < r.inHeight; ++y)for(var x = 0; x < r.inWidth; ++x){\n            for(var b = y - d, w = x - f, C = 0, E = 0; E < l; E += u){\n                var R = (b + E) / i;\n                if (!(R < 0 || R >= r.outHeight || Math.floor(R) !== R)) for(var I = 0; I < h; I += c){\n                    var k = (w + I) / s;\n                    if (!(k < 0 || k >= r.outWidth || Math.floor(k) !== k)) {\n                        var S = l * h - 1 - a.get(g, R, k, m) === E * h + I ? 1 : 0;\n                        if (0 !== S) C += v.get(g, R, k, m) * S;\n                    }\n                }\n            }\n            p.set(C, g, y, x, m);\n        }\n        return p.toTensor();\n    }, o.prototype.avgPoolBackprop = function(t, e, n) {\n        df([\n            t,\n            e\n        ], \"avgPoolBackprop\");\n        for(var r = n.strideHeight, o = n.strideWidth, a = n.filterHeight, i = n.filterWidth, s = n.dilationHeight, u = n.dilationWidth, c = n.effectiveFilterHeight, l = n.effectiveFilterWidth, h = l - 1 - n.padInfo.left, f = c - 1 - n.padInfo.top, d = er(e.shape, \"float32\"), p = 1 / (a * i), v = this.bufferSync(t), g = 0; g < n.batchSize; ++g)for(var m = 0; m < n.inChannels; ++m)for(var y = 0; y < n.inHeight; ++y)for(var x = 0; x < n.inWidth; ++x){\n            for(var b = y - f, w = x - h, C = 0, E = 0; E < c; E += s){\n                var R = (b + E) / r;\n                if (!(R < 0 || R >= n.outHeight || Math.floor(R) !== R)) for(var I = 0; I < l; I += u){\n                    var k = (w + I) / o;\n                    if (!(k < 0 || k >= n.outWidth || Math.floor(k) !== k)) C += v.get(g, R, k, m);\n                }\n            }\n            d.set(C * p, g, y, x, m);\n        }\n        return d.toTensor();\n    }, o.prototype.pool3d = function(t, e, n) {\n        df(t, \"pool3d\");\n        for(var r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, i = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, f = e.padInfo.front, d = e.padInfo.top, p = e.padInfo.left, v = \"max\" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, g = this.readSync(t.dataId), m = er(e.outShape, t.dtype), y = m.values, x = e.outShape[1] * e.outShape[2] * e.outShape[3] * e.outShape[4], b = e.outShape[2] * e.outShape[3] * e.outShape[4], w = e.outShape[3] * e.outShape[4], C = e.outShape[4], E = 0; E < e.batchSize; ++E)for(var R = E * x, I = E * t.strides[0], k = 0; k < e.inChannels; ++k)for(var S = 0; S < e.outDepth; ++S){\n            for(var A = S * r - f, T = A; T < 0;)T += i;\n            for(var D = Math.min(e.inDepth, c + A), N = R + S * b, F = 0; F < e.outHeight; ++F){\n                for(var _ = F * o - d, O = _; O < 0;)O += s;\n                for(var M = Math.min(e.inHeight, l + _), B = N + F * w, P = 0; P < e.outWidth; ++P){\n                    for(var L = P * a - p, W = L; W < 0;)W += u;\n                    for(var U = Math.min(e.inWidth, h + L), V = B + P * C, z = v, G = 0, H = 0, q = T; q < D; q += i){\n                        for(var K = I + q * t.strides[1], j = O; j < M; j += s){\n                            for(var X = K + j * t.strides[2], Y = W; Y < U; Y += u){\n                                var $ = g[X + Y * t.strides[3] + k];\n                                if (\"max\" === n && $ > z ? z = $ : \"avg\" === n && (G += $, H++), isNaN(z)) break;\n                            }\n                            if (isNaN(z)) break;\n                        }\n                        if (isNaN(z)) break;\n                    }\n                    y[V + k] = \"avg\" === n ? G / H : z;\n                }\n            }\n        }\n        return m.toTensor();\n    }, o.prototype.avgPool3d = function(t, e) {\n        return df(t, \"avgPool3d\"), this.pool3d(t, e, \"avg\").toFloat();\n    }, o.prototype.avgPool3dBackprop = function(t, e, n) {\n        df([\n            t,\n            e\n        ], \"avgPool3dBackprop\");\n        for(var r = n.strideDepth, o = n.strideHeight, a = n.strideWidth, i = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = n.dilationDepth, l = n.dilationHeight, h = n.dilationWidth, f = n.effectiveFilterDepth, d = n.effectiveFilterHeight, p = n.effectiveFilterWidth, v = f - 1 - n.padInfo.front, g = p - 1 - n.padInfo.left, m = d - 1 - n.padInfo.top, y = er(e.shape, \"float32\"), x = 1 / (i * s * u), b = this.bufferSync(t), w = 0; w < n.batchSize; ++w)for(var C = 0; C < n.inChannels; ++C)for(var E = 0; E < n.inDepth; ++E)for(var R = 0; R < n.inHeight; ++R)for(var I = 0; I < n.inWidth; ++I){\n            for(var k = E - v, S = R - m, A = I - g, T = 0, D = 0; D < f; D += c){\n                var N = (k + D) / r;\n                if (!(N < 0 || N >= n.outDepth || Math.floor(N) !== N)) for(var F = 0; F < d; F += l){\n                    var _ = (S + F) / o;\n                    if (!(_ < 0 || _ >= n.outHeight || Math.floor(_) !== _)) for(var O = 0; O < p; O += h){\n                        var M = (A + O) / a;\n                        if (!(M < 0 || M >= n.outWidth || Math.floor(M) !== M)) T += b.get(w, N, _, M, C);\n                    }\n                }\n            }\n            y.set(T * x, w, E, R, I, C);\n        }\n        return y.toTensor();\n    }, o.prototype.maxPool3d = function(t, e) {\n        return df(t, \"maxPool3d\"), this.pool3d(t, e, \"max\").toFloat();\n    }, o.prototype.maxPool3dPositions = function(t, e) {\n        for(var n = er(e.outShape, \"int32\"), r = e.strideDepth, o = e.strideHeight, a = e.strideWidth, i = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, f = e.padInfo.front, d = e.padInfo.top, p = e.padInfo.left, v = this.bufferSync(t), g = 0; g < e.batchSize; ++g)for(var m = 0; m < e.inChannels; ++m)for(var y = 0; y < e.outDepth; ++y){\n            for(var x = y * r - f, b = x; b < 0;)b += i;\n            for(var w = Math.min(e.inDepth, c + x), C = 0; C < e.outHeight; ++C){\n                for(var E = C * o - d, R = E; R < 0;)R += s;\n                for(var I = Math.min(e.inHeight, l + E), k = 0; k < e.outWidth; ++k){\n                    for(var S = k * a - p, A = S; A < 0;)A += u;\n                    for(var T = Math.min(e.inWidth, h + S), D = Number.NEGATIVE_INFINITY, N = -1, F = b; F < w; F += i)for(var _ = F - x, O = R; O < I; O += s)for(var M = O - E, B = A; B < T; B += u){\n                        var P = B - S, L = v.get(g, F, O, B, m);\n                        L >= D && (D = L, N = _ * l * h + M * l + P);\n                    }\n                    n.set(N, g, y, C, k, m);\n                }\n            }\n        }\n        return n.toTensor();\n    }, o.prototype.maxPool3dBackprop = function(t, e, n, r) {\n        df([\n            e,\n            n\n        ], \"maxPool3dBackprop\");\n        for(var o = this.maxPool3dPositions(e, r), a = r.strideDepth, i = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, c = r.dilationHeight, l = r.dilationWidth, h = r.effectiveFilterDepth, f = r.effectiveFilterHeight, d = r.effectiveFilterWidth, p = h - 1 - r.padInfo.front, v = d - 1 - r.padInfo.left, g = f - 1 - r.padInfo.top, m = er(e.shape, \"float32\"), y = this.bufferSync(o), x = this.bufferSync(t), b = 0; b < r.batchSize; ++b)for(var w = 0; w < r.inChannels; ++w)for(var C = 0; C < r.inDepth; ++C)for(var E = 0; E < r.inHeight; ++E)for(var R = 0; R < r.inWidth; ++R){\n            for(var I = C - p, k = E - g, S = R - v, A = 0, T = 0; T < h; T += u){\n                var D = (I + T) / a;\n                if (!(D < 0 || D >= r.outDepth || Math.floor(D) !== D)) for(var N = 0; N < f; N += c){\n                    var F = (k + N) / i;\n                    if (!(F < 0 || F >= r.outHeight || Math.floor(F) !== F)) for(var _ = 0; _ < d; _ += l){\n                        var O = (S + _) / s;\n                        if (!(O < 0 || O >= r.outWidth || Math.floor(O) !== O)) {\n                            var M = h * f * d - 1 - y.get(b, D, F, O, w) === T * f * d + N * d + _ ? 1 : 0;\n                            if (0 !== M) A += x.get(b, D, F, O, w) * M;\n                        }\n                    }\n                }\n            }\n            m.set(A, b, C, E, R, w);\n        }\n        return m.toTensor();\n    }, o.prototype.cast = function(t, e) {\n        return Ra(t, e, this);\n    }, o.prototype.reshape = function(t, e) {\n        return Ia(t, e);\n    }, o.prototype.avgPool = function(t, e) {\n        return df(t, \"avgPool\"), df(t, \"maxPool\"), pf(this.readSync(t.dataId), t.shape, t.dtype, t.strides, e, \"avg\").toTensor().toFloat();\n    }, o.prototype.resizeBilinear = function(t, e, n, r) {\n        df(t, \"resizeBilinear\");\n        for(var o = t.shape, a = o[0], i = o[1], s = o[2], u = o[3], c = this.readSync(t.dataId), l = new Float32Array(k([\n            a,\n            e,\n            n,\n            u\n        ])), h = [\n            r && e > 1 ? i - 1 : i,\n            r && n > 1 ? s - 1 : s\n        ], f = [\n            r && e > 1 ? e - 1 : e,\n            r && n > 1 ? n - 1 : n\n        ], d = 0, p = h[0] / f[0], v = h[1] / f[1], g = 0; g < a; g++)for(var m = 0; m < e; m++)for(var y = p * m, x = Math.floor(y), b = y - x, w = Math.min(i - 1, Math.ceil(y)), C = g * t.strides[0] + x * t.strides[1], E = g * t.strides[0] + w * t.strides[1], R = 0; R < n; R++)for(var I = v * R, S = Math.floor(I), A = I - S, T = Math.min(s - 1, Math.ceil(I)), D = C + S * t.strides[2], N = E + S * t.strides[2], F = C + T * t.strides[2], _ = E + T * t.strides[2], O = 0; O < u; O++){\n            var M = c[D + O], B = c[N + O], P = M + (c[F + O] - M) * A, L = P + (B + (c[_ + O] - B) * A - P) * b;\n            l[d++] = L;\n        }\n        return Fn(l, [\n            a,\n            e,\n            n,\n            u\n        ]);\n    }, o.prototype.resizeBilinearBackprop = function(t, e, n) {\n        df([\n            t,\n            e\n        ], \"resizeBilinearBackprop\");\n        for(var r = e.shape, o = r[0], a = r[1], i = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * a * i * s), f = [\n            n && c > 1 ? a - 1 : a,\n            n && l > 1 ? i - 1 : i\n        ], d = [\n            n && c > 1 ? c - 1 : c,\n            n && l > 1 ? l - 1 : l\n        ], p = f[0] / d[0], v = f[1] / d[1], g = this.readSync(t.dataId), m = 0, y = 0; y < o; y++)for(var x = y * e.strides[0], b = 0; b < c; b++)for(var w = b * p, C = Math.floor(w), E = Math.min(Math.ceil(w), a - 1), R = x + C * e.strides[1], I = x + E * e.strides[1], k = w - C, S = 1 - k, A = 0; A < l; A++)for(var T = A * v, D = Math.floor(T), N = Math.min(Math.ceil(T), i - 1), F = T - D, _ = 1 - F, O = R + D * e.strides[2], M = R + N * e.strides[2], B = I + D * e.strides[2], P = I + N * e.strides[2], L = S * _, W = S * F, U = k * _, V = k * F, z = 0; z < s; z++){\n            var G = g[m++];\n            h[O + z] += G * L, h[M + z] += G * W, h[B + z] += G * U, h[P + z] += G * V;\n        }\n        return Ln(h, [\n            o,\n            i,\n            a,\n            s\n        ], e.dtype);\n    }, o.prototype.resizeNearestNeighbor = function(t, e, n, r) {\n        df(t, \"resizeNearestNeighbor\");\n        for(var o = t.shape, a = o[0], i = o[1], s = o[2], u = o[3], c = this.readSync(t.dataId), l = new Float32Array(a * e * n * u), h = [\n            r && e > 1 ? i - 1 : i,\n            r && n > 1 ? s - 1 : s\n        ], f = [\n            r && e > 1 ? e - 1 : e,\n            r && n > 1 ? n - 1 : n\n        ], d = h[0] / f[0], p = h[1] / f[1], v = 0, g = 0; g < a; g++)for(var m = g * t.strides[0], y = 0; y < e; y++)for(var x = d * y, b = m + Math.min(i - 1, r ? Math.round(x) : Math.floor(x)) * t.strides[1], w = 0; w < n; w++)for(var C = p * w, E = b + Math.min(s - 1, r ? Math.round(C) : Math.floor(C)) * t.strides[2], R = 0; R < u; R++){\n            var I = c[E + R];\n            l[v++] = I;\n        }\n        return Fn(l, [\n            a,\n            e,\n            n,\n            u\n        ], t.dtype);\n    }, o.prototype.resizeNearestNeighborBackprop = function(t, e, n) {\n        df([\n            t,\n            e\n        ], \"resizeNearestNeighborBackprop\");\n        for(var r = e.shape, o = r[0], a = r[1], i = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * a * i * s), f = this.readSync(t.dataId), d = [\n            n && c > 1 ? a - 1 : a,\n            n && l > 1 ? i - 1 : i\n        ], p = [\n            n && c > 1 ? c - 1 : c,\n            n && l > 1 ? l - 1 : l\n        ], v = d[0] / p[0], g = d[1] / p[1], m = 1 / v, y = 1 / g, x = 2 * Math.ceil(m) + 2, b = 2 * Math.ceil(y) + 2, w = 0; w < o; w++)for(var C = w * e.strides[0], E = 0; E < a; E++)for(var R = C + E * e.strides[1], I = Math.floor(E * m), k = Math.floor(I - x / 2), S = 0; S < i; S++)for(var A = R + S * e.strides[2], T = Math.floor(S * y), D = Math.floor(T - b / 2), N = 0; N < s; N++){\n            for(var F = 0, _ = 0; _ < x; _++){\n                var O = _ + k;\n                if (!(O < 0 || O >= c)) {\n                    var M = C + O * t.strides[1], B = O * v;\n                    if (E === Math.min(a - 1, n ? Math.round(B) : Math.floor(B))) for(var P = 0; P < b; P++){\n                        var L = P + D;\n                        if (!(L < 0 || L >= l)) {\n                            var W = M + L * t.strides[2], U = L * g;\n                            S === Math.min(i - 1, n ? Math.round(U) : Math.floor(U)) && (F += f[W + N]);\n                        }\n                    }\n                }\n            }\n            h[A + N] = F;\n        }\n        return Ln(h, e.shape, e.dtype);\n    }, o.prototype.batchNormalization = function(t, e, n, r, o, a) {\n        df([\n            t,\n            e,\n            n,\n            o,\n            a\n        ], \"batchNorm\");\n        for(var i = this.readSync(t.dataId), s = this.readSync(e.dataId), u = this.readSync(n.dataId), c = o ? this.readSync(o.dataId) : new Float32Array([\n            1\n        ]), l = a ? this.readSync(a.dataId) : new Float32Array([\n            0\n        ]), h = new Float32Array(i.length), f = l.length, d = c.length, p = u.length, v = s.length, g = 0, m = 0, y = 0, x = 0, b = 0; b < i.length; ++b)h[b] = l[g++] + (i[b] - s[m++]) * c[y++] / Math.sqrt(u[x++] + r), g >= f && (g = 0), m >= v && (m = 0), y >= d && (y = 0), x >= p && (x = 0);\n        return Ln(h, t.shape);\n    }, o.prototype.localResponseNormalization4D = function(t, e, n, r, o) {\n        df(t, \"localResponseNormalization4D\");\n        var a = t.shape[3], i = a - 1, s = this.readSync(t.dataId), u = t.size, c = new Float32Array(u);\n        function l(t) {\n            for(var n = t % a, r = t - n + Math.max(0, n - e), o = t - n + Math.min(n + e, i), u = 0; r <= o; r++){\n                var c = s[r];\n                u += c * c;\n            }\n            return u;\n        }\n        for(var h = 0; h < u; h++){\n            var f = l(h), d = s[h] * Math.pow(n + r * f, -o);\n            c[h] = d;\n        }\n        return Ln(c, t.shape);\n    }, o.prototype.LRNGrad = function(t, e, n, r, o, a, i) {\n        df(t, \"LRNGrad\");\n        for(var s = t.shape[3], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = this.readSync(n.dataId), h = new Float32Array(t.size), f = t.size, d = 0; d < f; d++){\n            for(var p = d % s, v = d - p + Math.max(0, p - r), g = d - p + Math.min(s, p + r + 1), m = 0, y = v; y < g; y++)m += Math.pow(c[y], 2);\n            m = a * m + o;\n            for(y = v; y < g; y++){\n                var x = -2 * a * i * c[y] * l[d] / m;\n                d === y && (x += Math.pow(m, -i)), x *= u[d], h[y] += x;\n            }\n        }\n        return Ln(h, t.shape);\n    }, o.prototype.multinomial = function(t, e, n, r) {\n        df(t, \"multinomial\");\n        for(var o = e ? t : ia(t), a = o.shape[0], i = o.shape[1], s = Gn([\n            a,\n            n\n        ], \"int32\"), u = this.readSync(s.dataId), c = this.readSync(o.dataId), l = 0; l < a; ++l){\n            var h = l * i, f = new Float32Array(i - 1);\n            f[0] = c[h];\n            for(var d = 1; d < f.length; ++d)f[d] = f[d - 1] + c[h + d];\n            for(var p = Yu(r.toString()), v = l * n, g = 0; g < n; ++g){\n                var m = p();\n                u[v + g] = f.length;\n                for(var y = 0; y < f.length; y++)if (m < f[y]) {\n                    u[v + g] = y;\n                    break;\n                }\n            }\n        }\n        return s;\n    }, o.prototype.oneHot = function(t, e, n, r) {\n        df(t, \"oneHot\");\n        var o = new Float32Array(t.size * e);\n        o.fill(r);\n        for(var a = this.readSync(t.dataId), i = 0; i < t.size; ++i)a[i] >= 0 && a[i] < e && (o[i * e + a[i]] = n);\n        return Bn(o, [\n            t.size,\n            e\n        ], \"int32\");\n    }, o.prototype.nonMaxSuppression = function(t, e, n, r, o) {\n        return df(t, \"nonMaxSuppression\"), Oa(this.readSync(t.dataId), this.readSync(e.dataId), n, r, o);\n    }, o.prototype.fft = function(t) {\n        return this.fftBatch(t, !1);\n    }, o.prototype.ifft = function(t) {\n        return this.fftBatch(t, !0);\n    }, o.prototype.fftBatch = function(t, e) {\n        for(var n = t.shape[0], r = t.shape[1], o = er(t.shape, \"float32\"), a = er(t.shape, \"float32\"), i = Dn(t).as2D(n, r), s = Nn(t).as2D(n, r), u = 0; u < n; u++)for(var c = i.slice([\n            u,\n            0\n        ], [\n            1,\n            r\n        ]), l = s.slice([\n            u,\n            0\n        ], [\n            1,\n            r\n        ]), h = Tn(c, l), f = this.readSync(this.fftImpl(h, e).dataId), d = 0; d < r; d++){\n            var p = Ta(f, d);\n            o.values[u * r + d] = p.real, a.values[u * r + d] = p.imag;\n        }\n        return Tn(o.toTensor(), a.toTensor()).as2D(n, r);\n    }, o.prototype.fftImpl = function(t, e) {\n        var n = t.as1D(), r = n.size;\n        if (this.isExponentOf2(r)) {\n            var o = this.fftRadix2(n, r, e).as2D(t.shape[0], t.shape[1]);\n            return e && (o = Tn(Dn(o).div(On(r)), Nn(o).div(On(r)))), o;\n        }\n        var a = this.readSync(t.dataId), i = function(t) {\n            for(var e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2), r = 0; r < t.length; r += 2)e[r / 2] = t[r], n[r / 2] = t[r + 1];\n            return {\n                real: e,\n                imag: n\n            };\n        }(this.fourierTransformByMatmul(a, r, e));\n        return Tn(i.real, i.imag).as2D(t.shape[0], t.shape[1]);\n    }, o.prototype.isExponentOf2 = function(t) {\n        return 0 == (t & t - 1);\n    }, o.prototype.fftRadix2 = function(t, e, n) {\n        if (1 === e) return t;\n        var r = this.readSync(t.dataId), o = e / 2, a = function(t) {\n            for(var e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 0; o < t.length; o += 4)n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];\n            return {\n                real: n,\n                imag: r\n            };\n        }(r), i = Tn(a.real, a.imag).as1D(), s = function(t) {\n            for(var e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 2; o < t.length; o += 4)n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];\n            return {\n                real: n,\n                imag: r\n            };\n        }(r), u = Tn(s.real, s.imag).as1D();\n        i = this.fftRadix2(i, o, n), u = this.fftRadix2(u, o, n);\n        var c = function(t, e) {\n            for(var n = new Float32Array(t / 2), r = new Float32Array(t / 2), o = 0; o < Math.ceil(t / 2); o++){\n                var a = (e ? 2 : -2) * Math.PI * (o / t);\n                n[o] = Math.cos(a), r[o] = Math.sin(a);\n            }\n            return {\n                real: n,\n                imag: r\n            };\n        }(e, n), l = Tn(c.real, c.imag).mul(u), h = i.add(l), f = i.sub(l), d = Dn(h).concat(Dn(f)), p = Nn(h).concat(Nn(f));\n        return Tn(d, p).as1D();\n    }, o.prototype.fourierTransformByMatmul = function(t, e, n) {\n        for(var r = new Float32Array(2 * e), o = 0; o < e; o++){\n            for(var a = 0, i = 0, s = 0; s < e; s++){\n                var u = Na(o * s, e, n), c = Ta(t, s);\n                a += c.real * u.real - c.imag * u.imag, i += c.real * u.imag + c.imag * u.real;\n            }\n            n && (a /= e, i /= e), Da(r, a, i, o);\n        }\n        return r;\n    }, o.prototype.depthToSpace = function(t, e, n) {\n        C(\"NHWC\" === n, function() {\n            return \"Only NHWC dataFormat supported on CPU for depthToSpace. Got \" + n;\n        }), C(e > 1, function() {\n            return \"blockSize should be > 1 for depthToSpace, but was: \" + e;\n        });\n        for(var r = t.shape[0], o = t.shape[1], a = t.shape[2], i = t.shape[3], s = o * e, u = a * e, c = i / (e * e), l = this.readSync(t.dataId), h = new Float32Array(r * s * u * c), f = 0, d = 0; d < r; ++d)for(var p = 0; p < s; ++p)for(var v = Math.floor(p / e), g = p % e, m = 0; m < u; ++m)for(var y = Math.floor(m / e), x = (g * e + m % e) * c, b = 0; b < c; ++b){\n            var w = b + x + i * (y + a * (v + o * d));\n            h[f++] = l[w];\n        }\n        return Ln(h, [\n            r,\n            s,\n            u,\n            c\n        ]);\n    }, o.prototype.broadcastedBinaryOp = function(t, e, n, r) {\n        var o = Pr(t.shape, e.shape), a = er(o, n), i = this.readSync(t.dataId), s = this.readSync(e.dataId), u = Mr(t.shape, o), c = Mr(e.shape, o), l = a.values;\n        if (u.length + c.length === 0) for(var h = 0; h < l.length; ++h)l[h] = r(i[h % i.length], s[h % s.length]);\n        else {\n            var f = this.bufferSync(t), d = this.bufferSync(e), p = function(n) {\n                var o = a.indexToLoc(n), h = o.slice(-t.rank);\n                u.forEach(function(t) {\n                    return h[t] = 0;\n                });\n                var p = f.locToIndex(h), v = o.slice(-e.rank);\n                c.forEach(function(t) {\n                    return v[t] = 0;\n                });\n                var g = d.locToIndex(v);\n                l[n] = r(i[p], s[g]);\n            };\n            for(h = 0; h < l.length; ++h)p(h);\n        }\n        return a.toTensor();\n    }, o.prototype.broadcastedBinaryComplexOp = function(t, e, n) {\n        var r = Pr(t.shape, e.shape), o = er(r, \"float32\"), a = er(r, \"float32\"), i = this.readSync(t.dataId), s = this.readSync(e.dataId), u = Mr(t.shape, r), c = Mr(e.shape, r), l = o.values, h = a.values;\n        if (u.length + c.length === 0) for(var f = 0; f < l.length; f++){\n            var d = f % i.length, p = f % s.length, v = n(i[2 * d], i[2 * d + 1], s[2 * p], s[2 * p + 1]);\n            l[f] = v.real, h[f] = v.imag;\n        }\n        else {\n            var g = this.bufferSync(this.data.get(t.dataId).complexTensors.real), m = this.bufferSync(this.data.get(e.dataId).complexTensors.real), y = function(r) {\n                var a = o.indexToLoc(r), f = a.slice(-t.rank);\n                u.forEach(function(t) {\n                    return f[t] = 0;\n                });\n                var d = g.locToIndex(f), p = a.slice(-e.rank);\n                c.forEach(function(t) {\n                    return p[t] = 0;\n                });\n                var v = m.locToIndex(p), y = n(i[2 * d], i[2 * d + 1], s[2 * v], s[2 * v + 1]);\n                l[r] = y.real, h[r] = y.imag;\n            };\n            for(f = 0; f < l.length; f++)y(f);\n        }\n        return this.complex(o.toTensor(), a.toTensor());\n    }, o.prototype.split = function(t, e, n) {\n        return Ua(t, e, n);\n    }, o.prototype.dispose = function() {}, o.prototype.floatPrecision = function() {\n        return 32;\n    }, o.prototype.epsilon = function() {\n        return 1e-7;\n    }, o.prototype.cropAndResize = function(t, e, n, r, o, a) {\n        for(var i = t.shape, s = i[0], u = i[1], c = i[2], l = i[3], h = e.shape[0], f = r[0], d = r[1], p = er([\n            h,\n            f,\n            d,\n            l\n        ], \"float32\"), v = this.readSync(e.dataId), g = this.readSync(n.dataId), m = this.readSync(t.dataId), y = t.strides, x = p.strides, b = 0; b < h; b++){\n            var w = 4 * b, C = v[w], E = v[w + 1], R = v[w + 2], I = v[w + 3], k = g[b];\n            if (!(k >= s)) for(var S = f > 1 ? (R - C) * (u - 1) / (f - 1) : 0, A = d > 1 ? (I - E) * (c - 1) / (d - 1) : 0, T = 0; T < f; T++){\n                var D = f > 1 ? C * (u - 1) + T * S : .5 * (C + R) * (u - 1);\n                if (D < 0 || D > u - 1) for(var N = 0; N < d; N++)for(var F = 0; F < l; F++){\n                    var _ = F + N * x[2] + T * x[1] + b * x[0];\n                    p.values[_] = a;\n                }\n                else if (\"bilinear\" === o) {\n                    var O = Math.floor(D), M = Math.ceil(D), B = D - O;\n                    for(N = 0; N < d; N++){\n                        if ((q = d > 1 ? E * (c - 1) + N * A : .5 * (E + I) * (c - 1)) < 0 || q > c - 1) for(F = 0; F < l; F++){\n                            _ = F + N * x[2] + T * x[1] + b * x[0];\n                            p.values[_] = a;\n                        }\n                        else {\n                            var P = Math.floor(q), L = Math.ceil(q), W = q - P;\n                            for(F = 0; F < l; F++){\n                                var U = m[_ = F + P * y[2] + O * y[1] + k * y[0]], V = m[_ = F + L * y[2] + O * y[1] + k * y[0]], z = m[_ = F + P * y[2] + M * y[1] + k * y[0]], G = U + (V - U) * W, H = z + (m[_ = F + L * y[2] + M * y[1] + k * y[0]] - z) * W;\n                                _ = F + N * x[2] + T * x[1] + b * x[0], p.values[_] = G + (H - G) * B;\n                            }\n                        }\n                    }\n                } else for(N = 0; N < d; ++N){\n                    var q;\n                    if ((q = d > 1 ? E * (c - 1) + N * A : .5 * (E + I) * (c - 1)) < 0 || q > c - 1) for(F = 0; F < l; F++){\n                        _ = F + N * x[2] + T * x[1] + b * x[0];\n                        p.values[_] = a;\n                    }\n                    else {\n                        var K = Math.round(q), j = Math.round(D);\n                        for(F = 0; F < l; F++){\n                            var X = F + K * y[2] + j * y[1] + k * y[0], Y = F + N * x[2] + T * x[1] + b * x[0];\n                            p.values[Y] = m[X];\n                        }\n                    }\n                }\n            }\n        }\n        return p.toTensor();\n    }, o.prototype.sparseToDense = function(t, e, n, r) {\n        var o = Go(0, t, n), a = o.sliceRank, i = o.numUpdates, s = o.sliceSize, u = o.strides, c = o.outputSize;\n        return this.scatter(t, e, n, c, s, i, a, u, r, !1);\n    }, o.prototype.gatherND = function(t, e) {\n        var n = e.shape, r = n[n.length - 1], o = Po(t, e), a = o[0], i = o[1], s = o[2], u = o[3];\n        if (0 === i) return Fn([], a, t.dtype);\n        for(var c = new mt([\n            i,\n            s\n        ], t.dtype), l = this.readSync(e.dataId), h = this.readSync(t.dataId), f = 0; f < i; f++){\n            for(var d = [], p = 0, v = 0; v < r; v++){\n                var g = l[f * r + v];\n                p += g * u[v], d.push(g);\n            }\n            if (p < 0 || p >= t.size / s) throw new Error(\"Invalid indices: \" + d + \" does not index into \" + t.shape);\n            for(var m = 0; m < s; m++)c.values[f * s + m] = h[p * s + m];\n        }\n        return c.toTensor().reshape(a);\n    }, o.prototype.scatterND = function(t, e, n) {\n        var r = Go(0, t, n), o = r.sliceRank, a = r.numUpdates, i = r.sliceSize, s = r.strides, u = r.outputSize, c = On(0);\n        return this.scatter(t, e, n, u, i, a, o, s, c, !0);\n    }, o.prototype.fill = function(t, e, n) {\n        var r = P(n = n || j(e), k(t));\n        return r.fill(e), Lt.makeTensor(r, t, n, this);\n    }, o.prototype.onesLike = function(t) {\n        if (\"string\" === t.dtype) throw new Error(\"onesLike is not supported for string tensors\");\n        return this.fill(t.shape, 1, t.dtype);\n    }, o.prototype.zerosLike = function(t) {\n        var e = P(t.dtype, k(t.shape));\n        return this.makeOutput(e, t.shape, t.dtype);\n    }, o.prototype.linspace = function(t, e, n) {\n        return ka(t, e, n);\n    }, o.prototype.scatter = function(t, e, n, r, o, a, i, s, u, c) {\n        var l = [\n            r / o,\n            o\n        ], h = this.readSync(t.dataId), f = this.readSync(e.dataId);\n        if (0 === r) return Fn([], n, e.dtype);\n        var d = new mt(l, e.dtype);\n        d.values.fill(this.readSync(u.dataId)[0]);\n        for(var p = 0; p < a; p++){\n            for(var v = [], g = 0, m = 0; m < i; m++){\n                var y = h[p * i + m];\n                v.push(y), g += y * s[m];\n            }\n            if (g < 0 || g >= r / o) throw new Error(\"Invalid indices: \" + v + \" does not index into \" + n);\n            for(var x = 0; x < o; x++)c ? d.values[g * o + x] += f[p * o + x] : d.values[g * o + x] = 0 === e.rank ? f[0] : f[p * o + x];\n        }\n        return d.toTensor().reshape(n);\n    }, o;\n}(la);\nfunction yf(t, e) {\n    return {\n        kernelName: t,\n        backendName: \"cpu\",\n        kernelFunc: function(n) {\n            var r = n.inputs, o = n.backend, a = r, i = a.a, s = a.b, u = o;\n            df([\n                i,\n                s\n            ], t);\n            var c = u.data.get(i.dataId).values, l = u.data.get(s.dataId).values, h = e(i.shape, s.shape, c, l, i.dtype), f = h[0], d = h[1];\n            return {\n                dataId: u.write(f, d, i.dtype),\n                shape: d,\n                dtype: i.dtype\n            };\n        }\n    };\n}\nfunction xf(t) {\n    return function(e, n, r, o, a) {\n        var i = Pr(e, n), s = i.length, u = $(i), c = B(a, k(i)), l = e.length, h = n.length, f = $(e), d = $(n), p = Mr(e, i), v = Mr(n, i);\n        if (p.length + v.length === 0) for(var g = 0; g < c.length; ++g)c[g] = t(r[g % r.length], o[g % o.length]);\n        else {\n            var m = function(e) {\n                var n = it(e, s, u), a = n.slice(-l);\n                p.forEach(function(t) {\n                    return a[t] = 0;\n                });\n                var i = at(a, l, f), g = n.slice(-h);\n                v.forEach(function(t) {\n                    return g[t] = 0;\n                });\n                var m = at(g, h, d);\n                c[e] = t(r[i], o[m]);\n            };\n            for(g = 0; g < c.length; ++g)m(g);\n        }\n        return [\n            c,\n            i\n        ];\n    };\n}\nLt.registerBackend(\"cpu\", function() {\n    return new mf;\n}, 1);\nvar bf = xf(function(t, e) {\n    return t / e;\n}), wf = yf(wr, bf);\nvar Cf = {\n    kernelName: \"MaxPoolWithArgmax\",\n    backendName: \"cpu\",\n    kernelFunc: function(t) {\n        var e = t.inputs, n = t.attrs, r = t.backend, o = e.x, a = n, i = a.filterSize, s = a.strides, u = a.pad, c = a.includeBatchInIndex, l = r;\n        df(o, \"MaxPoolWithArgmax\");\n        var h = l.data.get(o.dataId).values, f = fa(o.shape, i, s, [\n            1,\n            1\n        ], u), d = function(t, e, n, r, o) {\n            var a = pf(t, 0, n, $(e), o, \"max\"), i = vf(t, e, n, o, !0, r);\n            return [\n                a.values,\n                i.values\n            ];\n        }(h, o.shape, o.dtype, c, f), p = d[0], v = d[1], g = l.write(p, f.outShape, o.dtype), m = l.write(v, f.outShape, o.dtype);\n        return [\n            {\n                dataId: g,\n                shape: f.outShape,\n                dtype: o.dtype\n            },\n            {\n                dataId: m,\n                shape: f.outShape,\n                dtype: \"int32\"\n            }\n        ];\n    }\n}, Ef = {\n    kernelName: \"NonMaxSuppressionV5\",\n    backendName: \"cpu\",\n    kernelFunc: function(t) {\n        var e = t.inputs, n = t.backend, r = t.attrs, o = e, a = o.boxes, i = o.scores, s = r, u = s.maxOutputSize, c = s.iouThreshold, l = s.scoreThreshold, h = s.softNmsSigma, f = n;\n        df(a, \"NonMaxSuppressionWithScore\");\n        var d = Ma(f.data.get(a.dataId).values, f.data.get(i.dataId).values, u, c, l, h);\n        return [\n            d.selectedIndices,\n            d.selectedScores\n        ];\n    }\n}, Rf = {\n    kernelName: \"Square\",\n    backendName: \"cpu\",\n    kernelFunc: function(t) {\n        var e = t.inputs, n = t.backend, r = e.x, o = n;\n        df(r, \"square\");\n        for(var a = o.data.get(r.dataId).values, i = new Float32Array(a.length), s = 0; s < a.length; ++s){\n            var u = a[s];\n            i[s] = u * u;\n        }\n        return {\n            dataId: o.write(i, r.shape, r.dtype),\n            shape: r.shape,\n            dtype: r.dtype\n        };\n    }\n}, If = xf(function(t, e) {\n    var n = t - e;\n    return n * n;\n});\nfunction kf(t, e, n, r, o) {\n    for(var a = k(e), i = e.length, s = $(e), u = $(o), c = B(n, k(o)), l = 0; l < a; ++l){\n        for(var h = it(l, i, s), f = new Array(h.length), d = 0; d < f.length; d++)f[d] = h[r[d]];\n        c[at(f, i, u)] = t[l];\n    }\n    return c;\n}\nfor(var Sf = 0, Af = [\n    Ef,\n    Rf,\n    yf(Er, If),\n    wf,\n    {\n        kernelName: \"Transpose\",\n        backendName: \"cpu\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.attrs, r = t.backend, o = e.x, a = n.perm, i = r;\n            df(o, \"transpose\");\n            for(var s = o.shape.length, u = new Array(s), c = 0; c < u.length; c++)u[c] = o.shape[a[c]];\n            var l = kf(i.data.get(o.dataId).values, o.shape, o.dtype, a, u);\n            return {\n                dataId: i.write(l, u, o.dtype),\n                shape: u,\n                dtype: o.dtype\n            };\n        }\n    },\n    Cf\n]; Sf < Af.length; Sf++){\n    d(Af[Sf]);\n}\nvar Tf, Df = function(t) {\n    this.variableNames = [\n        \"A\"\n    ];\n    var e = Ya(), n = t[0], r = t[1];\n    this.outputShape = t, this.userCode = \"\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int texR = coords[0];\\n        int texC = coords[1];\\n        int depth = coords[2];\\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + r + \".0, \" + n + \".0);\\n\\n        vec4 values = \" + e.texture2D + \"(A, uv);\\n        float value;\\n        if (depth == 0) {\\n          value = values.r;\\n        } else if (depth == 1) {\\n          value = values.g;\\n        } else if (depth == 2) {\\n          value = values.b;\\n        } else if (depth == 3) {\\n          value = values.a;\\n        }\\n\\n        setOutput(floor(value * 255.0 + 0.5));\\n      }\\n    \";\n}, Nf = function(t) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !1, this.packedOutput = !0;\n    var e = Ya(), n = t[0], r = t[1];\n    this.outputShape = t, this.userCode = \"\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int texR = coords[0];\\n        int texC = coords[1];\\n        int depth = coords[2];\\n\\n        vec4 result = vec4(0.);\\n\\n        for(int row=0; row<=1; row++) {\\n          for(int col=0; col<=1; col++) {\\n            texC = coords[1] + row;\\n            depth = coords[2] + col;\\n\\n            vec2 uv = (vec2(texC, texR) + halfCR) /\\n                       vec2(\" + r + \".0, \" + n + \".0);\\n            vec4 values = \" + e.texture2D + \"(A, uv);\\n            float value;\\n            if (depth == 0) {\\n              value = values.r;\\n            } else if (depth == 1) {\\n              value = values.g;\\n            } else if (depth == 2) {\\n              value = values.b;\\n            } else if (depth == 3) {\\n              value = values.a;\\n            }\\n\\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\\n          }\\n        }\\n\\n        \" + e.output + \" = result;\\n      }\\n    \";\n};\nvar Ff = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ];\n    for(var n = new Array(t.length), r = 0; r < n.length; r++)n[r] = t[e[r]];\n    this.outputShape = n, this.rank = n.length;\n    var o = ui(this.rank), a = function(t) {\n        var e = t.length;\n        if (e > 6) throw Error(\"Transpose for rank \" + e + \" is not yet supported\");\n        for(var n = [\n            \"resRC.x\",\n            \"resRC.y\",\n            \"resRC.z\",\n            \"resRC.w\",\n            \"resRC.u\",\n            \"resRC.v\"\n        ], r = new Array(e), o = 0; o < t.length; o++)r[t[o]] = n[o];\n        return r.join();\n    }(e);\n    this.userCode = \"\\n    void main() {\\n      \" + o + \" resRC = getOutputCoords();\\n      setOutput(getA(\" + a + \"));\\n    }\\n    \";\n};\nvar _f = function(t, e) {\n    this.variableNames = [\n        \"A\"\n    ], this.packedInputs = !0, this.packedOutput = !0;\n    for(var n = new Array(t.length), r = 0; r < n.length; r++)n[r] = t[e[r]];\n    if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error(\"Packed transpose for rank \" + this.rank + \" is not yet supported.\");\n    var o = ui(this.rank), a = ja(\"rc\", this.rank), i = new Array(this.rank);\n    for(r = 0; r < e.length; r++)i[e[r]] = a[r];\n    var s = \"vec2(\" + i.slice(-2).join() + \")\", u = \"++\" + a[this.rank - 1] + \" < \" + n[this.rank - 1], c = \"getChannel(getA(\" + i.join() + \"), \" + s + \")\";\n    this.userCode = \"\\n    void main() {\\n      \" + o + \" rc = getOutputCoords();\\n      vec4 result = vec4(0.);\\n      result[0] = \" + c + \";\\n      if(\" + u + \") {\\n        result[1] = \" + c + \";\\n      }\\n      --\" + a[this.rank - 1] + \";\\n      if(++\" + a[this.rank - 2] + \" < \" + n[this.rank - 2] + \") {\\n        result[2] = \" + c + \";\\n        if(\" + u + \") {\\n          result[3] = \" + c + \";\\n        }\\n      }\\n      setOutput(result);\\n    }\\n    \";\n};\nfor(var Of = 0, Mf = [\n    {\n        kernelName: \"FromPixels\",\n        backendName: \"webgl\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = t.attrs, o = e.pixels, a = r.numChannels, s = \"undefined\" != typeof HTMLVideoElement && o instanceof HTMLVideoElement, u = \"undefined\" != typeof HTMLImageElement && o instanceof HTMLImageElement, c = s ? [\n                o.videoWidth,\n                o.videoHeight\n            ] : [\n                o.width,\n                o.height\n            ], l = c[0], h = c[1], f = [\n                h,\n                l\n            ], d = [\n                h,\n                l,\n                a\n            ];\n            (u || s) && (null == Tf && (Tf = document.createElement(\"canvas\").getContext(\"2d\")), Tf.canvas.width = l, Tf.canvas.height = h, Tf.drawImage(o, 0, 0, l, h), o = Tf.canvas);\n            var p = n.makeTensorInfo(f, \"int32\");\n            n.texData.get(p.dataId).usage = zt.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(p.dataId), o);\n            var v = i().getBool(\"WEBGL_PACK\") ? new Nf(d) : new Df(d), g = n.runWebGLProgram(v, [\n                p\n            ], \"int32\");\n            return n.disposeData(p.dataId), g;\n        }\n    },\n    {\n        kernelName: wr,\n        backendName: \"webgl\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = e;\n            return function(t, e, n) {\n                var r = new Ri(Ci, t.shape, e.shape);\n                return i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") && (r = new Si(Ii, t.shape, e.shape, !0)), n.runWebGLProgram(r, [\n                    t,\n                    e\n                ], \"float32\");\n            }(r.a, r.b, n);\n        }\n    },\n    {\n        kernelName: \"NonMaxSuppressionV5\",\n        backendName: \"webgl\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = t.attrs;\n            dn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\");\n            var o = e, a = o.boxes, i = o.scores, s = r, u = s.maxOutputSize, c = s.iouThreshold, l = s.scoreThreshold, h = s.softNmsSigma, f = n, d = Ma(f.readSync(a.dataId), f.readSync(i.dataId), u, c, l, h);\n            return [\n                d.selectedIndices,\n                d.selectedScores\n            ];\n        }\n    },\n    {\n        kernelName: \"Square\",\n        backendName: \"webgl\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = e.x, o = n, a = new cu(r.shape, \"return x * x;\");\n            return o.runWebGLProgram(a, [\n                r\n            ], r.dtype);\n        }\n    },\n    {\n        kernelName: Er,\n        backendName: \"webgl\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.backend, r = e, o = r.a, a = r.b, s = n, u = i().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Si(\"return (a - b) * (a - b);\", o.shape, a.shape) : new Ri(\"return (a - b) * (a - b);\", o.shape, a.shape);\n            return s.compileAndRun(u, [\n                o,\n                a\n            ]);\n        }\n    },\n    {\n        kernelName: \"Transpose\",\n        backendName: \"webgl\",\n        kernelFunc: function(t) {\n            for(var e, n = t.inputs, r = t.attrs, o = t.backend, a = n.x, s = r.perm, u = o, c = a.shape.length, l = new Array(c), h = 0; h < l.length; h++)l[h] = a.shape[s[h]];\n            if (u.shouldExecuteOnCPU([\n                a\n            ])) {\n                var f = kf(u.texData.get(a.dataId).values, a.shape, a.dtype, s, l);\n                e = u.makeTensorInfo(l, a.dtype), u.texData.get(e.dataId).values = f;\n            } else e = function(t, e, n) {\n                var r = i().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new _f(t.shape, e) : new Ff(t.shape, e);\n                return n.runWebGLProgram(r, [\n                    t\n                ], t.dtype);\n            }(a, s, u);\n            return e;\n        }\n    },\n    {\n        kernelName: \"MaxPoolWithArgmax\",\n        backendName: \"webgl\",\n        kernelFunc: function(t) {\n            var e = t.inputs, n = t.attrs, r = t.backend, o = e.x, a = n, i = a.filterSize, s = a.strides, u = a.pad, c = a.includeBatchInIndex, l = r;\n            C(4 === o.shape.length, function() {\n                return \"Error in maxPool: input must be rank 4 but got rank \" + o.shape.length + \".\";\n            });\n            var h = [\n                1,\n                1\n            ];\n            C(Ca(s, h), function() {\n                return \"Error in maxPool: Either strides or dilations must be 1. Got strides \" + s + \" and dilations '\" + h + \"'\";\n            });\n            var f = fa(o.shape, i, s, h, u), d = function(t, e, n, r) {\n                var o = new Ws(n, \"max\", !1), a = r.runWebGLProgram(o, [\n                    t\n                ], \"float32\");\n                return o = new Ws(n, \"max\", !0, !0, e), [\n                    a,\n                    r.runWebGLProgram(o, [\n                        t\n                    ], \"float32\")\n                ];\n            }(o, c, f, l);\n            return [\n                d[0],\n                d[1]\n            ];\n        }\n    }\n]; Of < Mf.length; Of++){\n    d(Mf[Of]);\n}\nfor(var Bf = 0, Pf = [\n    {\n        kernelName: xr,\n        inputsToSave: [\n            \"a\",\n            \"b\"\n        ],\n        gradFunc: function(t, e) {\n            var n = e[0], r = e[1], o = Pr(n.shape, r.shape);\n            return {\n                a: function() {\n                    var e = t, r = Br(n.shape, o);\n                    return r.length > 0 && (e = e.sum(r)), e.reshape(n.shape);\n                },\n                b: function() {\n                    var e = t, n = Br(r.shape, o);\n                    return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);\n                }\n            };\n        }\n    },\n    {\n        kernelName: \"AddN\",\n        saveAllInputs: !0,\n        gradFunc: function(t, e) {\n            var n = {};\n            return e.forEach(function(e, r) {\n                n[r] = function() {\n                    return t.clone();\n                };\n            }), n;\n        }\n    },\n    {\n        kernelName: Sr,\n        gradFunc: function(t, e, n) {\n            for(var r = n, o = r.inputShape, a = r.shape, i = Array.from(a), s = o.length - 1; s >= 0; s--)if (o[s] === a[s]) i[s] = 1;\n            else if (1 !== o[s]) throw new Error(\"broadcastTo(): [\" + o + \"] cannot be broadcast to [\" + a + \"].\");\n            var u = [];\n            for(s = 0; s < i.length; s++)i[s] > 1 && u.push(s);\n            return {\n                x: function() {\n                    return t.sum(u, !0);\n                }\n            };\n        }\n    },\n    {\n        kernelName: wr,\n        inputsToSave: [\n            \"a\",\n            \"b\"\n        ],\n        gradFunc: function(t, e) {\n            var n = e[0], r = e[1], o = Pr(n.shape, r.shape);\n            return {\n                a: function() {\n                    var e = Bo(t, r.toFloat()), a = Br(n.shape, o);\n                    return a.length > 0 ? th(e, a).reshape(n.shape) : e;\n                },\n                b: function() {\n                    var e = t.mul(n.toFloat()), a = Br(r.shape, o);\n                    a.length > 0 && (e = th(e, a).reshape(r.shape));\n                    var i = Gc(r);\n                    return no(Bo(e, i.toFloat()));\n                }\n            };\n        }\n    },\n    {\n        kernelName: \"FusedBatchNorm\",\n        inputsToSave: [\n            \"x\",\n            \"mean\",\n            \"variance\",\n            \"scale\"\n        ],\n        gradFunc: function(t, e, n) {\n            var r = n.varianceEpsilon, o = e[0], a = e[1], i = e[2], s = e[3], u = Ju(o), c = null == s ? On(1) : s, l = Br(a.shape, u.shape), h = [];\n            if (1 === a.rank) {\n                for(var f = 0; f < u.shape.length - 1; ++f)h.push(u.shape[f]);\n                h.push(1);\n            }\n            var d = Oo(o, a), p = To(t, c), v = ao(Or(i, On(r))), g = To(To(To(v, v), v), On(-.5));\n            return {\n                x: function() {\n                    return 1 === a.rank ? ur(To(To(t, wc(v.as4D(1, 1, 1, a.shape[0]), h)), c), o.shape) : ur(To(To(t, v), c), o.shape);\n                },\n                mean: function() {\n                    var t = To(To(v, On(-1)), p);\n                    return 1 === a.rank && (t = th(t, l)), ur(t, a.shape);\n                },\n                variance: function() {\n                    var t = To(To(g, d), p);\n                    return 1 === a.rank && (t = th(t, l)), ur(t, a.shape);\n                },\n                scale: function() {\n                    var e = To(d, v), n = To(t, e);\n                    return 1 === a.rank && (n = th(n, l)), ur(n, a.shape);\n                },\n                offset: function() {\n                    var e = t;\n                    return 1 === a.rank && (e = th(e, l)), ur(e, a.shape);\n                }\n            };\n        }\n    },\n    {\n        kernelName: Tr,\n        gradFunc: function(t) {\n            return {\n                x: function() {\n                    return t.toFloat();\n                }\n            };\n        }\n    },\n    {\n        kernelName: Ar,\n        inputsToSave: [\n            \"indices\"\n        ],\n        gradFunc: function(t, e) {\n            var n = e[0];\n            return {\n                indices: function() {\n                    return Gn(n.shape, \"float32\");\n                }\n            };\n        }\n    },\n    {\n        kernelName: Nr,\n        inputsToSave: [\n            \"x\"\n        ],\n        gradFunc: function(t, e, n) {\n            var r = e[0], o = n.paddings.map(function(t) {\n                return t[0];\n            });\n            return {\n                x: function() {\n                    return t.slice(o, r.shape);\n                }\n            };\n        }\n    },\n    {\n        kernelName: \"Square\",\n        inputsToSave: [\n            \"x\"\n        ],\n        gradFunc: function(t, e) {\n            var n = e[0];\n            return {\n                x: function() {\n                    return t.mul(n.toFloat().mul(2));\n                }\n            };\n        }\n    },\n    {\n        kernelName: Er,\n        inputsToSave: [\n            \"a\",\n            \"b\"\n        ],\n        gradFunc: function(t, e) {\n            var n = e[0], r = e[1], o = On(2);\n            return {\n                a: function() {\n                    return To(t, To(o, Oo(n, r)));\n                },\n                b: function() {\n                    return To(t, To(o, Oo(r, n)));\n                }\n            };\n        }\n    },\n    {\n        kernelName: Dr,\n        inputsToSave: [\n            \"x\"\n        ],\n        gradFunc: function(t, e, n) {\n            var r = e[0], o = n.reps;\n            return {\n                x: function() {\n                    var e = Xn(r);\n                    if (1 === r.rank) for(var n = 0; n < o[0]; ++n)e = e.add(t.slice([\n                        n * r.shape[0]\n                    ], [\n                        r.shape[0]\n                    ]));\n                    else if (2 === r.rank) for(n = 0; n < o[0]; ++n)for(var a = 0; a < o[1]; ++a)e = e.add(t.slice([\n                        n * r.shape[0],\n                        a * r.shape[1]\n                    ], [\n                        r.shape[0],\n                        r.shape[1]\n                    ]));\n                    else if (3 === r.rank) for(n = 0; n < o[0]; ++n)for(a = 0; a < o[1]; ++a)for(var i = 0; i < o[2]; ++i)e = e.add(t.slice([\n                        n * r.shape[0],\n                        a * r.shape[1],\n                        i * r.shape[2]\n                    ], [\n                        r.shape[0],\n                        r.shape[1],\n                        r.shape[2]\n                    ]));\n                    else {\n                        if (4 !== r.rank) throw new Error(\"Gradient for tile operation is not implemented for rank-\" + r.rank + \" tensors yet.\");\n                        for(n = 0; n < o[0]; ++n)for(a = 0; a < o[1]; ++a)for(i = 0; i < o[2]; ++i)for(var s = 0; s < o[3]; ++s)e = e.add(t.slice([\n                            n * r.shape[0],\n                            a * r.shape[1],\n                            i * r.shape[2],\n                            s * r.shape[3]\n                        ], [\n                            r.shape[0],\n                            r.shape[1],\n                            r.shape[2],\n                            r.shape[3]\n                        ]));\n                    }\n                    return e;\n                }\n            };\n        }\n    },\n    {\n        kernelName: \"Transpose\",\n        gradFunc: function(t, e, n) {\n            var r = Rn(n.perm);\n            return {\n                x: function() {\n                    return ua(t, r);\n                }\n            };\n        }\n    }\n]; Bf < Pf.length; Bf++){\n    p(Pf[Bf]);\n}\nvar Lf = function() {\n    function t() {}\n    return t.prototype.fetch = function(t, e) {\n        return fetch(t, e);\n    }, t.prototype.now = function() {\n        return performance.now();\n    }, t.prototype.encode = function(t, e) {\n        if (\"utf-8\" !== e && \"utf8\" !== e) throw new Error(\"Browser's encoder only supports utf-8, but got \" + e);\n        return null == this.textEncoder && (this.textEncoder = new TextEncoder), this.textEncoder.encode(t);\n    }, t.prototype.decode = function(t, e) {\n        return new TextDecoder(e).decode(t);\n    }, t;\n}();\ni().get(\"IS_BROWSER\") && i().setPlatform(\"browser\", new Lf);\nvar Wf, Uf = function() {\n    return __webpack_require__(/*! node-fetch */ \"(ssr)/./node_modules/@tensorflow/tfjs-core/node_modules/node-fetch/lib/index.es.js\");\n}, Vf = function() {\n    function t() {\n        this.util = __webpack_require__(/*! util */ \"util\"), this.textEncoder = new this.util.TextEncoder;\n    }\n    return t.prototype.fetch = function(t, e) {\n        return null != i().global.fetch ? i().global.fetch(t, e) : (null == Wf && (Wf = Uf()), Wf(t, e));\n    }, t.prototype.now = function() {\n        var t = process.hrtime();\n        return 1e3 * t[0] + t[1] / 1e6;\n    }, t.prototype.encode = function(t, e) {\n        if (\"utf-8\" !== e && \"utf8\" !== e) throw new Error(\"Node built-in encoder only supports utf-8, but got \" + e);\n        return this.textEncoder.encode(t);\n    }, t.prototype.decode = function(t, e) {\n        return 0 === t.length ? \"\" : new this.util.TextDecoder(e).decode(t);\n    }, t;\n}();\ni().get(\"IS_NODE\") && i().setPlatform(\"node\", new Vf);\nvar zf = {\n    float32: 4,\n    int32: 4,\n    uint16: 2,\n    uint8: 1,\n    bool: 1\n}, Gf = 4;\nfunction Hf(t, e) {\n    for(var n = {}, r = 0, o = function(e) {\n        var o = e.name, a = e.dtype, i = e.shape, s = k(i), u = void 0;\n        if ((\"quantization\" in e)) {\n            var c = e.quantization;\n            if (\"uint8\" !== c.dtype && \"uint16\" !== c.dtype) throw new Error(\"Weight \" + e.name + \" has unknown quantization dtype \" + c.dtype + \". Supported quantization dtypes are: 'uint8' and 'uint16'.\");\n            var l = zf[c.dtype], h = t.slice(r, r + s * l), f = \"uint8\" === c.dtype ? new Uint8Array(h) : new Uint16Array(h);\n            if (\"float32\" === a) u = Float32Array.from(f, function(t) {\n                return t * c.scale + c.min;\n            });\n            else {\n                if (\"int32\" !== a) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + a);\n                u = Int32Array.from(f, function(t) {\n                    return Math.round(t * c.scale + c.min);\n                });\n            }\n            r += s * l;\n        } else if (\"string\" === a) {\n            var d = k(e.shape);\n            u = [];\n            for(var p = 0; p < d; p++){\n                var v = new Uint32Array(t.slice(r, r + Gf))[0];\n                r += Gf;\n                var g = new Uint8Array(t.slice(r, r + v));\n                u.push(g), r += v;\n            }\n        } else {\n            var m = zf[a];\n            h = t.slice(r, r + s * m);\n            if (\"float32\" === a) u = new Float32Array(h);\n            else if (\"int32\" === a) u = new Int32Array(h);\n            else {\n                if (\"bool\" !== a) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + a);\n                u = new Uint8Array(h);\n            }\n            r += s * m;\n        }\n        n[o] = Fn(u, i, a);\n    }, a = 0, i = e; a < i.length; a++){\n        o(i[a]);\n    }\n    return n;\n}\nfunction qf(t) {\n    if (null === t) throw new Error(\"Invalid input value: \" + JSON.stringify(t));\n    var e = 0, n = [];\n    t.forEach(function(t) {\n        if (e += t.byteLength, n.push(t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)), !(t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array)) throw new Error(\"Unsupported TypedArray subtype: \" + t.constructor.name);\n    });\n    var r = new Uint8Array(e), o = 0;\n    return n.forEach(function(t) {\n        r.set(new Uint8Array(t.buffer), o), o += t.byteLength;\n    }), r.buffer;\n}\nvar Kf = \"undefined\" != typeof Buffer && (\"undefined\" == typeof Blob || \"undefined\" == typeof atob || \"undefined\" == typeof btoa);\nfunction jf(t) {\n    return Kf ? Buffer.byteLength(t) : new Blob([\n        t\n    ]).size;\n}\nfunction Xf(t) {\n    var e = 0;\n    t.forEach(function(t) {\n        e += t.byteLength;\n    });\n    var n = new Uint8Array(e), r = 0;\n    return t.forEach(function(t) {\n        n.set(new Uint8Array(t), r), r += t.byteLength;\n    }), n.buffer;\n}\nfunction Yf(t) {\n    for(t = t.trim(); t.endsWith(\"/\");)t = t.slice(0, t.length - 1);\n    var e = t.split(\"/\");\n    return e[e.length - 1];\n}\nfunction $f(t) {\n    if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"Expected JSON model topology, received ArrayBuffer.\");\n    return {\n        dateSaved: new Date,\n        modelTopologyType: \"JSON\",\n        modelTopologyBytes: null == t.modelTopology ? 0 : jf(JSON.stringify(t.modelTopology)),\n        weightSpecsBytes: null == t.weightSpecs ? 0 : jf(JSON.stringify(t.weightSpecs)),\n        weightDataBytes: null == t.weightData ? 0 : t.weightData.byteLength\n    };\n}\nvar Qf = function() {\n    function t() {\n        this.saveRouters = [], this.loadRouters = [];\n    }\n    return t.getInstance = function() {\n        return null == t.instance && (t.instance = new t), t.instance;\n    }, t.registerSaveRouter = function(e) {\n        t.getInstance().saveRouters.push(e);\n    }, t.registerLoadRouter = function(e) {\n        t.getInstance().loadRouters.push(e);\n    }, t.getSaveHandlers = function(e) {\n        return t.getHandlers(e, \"save\");\n    }, t.getLoadHandlers = function(e, n) {\n        return t.getHandlers(e, \"load\", n);\n    }, t.getHandlers = function(e, n, r) {\n        var o = [];\n        return (\"load\" === n ? t.getInstance().loadRouters : t.getInstance().saveRouters).forEach(function(t) {\n            var n = t(e, r);\n            null !== n && o.push(n);\n        }), o;\n    }, t;\n}(), Jf = \"://\", Zf = function() {\n    function t() {\n        this.managers = {};\n    }\n    return t.getInstance = function() {\n        return null == t.instance && (t.instance = new t), t.instance;\n    }, t.registerManager = function(e, n) {\n        C(null != e, function() {\n            return \"scheme must not be undefined or null.\";\n        }), e.endsWith(Jf) && (e = e.slice(0, e.indexOf(Jf))), C(e.length > 0, function() {\n            return \"scheme must not be an empty string.\";\n        });\n        var r = t.getInstance();\n        C(null == r.managers[e], function() {\n            return \"A model store manager is already registered for scheme '\" + e + \"'.\";\n        }), r.managers[e] = n;\n    }, t.getManager = function(t) {\n        var e = this.getInstance().managers[t];\n        if (null == e) throw new Error(\"Cannot find model manager for scheme '\" + t + \"'\");\n        return e;\n    }, t.getSchemes = function() {\n        return Object.keys(this.getInstance().managers);\n    }, t;\n}();\nfunction td(t) {\n    if (-1 === t.indexOf(Jf)) throw new Error(\"The url string provided does not contain a scheme. Supported schemes are: \" + Zf.getSchemes().join(\",\"));\n    return {\n        scheme: t.split(Jf)[0],\n        path: t.split(Jf)[1]\n    };\n}\nfunction ed(t, e, o) {\n    return void 0 === o && (o = !1), n(this, void 0, void 0, function() {\n        var n, a, i, s, u, c, l, h, f;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return C(t !== e, function() {\n                        return \"Old path and new path are the same: '\" + t + \"'\";\n                    }), C((n = Qf.getLoadHandlers(t)).length > 0, function() {\n                        return \"Copying failed because no load handler is found for source URL \" + t + \".\";\n                    }), C(n.length < 2, function() {\n                        return \"Copying failed because more than one (\" + n.length + \") load handlers for source URL \" + t + \".\";\n                    }), a = n[0], C((i = Qf.getSaveHandlers(e)).length > 0, function() {\n                        return \"Copying failed because no save handler is found for destination URL \" + e + \".\";\n                    }), C(i.length < 2, function() {\n                        return \"Copying failed because more than one (\" + n.length + \") save handlers for destination URL \" + e + \".\";\n                    }), s = i[0], u = td(t).scheme, c = td(t).path, l = u === td(t).scheme, [\n                        4,\n                        a.load()\n                    ];\n                case 1:\n                    return h = r.sent(), o && l ? [\n                        4,\n                        Zf.getManager(u).removeModel(c)\n                    ] : [\n                        3,\n                        3\n                    ];\n                case 2:\n                    r.sent(), r.label = 3;\n                case 3:\n                    return [\n                        4,\n                        s.save(h)\n                    ];\n                case 4:\n                    return f = r.sent(), !o || l ? [\n                        3,\n                        6\n                    ] : [\n                        4,\n                        Zf.getManager(u).removeModel(c)\n                    ];\n                case 5:\n                    r.sent(), r.label = 6;\n                case 6:\n                    return [\n                        2,\n                        f.modelArtifactsInfo\n                    ];\n            }\n        });\n    });\n}\nvar nd = \"models_store\", rd = \"model_info_store\";\nfunction od() {\n    if (!i().getBool(\"IS_BROWSER\")) throw new Error(\"Failed to obtain IndexedDB factory because the current environmentis not a web browser.\");\n    var t = window || self, e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;\n    if (null == e) throw new Error(\"The current browser does not appear to support IndexedDB.\");\n    return e;\n}\nfunction ad(t) {\n    var e = t.result;\n    e.createObjectStore(nd, {\n        keyPath: \"modelPath\"\n    }), e.createObjectStore(rd, {\n        keyPath: \"modelPath\"\n    });\n}\nvar id = function() {\n    function t(t) {\n        if (this.indexedDB = od(), null == t || !t) throw new Error(\"For IndexedDB, modelPath must not be null, undefined or empty.\");\n        this.modelPath = t;\n    }\n    return t.prototype.save = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");\n                return [\n                    2,\n                    this.databaseAction(this.modelPath, t)\n                ];\n            });\n        });\n    }, t.prototype.load = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                return [\n                    2,\n                    this.databaseAction(this.modelPath)\n                ];\n            });\n        });\n    }, t.prototype.databaseAction = function(t, e) {\n        var n = this;\n        return new Promise(function(t, r) {\n            var o = n.indexedDB.open(\"tensorflowjs\", 1);\n            o.onupgradeneeded = function() {\n                return ad(o);\n            }, o.onsuccess = function() {\n                var a = o.result;\n                if (null == e) {\n                    var i = a.transaction(nd, \"readonly\"), s = i.objectStore(nd).get(n.modelPath);\n                    s.onsuccess = function() {\n                        if (null == s.result) return a.close(), r(new Error(\"Cannot find model with path '\" + n.modelPath + \"' in IndexedDB.\"));\n                        t(s.result.modelArtifacts);\n                    }, s.onerror = function(t) {\n                        return a.close(), r(s.error);\n                    }, i.oncomplete = function() {\n                        return a.close();\n                    };\n                } else {\n                    var u, c = $f(e), l = a.transaction(rd, \"readwrite\"), h = l.objectStore(rd), f = h.put({\n                        modelPath: n.modelPath,\n                        modelArtifactsInfo: c\n                    });\n                    f.onsuccess = function() {\n                        var o = (u = a.transaction(nd, \"readwrite\")).objectStore(nd).put({\n                            modelPath: n.modelPath,\n                            modelArtifacts: e,\n                            modelArtifactsInfo: c\n                        });\n                        o.onsuccess = function() {\n                            return t({\n                                modelArtifactsInfo: c\n                            });\n                        }, o.onerror = function(t) {\n                            var e = (h = l.objectStore(rd)).delete(n.modelPath);\n                            e.onsuccess = function() {\n                                return a.close(), r(o.error);\n                            }, e.onerror = function(t) {\n                                return a.close(), r(o.error);\n                            };\n                        };\n                    }, f.onerror = function(t) {\n                        return a.close(), r(f.error);\n                    }, l.oncomplete = function() {\n                        null == u ? a.close() : u.oncomplete = function() {\n                            return a.close();\n                        };\n                    };\n                }\n            }, o.onerror = function(t) {\n                return r(o.error);\n            };\n        });\n    }, t.URL_SCHEME = \"indexeddb://\", t;\n}(), sd = function(t) {\n    return i().getBool(\"IS_BROWSER\") && !Array.isArray(t) && t.startsWith(id.URL_SCHEME) ? (e = t.slice(id.URL_SCHEME.length), new id(e)) : null;\n    var e;\n};\nQf.registerSaveRouter(sd), Qf.registerLoadRouter(sd);\nvar ud = function() {\n    function t() {\n        this.indexedDB = od();\n    }\n    return t.prototype.listModels = function() {\n        return n(this, void 0, void 0, function() {\n            var t = this;\n            return r(this, function(e) {\n                return [\n                    2,\n                    new Promise(function(e, n) {\n                        var r = t.indexedDB.open(\"tensorflowjs\", 1);\n                        r.onupgradeneeded = function() {\n                            return ad(r);\n                        }, r.onsuccess = function() {\n                            var t = r.result, o = t.transaction(rd, \"readonly\"), a = o.objectStore(rd).getAll();\n                            a.onsuccess = function() {\n                                for(var t = {}, n = 0, r = a.result; n < r.length; n++){\n                                    var o = r[n];\n                                    t[o.modelPath] = o.modelArtifactsInfo;\n                                }\n                                e(t);\n                            }, a.onerror = function(e) {\n                                return t.close(), n(a.error);\n                            }, o.oncomplete = function() {\n                                return t.close();\n                            };\n                        }, r.onerror = function(t) {\n                            return n(r.error);\n                        };\n                    })\n                ];\n            });\n        });\n    }, t.prototype.removeModel = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e = this;\n            return r(this, function(n) {\n                var r;\n                return t = (r = t).startsWith(id.URL_SCHEME) ? r.slice(id.URL_SCHEME.length) : r, [\n                    2,\n                    new Promise(function(n, r) {\n                        var o = e.indexedDB.open(\"tensorflowjs\", 1);\n                        o.onupgradeneeded = function() {\n                            return ad(o);\n                        }, o.onsuccess = function() {\n                            var e, a = o.result, i = a.transaction(rd, \"readwrite\"), s = i.objectStore(rd), u = s.get(t);\n                            u.onsuccess = function() {\n                                if (null == u.result) return a.close(), r(new Error(\"Cannot find model with path '\" + t + \"' in IndexedDB.\"));\n                                var o = s.delete(t), i = function() {\n                                    var o = (e = a.transaction(nd, \"readwrite\")).objectStore(nd).delete(t);\n                                    o.onsuccess = function() {\n                                        return n(u.result.modelArtifactsInfo);\n                                    }, o.onerror = function(t) {\n                                        return r(u.error);\n                                    };\n                                };\n                                o.onsuccess = i, o.onerror = function(t) {\n                                    return i(), a.close(), r(u.error);\n                                };\n                            }, u.onerror = function(t) {\n                                return a.close(), r(u.error);\n                            }, i.oncomplete = function() {\n                                null == e ? a.close() : e.oncomplete = function() {\n                                    return a.close();\n                                };\n                            };\n                        }, o.onerror = function(t) {\n                            return r(o.error);\n                        };\n                    })\n                ];\n            });\n        });\n    }, t;\n}();\nif (i().getBool(\"IS_BROWSER\")) try {\n    Zf.registerManager(id.URL_SCHEME, new ud);\n} catch (t) {}\nvar cd = \"/\", ld = \"tensorflowjs_models\", hd = \"info\", fd = \"model_topology\", dd = \"weight_specs\", pd = \"weight_data\", vd = \"model_metadata\";\nfunction gd(t) {\n    return {\n        info: [\n            ld,\n            t,\n            hd\n        ].join(cd),\n        topology: [\n            ld,\n            t,\n            fd\n        ].join(cd),\n        weightSpecs: [\n            ld,\n            t,\n            dd\n        ].join(cd),\n        weightData: [\n            ld,\n            t,\n            pd\n        ].join(cd),\n        modelMetadata: [\n            ld,\n            t,\n            vd\n        ].join(cd)\n    };\n}\nfunction md(t) {\n    var e = t.split(cd);\n    if (e.length < 3) throw new Error(\"Invalid key format: \" + t);\n    return e.slice(1, e.length - 1).join(cd);\n}\nvar yd = function() {\n    function t(t) {\n        if (!i().getBool(\"IS_BROWSER\") || \"undefined\" == \"undefined\" || 0) throw new Error(\"The current environment does not support local storage.\");\n        if (this.LS = window.localStorage, null == t || !t) throw new Error(\"For local storage, modelPath must not be null, undefined or empty.\");\n        this.modelPath = t, this.keys = gd(this.modelPath);\n    }\n    return t.prototype.save = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o;\n            return r(this, function(r) {\n                if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");\n                e = JSON.stringify(t.modelTopology), n = JSON.stringify(t.weightSpecs), o = $f(t);\n                try {\n                    return this.LS.setItem(this.keys.info, JSON.stringify(o)), this.LS.setItem(this.keys.topology, e), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, function(t) {\n                        if (Kf) return Buffer.from(t).toString(\"base64\");\n                        for(var e = new Uint8Array(t), n = \"\", r = 0, o = e.length; r < o; r++)n += String.fromCharCode(e[r]);\n                        return btoa(n);\n                    }(t.weightData)), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({\n                        format: t.format,\n                        generatedBy: t.generatedBy,\n                        convertedBy: t.convertedBy,\n                        userDefinedMetadata: t.userDefinedMetadata\n                    })), [\n                        2,\n                        {\n                            modelArtifactsInfo: o\n                        }\n                    ];\n                } catch (t) {\n                    throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error(\"Failed to save model '\" + this.modelPath + \"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=\" + o.modelTopologyBytes + \", weightSpecsBytes=\" + o.weightSpecsBytes + \", weightDataBytes=\" + o.weightDataBytes + \".\");\n                }\n                return [\n                    2\n                ];\n            });\n        });\n    }, t.prototype.load = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n, o, a, i, s;\n            return r(this, function(r) {\n                if (null == (t = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error(\"In local storage, there is no model with name '\" + this.modelPath + \"'\");\n                if (\"JSON\" !== t.modelTopologyType) throw new Error(\"BrowserLocalStorage does not support loading non-JSON model topology yet.\");\n                if (e = {}, null == (n = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error(\"In local storage, the topology of model '\" + this.modelPath + \"' is missing.\");\n                if (e.modelTopology = n, null == (o = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error(\"In local storage, the weight specs of model '\" + this.modelPath + \"' are missing.\");\n                if (e.weightSpecs = o, null != (a = this.LS.getItem(this.keys.modelMetadata)) && (i = JSON.parse(a), e.format = i.format, e.generatedBy = i.generatedBy, e.convertedBy = i.convertedBy, e.userDefinedMetadata = i.userDefinedMetadata), null == (s = this.LS.getItem(this.keys.weightData))) throw new Error(\"In local storage, the binary weight values of model '\" + this.modelPath + \"' are missing.\");\n                return e.weightData = function(t) {\n                    if (Kf) {\n                        var e = Buffer.from(t, \"base64\");\n                        return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);\n                    }\n                    for(var n = atob(t), r = new Uint8Array(n.length), o = 0; o < n.length; ++o)r.set([\n                        n.charCodeAt(o)\n                    ], o);\n                    return r.buffer;\n                }(s), [\n                    2,\n                    e\n                ];\n            });\n        });\n    }, t.URL_SCHEME = \"localstorage://\", t;\n}(), xd = function(t) {\n    return i().getBool(\"IS_BROWSER\") && !Array.isArray(t) && t.startsWith(yd.URL_SCHEME) ? (e = t.slice(yd.URL_SCHEME.length), new yd(e)) : null;\n    var e;\n};\nQf.registerSaveRouter(xd), Qf.registerLoadRouter(xd);\nvar bd = function() {\n    function t() {\n        C(i().getBool(\"IS_BROWSER\"), function() {\n            return \"Current environment is not a web browser\";\n        }), C( true || 0, function() {\n            return \"Current browser does not appear to support localStorage\";\n        }), this.LS = window.localStorage;\n    }\n    return t.prototype.listModels = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n, o, a, i;\n            return r(this, function(r) {\n                for(t = {}, e = ld + cd, n = cd + hd, o = 0; o < this.LS.length; ++o)(a = this.LS.key(o)).startsWith(e) && a.endsWith(n) && (i = md(a), t[i] = JSON.parse(this.LS.getItem(a)));\n                return [\n                    2,\n                    t\n                ];\n            });\n        });\n    }, t.prototype.removeModel = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n;\n            return r(this, function(r) {\n                var o;\n                if (t = (o = t).startsWith(yd.URL_SCHEME) ? o.slice(yd.URL_SCHEME.length) : o, e = gd(t), null == this.LS.getItem(e.info)) throw new Error(\"Cannot find model at path '\" + t + \"'\");\n                return n = JSON.parse(this.LS.getItem(e.info)), this.LS.removeItem(e.info), this.LS.removeItem(e.topology), this.LS.removeItem(e.weightSpecs), this.LS.removeItem(e.weightData), [\n                    2,\n                    n\n                ];\n            });\n        });\n    }, t;\n}();\nif (i().getBool(\"IS_BROWSER\")) try {\n    Zf.registerManager(yd.URL_SCHEME, new bd);\n} catch (t) {}\nvar wd = \"model\", Cd = \".json\", Ed = \".weights.bin\";\nfunction Rd(t) {\n    return new Promise(function(t) {\n        return setTimeout(t);\n    }).then(t);\n}\nvar Id = function() {\n    function t(e) {\n        if (!i().getBool(\"IS_BROWSER\")) throw new Error(\"browserDownloads() cannot proceed because the current environment is not a browser.\");\n        e.startsWith(t.URL_SCHEME) && (e = e.slice(t.URL_SCHEME.length)), null != e && 0 !== e.length || (e = wd), this.modelTopologyFileName = e + Cd, this.weightDataFileName = e + Ed;\n    }\n    return t.prototype.save = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o, a, i, s;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (\"undefined\" == typeof document) throw new Error(\"Browser downloads are not supported in this environment since `document` is not present\");\n                        if (e = window.URL.createObjectURL(new Blob([\n                            t.weightData\n                        ], {\n                            type: \"application/octet-stream\"\n                        })), !(t.modelTopology instanceof ArrayBuffer)) return [\n                            3,\n                            1\n                        ];\n                        throw new Error(\"BrowserDownloads.save() does not support saving model topology in binary formats yet.\");\n                    case 1:\n                        return n = [\n                            {\n                                paths: [\n                                    \"./\" + this.weightDataFileName\n                                ],\n                                weights: t.weightSpecs\n                            }\n                        ], o = {\n                            modelTopology: t.modelTopology,\n                            format: t.format,\n                            generatedBy: t.generatedBy,\n                            convertedBy: t.convertedBy,\n                            weightsManifest: n\n                        }, a = window.URL.createObjectURL(new Blob([\n                            JSON.stringify(o)\n                        ], {\n                            type: \"application/json\"\n                        })), (i = null == this.jsonAnchor ? document.createElement(\"a\") : this.jsonAnchor).download = this.modelTopologyFileName, i.href = a, [\n                            4,\n                            Rd(function() {\n                                return i.dispatchEvent(new MouseEvent(\"click\"));\n                            })\n                        ];\n                    case 2:\n                        return r.sent(), null == t.weightData ? [\n                            3,\n                            4\n                        ] : ((s = null == this.weightDataAnchor ? document.createElement(\"a\") : this.weightDataAnchor).download = this.weightDataFileName, s.href = e, [\n                            4,\n                            Rd(function() {\n                                return s.dispatchEvent(new MouseEvent(\"click\"));\n                            })\n                        ]);\n                    case 3:\n                        r.sent(), r.label = 4;\n                    case 4:\n                        return [\n                            2,\n                            {\n                                modelArtifactsInfo: $f(t)\n                            }\n                        ];\n                }\n            });\n        });\n    }, t.URL_SCHEME = \"downloads://\", t;\n}(), kd = function() {\n    function t(t) {\n        if (null == t || t.length < 1) throw new Error(\"When calling browserFiles, at least 1 file is required, but received \" + t);\n        this.files = t;\n    }\n    return t.prototype.load = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n = this;\n            return r(this, function(r) {\n                return t = this.files[0], e = this.files.slice(1), [\n                    2,\n                    new Promise(function(r, o) {\n                        var a = new FileReader;\n                        a.onload = function(a) {\n                            var i = JSON.parse(a.target.result), s = i.modelTopology;\n                            if (null != s) {\n                                0 === e.length && r({\n                                    modelTopology: s\n                                });\n                                var u = i.weightsManifest;\n                                if (null != u) {\n                                    var c;\n                                    try {\n                                        c = n.checkManifestAndWeightFiles(u, e);\n                                    } catch (t) {\n                                        return void o(t);\n                                    }\n                                    var l = [], h = [], f = [];\n                                    u.forEach(function(t) {\n                                        t.paths.forEach(function(t) {\n                                            h.push(t), f.push(null);\n                                        }), l.push.apply(l, t.weights);\n                                    }), u.forEach(function(t) {\n                                        t.paths.forEach(function(t) {\n                                            var e = new FileReader;\n                                            e.onload = function(e) {\n                                                var n = e.target.result, o = h.indexOf(t);\n                                                f[o] = n, -1 === f.indexOf(null) && r({\n                                                    modelTopology: s,\n                                                    weightSpecs: l,\n                                                    weightData: Xf(f),\n                                                    format: i.format,\n                                                    generatedBy: i.generatedBy,\n                                                    convertedBy: i.convertedBy,\n                                                    userDefinedMetadata: i.userDefinedMetadata\n                                                });\n                                            }, e.onerror = function(e) {\n                                                return o(\"Failed to weights data from file of path '\" + t + \"'.\");\n                                            }, e.readAsArrayBuffer(c[t]);\n                                        });\n                                    });\n                                } else o(new Error(\"weightManifest field is missing from file \" + t.name));\n                            } else o(new Error(\"modelTopology field is missing from file \" + t.name));\n                        }, a.onerror = function(e) {\n                            return o(\"Failed to read model topology and weights manifest JSON from file '\" + t.name + \"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.\");\n                        }, a.readAsText(t);\n                    })\n                ];\n            });\n        });\n    }, t.prototype.checkManifestAndWeightFiles = function(t, e) {\n        for(var n = [], r = e.map(function(t) {\n            return Yf(t.name);\n        }), o = {}, a = 0, i = t; a < i.length; a++){\n            i[a].paths.forEach(function(t) {\n                var a = Yf(t);\n                if (-1 !== n.indexOf(a)) throw new Error(\"Duplicate file basename found in weights manifest: '\" + a + \"'\");\n                if (n.push(a), -1 === r.indexOf(a)) throw new Error(\"Weight file with basename '\" + a + \"' is not provided.\");\n                o[t] = e[r.indexOf(a)];\n            });\n        }\n        if (n.length !== e.length) throw new Error(\"Mismatch in the number of files in weights manifest (\" + n.length + \") and the number of weight files provided (\" + e.length + \").\");\n        return o;\n    }, t;\n}();\nfunction Sd(t, e, n, r) {\n    !function(t) {\n        C(null != t && Array.isArray(t) && t.length > 0, function() {\n            return \"promises must be a none empty array\";\n        });\n    }(t), function(t, e) {\n        C(t >= 0 && t <= 1, function() {\n            return \"Progress fraction must be in range [0, 1], but got startFraction \" + t;\n        }), C(e >= 0 && e <= 1, function() {\n            return \"Progress fraction must be in range [0, 1], but got endFraction \" + e;\n        }), C(e >= t, function() {\n            return \"startFraction must be no more than endFraction, but got startFraction \" + t + \" and endFraction \" + e;\n        });\n    }(n = null == n ? 0 : n, r = null == r ? 1 : r);\n    var o = 0;\n    return Promise.all(t.map(function(a) {\n        return a.then(function(a) {\n            var i = n + ++o / t.length * (r - n);\n            return e(i), a;\n        }), a;\n    }));\n}\nfunction Ad(t, e) {\n    return n(this, void 0, void 0, function() {\n        var n, o, a, s, u, c, l, h, f;\n        return r(this, function(r) {\n            switch(r.label){\n                case 0:\n                    return null == e && (e = {}), n = null == e.fetchFunc ? i().platform.fetch : e.fetchFunc, o = t.map(function(t) {\n                        return n(t, e.requestInit, {\n                            isBinary: !0\n                        });\n                    }), a = 0, s = .5, null != e.onProgress ? [\n                        3,\n                        2\n                    ] : [\n                        4,\n                        Promise.all(o)\n                    ];\n                case 1:\n                    return u = r.sent(), [\n                        3,\n                        4\n                    ];\n                case 2:\n                    return [\n                        4,\n                        Sd(o, e.onProgress, a, s)\n                    ];\n                case 3:\n                    u = r.sent(), r.label = 4;\n                case 4:\n                    return c = u.map(function(t) {\n                        return t.arrayBuffer();\n                    }), l = .5, h = 1, null != e.onProgress ? [\n                        3,\n                        6\n                    ] : [\n                        4,\n                        Promise.all(c)\n                    ];\n                case 5:\n                    return f = r.sent(), [\n                        3,\n                        8\n                    ];\n                case 6:\n                    return [\n                        4,\n                        Sd(c, e.onProgress, l, h)\n                    ];\n                case 7:\n                    f = r.sent(), r.label = 8;\n                case 8:\n                    return [\n                        2,\n                        f\n                    ];\n            }\n        });\n    });\n}\nfunction Td(t) {\n    var e = this;\n    return function(o, a, i) {\n        return void 0 === a && (a = \"\"), n(e, void 0, void 0, function() {\n            var e, n, s, u, c, l, h, f, d, p;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (e = o.map(function() {\n                            return !1;\n                        }), n = {}, s = null != i ? i.map(function() {\n                            return !1;\n                        }) : [], u = [], o.forEach(function(t, r) {\n                            var o = 0;\n                            t.weights.forEach(function(t) {\n                                var a = \"quantization\" in t ? t.quantization.dtype : t.dtype, c = zf[a] * k(t.shape), l = function() {\n                                    e[r] = !0, null == n[r] && (n[r] = []), n[r].push({\n                                        manifestEntry: t,\n                                        groupOffset: o,\n                                        sizeBytes: c\n                                    });\n                                };\n                                null != i ? i.forEach(function(e, n) {\n                                    e === t.name && (l(), s[n] = !0);\n                                }) : l(), u.push(t.name), o += c;\n                            });\n                        }), !s.every(function(t) {\n                            return t;\n                        })) throw c = i.filter(function(t, e) {\n                            return !s[e];\n                        }), new Error(\"Could not find weights in manifest with names: \" + c.join(\", \") + \". \\nManifest JSON has weights with names: \" + u.join(\", \") + \".\");\n                        return l = e.reduce(function(t, e, n) {\n                            return e && t.push(n), t;\n                        }, []), h = [], l.forEach(function(t) {\n                            o[t].paths.forEach(function(t) {\n                                var e = a + (a.endsWith(\"/\") ? \"\" : \"/\") + t;\n                                h.push(e);\n                            });\n                        }), [\n                            4,\n                            t(h)\n                        ];\n                    case 1:\n                        return f = r.sent(), d = {}, p = 0, l.forEach(function(t) {\n                            for(var e = o[t].paths.length, r = 0, a = 0; a < e; a++)r += f[p + a].byteLength;\n                            for(var i = new ArrayBuffer(r), s = new Uint8Array(i), u = 0, c = 0; c < e; c++){\n                                var l = new Uint8Array(f[p + c]);\n                                s.set(l, u), u += l.byteLength;\n                            }\n                            n[t].forEach(function(t) {\n                                var e = Hf(i.slice(t.groupOffset, t.groupOffset + t.sizeBytes), [\n                                    t.manifestEntry\n                                ]);\n                                for(var n in e)d[n] = e[n];\n                            }), p += e;\n                        }), [\n                            2,\n                            d\n                        ];\n                }\n            });\n        });\n    };\n}\nQf.registerSaveRouter(function(t) {\n    return i().getBool(\"IS_BROWSER\") && !Array.isArray(t) && t.startsWith(Id.URL_SCHEME) ? function(t) {\n        void 0 === t && (t = \"model\");\n        return new Id(t);\n    }(t.slice(Id.URL_SCHEME.length)) : null;\n});\nvar Dd = function() {\n    function t(t, e) {\n        if (this.DEFAULT_METHOD = \"POST\", null == e && (e = {}), this.weightPathPrefix = e.weightPathPrefix, this.onProgress = e.onProgress, null != e.fetchFunc ? (C(\"function\" == typeof e.fetchFunc, function() {\n            return \"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)\";\n        }), this.fetch = e.fetchFunc) : this.fetch = i().platform.fetch, C(null != t && t.length > 0, function() {\n            return \"URL path for http must not be null, undefined or empty.\";\n        }), Array.isArray(t) && C(2 === t.length, function() {\n            return \"URL paths for http must have a length of 2, (actual length is \" + t.length + \").\";\n        }), this.path = t, null != e.requestInit && null != e.requestInit.body) throw new Error(\"requestInit is expected to have no pre-existing body, but has one.\");\n        this.requestInit = e.requestInit || {};\n    }\n    return t.prototype.save = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o, a;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.\");\n                        return (e = Object.assign({\n                            method: this.DEFAULT_METHOD\n                        }, this.requestInit)).body = new FormData, n = [\n                            {\n                                paths: [\n                                    \"./model.weights.bin\"\n                                ],\n                                weights: t.weightSpecs\n                            }\n                        ], o = {\n                            modelTopology: t.modelTopology,\n                            format: t.format,\n                            generatedBy: t.generatedBy,\n                            convertedBy: t.convertedBy,\n                            userDefinedMetadata: t.userDefinedMetadata,\n                            weightsManifest: n\n                        }, e.body.append(\"model.json\", new Blob([\n                            JSON.stringify(o)\n                        ], {\n                            type: \"application/json\"\n                        }), \"model.json\"), null != t.weightData && e.body.append(\"model.weights.bin\", new Blob([\n                            t.weightData\n                        ], {\n                            type: \"application/octet-stream\"\n                        }), \"model.weights.bin\"), [\n                            4,\n                            this.fetch(this.path, e)\n                        ];\n                    case 1:\n                        if ((a = r.sent()).ok) return [\n                            2,\n                            {\n                                modelArtifactsInfo: $f(t),\n                                responses: [\n                                    a\n                                ]\n                            }\n                        ];\n                        throw new Error(\"BrowserHTTPRequest.save() failed due to HTTP response status \" + a.status + \".\");\n                }\n            });\n        });\n    }, t.prototype.load = function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n, o, a, i, s, u, c, l, h, f;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        return [\n                            4,\n                            this.fetch(this.path, this.requestInit)\n                        ];\n                    case 1:\n                        if (!(t = r.sent()).ok) throw new Error(\"Request to \" + this.path + \" failed with status code \" + t.status + \". Please verify this URL points to the model JSON of the model to load.\");\n                        r.label = 2;\n                    case 2:\n                        return r.trys.push([\n                            2,\n                            4,\n                            ,\n                            5\n                        ]), [\n                            4,\n                            t.json()\n                        ];\n                    case 3:\n                        return e = r.sent(), [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        throw r.sent(), n = \"Failed to parse model JSON of response from \" + this.path + \".\", this.path.endsWith(\".pb\") ? n += \" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.\" : n += \" Please make sure the server is serving valid JSON for this request.\", new Error(n);\n                    case 5:\n                        if (o = e.modelTopology, a = e.weightsManifest, i = e.generatedBy, s = e.convertedBy, u = e.format, c = e.userDefinedMetadata, null == o && null == a) throw new Error(\"The JSON from HTTP path \" + this.path + \" contains neither model topology or manifest for weights.\");\n                        return null == a ? [\n                            3,\n                            7\n                        ] : [\n                            4,\n                            this.loadWeights(a)\n                        ];\n                    case 6:\n                        f = r.sent(), l = f[0], h = f[1], r.label = 7;\n                    case 7:\n                        return [\n                            2,\n                            {\n                                modelTopology: o,\n                                weightSpecs: l,\n                                weightData: h,\n                                userDefinedMetadata: c,\n                                generatedBy: i,\n                                convertedBy: s,\n                                format: u\n                            }\n                        ];\n                }\n            });\n        });\n    }, t.prototype.loadWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n, o, a, i, s, u, c, l, h, f;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        for(e = Array.isArray(this.path) ? this.path[1] : this.path, n = function(t) {\n                            var e = t.lastIndexOf(\"/\"), n = t.lastIndexOf(\"?\"), r = t.substring(0, e), o = n > e ? t.substring(n) : \"\";\n                            return [\n                                r + \"/\",\n                                o\n                            ];\n                        }(e), o = n[0], a = n[1], i = this.weightPathPrefix || o, s = [], u = 0, c = t; u < c.length; u++)l = c[u], s.push.apply(s, l.weights);\n                        return h = [], t.forEach(function(t) {\n                            t.paths.forEach(function(t) {\n                                h.push(i + t + a);\n                            });\n                        }), [\n                            4,\n                            Ad(h, {\n                                requestInit: this.requestInit,\n                                fetchFunc: this.fetch,\n                                onProgress: this.onProgress\n                            })\n                        ];\n                    case 1:\n                        return f = r.sent(), [\n                            2,\n                            [\n                                s,\n                                Xf(f)\n                            ]\n                        ];\n                }\n            });\n        });\n    }, t.URL_SCHEME_REGEX = /^https?:\\/\\//, t;\n}();\nfunction Nd(t) {\n    return null != t.match(Dd.URL_SCHEME_REGEX);\n}\nvar Fd = function(t, e) {\n    if (\"undefined\" == typeof fetch) return null;\n    return (Array.isArray(t) ? t.every(function(t) {\n        return Nd(t);\n    }) : Nd(t)) ? _d(t, {\n        onProgress: e\n    }) : null;\n};\nfunction _d(t, e) {\n    return new Dd(t, e);\n}\nQf.registerSaveRouter(Fd), Qf.registerLoadRouter(Fd);\nvar Od = function() {\n    function t(t) {\n        this.modelArtifacts = t;\n    }\n    return t.prototype.load = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                return [\n                    2,\n                    this.modelArtifacts\n                ];\n            });\n        });\n    }, t;\n}(), Md = function() {\n    function t(t) {\n        this.saveHandler = t;\n    }\n    return t.prototype.save = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                return [\n                    2,\n                    this.saveHandler(t)\n                ];\n            });\n        });\n    }, t;\n}();\nvar Bd = Object.freeze({\n    browserFiles: function(t) {\n        return new kd(t);\n    },\n    browserHTTPRequest: function(t, e) {\n        return _d(t, e);\n    },\n    concatenateArrayBuffers: Xf,\n    decodeWeights: Hf,\n    encodeWeights: function(t, e) {\n        return n(this, void 0, void 0, function() {\n            var o, a, i, s, u, c = this;\n            return r(this, function(l) {\n                switch(l.label){\n                    case 0:\n                        for(o = [], a = [], i = Array.isArray(t) ? t.map(function(t) {\n                            return t.name;\n                        }) : Object.keys(t), s = function(s) {\n                            var u = i[s], l = Array.isArray(t) ? t[s].tensor : t[u];\n                            if (\"float32\" !== l.dtype && \"int32\" !== l.dtype && \"bool\" !== l.dtype && \"string\" !== l.dtype) throw new Error(\"Unsupported dtype in weight '\" + u + \"': \" + l.dtype);\n                            var h = {\n                                name: u,\n                                shape: l.shape,\n                                dtype: l.dtype\n                            };\n                            if (\"string\" === l.dtype) {\n                                var f = new Promise(function(t) {\n                                    return n(c, void 0, void 0, function() {\n                                        var e, n, o, a, i, s, u;\n                                        return r(this, function(r) {\n                                            switch(r.label){\n                                                case 0:\n                                                    return [\n                                                        4,\n                                                        l.bytes()\n                                                    ];\n                                                case 1:\n                                                    for(e = r.sent(), n = e.reduce(function(t, e) {\n                                                        return t + e.length;\n                                                    }, 0) + Gf * e.length, o = new Uint8Array(n), a = 0, i = 0; i < e.length; i++)s = e[i], u = new Uint8Array(new Uint32Array([\n                                                        s.length\n                                                    ]).buffer), o.set(u, a), a += Gf, o.set(s, a), a += s.length;\n                                                    return t(o), [\n                                                        2\n                                                    ];\n                                            }\n                                        });\n                                    });\n                                });\n                                a.push(f);\n                            } else a.push(l.data());\n                            null != e && (h.group = e), o.push(h);\n                        }, u = 0; u < i.length; ++u)s(u);\n                        return [\n                            4,\n                            Promise.all(a)\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            {\n                                data: qf(l.sent()),\n                                specs: o\n                            }\n                        ];\n                }\n            });\n        });\n    },\n    fromMemory: function(t, e, n, r) {\n        return 1 === arguments.length ? null != t.modelTopology || null != t.weightSpecs ? new Od(t) : (console.warn(\"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.\"), new Od({\n            modelTopology: t\n        })) : (console.warn(\"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.\"), new Od({\n            modelTopology: t,\n            weightSpecs: e,\n            weightData: n,\n            trainingConfig: r\n        }));\n    },\n    getLoadHandlers: function(t, e) {\n        return Qf.getLoadHandlers(t, e);\n    },\n    getModelArtifactsInfoForJSON: $f,\n    getSaveHandlers: function(t) {\n        return Qf.getSaveHandlers(t);\n    },\n    http: _d,\n    isHTTPScheme: Nd,\n    loadWeights: function(t, e, o, a) {\n        return void 0 === e && (e = \"\"), n(this, void 0, void 0, function() {\n            return r(this, function(n) {\n                return [\n                    2,\n                    Td(function(t) {\n                        return Ad(t, {\n                            requestInit: a\n                        });\n                    })(t, e, o)\n                ];\n            });\n        });\n    },\n    registerLoadRouter: function(t) {\n        return Qf.registerLoadRouter(t);\n    },\n    registerSaveRouter: function(t) {\n        return Qf.registerSaveRouter(t);\n    },\n    weightsLoaderFactory: Td,\n    withSaveHandler: function(t) {\n        return new Md(t);\n    },\n    copyModel: function(t, e) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(n) {\n                return !1, [\n                    2,\n                    ed(t, e, !1)\n                ];\n            });\n        });\n    },\n    listModels: function() {\n        return n(this, void 0, void 0, function() {\n            var t, e, n, o, a, i, s;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        t = Zf.getSchemes(), e = {}, n = 0, o = t, r.label = 1;\n                    case 1:\n                        return n < o.length ? (a = o[n], [\n                            4,\n                            Zf.getManager(a).listModels()\n                        ]) : [\n                            3,\n                            4\n                        ];\n                    case 2:\n                        for(s in i = r.sent())e[a + Jf + s] = i[s];\n                        r.label = 3;\n                    case 3:\n                        return n++, [\n                            3,\n                            1\n                        ];\n                    case 4:\n                        return [\n                            2,\n                            e\n                        ];\n                }\n            });\n        });\n    },\n    moveModel: function(t, e) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(n) {\n                return !0, [\n                    2,\n                    ed(t, e, !0)\n                ];\n            });\n        });\n    },\n    removeModel: function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                return e = td(t), [\n                    2,\n                    Zf.getManager(e.scheme).removeModel(e.path)\n                ];\n            });\n        });\n    }\n});\nvar Pd, Ld = An({\n    confusionMatrix_: function(t, e, n) {\n        var r = gn(t, \"labels\", \"confusionMatrix\"), o = gn(e, \"predictions\", \"confusionMatrix\");\n        C(null == n || n > 0 && Number.isInteger(n), function() {\n            return \"If provided, numClasses must be a positive integer, but got \" + n;\n        }), C(1 === r.rank, function() {\n            return \"Expected the rank of labels to be 1, but got \" + r.rank;\n        }), C(1 === o.rank, function() {\n            return \"Expected the rank of predictions to be 1, but got \" + o.rank;\n        }), C(r.shape[0] === o.shape[0], function() {\n            return \"Mismatch in the number of examples: \" + r.shape[0] + \" vs. \" + o.shape[0] + \". Labels and predictions should have the same number of elements.\";\n        }), C(n > 0 && Number.isInteger(n), function() {\n            return \"numClasses is required to be a positive integer, but got \" + n;\n        });\n        var a = Rc(r.asType(\"int32\"), n), i = Rc(o.asType(\"int32\"), n);\n        return a.transpose().matMul(i).asType(\"int32\");\n    }\n}), Wd = Object.freeze({\n    confusionMatrix: Ld\n});\nvar Ud = An({\n    fromPixels_: function(t, e) {\n        if (void 0 === e && (e = 3), e > 4) throw new Error(\"Cannot construct Tensor with more than 4 channels from pixels.\");\n        if (null == t) throw new Error(\"pixels passed to tf.browser.fromPixels() can not be null\");\n        var n = !1, r = !1, o = !1, a = !1, i = !1;\n        if (t.data instanceof Uint8Array) n = !0;\n        else if (\"undefined\" != typeof ImageData && t instanceof ImageData) r = !0;\n        else if (\"undefined\" != typeof HTMLVideoElement && t instanceof HTMLVideoElement) o = !0;\n        else if (\"undefined\" != typeof HTMLImageElement && t instanceof HTMLImageElement) a = !0;\n        else {\n            if (null == t.getContext) throw new Error(\"pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was \" + t.constructor.name);\n            i = !0;\n        }\n        if (o) {\n            if (o && t.readyState < 2) throw new Error(\"The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.\");\n        }\n        if (null != l(\"FromPixels\", Lt.backendName)) return Lt.runKernel(\"FromPixels\", {\n            pixels: t\n        }, {\n            numChannels: e\n        });\n        var s, u, c = o ? [\n            t.videoWidth,\n            t.videoHeight\n        ] : [\n            t.width,\n            t.height\n        ], h = c[0], f = c[1];\n        if (i ? s = t.getContext(\"2d\").getImageData(0, 0, h, f).data : r || n ? s = t.data : (a || o) && (null == Pd && (Pd = document.createElement(\"canvas\").getContext(\"2d\")), Pd.canvas.width = h, Pd.canvas.height = f, Pd.drawImage(t, 0, 0, h, f), s = Pd.getImageData(0, 0, h, f).data), 4 === e) u = new Int32Array(s);\n        else {\n            var d = h * f;\n            u = new Int32Array(d * e);\n            for(var p = 0; p < d; p++)for(var v = 0; v < e; ++v)u[p * e + v] = s[4 * p + v];\n        }\n        return Pn(u, [\n            f,\n            h,\n            e\n        ], \"int32\");\n    }\n}), Vd = Object.freeze({\n    toPixels: function(t, e) {\n        return n(this, void 0, void 0, function() {\n            var n, o, a, i, s, u, c, l, h, f, d, p, v, g, m, y, x, b, w, C, E, R, I;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        if (n = gn(t, \"img\", \"toPixels\"), t instanceof wt || (n = n.toInt()), 2 !== n.rank && 3 !== n.rank) throw new Error(\"toPixels only supports rank 2 or 3 tensors, got rank \" + n.rank + \".\");\n                        if (o = n.shape.slice(0, 2), a = o[0], i = o[1], (s = 2 === n.rank ? 1 : n.shape[2]) > 4 || 2 === s) throw new Error(\"toPixels only supports depth of size 1, 3 or 4 but got \" + s);\n                        return [\n                            4,\n                            n.data()\n                        ];\n                    case 1:\n                        return u = r.sent(), c = n.min(), l = n.max(), [\n                            4,\n                            Promise.all([\n                                c.data(),\n                                l.data()\n                            ])\n                        ];\n                    case 2:\n                        if (h = r.sent(), f = h[0], d = h[1], p = f[0], v = d[0], c.dispose(), l.dispose(), \"float32\" === n.dtype) {\n                            if (p < 0 || v > 1) throw new Error(\"Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [\" + p + \" - \" + v + \"].\");\n                        } else {\n                            if (\"int32\" !== n.dtype) throw new Error(\"Unsupported type for toPixels: \" + n.dtype + \". Please use float32 or int32 tensors.\");\n                            if (p < 0 || v > 255) throw new Error(\"Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [\" + p + \" - \" + v + \"].\");\n                        }\n                        for(g = \"float32\" === n.dtype ? 255 : 1, m = new Uint8ClampedArray(i * a * 4), y = 0; y < a * i; ++y)x = void 0, b = void 0, w = void 0, C = void 0, 1 === s ? (x = u[y] * g, b = u[y] * g, w = u[y] * g, C = 255) : 3 === s ? (x = u[3 * y] * g, b = u[3 * y + 1] * g, w = u[3 * y + 2] * g, C = 255) : 4 === s && (x = u[4 * y] * g, b = u[4 * y + 1] * g, w = u[4 * y + 2] * g, C = u[4 * y + 3] * g), m[(E = 4 * y) + 0] = Math.round(x), m[E + 1] = Math.round(b), m[E + 2] = Math.round(w), m[E + 3] = Math.round(C);\n                        return null != e && (e.width = i, e.height = a, R = e.getContext(\"2d\"), I = new ImageData(m, i, a), R.putImageData(I, 0, 0)), n !== t && n.dispose(), [\n                            2,\n                            m\n                        ];\n                }\n            });\n        });\n    },\n    fromPixels: Ud\n}), zd = function() {\n    function t() {}\n    return t.prototype.getClassName = function() {\n        return this.constructor.className;\n    }, t.fromConfig = function(t, e) {\n        return new t(e);\n    }, t;\n}(), Gd = function() {\n    function t() {\n        this.classNameMap = {};\n    }\n    return t.getMap = function() {\n        return null == t.instance && (t.instance = new t), t.instance;\n    }, t.register = function(e) {\n        t.getMap().classNameMap[e.className] = [\n            e,\n            e.fromConfig\n        ];\n    }, t;\n}();\nfunction Hd(t) {\n    C(null != t.className, function() {\n        return \"Class being registered does not have the static className property defined.\";\n    }), C(\"string\" == typeof t.className, function() {\n        return \"className is required to be a string, but got type \" + typeof t.className;\n    }), C(t.className.length > 0, function() {\n        return \"Class being registered has an empty-string as its className, which is disallowed.\";\n    }), Gd.register(t);\n}\nvar qd = Object.freeze({\n    Serializable: zd,\n    SerializationMap: Gd,\n    registerClass: Hd\n}), Kd = \"1.7.4\";\nvar jd = Object.freeze({\n    gpgpu_util: Rs,\n    webgl_util: Ge,\n    forceHalfFloat: function() {\n        i().set(\"WEBGL_FORCE_F16_TEXTURES\", !0);\n    },\n    MathBackendWebGL: Uu,\n    setWebGLContext: Kt,\n    GPGPUContext: Is\n}), Xd = function(t) {\n    function o() {\n        return null !== t && t.apply(this, arguments) || this;\n    }\n    return e(o, t), o.prototype.minimize = function(t, e, n) {\n        void 0 === e && (e = !1);\n        var r = this.computeGradients(t, n), o = r.value, a = r.grads;\n        if (null != n) {\n            var i = n.map(function(t) {\n                return {\n                    name: t.name,\n                    tensor: a[t.name]\n                };\n            });\n            this.applyGradients(i);\n        } else this.applyGradients(a);\n        return tn(a), e ? o : (o.dispose(), null);\n    }, Object.defineProperty(o.prototype, \"iterations\", {\n        get: function() {\n            return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;\n        },\n        enumerable: !0,\n        configurable: !0\n    }), o.prototype.incrementIterations = function() {\n        this.iterations_ = this.iterations + 1;\n    }, o.prototype.computeGradients = function(t, e) {\n        return ra(t, e);\n    }, o.prototype.dispose = function() {\n        null != this.iterations_ && tn(this.iterations_);\n    }, o.prototype.saveIterations = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                return null == this.iterations_ && (this.iterations_ = 0), [\n                    2,\n                    {\n                        name: \"iter\",\n                        tensor: On(this.iterations_, \"int32\")\n                    }\n                ];\n            });\n        });\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                throw new Error(\"getWeights() is not implemented for this optimizer yet.\");\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                throw new Error(\"setWeights() is not implemented for this optimizer class \" + this.getClassName());\n            });\n        });\n    }, o.prototype.extractIterations = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        return e = this, [\n                            4,\n                            t[0].tensor.data()\n                        ];\n                    case 1:\n                        return e.iterations_ = n.sent()[0], [\n                            2,\n                            t.slice(1)\n                        ];\n                }\n            });\n        });\n    }, o;\n}(zd);\nObject.defineProperty(Xd, Symbol.hasInstance, {\n    value: function(t) {\n        return null != t.minimize && null != t.computeGradients && null != t.applyGradients;\n    }\n});\nvar Yd = function(t) {\n    function o(e, n, r) {\n        void 0 === r && (r = null);\n        var o = t.call(this) || this;\n        return o.learningRate = e, o.rho = n, o.epsilon = r, o.accumulatedGrads = [], o.accumulatedUpdates = [], null == r && (o.epsilon = Lt.backend.epsilon()), o;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this;\n        (Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t)).forEach(function(n, r) {\n            var o = Lt.registeredVariables[n];\n            null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {\n                originalName: n + \"/accum_grad\",\n                variable: Ze(function() {\n                    return Xn(o).variable(!1);\n                })\n            }), null == e.accumulatedUpdates[r] && (e.accumulatedUpdates[r] = {\n                originalName: n + \"/accum_var\",\n                variable: Ze(function() {\n                    return Xn(o).variable(!1);\n                })\n            });\n            var a = Array.isArray(t) ? t[r].tensor : t[n];\n            if (null != a) {\n                var i = e.accumulatedGrads[r].variable, s = e.accumulatedUpdates[r].variable;\n                Ze(function() {\n                    var t = i.mul(e.rho).add(a.square().mul(1 - e.rho)), n = s.add(e.epsilon).sqrt().div(i.add(e.epsilon).sqrt()).mul(a), r = s.mul(e.rho).add(n.square().mul(1 - e.rho));\n                    i.assign(t), s.assign(r);\n                    var u = n.mul(-e.learningRate).add(o);\n                    o.assign(u);\n                });\n            }\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        null != this.accumulatedUpdates && (tn(this.accumulatedGrads.map(function(t) {\n            return t.variable;\n        })), tn(this.accumulatedUpdates.map(function(t) {\n            return t.variable;\n        })));\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return t = this.accumulatedGrads.concat(this.accumulatedUpdates), [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                e.sent()\n                            ].concat(t.map(function(t) {\n                                return {\n                                    name: t.originalName,\n                                    tensor: t.variable\n                                };\n                            }))\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        return t = n.sent(), e = t.length / 2, !1, this.accumulatedGrads = t.slice(0, e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), this.accumulatedUpdates = t.slice(e, 2 * e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            rho: this.rho,\n            epsilon: this.epsilon\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.rho, e.epsilon);\n    }, o.className = \"Adadelta\", o;\n}(Xd);\nHd(Yd);\nvar $d = function(t) {\n    function o(e, n) {\n        void 0 === n && (n = .1);\n        var r = t.call(this) || this;\n        return r.learningRate = e, r.initialAccumulatorValue = n, r.accumulatedGrads = [], r;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this;\n        (Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t)).forEach(function(n, r) {\n            var o = Lt.registeredVariables[n];\n            if (null == e.accumulatedGrads[r]) {\n                e.accumulatedGrads[r] = {\n                    originalName: n + \"/accumulator\",\n                    variable: Ze(function() {\n                        return Hn(o.shape, e.initialAccumulatorValue).variable(!1);\n                    })\n                };\n            }\n            var a = Array.isArray(t) ? t[r].tensor : t[n];\n            if (null != a) {\n                var i = e.accumulatedGrads[r].variable;\n                Ze(function() {\n                    var t = i.add(a.square());\n                    i.assign(t);\n                    var n = a.div(t.add(Lt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(o);\n                    o.assign(n);\n                });\n            }\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        null != this.accumulatedGrads && tn(this.accumulatedGrads.map(function(t) {\n            return t.variable;\n        }));\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                switch(t.label){\n                    case 0:\n                        return [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                t.sent()\n                            ].concat(this.accumulatedGrads.map(function(t) {\n                                return {\n                                    name: t.originalName,\n                                    tensor: t.variable\n                                };\n                            }))\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        return t = e.sent(), !1, this.accumulatedGrads = t.map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            initialAccumulatorValue: this.initialAccumulatorValue\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.initialAccumulatorValue);\n    }, o.className = \"Adagrad\", o;\n}(Xd);\nHd($d);\nvar Qd = function(t) {\n    function o(e, n, r, o) {\n        void 0 === o && (o = null);\n        var a = t.call(this) || this;\n        return a.learningRate = e, a.beta1 = n, a.beta2 = r, a.epsilon = o, a.accumulatedFirstMoment = [], a.accumulatedSecondMoment = [], Ze(function() {\n            a.accBeta1 = On(n).variable(), a.accBeta2 = On(r).variable();\n        }), null == o && (a.epsilon = Lt.backend.epsilon()), a;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this, n = Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t);\n        Ze(function() {\n            var r = Oo(1, e.accBeta1), o = Oo(1, e.accBeta2);\n            n.forEach(function(n, a) {\n                var i = Lt.registeredVariables[n];\n                null == e.accumulatedFirstMoment[a] && (e.accumulatedFirstMoment[a] = {\n                    originalName: n + \"/m\",\n                    variable: Ze(function() {\n                        return Xn(i).variable(!1);\n                    })\n                }), null == e.accumulatedSecondMoment[a] && (e.accumulatedSecondMoment[a] = {\n                    originalName: n + \"/v\",\n                    variable: Ze(function() {\n                        return Xn(i).variable(!1);\n                    })\n                });\n                var s = Array.isArray(t) ? t[a].tensor : t[n];\n                if (null != s) {\n                    var u = e.accumulatedFirstMoment[a].variable, c = e.accumulatedSecondMoment[a].variable, l = u.mul(e.beta1).add(s.mul(1 - e.beta1)), h = c.mul(e.beta2).add(s.square().mul(1 - e.beta2)), f = l.div(r), d = h.div(o);\n                    u.assign(l), c.assign(h);\n                    var p = f.div(d.sqrt().add(e.epsilon)).mul(-e.learningRate).add(i);\n                    i.assign(p);\n                }\n            }), e.accBeta1.assign(e.accBeta1.mul(e.beta1)), e.accBeta2.assign(e.accBeta2.mul(e.beta2));\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function(t) {\n            return t.variable;\n        })), null != this.accumulatedSecondMoment && tn(this.accumulatedSecondMoment.map(function(t) {\n            return t.variable;\n        }));\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return t = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                e.sent()\n                            ].concat(t.map(function(t) {\n                                return {\n                                    name: t.originalName,\n                                    tensor: t.variable\n                                };\n                            }))\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e, n = this;\n            return r(this, function(r) {\n                switch(r.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        return t = r.sent(), Ze(function() {\n                            n.accBeta1.assign(No(n.beta1, n.iterations_ + 1)), n.accBeta2.assign(No(n.beta2, n.iterations_ + 1));\n                        }), e = t.length / 2, !1, this.accumulatedFirstMoment = t.slice(0, e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), this.accumulatedSecondMoment = t.slice(e, 2 * e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            beta1: this.beta1,\n            beta2: this.beta2,\n            epsilon: this.epsilon\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.beta1, e.beta2, e.epsilon);\n    }, o.className = \"Adam\", o;\n}(Xd);\nHd(Qd);\nvar Jd = function(t) {\n    function o(e, n, r, o, a) {\n        void 0 === o && (o = null), void 0 === a && (a = 0);\n        var i = t.call(this) || this;\n        return i.learningRate = e, i.beta1 = n, i.beta2 = r, i.epsilon = o, i.decay = a, i.accumulatedFirstMoment = [], i.accumulatedWeightedInfNorm = [], Ze(function() {\n            i.iteration = On(0).variable(), i.accBeta1 = On(n).variable();\n        }), null == o && (i.epsilon = Lt.backend.epsilon()), i;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this, n = Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t);\n        Ze(function() {\n            var r = Oo(1, e.accBeta1), o = Bo(-e.learningRate, e.iteration.mul(e.decay).add(1));\n            n.forEach(function(n, a) {\n                var i = Lt.registeredVariables[n];\n                null == e.accumulatedFirstMoment[a] && (e.accumulatedFirstMoment[a] = {\n                    originalName: n + \"/m\",\n                    variable: Xn(i).variable(!1)\n                }), null == e.accumulatedWeightedInfNorm[a] && (e.accumulatedWeightedInfNorm[a] = {\n                    originalName: n + \"/v\",\n                    variable: Xn(i).variable(!1)\n                });\n                var s = Array.isArray(t) ? t[a].tensor : t[n];\n                if (null != s) {\n                    var u = e.accumulatedFirstMoment[a].variable, c = e.accumulatedWeightedInfNorm[a].variable, l = u.mul(e.beta1).add(s.mul(1 - e.beta1)), h = c.mul(e.beta2), f = s.abs(), d = h.maximum(f);\n                    u.assign(l), c.assign(d);\n                    var p = o.div(r).mul(l.div(d.add(e.epsilon))).add(i);\n                    i.assign(p);\n                }\n            }), e.iteration.assign(e.iteration.add(1)), e.accBeta1.assign(e.accBeta1.mul(e.beta1));\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && tn(this.accumulatedFirstMoment.map(function(t) {\n            return t.variable;\n        })), null != this.accumulatedWeightedInfNorm && tn(this.accumulatedWeightedInfNorm.map(function(t) {\n            return t.variable;\n        }));\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                throw new Error(\"getWeights() is not implemented for Adamax yet.\");\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                throw new Error(\"setWeights() is not implemented for Adamax yet.\");\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            beta1: this.beta1,\n            beta2: this.beta2,\n            epsilon: this.epsilon,\n            decay: this.decay\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay);\n    }, o.className = \"Adamax\", o;\n}(Xd);\nHd(Jd);\nvar Zd = function(t) {\n    function o(e) {\n        var n = t.call(this) || this;\n        return n.learningRate = e, n.setLearningRate(e), n;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this;\n        (Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t)).forEach(function(n, r) {\n            var o = Array.isArray(t) ? t[r].tensor : t[n];\n            if (null != o) {\n                var a = Lt.registeredVariables[n];\n                Ze(function() {\n                    var t = e.c.mul(o).add(a);\n                    a.assign(t);\n                });\n            }\n        }), this.incrementIterations();\n    }, o.prototype.setLearningRate = function(t) {\n        this.learningRate = t, null != this.c && this.c.dispose(), this.c = en(On(-t));\n    }, o.prototype.dispose = function() {\n        this.c.dispose();\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                switch(t.label){\n                    case 0:\n                        return [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                t.sent()\n                            ]\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        if (0 !== (t = e.sent()).length) throw new Error(\"SGD optimizer does not have settable weights.\");\n                        return [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate);\n    }, o.className = \"SGD\", o;\n}(Xd);\nHd(Zd);\nvar tp = function(t) {\n    function o(e, n, r) {\n        void 0 === r && (r = !1);\n        var o = t.call(this, e) || this;\n        return o.learningRate = e, o.momentum = n, o.useNesterov = r, o.accumulations = [], o.m = On(o.momentum), o;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this;\n        (Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t)).forEach(function(n, r) {\n            var o = Lt.registeredVariables[n];\n            if (null == e.accumulations[r]) {\n                e.accumulations[r] = {\n                    originalName: n + \"/momentum\",\n                    variable: Ze(function() {\n                        return Xn(o).variable(!1);\n                    })\n                };\n            }\n            var a = e.accumulations[r].variable, i = Array.isArray(t) ? t[r].tensor : t[n];\n            null != i && Ze(function() {\n                var t, n = e.m.mul(a).add(i);\n                t = e.useNesterov ? e.c.mul(i.add(n.mul(e.m))).add(o) : e.c.mul(n).add(o), a.assign(n), o.assign(t);\n            });\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        this.m.dispose(), null != this.accumulations && tn(this.accumulations.map(function(t) {\n            return t.variable;\n        }));\n    }, o.prototype.setMomentum = function(t) {\n        this.momentum = t;\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(t) {\n                switch(t.label){\n                    case 0:\n                        return [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                t.sent()\n                            ].concat(this.accumulations.map(function(t) {\n                                return {\n                                    name: t.originalName,\n                                    tensor: t.variable\n                                };\n                            }))\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        return t = e.sent(), !1, this.accumulations = t.map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            momentum: this.momentum,\n            useNesterov: this.useNesterov\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.momentum, e.useNesterov);\n    }, o.className = \"Momentum\", o;\n}(Zd);\nHd(tp);\nvar ep = function(t) {\n    function o(e, n, r, o, a) {\n        void 0 === n && (n = .9), void 0 === r && (r = 0), void 0 === o && (o = null), void 0 === a && (a = !1);\n        var i = t.call(this) || this;\n        if (i.learningRate = e, i.decay = n, i.momentum = r, i.epsilon = o, i.accumulatedMeanSquares = [], i.accumulatedMoments = [], i.accumulatedMeanGrads = [], i.centered = a, null == o && (i.epsilon = Lt.backend.epsilon()), null == e) throw new Error(\"learningRate for RMSPropOptimizer must be defined.\");\n        return i;\n    }\n    return e(o, t), o.prototype.applyGradients = function(t) {\n        var e = this;\n        (Array.isArray(t) ? t.map(function(t) {\n            return t.name;\n        }) : Object.keys(t)).forEach(function(n, r) {\n            var o = Lt.registeredVariables[n];\n            null == e.accumulatedMeanSquares[r] && (e.accumulatedMeanSquares[r] = {\n                originalName: n + \"/rms\",\n                variable: Ze(function() {\n                    return Xn(o).variable(!1);\n                })\n            }), null == e.accumulatedMoments[r] && (e.accumulatedMoments[r] = {\n                originalName: n + \"/momentum\",\n                variable: Ze(function() {\n                    return Xn(o).variable(!1);\n                })\n            }), null == e.accumulatedMeanGrads[r] && e.centered && (e.accumulatedMeanGrads[r] = {\n                originalName: n + \"/mg\",\n                variable: Ze(function() {\n                    return Xn(o).variable(!1);\n                })\n            });\n            var a = Array.isArray(t) ? t[r].tensor : t[n];\n            if (null != a) {\n                var i = e.accumulatedMeanSquares[r].variable, s = e.accumulatedMoments[r].variable;\n                Ze(function() {\n                    var t = i.mul(e.decay).add(a.square().mul(1 - e.decay));\n                    if (e.centered) {\n                        var n = e.accumulatedMeanGrads[r].variable, u = n.mul(e.decay).add(a.mul(1 - e.decay)), c = s.mul(e.momentum).add(a.mul(e.learningRate).div(t.sub(u.square().add(e.epsilon)).sqrt()));\n                        i.assign(t), n.assign(u), s.assign(c);\n                        var l = o.sub(c);\n                        o.assign(l);\n                    } else {\n                        var h = i.mul(e.decay).add(a.square().mul(1 - e.decay));\n                        c = s.mul(e.momentum).add(a.mul(e.learningRate).div(h.add(e.epsilon).sqrt()));\n                        i.assign(h), s.assign(c);\n                        l = o.sub(c);\n                        o.assign(l);\n                    }\n                });\n            }\n        }), this.incrementIterations();\n    }, o.prototype.dispose = function() {\n        null != this.accumulatedMeanSquares && tn(this.accumulatedMeanSquares.map(function(t) {\n            return t.variable;\n        })), null != this.accumulatedMeanGrads && this.centered && tn(this.accumulatedMeanGrads.map(function(t) {\n            return t.variable;\n        })), null != this.accumulatedMoments && tn(this.accumulatedMoments.map(function(t) {\n            return t.variable;\n        }));\n    }, o.prototype.getWeights = function() {\n        return n(this, void 0, void 0, function() {\n            var t;\n            return r(this, function(e) {\n                switch(e.label){\n                    case 0:\n                        return t = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), [\n                            4,\n                            this.saveIterations()\n                        ];\n                    case 1:\n                        return [\n                            2,\n                            [\n                                e.sent()\n                            ].concat(t.map(function(t) {\n                                return {\n                                    name: t.originalName,\n                                    tensor: t.variable\n                                };\n                            }))\n                        ];\n                }\n            });\n        });\n    }, o.prototype.setWeights = function(t) {\n        return n(this, void 0, void 0, function() {\n            var e;\n            return r(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        return [\n                            4,\n                            this.extractIterations(t)\n                        ];\n                    case 1:\n                        return t = n.sent(), e = this.centered ? t.length / 3 : t.length / 2, !1, this.accumulatedMeanSquares = t.slice(0, e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), this.accumulatedMoments = t.slice(e, 2 * e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        }), this.centered && (this.accumulatedMeanGrads = t.slice(2 * e, 3 * e).map(function(t) {\n                            return {\n                                originalName: t.name,\n                                variable: t.tensor.variable(!1)\n                            };\n                        })), [\n                            2\n                        ];\n                }\n            });\n        });\n    }, o.prototype.getConfig = function() {\n        return {\n            learningRate: this.learningRate,\n            decay: this.decay,\n            momentum: this.momentum,\n            epsilon: this.epsilon,\n            centered: this.centered\n        };\n    }, o.fromConfig = function(t, e) {\n        return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered);\n    }, o.className = \"RMSProp\", o;\n}(Xd);\nHd(ep);\nvar np = function() {\n    function t() {}\n    return t.sgd = function(t) {\n        return new Zd(t);\n    }, t.momentum = function(t, e, n) {\n        return void 0 === n && (n = !1), new tp(t, e, n);\n    }, t.rmsprop = function(t, e, n, r, o) {\n        return void 0 === e && (e = .9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === o && (o = !1), new ep(t, e, n, r, o);\n    }, t.adam = function(t, e, n, r) {\n        return void 0 === t && (t = .001), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), new Qd(t, e, n, r);\n    }, t.adadelta = function(t, e, n) {\n        return void 0 === t && (t = .001), void 0 === e && (e = .95), void 0 === n && (n = null), new Yd(t, e, n);\n    }, t.adamax = function(t, e, n, r, o) {\n        return void 0 === t && (t = .002), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), void 0 === o && (o = 0), new Jd(t, e, n, r, o);\n    }, t.adagrad = function(t, e) {\n        return void 0 === e && (e = .1), new $d(t, e);\n    }, t;\n}(), rp = {\n    sgd: np.sgd,\n    momentum: np.momentum,\n    adadelta: np.adadelta,\n    adagrad: np.adagrad,\n    rmsprop: np.rmsprop,\n    adamax: np.adamax,\n    adam: np.adam\n}, op = \"undefined\" != typeof requestAnimationFrame ? requestAnimationFrame : \"undefined\" != typeof setImmediate ? setImmediate : function(t) {\n    return t();\n};\nfunction ap() {\n    return new Promise(function(t) {\n        return op(function() {\n            return t();\n        });\n    });\n}\nwt.prototype.add = function(t) {\n    return Or(this, t);\n}, wt.prototype.broadcastTo = function(t) {\n    return fc(this, t);\n}, wt.prototype.div = function(t) {\n    return Bo(this, t);\n}, wt.prototype.divNoNan = function(t) {\n    return bc(this, t);\n}, wt.prototype.squaredDifference = function(t) {\n    return Hc(this, t);\n}, wt.prototype.tile = function(t) {\n    return wc(this, t);\n}, wt.prototype.oneHot = function(t, e, n) {\n    return void 0 === e && (e = 1), void 0 === n && (n = 0), Rc(this, t, e, n);\n}, wt.prototype.transpose = function(t) {\n    return ua(this, t);\n}, wt.prototype.pad = function(t, e) {\n    return Ic(this, t, e);\n}, wt.prototype.batchNorm = function(t, e, n, r, o) {\n    return nc(this, t, e, n, r, o);\n}, xt = ff;\n //# sourceMappingURL=tf-core.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL2Rpc3QvdGYtY29yZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsSUFBSUEsSUFBRSxTQUFTQyxDQUFDLEVBQUNDLENBQUM7SUFBRSxPQUFNLENBQUNGLElBQUVHLE9BQU9DLGNBQWMsSUFBRTtRQUFDQyxXQUFVLEVBQUU7SUFBQSxjQUFZQyxTQUFPLFNBQVNOLENBQUMsRUFBQ0MsQ0FBQztRQUFFRCxFQUFFSyxTQUFTLEdBQUNKO0lBQUMsS0FBRyxTQUFTRCxDQUFDLEVBQUNDLENBQUM7UUFBRSxJQUFJLElBQUlDLEtBQUtELEVBQUVBLEVBQUVNLGNBQWMsQ0FBQ0wsTUFBS0YsQ0FBQUEsQ0FBQyxDQUFDRSxFQUFFLEdBQUNELENBQUMsQ0FBQ0MsRUFBRTtJQUFDLEdBQUdELEdBQUVDO0FBQUU7QUFBRSxTQUFTRCxFQUFFQSxDQUFDLEVBQUNDLENBQUM7SUFBRSxTQUFTTTtRQUFJLElBQUksQ0FBQ0MsV0FBVyxHQUFDUjtJQUFDO0lBQUNELEVBQUVDLEdBQUVDLElBQUdELEVBQUVTLFNBQVMsR0FBQyxTQUFPUixJQUFFQyxPQUFPUSxNQUFNLENBQUNULEtBQUlNLENBQUFBLEVBQUVFLFNBQVMsR0FBQ1IsRUFB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S0FBSyxNQUFJRCxLQUFJQSxDQUFBQSxJQUFFLElBQUcsS0FBSyxNQUFJQyxLQUFJQSxDQUFBQSxJQUFFLElBQUcwcUQsR0FBRyxJQUFJLEVBQUM1cUQsR0FBRUMsR0FBRUM7QUFBRSxHQUFFcVAsR0FBRzdPLFNBQVMsQ0FBQ3UxQixTQUFTLEdBQUMsU0FBU2oyQixDQUFDO0lBQUUsT0FBTzhpQyxHQUFHLElBQUksRUFBQzlpQztBQUFFLEdBQUV1UCxHQUFHN08sU0FBUyxDQUFDMmtDLEdBQUcsR0FBQyxTQUFTcmxDLENBQUMsRUFBQ0MsQ0FBQztJQUFFLE9BQU9nckQsR0FBRyxJQUFJLEVBQUNqckQsR0FBRUM7QUFBRSxHQUFFc1AsR0FBRzdPLFNBQVMsQ0FBQ3lSLFNBQVMsR0FBQyxTQUFTblMsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUMsRUFBQ00sQ0FBQyxFQUFDSyxDQUFDO0lBQUUsT0FBT21uRCxHQUFHLElBQUksRUFBQ2hvRCxHQUFFQyxHQUFFQyxHQUFFTSxHQUFFSztBQUFFLEdBQUV3TyxLQUFHcXhEO0FBQWsrSSxDQUNqaitoQix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWNvbW1lbnRlci8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvZGlzdC90Zi1jb3JlLmVzbS5qcz80MGMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbnZhciB0PWZ1bmN0aW9uKGUsbil7cmV0dXJuKHQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKHQsZSl7dC5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSl9KShlLG4pfTtmdW5jdGlvbiBlKGUsbil7ZnVuY3Rpb24gcigpe3RoaXMuY29uc3RydWN0b3I9ZX10KGUsbiksZS5wcm90b3R5cGU9bnVsbD09PW4/T2JqZWN0LmNyZWF0ZShuKTooci5wcm90b3R5cGU9bi5wcm90b3R5cGUsbmV3IHIpfWZ1bmN0aW9uIG4odCxlLG4scil7cmV0dXJuIG5ldyhufHwobj1Qcm9taXNlKSkoKGZ1bmN0aW9uKG8sYSl7ZnVuY3Rpb24gaSh0KXt0cnl7dShyLm5leHQodCkpfWNhdGNoKHQpe2EodCl9fWZ1bmN0aW9uIHModCl7dHJ5e3Uoci50aHJvdyh0KSl9Y2F0Y2godCl7YSh0KX19ZnVuY3Rpb24gdSh0KXt0LmRvbmU/byh0LnZhbHVlKTpuZXcgbigoZnVuY3Rpb24oZSl7ZSh0LnZhbHVlKX0pKS50aGVuKGkscyl9dSgocj1yLmFwcGx5KHQsZXx8W10pKS5uZXh0KCkpfSkpfWZ1bmN0aW9uIHIodCxlKXt2YXIgbixyLG8sYSxpPXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZigxJm9bMF0pdGhyb3cgb1sxXTtyZXR1cm4gb1sxXX0sdHJ5czpbXSxvcHM6W119O3JldHVybiBhPXtuZXh0OnMoMCksdGhyb3c6cygxKSxyZXR1cm46cygyKX0sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYoYVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxhO2Z1bmN0aW9uIHMoYSl7cmV0dXJuIGZ1bmN0aW9uKHMpe3JldHVybiBmdW5jdGlvbihhKXtpZihuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO2Zvcig7aTspdHJ5e2lmKG49MSxyJiYobz0yJmFbMF0/ci5yZXR1cm46YVswXT9yLnRocm93fHwoKG89ci5yZXR1cm4pJiZvLmNhbGwociksMCk6ci5uZXh0KSYmIShvPW8uY2FsbChyLGFbMV0pKS5kb25lKXJldHVybiBvO3N3aXRjaChyPTAsbyYmKGE9WzImYVswXSxvLnZhbHVlXSksYVswXSl7Y2FzZSAwOmNhc2UgMTpvPWE7YnJlYWs7Y2FzZSA0OnJldHVybiBpLmxhYmVsKysse3ZhbHVlOmFbMV0sZG9uZTohMX07Y2FzZSA1OmkubGFiZWwrKyxyPWFbMV0sYT1bMF07Y29udGludWU7Y2FzZSA3OmE9aS5vcHMucG9wKCksaS50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShvPShvPWkudHJ5cykubGVuZ3RoPjAmJm9bby5sZW5ndGgtMV0pJiYoNj09PWFbMF18fDI9PT1hWzBdKSl7aT0wO2NvbnRpbnVlfWlmKDM9PT1hWzBdJiYoIW98fGFbMV0+b1swXSYmYVsxXTxvWzNdKSl7aS5sYWJlbD1hWzFdO2JyZWFrfWlmKDY9PT1hWzBdJiZpLmxhYmVsPG9bMV0pe2kubGFiZWw9b1sxXSxvPWE7YnJlYWt9aWYobyYmaS5sYWJlbDxvWzJdKXtpLmxhYmVsPW9bMl0saS5vcHMucHVzaChhKTticmVha31vWzJdJiZpLm9wcy5wb3AoKSxpLnRyeXMucG9wKCk7Y29udGludWV9YT1lLmNhbGwodCxpKX1jYXRjaCh0KXthPVs2LHRdLHI9MH1maW5hbGx5e249bz0wfWlmKDUmYVswXSl0aHJvdyBhWzFdO3JldHVybnt2YWx1ZTphWzBdP2FbMV06dm9pZCAwLGRvbmU6ITB9fShbYSxzXSl9fX12YXIgbz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5nbG9iYWw9dCx0aGlzLmZsYWdzPXt9LHRoaXMuZmxhZ1JlZ2lzdHJ5PXt9LHRoaXMudXJsRmxhZ3M9e30sdGhpcy5wb3B1bGF0ZVVSTEZsYWdzKCl9cmV0dXJuIHQucHJvdG90eXBlLnNldFBsYXRmb3JtPWZ1bmN0aW9uKHQsZSl7bnVsbCE9dGhpcy5wbGF0Zm9ybSYmY29uc29sZS53YXJuKFwiUGxhdGZvcm0gXCIrdGhpcy5wbGF0Zm9ybU5hbWUrXCIgaGFzIGFscmVhZHkgYmVlbiBzZXQuIE92ZXJ3cml0aW5nIHRoZSBwbGF0Zm9ybSB3aXRoIFwiK2UrXCIuXCIpLHRoaXMucGxhdGZvcm1OYW1lPXQsdGhpcy5wbGF0Zm9ybT1lfSx0LnByb3RvdHlwZS5yZWdpc3RlckZsYWc9ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuZmxhZ1JlZ2lzdHJ5W3RdPXtldmFsdWF0aW9uRm46ZSxzZXRIb29rOm59LG51bGwhPXRoaXMudXJsRmxhZ3NbdF0pe3ZhciByPXRoaXMudXJsRmxhZ3NbdF07Y29uc29sZS53YXJuKFwiU2V0dGluZyBmZWF0dXJlIG92ZXJyaWRlIGZyb20gVVJMIFwiK3QrXCI6IFwiK3IrXCIuXCIpLHRoaXMuc2V0KHQscil9fSx0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW4gdGhpcy5mbGFncz90aGlzLmZsYWdzW3RdOih0aGlzLmZsYWdzW3RdPXRoaXMuZXZhbHVhdGVGbGFnKHQpLHRoaXMuZmxhZ3NbdF0pfSx0LnByb3RvdHlwZS5nZXROdW1iZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0KHQpfSx0LnByb3RvdHlwZS5nZXRCb29sPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldCh0KX0sdC5wcm90b3R5cGUuZ2V0RmxhZ3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mbGFnc30sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZmVhdHVyZXNcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmxhZ3N9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09dGhpcy5mbGFnUmVnaXN0cnlbdF0pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBmbGFnIFwiK3QrXCIgYXMgaXQgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXCIpO3RoaXMuZmxhZ3NbdF09ZSxudWxsIT10aGlzLmZsYWdSZWdpc3RyeVt0XS5zZXRIb29rJiZ0aGlzLmZsYWdSZWdpc3RyeVt0XS5zZXRIb29rKGUpfSx0LnByb3RvdHlwZS5ldmFsdWF0ZUZsYWc9ZnVuY3Rpb24odCl7aWYobnVsbD09dGhpcy5mbGFnUmVnaXN0cnlbdF0pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGV2YWx1YXRlIGZsYWcgJ1wiK3QrXCInOiBubyBldmFsdWF0aW9uIGZ1bmN0aW9uIGZvdW5kLlwiKTtyZXR1cm4gdGhpcy5mbGFnUmVnaXN0cnlbdF0uZXZhbHVhdGlvbkZuKCl9LHQucHJvdG90eXBlLnNldEZsYWdzPWZ1bmN0aW9uKHQpe3RoaXMuZmxhZ3M9T2JqZWN0LmFzc2lnbih7fSx0KX0sdC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmZsYWdzPXt9LHRoaXMudXJsRmxhZ3M9e30sdGhpcy5wb3B1bGF0ZVVSTEZsYWdzKCl9LHQucHJvdG90eXBlLnBvcHVsYXRlVVJMRmxhZ3M9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKHZvaWQgMCE9PXRoaXMuZ2xvYmFsJiZ2b2lkIDAhPT10aGlzLmdsb2JhbC5sb2NhdGlvbiYmdm9pZCAwIT09dGhpcy5nbG9iYWwubG9jYXRpb24uc2VhcmNoKXt2YXIgZSxuLHI9KGU9dGhpcy5nbG9iYWwubG9jYXRpb24uc2VhcmNoLG49e30sZS5yZXBsYWNlKC9bPyZdKFtePT8mXSspKD86PShbXiZdKikpPy9nLChmdW5jdGlvbih0KXtmb3IodmFyIGU9W10scj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspZVtyLTFdPWFyZ3VtZW50c1tyXTtyZXR1cm4gYShuLGVbMF0sZVsxXSksZS5qb2luKFwiPVwiKX0pKSxuKTtpZihcInRmanNmbGFnc1wiaW4gcilyLnRmanNmbGFncy5zcGxpdChcIixcIikuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49ZS5zcGxpdChcIjpcIikscj1uWzBdLG89blsxXTt0LnVybEZsYWdzW3JdPWZ1bmN0aW9uKHQsZSl7aWYoXCJ0cnVlXCI9PT0oZT1lLnRvTG93ZXJDYXNlKCkpfHxcImZhbHNlXCI9PT1lKXJldHVyblwidHJ1ZVwiPT09ZTtpZihcIlwiKyArZT09PWUpcmV0dXJuK2U7dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHBhcnNlIHZhbHVlIGZsYWcgdmFsdWUgXCIrZStcIiBmb3IgZmxhZyBcIit0K1wiLlwiKX0ocixvKX0pKX19LHR9KCk7ZnVuY3Rpb24gYSh0LGUsbil7dFtkZWNvZGVVUklDb21wb25lbnQoZSldPWRlY29kZVVSSUNvbXBvbmVudChufHxcIlwiKX1mdW5jdGlvbiBpKCl7cmV0dXJuIHN9dmFyIHM9bnVsbDt2YXIgdT1uZXcgTWFwLGM9bmV3IE1hcDtmdW5jdGlvbiBsKHQsZSl7dmFyIG49bSh0LGUpO3JldHVybiB1LmdldChuKX1mdW5jdGlvbiBoKHQpe3JldHVybiBjLmdldCh0KX1mdW5jdGlvbiBmKHQpe2Zvcih2YXIgZT11LmVudHJpZXMoKSxuPVtdOzspe3ZhciByPWUubmV4dCgpLG89ci5kb25lLGE9ci52YWx1ZTtpZihvKWJyZWFrO3ZhciBpPWFbMF0scz1hWzFdO2kuc3BsaXQoXCJfXCIpWzBdPT09dCYmbi5wdXNoKHMpfXJldHVybiBufWZ1bmN0aW9uIGQodCl7dmFyIGU9dC5rZXJuZWxOYW1lLG49dC5iYWNrZW5kTmFtZSxyPW0oZSxuKTtpZih1LmhhcyhyKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUga2VybmVsICdcIitlK1wiJyBmb3IgYmFja2VuZCAnXCIrbitcIicgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO3Uuc2V0KHIsdCl9ZnVuY3Rpb24gcCh0KXt2YXIgZT10Lmtlcm5lbE5hbWU7Yy5oYXMoZSkmJmNvbnNvbGUud2FybihcIk92ZXJyaWRpbmcgdGhlIGdyYWRpZW50IGZvciAnXCIrZStcIidcIiksYy5zZXQoZSx0KX1mdW5jdGlvbiB2KHQsZSl7dmFyIG49bSh0LGUpO2lmKCF1LmhhcyhuKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUga2VybmVsICdcIit0K1wiJyBmb3IgYmFja2VuZCAnXCIrZStcIicgaXMgbm90IHJlZ2lzdGVyZWRcIik7dS5kZWxldGUobil9ZnVuY3Rpb24gZyh0KXtpZighYy5oYXModCkpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGdyYWRpZW50ICdcIit0K1wiJyBmb3IgYmFja2VuZCBpcyBub3QgcmVnaXN0ZXJlZFwiKTtjLmRlbGV0ZSh0KX1mdW5jdGlvbiBtKHQsZSl7cmV0dXJuIGUrXCJfXCIrdH1mdW5jdGlvbiB5KHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxuPTAscj0wO2U+MDspcj1NYXRoLnJhbmRvbSgpKmV8MCxuPXRbLS1lXSx0W2VdPXRbcl0sdFtyXT1ufWZ1bmN0aW9uIHgodCxlLG4pe3JldHVybiBNYXRoLm1heCh0LE1hdGgubWluKGUsbikpfWZ1bmN0aW9uIGIodCl7cmV0dXJuIHQlMj09MD90OnQrMX1mdW5jdGlvbiB3KHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoO24rKyllKz10W25dO3JldHVybiBlfWZ1bmN0aW9uIEModCxlKXtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJzdHJpbmdcIj09dHlwZW9mIGU/ZTplKCkpfWZ1bmN0aW9uIEUodCxlLG4pe3ZvaWQgMD09PW4mJihuPVwiXCIpLEMoUyh0LGUpLChmdW5jdGlvbigpe3JldHVybiBuK1wiIFNoYXBlcyBcIit0K1wiIGFuZCBcIitlK1wiIG11c3QgbWF0Y2hcIn0pKX1mdW5jdGlvbiBSKHQpe0MobnVsbCE9dCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBpbnB1dCB0byB0aGUgdGVuc29yIGNvbnN0cnVjdG9yIG11c3QgYmUgYSBub24tbnVsbCB2YWx1ZS5cIn0pKX1mdW5jdGlvbiBJKHQsZSxuKXtpZih2b2lkIDA9PT1lJiYoZT1bXSksdm9pZCAwPT09biYmKG49ITEpLG51bGw9PWUmJihlPVtdKSxBcnJheS5pc0FycmF5KHQpfHxWKHQpJiYhbilmb3IodmFyIHI9MDtyPHQubGVuZ3RoOysrcilJKHRbcl0sZSxuKTtlbHNlIGUucHVzaCh0KTtyZXR1cm4gZX1mdW5jdGlvbiBrKHQpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gMTtmb3IodmFyIGU9dFswXSxuPTE7bjx0Lmxlbmd0aDtuKyspZSo9dFtuXTtyZXR1cm4gZX1mdW5jdGlvbiBTKHQsZSl7aWYodD09PWUpcmV0dXJuITA7aWYobnVsbD09dHx8bnVsbD09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKHRbbl0hPT1lW25dKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIEEodCl7cmV0dXJuIHQlMT09MH1mdW5jdGlvbiBUKHQpe2lmKG51bGwhPU1hdGgudGFuaClyZXR1cm4gTWF0aC50YW5oKHQpO2lmKHQ9PT0xLzApcmV0dXJuIDE7aWYodD09PS0xLzApcmV0dXJuLTE7dmFyIGU9TWF0aC5leHAoMip0KTtyZXR1cm4oZS0xKS8oZSsxKX1mdW5jdGlvbiBEKHQpe3ZhciBlPU1hdGguY2VpbChNYXRoLnNxcnQodCkpO3JldHVybltlLE1hdGguY2VpbCh0L2UpXX1mdW5jdGlvbiBOKHQsZSl7cmV0dXJuIGU8PXQubGVuZ3RoP3Q6dCtcIiBcIi5yZXBlYXQoZS10Lmxlbmd0aCl9ZnVuY3Rpb24gRih0LGUsbil7cmV0dXJuIHZvaWQgMD09PWUmJihlPWZ1bmN0aW9uKHQpe3JldHVybiAwfSksbmV3IFByb21pc2UoKGZ1bmN0aW9uKHIsbyl7dmFyIGE9MCxpPWZ1bmN0aW9uKCl7aWYodCgpKXIoKTtlbHNle2ErKzt2YXIgcz1lKGEpO251bGwhPW4mJmE+PW4/bygpOnNldFRpbWVvdXQoaSxzKX19O2koKX0pKX1mdW5jdGlvbiBfKHQsZSl7Zm9yKHZhciBuPTEscj0tMSxvPTA7bzx0Lmxlbmd0aDsrK28paWYodFtvXT49MCluKj10W29dO2Vsc2UgaWYoLTE9PT10W29dKXtpZigtMSE9PXIpdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG9ubHkgaGF2ZSAxIGltcGxpY2l0IHNpemUuIEZvdW5kIC0xIGF0IGRpbSBcIityK1wiIGFuZCBkaW0gXCIrbyk7cj1vfWVsc2UgaWYodFtvXTwwKXRocm93IEVycm9yKFwiU2hhcGVzIGNhbiBub3QgYmUgPCAwLiBGb3VuZCBcIit0W29dK1wiIGF0IGRpbSBcIitvKTtpZigtMT09PXIpe2lmKGU+MCYmZSE9PW4pdGhyb3cgRXJyb3IoXCJTaXplKFwiK2UrXCIpIG11c3QgbWF0Y2ggdGhlIHByb2R1Y3Qgb2Ygc2hhcGUgXCIrdCk7cmV0dXJuIHR9aWYoMD09PW4pdGhyb3cgRXJyb3IoXCJDYW5ub3QgaW5mZXIgdGhlIG1pc3Npbmcgc2l6ZSBpbiBbXCIrdCtcIl0gd2hlbiB0aGVyZSBhcmUgMCBlbGVtZW50c1wiKTtpZihlJW4hPTApdGhyb3cgRXJyb3IoXCJUaGUgaW1wbGljaXQgc2hhcGUgY2FuJ3QgYmUgYSBmcmFjdGlvbmFsIG51bWJlci4gR290IFwiK2UrXCIgLyBcIituKTt2YXIgYT10LnNsaWNlKCk7cmV0dXJuIGFbcl09ZS9uLGF9ZnVuY3Rpb24gTyh0LGUpe3ZhciBuPWUubGVuZ3RoO3JldHVybiBDKCh0PW51bGw9PXQ/ZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV9KSk6W10uY29uY2F0KHQpKS5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PS1uJiZ0PG59KSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbiByYW5nZSBbLVwiK24rXCIsIFwiK24rXCIpIGJ1dCBnb3QgYXhpcyBcIit0fSkpLEModC5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIEEodCl9KSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgdmFsdWVzIGluIGF4aXMgcGFyYW0gbXVzdCBiZSBpbnRlZ2VycyBidXQgZ290IGF4aXMgXCIrdH0pKSx0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD9uK3Q6dH0pKX1mdW5jdGlvbiBNKHQsZSl7Zm9yKHZhciBuPVtdLHI9W10sbz1udWxsIT1lJiZBcnJheS5pc0FycmF5KGUpJiYwPT09ZS5sZW5ndGgsYT1udWxsPT1lfHxvP251bGw6TyhlLHQpLnNvcnQoKSxpPTAscz0wO3M8dC5sZW5ndGg7KytzKXtpZihudWxsIT1hKXtpZihhW2ldPT09cyYmMSE9PXRbc10pdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3F1ZWV6ZSBheGlzIFwiK3MrXCIgc2luY2UgaXRzIGRpbSAnXCIrdFtzXStcIicgaXMgbm90IDFcIik7KG51bGw9PWFbaV18fGFbaV0+cykmJjE9PT10W3NdJiYobi5wdXNoKHRbc10pLHIucHVzaChzKSksYVtpXTw9cyYmaSsrfTEhPT10W3NdJiYobi5wdXNoKHRbc10pLHIucHVzaChzKSl9cmV0dXJue25ld1NoYXBlOm4sa2VwdERpbXM6cn19ZnVuY3Rpb24gQih0LGUpe3ZhciBuPW51bGw7aWYobnVsbD09dHx8XCJmbG9hdDMyXCI9PT10KW49bmV3IEZsb2F0MzJBcnJheShlKTtlbHNlIGlmKFwiaW50MzJcIj09PXQpbj1uZXcgSW50MzJBcnJheShlKTtlbHNle2lmKFwiYm9vbFwiIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGEgdHlwZSBcIit0KTtuPW5ldyBVaW50OEFycmF5KGUpfXJldHVybiBufWZ1bmN0aW9uIFAodCxlKXt2YXIgbj1udWxsO2lmKG51bGw9PXR8fFwiZmxvYXQzMlwiPT09dCluPW5ldyBGbG9hdDMyQXJyYXkoZSk7ZWxzZSBpZihcImludDMyXCI9PT10KW49bmV3IEludDMyQXJyYXkoZSk7ZWxzZSBpZihcImJvb2xcIj09PXQpbj1uZXcgVWludDhBcnJheShlKTtlbHNle2lmKFwic3RyaW5nXCIhPT10KXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK3QpO249bmV3IEFycmF5KGUpfXJldHVybiBufWZ1bmN0aW9uIEwodCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtpZihpc05hTihyKXx8IWlzRmluaXRlKHIpKXRocm93IEVycm9yKFwiQSB0ZW5zb3Igb2YgdHlwZSBcIitlK1wiIGJlaW5nIHVwbG9hZGVkIGNvbnRhaW5zIFwiK3IrXCIuXCIpfX1mdW5jdGlvbiBXKHQpe3JldHVyblwiYm9vbFwiPT09dHx8XCJjb21wbGV4NjRcIj09PXR8fFwiZmxvYXQzMlwiPT09dHx8XCJpbnQzMlwiPT09dHx8XCJzdHJpbmdcIj09PXR9ZnVuY3Rpb24gVSh0LGUpe3JldHVyblwiY29tcGxleDY0XCIhPT1lJiYoKFwiZmxvYXQzMlwiIT09ZXx8XCJjb21wbGV4NjRcIj09PXQpJiYoKFwiaW50MzJcIiE9PWV8fFwiZmxvYXQzMlwiPT09dHx8XCJjb21wbGV4NjRcIj09PXQpJiYoXCJib29sXCIhPT1lfHxcImJvb2xcIiE9PXQpKSl9ZnVuY3Rpb24gVih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50OEFycmF5fWZ1bmN0aW9uIHoodCl7aWYoXCJmbG9hdDMyXCI9PT10fHxcImludDMyXCI9PT10KXJldHVybiA0O2lmKFwiY29tcGxleDY0XCI9PT10KXJldHVybiA4O2lmKFwiYm9vbFwiPT09dClyZXR1cm4gMTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiK3QpfWZ1bmN0aW9uIEcodCl7aWYobnVsbD09dClyZXR1cm4gMDt2YXIgZT0wO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBlKz10Lmxlbmd0aH0pKSxlfWZ1bmN0aW9uIEgodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd9ZnVuY3Rpb24gcSh0KXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIHR9ZnVuY3Rpb24gSyh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdH1mdW5jdGlvbiBqKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpP2oodFswXSk6dCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheT9cImZsb2F0MzJcIjp0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/XCJpbnQzMlwiOksodCk/XCJmbG9hdDMyXCI6SCh0KT9cInN0cmluZ1wiOnEodCk/XCJib29sXCI6XCJmbG9hdDMyXCJ9ZnVuY3Rpb24gWCh0KXtyZXR1cm4hISh0JiZ0LmNvbnN0cnVjdG9yJiZ0LmNhbGwmJnQuYXBwbHkpfWZ1bmN0aW9uIFkodCxlKXtmb3IodmFyIG49ZTtuPHQ7KytuKWlmKHQlbj09MClyZXR1cm4gbjtyZXR1cm4gdH1mdW5jdGlvbiAkKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGU8MilyZXR1cm5bXTt2YXIgbj1uZXcgQXJyYXkoZS0xKTtuW2UtMl09dFtlLTFdO2Zvcih2YXIgcj1lLTM7cj49MDstLXIpbltyXT1uW3IrMV0qdFtyKzFdO3JldHVybiBufWZ1bmN0aW9uIFEodCxlLG4pe2lmKFwic3RyaW5nXCI9PT1lKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IGEgc3RyaW5nW10gdG8gYSBUeXBlZEFycmF5XCIpO2lmKEFycmF5LmlzQXJyYXkodCkmJih0PUkodCkpLG4mJkwodCxlKSxmdW5jdGlvbih0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5JiZcImZsb2F0MzJcIj09PWV8fHQgaW5zdGFuY2VvZiBJbnQzMkFycmF5JiZcImludDMyXCI9PT1lfHx0IGluc3RhbmNlb2YgVWludDhBcnJheSYmXCJib29sXCI9PT1lfSh0LGUpKXJldHVybiB0O2lmKG51bGw9PWV8fFwiZmxvYXQzMlwiPT09ZXx8XCJjb21wbGV4NjRcIj09PWUpcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkodCk7aWYoXCJpbnQzMlwiPT09ZSlyZXR1cm4gbmV3IEludDMyQXJyYXkodCk7aWYoXCJib29sXCI9PT1lKXtmb3IodmFyIHI9bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpLG89MDtvPHIubGVuZ3RoOysrbykwIT09TWF0aC5yb3VuZCh0W29dKSYmKHJbb109MSk7cmV0dXJuIHJ9dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrZSl9ZnVuY3Rpb24gSih0LGUpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gZVswXTt2YXIgbj10LnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpO2lmKDA9PT1uKXJldHVybltdO2lmKG4hPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJbXCIrdCtcIl0gZG9lcyBub3QgbWF0Y2ggdGhlIGlucHV0IHNpemUuXCIpO3JldHVybiBmdW5jdGlvbiB0KGUsbixyKXt2YXIgbz1uZXcgQXJyYXk7aWYoMT09PW4ubGVuZ3RoKWZvcih2YXIgYT1uWzBdLGk9MDtpPGE7aSsrKW9baV09cltlK2ldO2Vsc2V7YT1uWzBdO3ZhciBzPW4uc2xpY2UoMSksdT1zLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpO2ZvcihpPTA7aTxhO2krKylvW2ldPXQoZStpKnUscyxyKX1yZXR1cm4gb30oMCx0LGUpfWZ1bmN0aW9uIFoodCxlKXtmb3IodmFyIG49dHQodCxlKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT0xO3JldHVybiBufWZ1bmN0aW9uIHR0KHQsZSl7aWYobnVsbD09ZXx8XCJmbG9hdDMyXCI9PT1lfHxcImNvbXBsZXg2NFwiPT09ZSlyZXR1cm4gbmV3IEZsb2F0MzJBcnJheSh0KTtpZihcImludDMyXCI9PT1lKXJldHVybiBuZXcgSW50MzJBcnJheSh0KTtpZihcImJvb2xcIj09PWUpcmV0dXJuIG5ldyBVaW50OEFycmF5KHQpO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiK2UpfWZ1bmN0aW9uIGV0KCl7cmV0dXJuIGkoKS5wbGF0Zm9ybS5ub3coKX1mdW5jdGlvbiBudCh0KXt0LmZvckVhY2goKGZ1bmN0aW9uKGUpe0MoTnVtYmVyLmlzSW50ZWdlcihlKSYmZT49MCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRlbnNvciBtdXN0IGhhdmUgYSBzaGFwZSBjb21wcmlzZWQgb2YgcG9zaXRpdmUgaW50ZWdlcnMgYnV0IGdvdCBzaGFwZSBbXCIrdCtcIl0uXCJ9KSl9KSl9ZnVuY3Rpb24gcnQodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJ1dGYtOFwiKSxlPWV8fFwidXRmLThcIixpKCkucGxhdGZvcm0uZW5jb2RlKHQsZSl9ZnVuY3Rpb24gb3QodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJ1dGYtOFwiKSxlPWV8fFwidXRmLThcIixpKCkucGxhdGZvcm0uZGVjb2RlKHQsZSl9ZnVuY3Rpb24gYXQodCxlLG4pe2lmKDA9PT1lKXJldHVybiAwO2lmKDE9PT1lKXJldHVybiB0WzBdO2Zvcih2YXIgcj10W3QubGVuZ3RoLTFdLG89MDtvPHQubGVuZ3RoLTE7KytvKXIrPW5bb10qdFtvXTtyZXR1cm4gcn1mdW5jdGlvbiBpdCh0LGUsbil7aWYoMD09PWUpcmV0dXJuW107aWYoMT09PWUpcmV0dXJuW3RdO2Zvcih2YXIgcj1uZXcgQXJyYXkoZSksbz0wO288ci5sZW5ndGgtMTsrK28pcltvXT1NYXRoLmZsb29yKHQvbltvXSksdC09cltvXSpuW29dO3JldHVybiByW3IubGVuZ3RoLTFdPXQscn12YXIgc3Q9T2JqZWN0LmZyZWV6ZSh7c2h1ZmZsZTp5LGNsYW1wOngsbmVhcmVzdExhcmdlckV2ZW46YixzdW06dyxyYW5kVW5pZm9ybTpmdW5jdGlvbih0LGUpe3ZhciBuPU1hdGgucmFuZG9tKCk7cmV0dXJuIGUqbisoMS1uKSp0fSxkaXN0U3F1YXJlZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wLHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG89TnVtYmVyKHRbcl0pLU51bWJlcihlW3JdKTtuKz1vKm99cmV0dXJuIG59LGFzc2VydDpDLGFzc2VydFNoYXBlc01hdGNoOkUsYXNzZXJ0Tm9uTnVsbDpSLGZsYXR0ZW46SSxzaXplRnJvbVNoYXBlOmssaXNTY2FsYXJTaGFwZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQubGVuZ3RofSxhcnJheXNFcXVhbDpTLGlzSW50OkEsdGFuaDpULHNpemVUb1NxdWFyaXNoU2hhcGU6RCxjcmVhdGVTaHVmZmxlZEluZGljZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBVaW50MzJBcnJheSh0KSxuPTA7bjx0OysrbillW25dPW47cmV0dXJuIHkoZSksZX0scmlnaHRQYWQ6TixyZXBlYXRlZFRyeTpGLGluZmVyRnJvbUltcGxpY2l0U2hhcGU6XyxwYXJzZUF4aXNQYXJhbTpPLHNxdWVlemVTaGFwZTpNLGdldFR5cGVkQXJyYXlGcm9tRFR5cGU6QixnZXRBcnJheUZyb21EVHlwZTpQLGNoZWNrQ29udmVyc2lvbkZvckVycm9yczpMLGlzVmFsaWREdHlwZTpXLGhhc0VuY29kaW5nTG9zczpVLGlzVHlwZWRBcnJheTpWLGJ5dGVzUGVyRWxlbWVudDp6LGJ5dGVzRnJvbVN0cmluZ0FycmF5OkcsaXNTdHJpbmc6SCxpc0Jvb2xlYW46cSxpc051bWJlcjpLLGluZmVyRHR5cGU6aixpc0Z1bmN0aW9uOlgsbmVhcmVzdERpdmlzb3I6WSxjb21wdXRlU3RyaWRlczokLHRvVHlwZWRBcnJheTpRLHRvTmVzdGVkQXJyYXk6SixtYWtlT25lc1R5cGVkQXJyYXk6WixtYWtlWmVyb3NUeXBlZEFycmF5OnR0LG5vdzpldCxhc3NlcnROb25OZWdhdGl2ZUludGVnZXJEaW1lbnNpb25zOm50LGZldGNoOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGkoKS5wbGF0Zm9ybS5mZXRjaCh0LGUpfSxlbmNvZGVTdHJpbmc6cnQsZGVjb2RlU3RyaW5nOm90LGxvY1RvSW5kZXg6YXQsaW5kZXhUb0xvYzppdH0pLHV0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMuYmFja2VuZFRpbWVyPXQsdGhpcy5sb2dnZXI9ZSxudWxsPT1lJiYodGhpcy5sb2dnZXI9bmV3IGN0KX1yZXR1cm4gdC5wcm90b3R5cGUucHJvZmlsZUtlcm5lbD1mdW5jdGlvbih0LGUsbil7dmFyIHIsbz10aGlzLGE9dGhpcy5iYWNrZW5kVGltZXIudGltZSgoZnVuY3Rpb24oKXtyPW4oKX0pKTtyZXR1cm4gci5mb3JFYWNoKChmdW5jdGlvbihuKXtuLmRhdGEoKS50aGVuKChmdW5jdGlvbihyKXshZnVuY3Rpb24odCxlLG4pe2lmKFwiZmxvYXQzMlwiIT09ZSlyZXR1cm4hMTtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG89dFtyXTtpZihpc05hTihvKXx8IWlzRmluaXRlKG8pKXJldHVybiBjb25zb2xlLndhcm4oXCJGb3VuZCBcIitvK1wiIGluIHRoZSByZXN1bHQgb2YgJ1wiK24rXCInXCIpLCEwfX0ocixuLmR0eXBlLHQpLGEudGhlbigoZnVuY3Rpb24oYSl7dmFyIGk9XCJcIjtudWxsIT1hLmdldEV4dHJhUHJvZmlsZUluZm8mJihpPWEuZ2V0RXh0cmFQcm9maWxlSW5mbygpKSxvLmxvZ2dlci5sb2dLZXJuZWxQcm9maWxlKHQsbixyLGEua2VybmVsTXMsZSxpKX0pKX0pKX0pKSxyfSx0fSgpO3ZhciBjdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmxvZ0tlcm5lbFByb2ZpbGU9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPVwibnVtYmVyXCI9PXR5cGVvZiByP04ocitcIm1zXCIsOSk6ci5lcnJvcixzPU4odCwyNSksdT1lLnJhbmssYz1lLnNpemUsbD1OKGUuc2hhcGUudG9TdHJpbmcoKSwxNCksaD1cIlwiO2Zvcih2YXIgZiBpbiBvKXt2YXIgZD1vW2ZdLnNoYXBlfHxlLnNoYXBlLHA9ZC5sZW5ndGg7aCs9ZitcIjogXCIrcCtcIkQgXCIrKHA+MD9kOlwiXCIpK1wiIFwifWNvbnNvbGUubG9nKFwiJWNcIitzK1wiXFx0JWNcIitpK1wiXFx0JWNcIit1K1wiRCBcIitsK1wiXFx0JWNcIitjK1wiXFx0JWNcIitoK1wiXFx0JWNcIithLFwiZm9udC13ZWlnaHQ6Ym9sZFwiLFwiY29sb3I6cmVkXCIsXCJjb2xvcjpibHVlXCIsXCJjb2xvcjogb3JhbmdlXCIsXCJjb2xvcjogZ3JlZW5cIixcImNvbG9yOiBzdGVlbGJsdWVcIil9LHR9KCk7dmFyIGx0PTIwLGh0PTMsZnQ9NztmdW5jdGlvbiBkdCh0LGUsbixyKXt2YXIgbz0kKGUpLGE9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89ayhlKSxhPXJbci5sZW5ndGgtMV0saT1uZXcgQXJyYXkoYSkuZmlsbCgwKSxzPWUubGVuZ3RoLHU9XCJjb21wbGV4NjRcIj09PW4/Z3QodCk6dDtpZihzPjEpZm9yKHZhciBjPTA7YzxvL2E7YysrKWZvcih2YXIgbD1jKmEsaD0wO2g8YTtoKyspaVtoXT1NYXRoLm1heChpW2hdLHB0KHVbbCtoXSwwLG4pLmxlbmd0aCk7cmV0dXJuIGl9KHQsZSxuLG8pLGk9ZS5sZW5ndGgscz1mdW5jdGlvbiB0KGUsbixyLG8sYSxpKXt2b2lkIDA9PT1pJiYoaT0hMCk7dmFyIHM9XCJjb21wbGV4NjRcIj09PXI/MjoxLHU9blswXSxjPW4ubGVuZ3RoO2lmKDA9PT1jKXtyZXR1cm5cImNvbXBsZXg2NFwiPT09cj9bcHQoZ3QoZSlbMF0sMCxyKV06XCJib29sXCI9PT1yP1t2dChlWzBdKV06W2VbMF0udG9TdHJpbmcoKV19aWYoMT09PWMpe2lmKHU+bHQpe3ZhciBsPWh0KnMsaD1BcnJheS5mcm9tKGUuc2xpY2UoMCxsKSksZj1BcnJheS5mcm9tKGUuc2xpY2UoKHUtaHQpKnMsdSpzKSk7cmV0dXJuXCJjb21wbGV4NjRcIj09PXImJihoPWd0KGgpLGY9Z3QoZikpLFtcIltcIitoLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcHQodCxhW2VdLHIpfSkpLmpvaW4oXCIsIFwiKStcIiwgLi4uLCBcIitmLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcHQodCxhW3UtaHQrZV0scil9KSkuam9pbihcIiwgXCIpK1wiXVwiXX1yZXR1cm5bXCJbXCIrKFwiY29tcGxleDY0XCI9PT1yP2d0KGUpOkFycmF5LmZyb20oZSkpLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcHQodCxhW2VdLHIpfSkpLmpvaW4oXCIsIFwiKStcIl1cIl19dmFyIGQ9bi5zbGljZSgxKSxwPW8uc2xpY2UoMSksdj1vWzBdKnMsZz1bXTtpZih1Pmx0KXtmb3IodmFyIG09MDttPGh0O20rKyl7dmFyIHk9KHg9bSp2KSt2O2cucHVzaC5hcHBseShnLHQoZS5zbGljZSh4LHkpLGQscixwLGEsITEpKX1nLnB1c2goXCIuLi5cIik7Zm9yKG09dS1odDttPHU7bSsrKXt5PSh4PW0qdikrdjtnLnB1c2guYXBwbHkoZyx0KGUuc2xpY2UoeCx5KSxkLHIscCxhLG09PT11LTEpKX19ZWxzZSBmb3IobT0wO208dTttKyspe3ZhciB4O3k9KHg9bSp2KSt2O2cucHVzaC5hcHBseShnLHQoZS5zbGljZSh4LHkpLGQscixwLGEsbT09PXUtMSkpfXZhciBiPTI9PT1jP1wiLFwiOlwiXCI7Z1swXT1cIltcIitnWzBdK2I7Zm9yKG09MTttPGcubGVuZ3RoLTE7bSsrKWdbbV09XCIgXCIrZ1ttXStiO3ZhciB3PVwiLFxcblwiO2ZvcihtPTI7bTxjO20rKyl3Kz1cIlxcblwiO3JldHVybiBnW2cubGVuZ3RoLTFdPVwiIFwiK2dbZy5sZW5ndGgtMV0rXCJdXCIrKGk/XCJcIjp3KSxnfSh0LGUsbixvLGEpLHU9W1wiVGVuc29yXCJdO3JldHVybiByJiYodS5wdXNoKFwiICBkdHlwZTogXCIrbiksdS5wdXNoKFwiICByYW5rOiBcIitpKSx1LnB1c2goXCIgIHNoYXBlOiBbXCIrZStcIl1cIiksdS5wdXNoKFwiICB2YWx1ZXM6XCIpKSx1LnB1c2gocy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwiICAgIFwiK3R9KSkuam9pbihcIlxcblwiKSksdS5qb2luKFwiXFxuXCIpfWZ1bmN0aW9uIHB0KHQsZSxuKXtyZXR1cm4gTihBcnJheS5pc0FycmF5KHQpP3BhcnNlRmxvYXQodFswXS50b0ZpeGVkKGZ0KSkrXCIgKyBcIitwYXJzZUZsb2F0KHRbMV0udG9GaXhlZChmdCkpK1wialwiOkgodCk/XCInXCIrdCtcIidcIjpcImJvb2xcIj09PW4/dnQodCk6cGFyc2VGbG9hdCh0LnRvRml4ZWQoZnQpKS50b1N0cmluZygpLGUpfWZ1bmN0aW9uIHZ0KHQpe3JldHVybiAwPT09dD9cImZhbHNlXCI6XCJ0cnVlXCJ9ZnVuY3Rpb24gZ3QodCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoO24rPTIpZS5wdXNoKFt0W25dLHRbbisxXV0pO3JldHVybiBlfXZhciBtdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4pe3ZhciByPXRoaXM7aWYodGhpcy5kdHlwZT1lLHRoaXMuc2hhcGU9dC5zbGljZSgpLHRoaXMuc2l6ZT1rKHQpLG51bGwhPW4pe3ZhciBvPW4ubGVuZ3RoO0Mobz09PXRoaXMuc2l6ZSwoZnVuY3Rpb24oKXtyZXR1cm5cIkxlbmd0aCBvZiB2YWx1ZXMgJ1wiK28rXCInIGRvZXMgbm90IG1hdGNoIHRoZSBzaXplIGluZmVycmVkIGJ5IHRoZSBzaGFwZSAnXCIrci5zaXplK1wiJy5cIn0pKX1pZihcImNvbXBsZXg2NFwiPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJjb21wbGV4NjQgZHR5cGUgVGVuc29yQnVmZmVycyBhcmUgbm90IHN1cHBvcnRlZC4gUGxlYXNlIGNyZWF0ZSBhIFRlbnNvckJ1ZmZlciBmb3IgdGhlIHJlYWwgYW5kIGltYWdpbmFyeSBwYXJ0cyBzZXBhcmF0ZWx5IGFuZCBjYWxsIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO3RoaXMudmFsdWVzPW58fFAoZSx0aGlzLnNpemUpLHRoaXMuc3RyaWRlcz0kKHQpfXJldHVybiB0LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMsbj1bXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyluW3ItMV09YXJndW1lbnRzW3JdOzA9PT1uLmxlbmd0aCYmKG49WzBdKSxDKG4ubGVuZ3RoPT09dGhpcy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiVGhlIG51bWJlciBvZiBwcm92aWRlZCBjb29yZGluYXRlcyAoXCIrbi5sZW5ndGgrXCIpIG11c3QgbWF0Y2ggdGhlIHJhbmsgKFwiK2UucmFuaytcIilcIn0pKTt2YXIgbz10aGlzLmxvY1RvSW5kZXgobik7dGhpcy52YWx1ZXNbb109dH0sdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdOzA9PT10Lmxlbmd0aCYmKHQ9WzBdKTtmb3IodmFyIG49MCxyPTAsbz10O3I8by5sZW5ndGg7cisrKXt2YXIgYT1vW3JdO2lmKGE8MHx8YT49dGhpcy5zaGFwZVtuXSl7dmFyIGk9XCJSZXF1ZXN0ZWQgb3V0IG9mIHJhbmdlIGVsZW1lbnQgYXQgXCIrdCtcIi4gICBCdWZmZXIgc2hhcGU9XCIrdGhpcy5zaGFwZTt0aHJvdyBuZXcgRXJyb3IoaSl9bisrfWZvcih2YXIgcz10W3QubGVuZ3RoLTFdLHU9MDt1PHQubGVuZ3RoLTE7Kyt1KXMrPXRoaXMuc3RyaWRlc1t1XSp0W3VdO3JldHVybiB0aGlzLnZhbHVlc1tzXX0sdC5wcm90b3R5cGUubG9jVG9JbmRleD1mdW5jdGlvbih0KXtpZigwPT09dGhpcy5yYW5rKXJldHVybiAwO2lmKDE9PT10aGlzLnJhbmspcmV0dXJuIHRbMF07Zm9yKHZhciBlPXRbdC5sZW5ndGgtMV0sbj0wO248dC5sZW5ndGgtMTsrK24pZSs9dGhpcy5zdHJpZGVzW25dKnRbbl07cmV0dXJuIGV9LHQucHJvdG90eXBlLmluZGV4VG9Mb2M9ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMucmFuaylyZXR1cm5bXTtpZigxPT09dGhpcy5yYW5rKXJldHVyblt0XTtmb3IodmFyIGU9bmV3IEFycmF5KHRoaXMuc2hhcGUubGVuZ3RoKSxuPTA7bjxlLmxlbmd0aC0xOysrbillW25dPU1hdGguZmxvb3IodC90aGlzLnN0cmlkZXNbbl0pLHQtPWVbbl0qdGhpcy5zdHJpZGVzW25dO3JldHVybiBlW2UubGVuZ3RoLTFdPXQsZX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmFua1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUudG9UZW5zb3I9ZnVuY3Rpb24oKXtyZXR1cm4geXQoKS5tYWtlVGVuc29yKHRoaXMudmFsdWVzLHRoaXMuc2hhcGUsdGhpcy5kdHlwZSl9LHR9KCkseXQ9bnVsbCx4dD1udWxsLGJ0PW51bGw7dmFyIHd0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbixyKXt0aGlzLmtlcHQ9ITEsdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWw9ITEsdGhpcy5zaGFwZT10LnNsaWNlKCksdGhpcy5kdHlwZT1lfHxcImZsb2F0MzJcIix0aGlzLnNpemU9ayh0KSx0aGlzLnN0cmlkZXM9JCh0KSx0aGlzLmRhdGFJZD1uLHRoaXMuaWQ9cix0aGlzLnJhbmtUeXBlPXRoaXMucmFuazw1P3RoaXMucmFuay50b1N0cmluZygpOlwiaGlnaGVyXCJ9cmV0dXJuIHQucHJvdG90eXBlLmZsYXR0ZW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLmFzMUQoKX0sdC5wcm90b3R5cGUuYXNTY2FsYXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxDKDE9PT10aGlzLnNpemUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJyYXkgbXVzdCBoYXZlIG9ubHkgMSBlbGVtZW50LlwifSkpLHRoaXMucmVzaGFwZShbXSl9LHQucHJvdG90eXBlLmFzMUQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnJlc2hhcGUoW3RoaXMuc2l6ZV0pfSx0LnByb3RvdHlwZS5hczJEPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0LGVdKX0sdC5wcm90b3R5cGUuYXMzRD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0LGUsbl0pfSx0LnByb3RvdHlwZS5hczREPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZShbdCxlLG4scl0pfSx0LnByb3RvdHlwZS5hczVEPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5yZXNoYXBlKFt0LGUsbixyLG9dKX0sdC5wcm90b3R5cGUuYXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNhc3QodGhpcyx0KX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwicmFua1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGFwZS5sZW5ndGh9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuYnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gdD1lLnNlbnQoKSxbMix4dC5idWZmZXIodGhpcy5zaGFwZSx0aGlzLmR0eXBlLHQpXX19KSl9KSl9LHQucHJvdG90eXBlLmJ1ZmZlclN5bmM9ZnVuY3Rpb24oKXtyZXR1cm4geHQuYnVmZmVyKHRoaXMuc2hhcGUsdGhpcy5kdHlwZSx0aGlzLmRhdGFTeW5jKCkpfSx0LnByb3RvdHlwZS5hcnJheT1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZGF0YSgpXTtjYXNlIDE6cmV0dXJuIHQ9ZS5zZW50KCksWzIsSih0aGlzLnNoYXBlLHQpXX19KSl9KSl9LHQucHJvdG90eXBlLmFycmF5U3luYz1mdW5jdGlvbigpe3JldHVybiBKKHRoaXMuc2hhcGUsdGhpcy5kYXRhU3luYygpKX0sdC5wcm90b3R5cGUuZGF0YT1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdD15dCgpLnJlYWQodGhpcy5kYXRhSWQpLFwic3RyaW5nXCIhPT10aGlzLmR0eXBlP1szLDJdOls0LHRdO2Nhc2UgMTplPW4uc2VudCgpO3RyeXtyZXR1cm5bMixlLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIG90KHQpfSkpXX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjb2RlIHRoZSBzdHJpbmcgYnl0ZXMgaW50byB1dGYtOC4gVG8gZ2V0IHRoZSBvcmlnaW5hbCBieXRlcywgY2FsbCB0ZW5zb3IuYnl0ZXMoKS5cIil9bi5sYWJlbD0yO2Nhc2UgMjpyZXR1cm5bMix0XX19KSl9KSl9LHQucHJvdG90eXBlLmRhdGFTeW5jPWZ1bmN0aW9uKCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgdD15dCgpLnJlYWRTeW5jKHRoaXMuZGF0YUlkKTtpZihcInN0cmluZ1wiPT09dGhpcy5kdHlwZSl0cnl7cmV0dXJuIHQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gb3QodCl9KSl9Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY29kZSB0aGUgc3RyaW5nIGJ5dGVzIGludG8gdXRmLTguIFRvIGdldCB0aGUgb3JpZ2luYWwgYnl0ZXMsIGNhbGwgdGVuc29yLmJ5dGVzKCkuXCIpfXJldHVybiB0fSx0LnByb3RvdHlwZS5ieXRlcz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLFs0LHl0KCkucmVhZCh0aGlzLmRhdGFJZCldO2Nhc2UgMTpyZXR1cm4gdD1lLnNlbnQoKSxcInN0cmluZ1wiPT09dGhpcy5kdHlwZT9bMix0XTpbMixuZXcgVWludDhBcnJheSh0LmJ1ZmZlcildfX0pKX0pKX0sdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3RoaXMuaXNEaXNwb3NlZHx8KHl0KCkuZGlzcG9zZVRlbnNvcih0aGlzKSx0aGlzLmlzRGlzcG9zZWRJbnRlcm5hbD0hMCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImlzRGlzcG9zZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNEaXNwb3NlZEludGVybmFsfSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLnRocm93SWZEaXNwb3NlZD1mdW5jdGlvbigpe2lmKHRoaXMuaXNEaXNwb3NlZCl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgaXMgZGlzcG9zZWQuXCIpfSx0LnByb3RvdHlwZS50b0Zsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNUeXBlKFwiZmxvYXQzMlwiKX0sdC5wcm90b3R5cGUudG9JbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hc1R5cGUoXCJpbnQzMlwiKX0sdC5wcm90b3R5cGUudG9Cb29sPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXNUeXBlKFwiYm9vbFwiKX0sdC5wcm90b3R5cGUucHJpbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSx4dC5wcmludCh0aGlzLHQpfSx0LnByb3RvdHlwZS5yZXNoYXBlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnJlc2hhcGUodGhpcyx0KX0sdC5wcm90b3R5cGUucmVzaGFwZUFzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMucmVzaGFwZSh0LnNoYXBlKX0sdC5wcm90b3R5cGUuZXhwYW5kRGltcz1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MCkseHQuZXhwYW5kRGltcyh0aGlzLHQpfSx0LnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09biYmKG49ITEpLHh0LmN1bXN1bSh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUuc3F1ZWV6ZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcXVlZXplKHRoaXMsdCl9LHQucHJvdG90eXBlLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY2xvbmUodGhpcyl9LHQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMSksZHQodGhpcy5kYXRhU3luYygpLHRoaXMuc2hhcGUsdGhpcy5kdHlwZSx0KX0sdC5wcm90b3R5cGUuZ2F0aGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZ2F0aGVyKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubWF0TXVsPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHZvaWQgMD09PW4mJihuPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1hdE11bCh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUuZG90PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmRvdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ub3JtPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9XCJldWNsaWRlYW5cIiksdm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubm9ybSh0aGlzLHQsZSxuKX0sdC5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zbGljZSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucmV2ZXJzZSh0aGlzLHQpfSx0LnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxlIGluc3RhbmNlb2YgdCYmKGU9W2VdKSx4dC5jb25jYXQoW3RoaXNdLmNvbmNhdChlKSxuKX0sdC5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9MCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcGxpdCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnN0YWNrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTApLHh0LnN0YWNrKFt0aGlzLHRdLGUpfSx0LnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx4dC51bnN0YWNrKHRoaXMsdCl9LHQucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB2b2lkIDA9PT1uJiYobj0uMDAxKSxidChcInRmLmJhdGNoTm9ybWFsaXphdGlvbigpIGlzIGdvaW5nIGF3YXkuIFVzZSB0Zi5iYXRjaE5vcm0oKSBpbnN0ZWFkLCBhbmQgbm90ZSB0aGUgcG9zaXRpb25hbCBhcmd1bWVudCBjaGFuZ2Ugb2Ygc2NhbGUsIG9mZnNldCwgYW5kIHZhcmlhbmNlRXBzaWxvblwiKSx0aGlzLmJhdGNoTm9ybSh0LGUsbyxyLG4pfSx0LnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYWxsKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFueSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmxvZ1N1bUV4cD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2dTdW1FeHAodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5zdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdm9pZCAwPT09ZSYmKGU9ITEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3VtKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUucHJvZD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5wcm9kKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubWVhbj1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tZWFuKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUubWluPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1pbih0aGlzLHQsZSl9LHQucHJvdG90eXBlLm1heD1mdW5jdGlvbih0LGUpe3JldHVybiB2b2lkIDA9PT10JiYodD1udWxsKSx2b2lkIDA9PT1lJiYoZT0hMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tYXgodGhpcyx0LGUpfSx0LnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PW51bGwpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYXJnTWluKHRoaXMsdCl9LHQucHJvdG90eXBlLmFyZ01heD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9bnVsbCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hcmdNYXgodGhpcyx0KX0sdC5wcm90b3R5cGUuY2FzdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jYXN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmFkZFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hZGRTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuYXRhbjI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYXRhbjIodGhpcyx0KX0sdC5wcm90b3R5cGUuc3ViPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnN1Yih0aGlzLHQpfSx0LnByb3RvdHlwZS5zdWJTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc3ViU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLnBvdz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5wb3codGhpcyx0KX0sdC5wcm90b3R5cGUucG93U3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnBvd1N0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tdWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubXVsKHRoaXMsdCl9LHQucHJvdG90eXBlLm11bFN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tdWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZmxvb3JEaXYodGhpcyx0KX0sdC5wcm90b3R5cGUuZGl2U3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmRpdlN0cmljdCh0aGlzLHQpfSx0LnByb3RvdHlwZS5taW5pbXVtPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1pbmltdW0odGhpcyx0KX0sdC5wcm90b3R5cGUubWluaW11bVN0cmljdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5taW5pbXVtU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubWF4aW11bSh0aGlzLHQpfSx0LnByb3RvdHlwZS5tYXhpbXVtU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1heGltdW1TdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm1vZCh0aGlzLHQpfSx0LnByb3RvdHlwZS5tb2RTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubW9kU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNxdWFyZWREaWZmZXJlbmNlU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLm5vdEVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm5vdEVxdWFsKHRoaXMsdCl9LHQucHJvdG90eXBlLm5vdEVxdWFsU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm5vdEVxdWFsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmxlc3M9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubGVzcyh0aGlzLHQpfSx0LnByb3RvdHlwZS5sZXNzU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lmxlc3NTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZXF1YWwodGhpcyx0KX0sdC5wcm90b3R5cGUuZXF1YWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZXF1YWxTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lmxlc3NFcXVhbCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sZXNzRXF1YWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubGVzc0VxdWFsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmdyZWF0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZ3JlYXRlcih0aGlzLHQpfSx0LnByb3RvdHlwZS5ncmVhdGVyU3RyaWN0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmdyZWF0ZXJTdHJpY3QodGhpcyx0KX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmdyZWF0ZXJFcXVhbCh0aGlzLHQpfSx0LnByb3RvdHlwZS5ncmVhdGVyRXF1YWxTdHJpY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZ3JlYXRlckVxdWFsU3RyaWN0KHRoaXMsdCl9LHQucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubG9naWNhbEFuZCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sb2dpY2FsT3I9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQubG9naWNhbE9yKHRoaXMsdCl9LHQucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2dpY2FsTm90KHRoaXMpfSx0LnByb3RvdHlwZS5sb2dpY2FsWG9yPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZ2ljYWxYb3IodGhpcyx0KX0sdC5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC53aGVyZSh0LHRoaXMsZSl9LHQucHJvdG90eXBlLm5lZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lm5lZyh0aGlzKX0sdC5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmNlaWwodGhpcyl9LHQucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZmxvb3IodGhpcyl9LHQucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zaWduKHRoaXMpfSx0LnByb3RvdHlwZS5pc05hTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmlzTmFOKHRoaXMpfSx0LnByb3RvdHlwZS5pc0luZj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmlzSW5mKHRoaXMpfSx0LnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmlzRmluaXRlKHRoaXMpfSx0LnByb3RvdHlwZS5leHA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5leHAodGhpcyl9LHQucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZXhwbTEodGhpcyl9LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZyh0aGlzKX0sdC5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2cxcCh0aGlzKX0sdC5wcm90b3R5cGUuc3FydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNxcnQodGhpcyl9LHQucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQucnNxcnQodGhpcyl9LHQucHJvdG90eXBlLnNxdWFyZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNxdWFyZSh0aGlzKX0sdC5wcm90b3R5cGUucmVjaXByb2NhbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnJlY2lwcm9jYWwodGhpcyl9LHQucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFicyh0aGlzKX0sdC5wcm90b3R5cGUuY2xpcEJ5VmFsdWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jbGlwQnlWYWx1ZSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5yZWx1KHRoaXMpfSx0LnByb3RvdHlwZS5yZWx1Nj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnJlbHU2KHRoaXMpfSx0LnByb3RvdHlwZS5lbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5lbHUodGhpcyl9LHQucHJvdG90eXBlLnNlbHU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zZWx1KHRoaXMpfSx0LnByb3RvdHlwZS5sZWFreVJlbHU9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS4yKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxlYWt5UmVsdSh0aGlzLHQpfSx0LnByb3RvdHlwZS5wcmVsdT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5wcmVsdSh0aGlzLHQpfSx0LnByb3RvdHlwZS5zaWdtb2lkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc2lnbW9pZCh0aGlzKX0sdC5wcm90b3R5cGUubG9nU2lnbW9pZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmxvZ1NpZ21vaWQodGhpcyl9LHQucHJvdG90eXBlLnNvZnRwbHVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc29mdHBsdXModGhpcyl9LHQucHJvdG90eXBlLnplcm9zTGlrZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0Lnplcm9zTGlrZSh0aGlzKX0sdC5wcm90b3R5cGUub25lc0xpa2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5vbmVzTGlrZSh0aGlzKX0sdC5wcm90b3R5cGUuc2luPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc2luKHRoaXMpfSx0LnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jb3ModGhpcyl9LHQucHJvdG90eXBlLnRhbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnRhbih0aGlzKX0sdC5wcm90b3R5cGUuYXNpbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmFzaW4odGhpcyl9LHQucHJvdG90eXBlLmFjb3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hY29zKHRoaXMpfSx0LnByb3RvdHlwZS5hdGFuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuYXRhbih0aGlzKX0sdC5wcm90b3R5cGUuc2luaD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNpbmgodGhpcyl9LHQucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jb3NoKHRoaXMpfSx0LnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQudGFuaCh0aGlzKX0sdC5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hc2luaCh0aGlzKX0sdC5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hY29zaCh0aGlzKX0sdC5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5hdGFuaCh0aGlzKX0sdC5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZXJmKHRoaXMpfSx0LnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnJvdW5kKHRoaXMpfSx0LnByb3RvdHlwZS5zdGVwPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnN0ZXAodGhpcyx0KX0sdC5wcm90b3R5cGUuc29mdG1heD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9LTEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc29mdG1heCh0aGlzLHQpfSx0LnByb3RvdHlwZS5sb2dTb2Z0bWF4PWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0tMSksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5sb2dTb2Z0bWF4KHRoaXMsdCl9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmltYWdlLnJlc2l6ZUJpbGluZWFyKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPSExKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmltYWdlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcih0aGlzLHQsZSl9LHQucHJvdG90eXBlLmNvbnYxZD1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIHZvaWQgMD09PXImJihyPVwiTldDXCIpLHZvaWQgMD09PW8mJihvPTEpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY29udjFkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj1cIk5IV0NcIiksdm9pZCAwPT09byYmKG89WzEsMV0pLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuY29udjJkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5jb252MmRUcmFuc3Bvc2U9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5jb252MmRUcmFuc3Bvc2UodGhpcyx0LGUsbixyLG8pfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj1cIk5IV0NcIiksdm9pZCAwPT09byYmKG89WzEsMV0pLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuZGVwdGh3aXNlQ29udjJkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5zZXBhcmFibGVDb252MmQ9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1vJiYobz1bMSwxXSksdm9pZCAwPT09YSYmKGE9XCJOSFdDXCIpLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQuc2VwYXJhYmxlQ29udjJkKHRoaXMsdCxlLG4scixvLGEpfSx0LnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmF2Z1Bvb2wodGhpcyx0LGUsbixyKX0sdC5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5tYXhQb29sKHRoaXMsdCxlLG4scil9LHQucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB2b2lkIDA9PT10JiYodD01KSx2b2lkIDA9PT1lJiYoZT0xKSx2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj0uNSkseHQubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24odGhpcyx0LGUsbixyKX0sdC5wcm90b3R5cGUucG9vbD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnBvb2wodGhpcyx0LGUsbixyLG8pfSx0LnByb3RvdHlwZS52YXJpYWJsZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PXQmJih0PSEwKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHl0KCkubWFrZVZhcmlhYmxlKHRoaXMsdCxlLG4pfSx0LnByb3RvdHlwZS51bnNvcnRlZFNlZ21lbnRTdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC51bnNvcnRlZFNlZ21lbnRTdW0odGhpcyx0LGUpfSx0LnByb3RvdHlwZS5iYXRjaFRvU3BhY2VORD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmJhdGNoVG9TcGFjZU5EKHRoaXMsdCxlKX0sdC5wcm90b3R5cGUuc3BhY2VUb0JhdGNoTkQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcGFjZVRvQmF0Y2hORCh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9MSksdm9pZCAwPT09ZSYmKGU9ITApLHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkseHQudG9wayh0aGlzLHQsZSl9LHQucHJvdG90eXBlLnN0cmlkZWRTbGljZT1mdW5jdGlvbih0LGUsbixyLG8sYSxpLHMpe3JldHVybiB2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz0wKSx2b2lkIDA9PT1hJiYoYT0wKSx2b2lkIDA9PT1pJiYoaT0wKSx2b2lkIDA9PT1zJiYocz0wKSx0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnN0cmlkZWRTbGljZSh0aGlzLHQsZSxuLHIsbyxhLGkscyl9LHQucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LmRlcHRoVG9TcGFjZSh0aGlzLHQsZSl9LHQucHJvdG90eXBlLmZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNwZWN0cmFsLmZmdCh0aGlzKX0sdC5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNwZWN0cmFsLmlmZnQodGhpcyl9LHQucHJvdG90eXBlLnJmZnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSx4dC5zcGVjdHJhbC5yZmZ0KHRoaXMpfSx0LnByb3RvdHlwZS5pcmZmdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLHh0LnNwZWN0cmFsLmlyZmZ0KHRoaXMpfSx0fSgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh3dCxTeW1ib2wuaGFzSW5zdGFuY2Use3ZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiEhdCYmbnVsbCE9dC5kYXRhSWQmJm51bGwhPXQuc2hhcGUmJm51bGwhPXQuZHR5cGV9fSk7dmFyIEN0LEV0LFJ0LEl0LGt0LFN0PWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oZSxuLHIsbyl7dmFyIGE9dC5jYWxsKHRoaXMsZS5zaGFwZSxlLmR0eXBlLGUuZGF0YUlkLG8pfHx0aGlzO3JldHVybiBhLnRyYWluYWJsZT1uLGEubmFtZT1yLGF9cmV0dXJuIGUobix0KSxuLnByb3RvdHlwZS5hc3NpZ249ZnVuY3Rpb24odCl7aWYodC5kdHlwZSE9PXRoaXMuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiZHR5cGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIrdC5kdHlwZStcIikgYW5kIHByZXZpb3VzIHZhbHVlIChcIit0aGlzLmR0eXBlK1wiKSBtdXN0IG1hdGNoXCIpO2lmKCFTKHQuc2hhcGUsdGhpcy5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwic2hhcGUgb2YgdGhlIG5ldyB2YWx1ZSAoXCIrdC5zaGFwZStcIikgYW5kIHByZXZpb3VzIHZhbHVlIChcIit0aGlzLnNoYXBlK1wiKSBtdXN0IG1hdGNoXCIpO3l0KCkuZGlzcG9zZVRlbnNvcih0aGlzKSx0aGlzLmRhdGFJZD10LmRhdGFJZCx5dCgpLmluY1JlZih0aGlzLG51bGwpfSxuLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7eXQoKS5kaXNwb3NlVmFyaWFibGUodGhpcyksdGhpcy5pc0Rpc3Bvc2VkSW50ZXJuYWw9ITB9LG59KHd0KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoU3QsU3ltYm9sLmhhc0luc3RhbmNlLHt2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHd0JiZudWxsIT10LmFzc2lnbiYmdC5hc3NpZ24gaW5zdGFuY2VvZiBGdW5jdGlvbn19KSxmdW5jdGlvbih0KXt0LlIwPVwiUjBcIix0LlIxPVwiUjFcIix0LlIyPVwiUjJcIix0LlIzPVwiUjNcIix0LlI0PVwiUjRcIix0LlI1PVwiUjVcIix0LlI2PVwiUjZcIn0oQ3R8fChDdD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImZsb2F0MzJcIix0LmludDMyPVwiaW50MzJcIix0LmJvb2w9XCJpbnQzMlwiLHQuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KEV0fHwoRXQ9e30pKSxmdW5jdGlvbih0KXt0LmZsb2F0MzI9XCJmbG9hdDMyXCIsdC5pbnQzMj1cImludDMyXCIsdC5ib29sPVwiYm9vbFwiLHQuY29tcGxleDY0PVwiY29tcGxleDY0XCJ9KFJ0fHwoUnQ9e30pKSxmdW5jdGlvbih0KXt0LmZsb2F0MzI9XCJmbG9hdDMyXCIsdC5pbnQzMj1cImZsb2F0MzJcIix0LmJvb2w9XCJmbG9hdDMyXCIsdC5jb21wbGV4NjQ9XCJjb21wbGV4NjRcIn0oSXR8fChJdD17fSkpLGZ1bmN0aW9uKHQpe3QuZmxvYXQzMj1cImNvbXBsZXg2NFwiLHQuaW50MzI9XCJjb21wbGV4NjRcIix0LmJvb2w9XCJjb21wbGV4NjRcIix0LmNvbXBsZXg2ND1cImNvbXBsZXg2NFwifShrdHx8KGt0PXt9KSk7dmFyIEF0PXtmbG9hdDMyOkl0LGludDMyOkV0LGJvb2w6UnQsY29tcGxleDY0Omt0fTtmdW5jdGlvbiBUdCh0LGUpe2lmKFwic3RyaW5nXCI9PT10fHxcInN0cmluZ1wiPT09ZSl7aWYoXCJzdHJpbmdcIj09PXQmJlwic3RyaW5nXCI9PT1lKXJldHVyblwic3RyaW5nXCI7dGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCB1cGNhc3QgXCIrdCtcIiB3aXRoIFwiK2UpfXJldHVybiBBdFt0XVtlXX1mdW5jdGlvbiBEdCh0KXtyZXR1cm4gVHQodCxcImludDMyXCIpfWZ1bmN0aW9uIE50KHQsZSl7aWYodC5kdHlwZT09PWUuZHR5cGUpcmV0dXJuW3QsZV07dmFyIG49VHQodC5kdHlwZSxlLmR0eXBlKTtyZXR1cm5bdC5jYXN0KG4pLGUuY2FzdChuKV19ZnVuY3Rpb24gRnQodCxlKXtDKHQuZHR5cGU9PT1lLmR0eXBlLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGR0eXBlcyBvZiB0aGUgZmlyc3QoXCIrdC5kdHlwZStcIikgYW5kIHNlY29uZChcIitlLmR0eXBlK1wiKSBpbnB1dCBtdXN0IG1hdGNoXCJ9KSl9ZnVuY3Rpb24gX3QodCl7dmFyIGU9W107cmV0dXJuIGZ1bmN0aW9uIHQoZSxuLHIpe2lmKG51bGw9PWUpcmV0dXJuO2lmKGUgaW5zdGFuY2VvZiB3dClyZXR1cm4gdm9pZCBuLnB1c2goZSk7aWYobz1lLCFBcnJheS5pc0FycmF5KG8pJiZcIm9iamVjdFwiIT10eXBlb2YgbylyZXR1cm47dmFyIG87dmFyIGE9ZTtmb3IodmFyIGkgaW4gYSl7dmFyIHM9YVtpXTtyLmhhcyhzKXx8KHIuYWRkKHMpLHQocyxuLHIpKX19KHQsZSxuZXcgU2V0KSxlfXZhciBPdCxNdD1PYmplY3QuZnJlZXplKHttYWtlVHlwZXNNYXRjaDpOdCxhc3NlcnRUeXBlc01hdGNoOkZ0LGlzVGVuc29ySW5MaXN0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWQ9PT10LmlkfSkpfSxnZXRUZW5zb3JzSW5Db250YWluZXI6X3R9KSxCdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXM9e30sdGhpcy5uZXh0VGFwZU5vZGVJZD0wLHRoaXMubnVtQnl0ZXM9MCx0aGlzLm51bVRlbnNvcnM9MCx0aGlzLm51bVN0cmluZ1RlbnNvcnM9MCx0aGlzLm51bURhdGFCdWZmZXJzPTAsdGhpcy5ncmFkaWVudERlcHRoPTAsdGhpcy5rZXJuZWxEZXB0aD0wLHRoaXMuc2NvcGVTdGFjaz1bXSx0aGlzLm51bURhdGFNb3Zlc1N0YWNrPVtdLHRoaXMubmV4dFNjb3BlSWQ9MCx0aGlzLnRlbnNvckluZm89bmV3IFdlYWtNYXAsdGhpcy5wcm9maWxpbmc9ITEsdGhpcy5hY3RpdmVQcm9maWxlPXtuZXdCeXRlczowLG5ld1RlbnNvcnM6MCxwZWFrQnl0ZXM6MCxrZXJuZWxzOltdLHJlc3VsdDpudWxsfX1yZXR1cm4gdC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXMpdGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzW3RdLmRpc3Bvc2UoKX0sdH0oKSxQdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5FTlY9dCx0aGlzLnJlZ2lzdHJ5PXt9LHRoaXMucmVnaXN0cnlGYWN0b3J5PXt9LHRoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQ9MCx0aGlzLnN0YXRlPW5ldyBCdH1yZXR1cm4gdC5wcm90b3R5cGUucmVhZHk9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsZSxuO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYobnVsbCE9dGhpcy5wZW5kaW5nQmFja2VuZEluaXQpcmV0dXJuWzIsdGhpcy5wZW5kaW5nQmFja2VuZEluaXQudGhlbigoZnVuY3Rpb24oKXt9KSldO2lmKG51bGwhPXRoaXMuYmFja2VuZEluc3RhbmNlKXJldHVyblsyXTt0PXRoaXMuZ2V0U29ydGVkQmFja2VuZHMoKSxlPTAsci5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gZTx0Lmxlbmd0aD8obj10W2VdLFs0LHRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQobikuc3VjY2Vzc10pOlszLDVdO2Nhc2UgMjpyZXR1cm4gci5zZW50KCk/WzQsdGhpcy5zZXRCYWNrZW5kKG4pXTpbMyw0XTtjYXNlIDM6cmV0dXJuIHIuc2VudCgpLFsyXTtjYXNlIDQ6cmV0dXJuIGUrKyxbMywxXTtjYXNlIDU6dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGluaXRpYWxpemUgYW55IGJhY2tlbmRzLCBhbGwgYmFja2VuZCBpbml0aWFsaXphdGlvbnMgZmFpbGVkLlwiKX19KSl9KSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcImJhY2tlbmRcIix7Z2V0OmZ1bmN0aW9uKCl7aWYobnVsbCE9dGhpcy5wZW5kaW5nQmFja2VuZEluaXQpdGhyb3cgbmV3IEVycm9yKFwiQmFja2VuZCAnXCIrdGhpcy5iYWNrZW5kTmFtZStcIicgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXplZC4gTWFrZSBzdXJlIHRvIGF3YWl0IHRmLnJlYWR5KCkgb3IgYXdhaXQgdGYuc2V0QmFja2VuZCgpIGJlZm9yZSBjYWxsaW5nIG90aGVyIG1ldGhvZHNcIik7aWYobnVsbD09dGhpcy5iYWNrZW5kSW5zdGFuY2Upe3ZhciB0PXRoaXMuaW5pdGlhbGl6ZUJhY2tlbmRzQW5kUmV0dXJuQmVzdCgpLGU9dC5uYW1lO2lmKHQuYXN5bmNJbml0KXRocm93IG5ldyBFcnJvcihcIlRoZSBoaWdoZXN0IHByaW9yaXR5IGJhY2tlbmQgJ1wiK2UrXCInIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuIE1ha2Ugc3VyZSB0byBhd2FpdCB0Zi5yZWFkeSgpIG9yIGF3YWl0IHRmLnNldEJhY2tlbmQoKSBiZWZvcmUgY2FsbGluZyBvdGhlciBtZXRob2RzXCIpO3RoaXMuc2V0QmFja2VuZChlKX1yZXR1cm4gdGhpcy5iYWNrZW5kSW5zdGFuY2V9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUuYmFja2VuZE5hbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KX0sdC5wcm90b3R5cGUuZmluZEJhY2tlbmQ9ZnVuY3Rpb24odCl7aWYoISh0IGluIHRoaXMucmVnaXN0cnkpKXtpZighKHQgaW4gdGhpcy5yZWdpc3RyeUZhY3RvcnkpKXJldHVybiBudWxsO2lmKHRoaXMuaW5pdGlhbGl6ZUJhY2tlbmQodCkuYXN5bmNJbml0KXJldHVybiBudWxsfXJldHVybiB0aGlzLnJlZ2lzdHJ5W3RdfSx0LnByb3RvdHlwZS5maW5kQmFja2VuZEZhY3Rvcnk9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW4gdGhpcy5yZWdpc3RyeUZhY3Rvcnk/dGhpcy5yZWdpc3RyeUZhY3RvcnlbdF0uZmFjdG9yeTpudWxsfSx0LnByb3RvdHlwZS5yZWdpc3RlckJhY2tlbmQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0xKSx0IGluIHRoaXMucmVnaXN0cnlGYWN0b3J5Pyhjb25zb2xlLndhcm4odCtcIiBiYWNrZW5kIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQuIFJldXNpbmcgZXhpc3RpbmcgYmFja2VuZCBmYWN0b3J5LlwiKSwhMSk6KHRoaXMucmVnaXN0cnlGYWN0b3J5W3RdPXtmYWN0b3J5OmUscHJpb3JpdHk6bn0sITApfSx0LnByb3RvdHlwZS5zZXRCYWNrZW5kPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG87cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZihudWxsPT10aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XSl0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZW5kIG5hbWUgJ1wiK3QrXCInIG5vdCBmb3VuZCBpbiByZWdpc3RyeVwiKTtyZXR1cm4gdGhpcy5iYWNrZW5kTmFtZT10LG51bGwhPXRoaXMucmVnaXN0cnlbdF0/WzMsNF06KHRoaXMuYmFja2VuZEluc3RhbmNlPW51bGwsZT10aGlzLmluaXRpYWxpemVCYWNrZW5kKHQpLG49ZS5zdWNjZXNzLGUuYXN5bmNJbml0P1s0LG5dOlszLDJdKTtjYXNlIDE6cmV0dXJuIG89ci5zZW50KCksWzMsM107Y2FzZSAyOm89bixyLmxhYmVsPTM7Y2FzZSAzOmlmKCFvKXJldHVyblsyLCExXTtyLmxhYmVsPTQ7Y2FzZSA0OnJldHVybiB0aGlzLmJhY2tlbmRJbnN0YW5jZT10aGlzLnJlZ2lzdHJ5W3RdLHRoaXMuc2V0dXBSZWdpc3RlcmVkS2VybmVscygpLHRoaXMucHJvZmlsZXI9bmV3IHV0KHRoaXMuYmFja2VuZEluc3RhbmNlKSxbMiwhMF19fSkpfSkpfSx0LnByb3RvdHlwZS5zZXR1cFJlZ2lzdGVyZWRLZXJuZWxzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztmKHRoaXMuYmFja2VuZE5hbWUpLmZvckVhY2goKGZ1bmN0aW9uKGUpe251bGwhPWUuc2V0dXBGdW5jJiZlLnNldHVwRnVuYyh0LmJhY2tlbmRJbnN0YW5jZSl9KSl9LHQucHJvdG90eXBlLmRpc3Bvc2VSZWdpc3RlcmVkS2VybmVscz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2YodCkuZm9yRWFjaCgoZnVuY3Rpb24obil7bnVsbCE9bi5kaXNwb3NlRnVuYyYmbi5kaXNwb3NlRnVuYyhlLnJlZ2lzdHJ5W3RdKX0pKX0sdC5wcm90b3R5cGUuaW5pdGlhbGl6ZUJhY2tlbmQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPXRoaXMucmVnaXN0cnlGYWN0b3J5W3RdO2lmKG51bGw9PW4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGluaXRpYWxpemUgYmFja2VuZCBcIit0K1wiLCBubyByZWdpc3RyYXRpb24gZm91bmQuXCIpO3RyeXt2YXIgcj1uLmZhY3RvcnkoKTtpZihQcm9taXNlLnJlc29sdmUocik9PT1yKXt2YXIgbz0rK3RoaXMucGVuZGluZ0JhY2tlbmRJbml0SWQsYT1yLnRoZW4oKGZ1bmN0aW9uKG4pe3JldHVybiEobzxlLnBlbmRpbmdCYWNrZW5kSW5pdElkKSYmKGUucmVnaXN0cnlbdF09bixlLnBlbmRpbmdCYWNrZW5kSW5pdD1udWxsLCEwKX0pKS5jYXRjaCgoZnVuY3Rpb24obil7cmV0dXJuIShvPGUucGVuZGluZ0JhY2tlbmRJbml0SWQpJiYoZS5wZW5kaW5nQmFja2VuZEluaXQ9bnVsbCxjb25zb2xlLndhcm4oXCJJbml0aWFsaXphdGlvbiBvZiBiYWNrZW5kIFwiK3QrXCIgZmFpbGVkXCIpLGNvbnNvbGUud2FybihuLnN0YWNrfHxuLm1lc3NhZ2UpLCExKX0pKTtyZXR1cm4gdGhpcy5wZW5kaW5nQmFja2VuZEluaXQ9YSx7c3VjY2VzczphLGFzeW5jSW5pdDohMH19cmV0dXJuIHRoaXMucmVnaXN0cnlbdF09cix7c3VjY2VzczohMCxhc3luY0luaXQ6ITF9fWNhdGNoKGUpe3JldHVybiBjb25zb2xlLndhcm4oXCJJbml0aWFsaXphdGlvbiBvZiBiYWNrZW5kIFwiK3QrXCIgZmFpbGVkXCIpLGNvbnNvbGUud2FybihlLnN0YWNrfHxlLm1lc3NhZ2UpLHtzdWNjZXNzOiExLGFzeW5jSW5pdDohMX19fSx0LnByb3RvdHlwZS5yZW1vdmVCYWNrZW5kPWZ1bmN0aW9uKHQpe2lmKCEodCBpbiB0aGlzLnJlZ2lzdHJ5RmFjdG9yeSkpdGhyb3cgbmV3IEVycm9yKHQrXCIgYmFja2VuZCBub3QgZm91bmQgaW4gcmVnaXN0cnlcIik7dGhpcy5iYWNrZW5kTmFtZT09PXQmJm51bGwhPXRoaXMucGVuZGluZ0JhY2tlbmRJbml0JiZ0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdElkKyssdCBpbiB0aGlzLnJlZ2lzdHJ5JiYodGhpcy5kaXNwb3NlUmVnaXN0ZXJlZEtlcm5lbHModCksdGhpcy5yZWdpc3RyeVt0XS5kaXNwb3NlKCksZGVsZXRlIHRoaXMucmVnaXN0cnlbdF0pLGRlbGV0ZSB0aGlzLnJlZ2lzdHJ5RmFjdG9yeVt0XSx0aGlzLmJhY2tlbmROYW1lPT09dCYmKHRoaXMucGVuZGluZ0JhY2tlbmRJbml0PW51bGwsdGhpcy5iYWNrZW5kTmFtZT1udWxsLHRoaXMuYmFja2VuZEluc3RhbmNlPW51bGwpfSx0LnByb3RvdHlwZS5nZXRTb3J0ZWRCYWNrZW5kcz1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYoMD09PU9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTm8gYmFja2VuZCBmb3VuZCBpbiByZWdpc3RyeS5cIik7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVnaXN0cnlGYWN0b3J5KS5zb3J0KChmdW5jdGlvbihlLG4pe3JldHVybiB0LnJlZ2lzdHJ5RmFjdG9yeVtuXS5wcmlvcml0eS10LnJlZ2lzdHJ5RmFjdG9yeVtlXS5wcmlvcml0eX0pKX0sdC5wcm90b3R5cGUuaW5pdGlhbGl6ZUJhY2tlbmRzQW5kUmV0dXJuQmVzdD1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdldFNvcnRlZEJhY2tlbmRzKCksZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj10W2VdLHI9dGhpcy5pbml0aWFsaXplQmFja2VuZChuKSxvPXIuc3VjY2VzcyxhPXIuYXN5bmNJbml0O2lmKGF8fG8pcmV0dXJue25hbWU6bixhc3luY0luaXQ6YX19dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGluaXRpYWxpemUgYW55IGJhY2tlbmRzLCBhbGwgYmFja2VuZCBpbml0aWFsaXphdGlvbnMgZmFpbGVkLlwiKX0sdC5wcm90b3R5cGUubW92ZURhdGE9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KGUpLHI9bi5iYWNrZW5kLG89dGhpcy5yZWFkU3luYyhlKTtyLmRpc3Bvc2VEYXRhKGUpLG4uYmFja2VuZD10LHQubW92ZShlLG8sbi5zaGFwZSxuLmR0eXBlKSx0aGlzLnNob3VsZENoZWNrRm9yTWVtTGVha3MoKSYmdGhpcy5zdGF0ZS5udW1EYXRhTW92ZXNTdGFja1t0aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrLmxlbmd0aC0xXSsrfSx0LnByb3RvdHlwZS50aWR5PWZ1bmN0aW9uKHQsZSl7dmFyIG4scj10aGlzLG89bnVsbDtpZihudWxsPT1lKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGEgZnVuY3Rpb24gdG8gdGlkeSgpXCIpO2U9dH1lbHNle2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0JiYhKHQgaW5zdGFuY2VvZiBTdHJpbmcpKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aWR5KCkgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSAybmQgYXJndW1lbnQgdG8gdGlkeSgpIG11c3QgYmUgYSBmdW5jdGlvblwiKTtvPXR9cmV0dXJuIHRoaXMuc2NvcGVkUnVuKChmdW5jdGlvbigpe3JldHVybiByLnN0YXJ0U2NvcGUobyl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gci5lbmRTY29wZShuKX0pLChmdW5jdGlvbigpe3JldHVybihuPWUoKSlpbnN0YW5jZW9mIFByb21pc2UmJmNvbnNvbGUuZXJyb3IoXCJDYW5ub3QgcmV0dXJuIGEgUHJvbWlzZSBpbnNpZGUgb2YgdGlkeS5cIiksbn0pKX0sdC5wcm90b3R5cGUuc2NvcGVkUnVuPWZ1bmN0aW9uKHQsZSxuKXt0KCk7dHJ5e3ZhciByPW4oKTtyZXR1cm4gZSgpLHJ9Y2F0Y2godCl7dGhyb3cgZSgpLHR9fSx0LnByb3RvdHlwZS5uZXh0VGVuc29ySWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdC5uZXh0VGVuc29ySWQrK30sdC5wcm90b3R5cGUubmV4dFZhcmlhYmxlSWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdC5uZXh0VmFyaWFibGVJZCsrfSx0LnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm1ha2VUZW5zb3JGcm9tRGF0YUlkKHQuZGF0YUlkLHQuc2hhcGUsdC5kdHlwZSksbj17eDp0fTtyZXR1cm4gdGhpcy5hZGRUYXBlTm9kZSh0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLm5hbWUsbixbZV0sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQudG9GbG9hdCgpfX19KSxbXSx7fSksZX0sdC5wcm90b3R5cGUucnVuS2VybmVsPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHRoaXMucnVuS2VybmVsRnVuYyhudWxsLGUsbnVsbCx0LG4scixvKX0sdC5wcm90b3R5cGUuc2hvdWxkQ2hlY2tGb3JNZW1MZWFrcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLkVOVi5nZXRCb29sKFwiSVNfVEVTVFwiKX0sdC5wcm90b3R5cGUuY2hlY2tLZXJuZWxGb3JNZW1MZWFrPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzLmJhY2tlbmQubnVtRGF0YUlkcygpLG89MDtuLmZvckVhY2goKGZ1bmN0aW9uKHQpe28rPVwiY29tcGxleDY0XCI9PT10LmR0eXBlPzM6MX0pKTt2YXIgYT10aGlzLnN0YXRlLm51bURhdGFNb3Zlc1N0YWNrW3RoaXMuc3RhdGUubnVtRGF0YU1vdmVzU3RhY2subGVuZ3RoLTFdLGk9ci1lLW8tYTtpZihpPjApdGhyb3cgbmV3IEVycm9yKFwiQmFja2VuZCAnXCIrdGhpcy5iYWNrZW5kTmFtZStcIicgaGFzIGFuIGludGVybmFsIG1lbW9yeSBsZWFrIChcIitpK1wiIGRhdGEgaWRzKSBhZnRlciBydW5uaW5nICdcIit0K1wiJ1wiKX0sdC5wcm90b3R5cGUucnVuS2VybmVsRnVuYz1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2YXIgcyx1PXRoaXMsYz1bXSxoPXRoaXMuaXNUYXBlT24oKTtudWxsPT1yJiYocj1udWxsIT10aGlzLnN0YXRlLmFjdGl2ZVNjb3BlP3RoaXMuc3RhdGUuYWN0aXZlU2NvcGUubmFtZTpcIlwiKTt2YXIgZixkPXRoaXMuc3RhdGUubnVtQnl0ZXMscD10aGlzLnN0YXRlLm51bVRlbnNvcnM7dGhpcy5zaG91bGRDaGVja0Zvck1lbUxlYWtzKCkmJnRoaXMuc3RhdGUubnVtRGF0YU1vdmVzU3RhY2sucHVzaCgwKTt2YXIgdixnPWwocix0aGlzLmJhY2tlbmROYW1lKTtpZihudWxsIT1nKWY9ZnVuY3Rpb24oKXt2YXIgdD11LmJhY2tlbmQubnVtRGF0YUlkcygpO3Y9Zy5rZXJuZWxGdW5jKHtpbnB1dHM6ZSxhdHRyczpvLGJhY2tlbmQ6dS5iYWNrZW5kfSk7dmFyIG49QXJyYXkuaXNBcnJheSh2KT92Olt2XTt1LnNob3VsZENoZWNrRm9yTWVtTGVha3MoKSYmdS5jaGVja0tlcm5lbEZvck1lbUxlYWsocix0LG4pO3ZhciBzPW4ubWFwKChmdW5jdGlvbih0KXt2YXIgZT10LmRhdGFJZCxuPXQuc2hhcGUscj10LmR0eXBlO3JldHVybiB1Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKGUsbixyKX0pKTtpZihoKXt2YXIgbD11LmdldFRlbnNvcnNGb3JHcmFkaWVudChyLGUscyk7aWYobnVsbD09bCl7bnVsbD09aSYmKGk9W10pO3ZhciBmPXMuZmlsdGVyKChmdW5jdGlvbih0LGUpe3JldHVybiBpW2VdfSkpO2w9KGF8fFtdKS5zbGljZSgpLmNvbmNhdChmKX1jPXUuc2F2ZVRlbnNvcnNGb3JCYWNrd2FyZE1vZGUobCl9cmV0dXJuIHN9O2Vsc2V7dmFyIG09ZnVuY3Rpb24odCl7aCYmKGM9dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB1LmtlZXAodS5jbG9uZSh0KSl9KSkpfTtmPWZ1bmN0aW9uKCl7dmFyIGU9dS5iYWNrZW5kLm51bURhdGFJZHMoKTt2PXUudGlkeSgoZnVuY3Rpb24oKXtyZXR1cm4gdCh1LmJhY2tlbmQsbSl9KSk7dmFyIG49QXJyYXkuaXNBcnJheSh2KT92Olt2XTtyZXR1cm4gdS5zaG91bGRDaGVja0Zvck1lbUxlYWtzKCkmJnUuY2hlY2tLZXJuZWxGb3JNZW1MZWFrKHIsZSxuKSxufX1yZXR1cm4gdGhpcy5zY29wZWRSdW4oKGZ1bmN0aW9uKCl7cmV0dXJuIHUuc3RhdGUua2VybmVsRGVwdGgrK30pLChmdW5jdGlvbigpe3JldHVybiB1LnN0YXRlLmtlcm5lbERlcHRoLS19KSwoZnVuY3Rpb24oKXtzPXUuRU5WLmdldEJvb2woXCJERUJVR1wiKT91LnByb2ZpbGVyLnByb2ZpbGVLZXJuZWwocixlLChmdW5jdGlvbigpe3JldHVybiBmKCl9KSk6ZigpfSkpLGgmJnRoaXMuYWRkVGFwZU5vZGUocixlLHMsbixjLG8pLHRoaXMuc3RhdGUucHJvZmlsaW5nJiZ0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUua2VybmVscy5wdXNoKHtuYW1lOnIsYnl0ZXNBZGRlZDp0aGlzLnN0YXRlLm51bUJ5dGVzLWQsdG90YWxCeXRlc1NuYXBzaG90OnRoaXMuc3RhdGUubnVtQnl0ZXMsdGVuc29yc0FkZGVkOnRoaXMuc3RhdGUubnVtVGVuc29ycy1wLHRvdGFsVGVuc29yc1NuYXBzaG90OnRoaXMuc3RhdGUubnVtVGVuc29ycyxpbnB1dFNoYXBlczpPYmplY3Qua2V5cyhlKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdLnNoYXBlfSkpLG91dHB1dFNoYXBlczpzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSl9KSxBcnJheS5pc0FycmF5KHYpP3M6c1swXX0sdC5wcm90b3R5cGUuc2F2ZVRlbnNvcnNGb3JCYWNrd2FyZE1vZGU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gdC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlLmtlZXAoZS5jbG9uZSh0KSl9KSl9LHQucHJvdG90eXBlLmdldFRlbnNvcnNGb3JHcmFkaWVudD1mdW5jdGlvbih0LGUsbil7dmFyIHI9aCh0KTtpZihudWxsIT1yKXt2YXIgbz1yLmlucHV0c1RvU2F2ZXx8W10sYT1yLm91dHB1dHNUb1NhdmV8fFtdLGk9dm9pZCAwO3Iuc2F2ZUFsbElucHV0cz8oQyhBcnJheS5pc0FycmF5KGUpLChmdW5jdGlvbigpe3JldHVyblwic2F2ZUFsbElucHV0cyBpcyB0cnVlLCBleHBlY3RlZCBpbnB1dHMgdG8gYmUgYW4gYXJyYXkuXCJ9KSksaT1PYmplY3Qua2V5cyhlKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfSkpKTppPW8ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0pKTt2YXIgcz1uLmZpbHRlcigoZnVuY3Rpb24odCxlKXtyZXR1cm4gYVtlXX0pKTtyZXR1cm4gaS5jb25jYXQocyl9cmV0dXJuIG51bGx9LHQucHJvdG90eXBlLm1ha2VUZW5zb3I9ZnVuY3Rpb24odCxlLG4scil7aWYobnVsbD09dCl0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZXMgcGFzc2VkIHRvIGVuZ2luZS5tYWtlVGVuc29yKCkgYXJlIG51bGxcIik7bj1ufHxcImZsb2F0MzJcIixyPXJ8fHRoaXMuYmFja2VuZDt2YXIgbz10O1wic3RyaW5nXCI9PT1uJiZIKHRbMF0pJiYobz10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHJ0KHQpfSkpKTt2YXIgYT1yLndyaXRlKG8sZSxuKSxpPW5ldyB3dChlLG4sYSx0aGlzLm5leHRUZW5zb3JJZCgpKTtpZih0aGlzLmluY1JlZihpLHIpLFwic3RyaW5nXCI9PT1uKXt2YXIgcz10aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KGEpLHU9RyhvKTt0aGlzLnN0YXRlLm51bUJ5dGVzKz11LXMuYnl0ZXMscy5ieXRlcz11fXJldHVybiBpfSx0LnByb3RvdHlwZS5tYWtlVGVuc29yRnJvbURhdGFJZD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgd3QoZSxuPW58fFwiZmxvYXQzMlwiLHQsdGhpcy5uZXh0VGVuc29ySWQoKSk7cmV0dXJuIHRoaXMuaW5jUmVmKG8sciksb30sdC5wcm90b3R5cGUubWFrZVZhcmlhYmxlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PWUmJihlPSEwKSxuPW58fHRoaXMubmV4dFZhcmlhYmxlSWQoKS50b1N0cmluZygpLG51bGwhPXImJnIhPT10LmR0eXBlJiYodD10LmFzVHlwZShyKSk7dmFyIG89bmV3IFN0KHQsZSxuLHRoaXMubmV4dFRlbnNvcklkKCkpO2lmKG51bGwhPXRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1tvLm5hbWVdKXRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlIHdpdGggbmFtZSBcIitvLm5hbWUrXCIgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZFwiKTtyZXR1cm4gdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW28ubmFtZV09byx0aGlzLmluY1JlZihvLHRoaXMuYmFja2VuZCksb30sdC5wcm90b3R5cGUuaW5jUmVmPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmhhcyh0LmRhdGFJZCk/dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCkucmVmQ291bnQ6MDtpZih0aGlzLnN0YXRlLm51bVRlbnNvcnMrKyxcInN0cmluZ1wiPT09dC5kdHlwZSYmdGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzKyssMD09PW4pe3RoaXMuc3RhdGUubnVtRGF0YUJ1ZmZlcnMrKzt2YXIgcj0wO1wiY29tcGxleDY0XCIhPT10LmR0eXBlJiZcInN0cmluZ1wiIT09dC5kdHlwZSYmKHI9dC5zaXplKnoodC5kdHlwZSkpLHRoaXMuc3RhdGUudGVuc29ySW5mby5zZXQodC5kYXRhSWQse2JhY2tlbmQ6ZXx8dGhpcy5iYWNrZW5kLGR0eXBlOnQuZHR5cGUsc2hhcGU6dC5zaGFwZSxieXRlczpyLHJlZkNvdW50OjB9KSx0aGlzLnN0YXRlLm51bUJ5dGVzKz1yfXRoaXMuc3RhdGUudGVuc29ySW5mby5nZXQodC5kYXRhSWQpLnJlZkNvdW50KyssdCBpbnN0YW5jZW9mIFN0fHx0aGlzLnRyYWNrKHQpfSx0LnByb3RvdHlwZS5kaXNwb3NlVGVuc29yPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc3RhdGUudGVuc29ySW5mby5oYXModC5kYXRhSWQpKXt0aGlzLnN0YXRlLm51bVRlbnNvcnMtLSxcInN0cmluZ1wiPT09dC5kdHlwZSYmdGhpcy5zdGF0ZS5udW1TdHJpbmdUZW5zb3JzLS07dmFyIGU9dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCk7ZS5yZWZDb3VudDw9MT8oXCJjb21wbGV4NjRcIiE9PXQuZHR5cGUmJih0aGlzLnN0YXRlLm51bUJ5dGVzLT1lLmJ5dGVzKSx0aGlzLnN0YXRlLm51bURhdGFCdWZmZXJzLS0sZS5iYWNrZW5kLmRpc3Bvc2VEYXRhKHQuZGF0YUlkKSx0aGlzLnN0YXRlLnRlbnNvckluZm8uZGVsZXRlKHQuZGF0YUlkKSk6dGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0LmRhdGFJZCkucmVmQ291bnQtLX19LHQucHJvdG90eXBlLmRpc3Bvc2VWYXJpYWJsZXM9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzKXt2YXIgZT10aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdF07dGhpcy5kaXNwb3NlVmFyaWFibGUoZSl9fSx0LnByb3RvdHlwZS5kaXNwb3NlVmFyaWFibGU9ZnVuY3Rpb24odCl7dGhpcy5kaXNwb3NlVGVuc29yKHQpLG51bGwhPXRoaXMuc3RhdGUucmVnaXN0ZXJlZFZhcmlhYmxlc1t0Lm5hbWVdJiZkZWxldGUgdGhpcy5zdGF0ZS5yZWdpc3RlcmVkVmFyaWFibGVzW3QubmFtZV19LHQucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuYmFja2VuZC5tZW1vcnkoKTtyZXR1cm4gdC5udW1UZW5zb3JzPXRoaXMuc3RhdGUubnVtVGVuc29ycyx0Lm51bURhdGFCdWZmZXJzPXRoaXMuc3RhdGUubnVtRGF0YUJ1ZmZlcnMsdC5udW1CeXRlcz10aGlzLnN0YXRlLm51bUJ5dGVzLHRoaXMuc3RhdGUubnVtU3RyaW5nVGVuc29ycz4wJiYodC51bnJlbGlhYmxlPSEwLG51bGw9PXQucmVhc29ucyYmKHQucmVhc29ucz1bXSksdC5yZWFzb25zLnB1c2goXCJNZW1vcnkgdXNhZ2UgYnkgc3RyaW5nIHRlbnNvcnMgaXMgYXBwcm94aW1hdGUgKDIgYnl0ZXMgcGVyIGNoYXJhY3RlcilcIikpLHR9LHQucHJvdG90eXBlLnByb2ZpbGU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG47cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7cmV0dXJuIHRoaXMuc3RhdGUucHJvZmlsaW5nPSEwLGU9dGhpcy5zdGF0ZS5udW1CeXRlcyxuPXRoaXMuc3RhdGUubnVtVGVuc29ycyx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUua2VybmVscz1bXSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUucmVzdWx0PXQoKSx0aGlzLnN0YXRlLnByb2ZpbGluZz0hMSx0aGlzLnN0YXRlLmFjdGl2ZVByb2ZpbGUucGVha0J5dGVzPU1hdGgubWF4LmFwcGx5KE1hdGgsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLmtlcm5lbHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC50b3RhbEJ5dGVzU25hcHNob3R9KSkpLHRoaXMuc3RhdGUuYWN0aXZlUHJvZmlsZS5uZXdCeXRlcz10aGlzLnN0YXRlLm51bUJ5dGVzLWUsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlLm5ld1RlbnNvcnM9dGhpcy5zdGF0ZS5udW1UZW5zb3JzLW4sWzIsdGhpcy5zdGF0ZS5hY3RpdmVQcm9maWxlXX0pKX0pKX0sdC5wcm90b3R5cGUuaXNUYXBlT249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoPjAmJjA9PT10aGlzLnN0YXRlLmtlcm5lbERlcHRofSx0LnByb3RvdHlwZS5hZGRUYXBlTm9kZT1mdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9dGhpcyxzPXtpZDp0aGlzLnN0YXRlLm5leHRUYXBlTm9kZUlkKyssa2VybmVsTmFtZTp0LGlucHV0czplLG91dHB1dHM6bixzYXZlZDpvfSx1PWgodCk7bnVsbCE9dSYmKHI9dS5ncmFkRnVuYyksbnVsbCE9ciYmKHMuZ3JhZGllbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9dC5tYXAoKGZ1bmN0aW9uKHQsZSl7aWYobnVsbD09dCl7dmFyIHI9bltlXSxvPXR0KHIuc2l6ZSxyLmR0eXBlKTtyZXR1cm4gaS5tYWtlVGVuc29yKG8sci5zaGFwZSxyLmR0eXBlKX1yZXR1cm4gdH0pKSxyKHQubGVuZ3RoPjE/dDp0WzBdLG8sYSl9KSx0aGlzLnN0YXRlLmFjdGl2ZVRhcGUucHVzaChzKX0sdC5wcm90b3R5cGUua2VlcD1mdW5jdGlvbih0KXtyZXR1cm4gdC5rZXB0PSEwLHR9LHQucHJvdG90eXBlLnN0YXJ0VGFwZT1mdW5jdGlvbigpezA9PT10aGlzLnN0YXRlLmdyYWRpZW50RGVwdGgmJih0aGlzLnN0YXRlLmFjdGl2ZVRhcGU9W10pLHRoaXMuc3RhdGUuZ3JhZGllbnREZXB0aCsrfSx0LnByb3RvdHlwZS5lbmRUYXBlPWZ1bmN0aW9uKCl7dGhpcy5zdGF0ZS5ncmFkaWVudERlcHRoLS19LHQucHJvdG90eXBlLnN0YXJ0U2NvcGU9ZnVuY3Rpb24odCl7dmFyIGU9e3RyYWNrOltdLG5hbWU6XCJ1bm5hbWVkIHNjb3BlXCIsaWQ6dGhpcy5zdGF0ZS5uZXh0U2NvcGVJZCsrfTt0JiYoZS5uYW1lPXQpLHRoaXMuc3RhdGUuc2NvcGVTdGFjay5wdXNoKGUpLHRoaXMuc3RhdGUuYWN0aXZlU2NvcGU9ZX0sdC5wcm90b3R5cGUuZW5kU2NvcGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMsbj1fdCh0KSxyPW5ldyBTZXQobi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkfSkpKSxvPTA7bzx0aGlzLnN0YXRlLmFjdGl2ZVNjb3BlLnRyYWNrLmxlbmd0aDtvKyspe3ZhciBhPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGUudHJhY2tbb107YS5rZXB0fHxyLmhhcyhhLmlkKXx8YS5kaXNwb3NlKCl9dmFyIGk9dGhpcy5zdGF0ZS5zY29wZVN0YWNrLnBvcCgpO3RoaXMuc3RhdGUuYWN0aXZlU2NvcGU9MD09PXRoaXMuc3RhdGUuc2NvcGVTdGFjay5sZW5ndGg/bnVsbDp0aGlzLnN0YXRlLnNjb3BlU3RhY2tbdGhpcy5zdGF0ZS5zY29wZVN0YWNrLmxlbmd0aC0xXSxuLmZvckVhY2goKGZ1bmN0aW9uKHQpe3Qua2VwdHx8dC5zY29wZUlkIT09aS5pZHx8ZS50cmFjayh0KX0pKX0sdC5wcm90b3R5cGUuZ3JhZGllbnRzPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXRoaXM7aWYodm9pZCAwPT09ciYmKHI9ITEpLEMoZS5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cImdyYWRpZW50cygpIHJlY2VpdmVkIGFuIGVtcHR5IGxpc3Qgb2YgeHMuXCJ9KSksbnVsbCE9biYmXCJmbG9hdDMyXCIhPT1uLmR0eXBlKXRocm93IG5ldyBFcnJvcihcImR5IG11c3QgaGF2ZSAnZmxvYXQzMicgZHR5cGUsIGJ1dCBoYXMgJ1wiK24uZHR5cGUrXCInXCIpO3ZhciBhPXRoaXMuc2NvcGVkUnVuKChmdW5jdGlvbigpe3JldHVybiBvLnN0YXJ0VGFwZSgpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIG8uZW5kVGFwZSgpfSksKGZ1bmN0aW9uKCl7cmV0dXJuIG8udGlkeShcImZvcndhcmRcIix0KX0pKTtDKGEgaW5zdGFuY2VvZiB3dCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSByZXN1bHQgeSByZXR1cm5lZCBieSBmKCkgbXVzdCBiZSBhIHRlbnNvci5cIn0pKTt2YXIgaT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPXt9LG89e30sYT0wO2E8ZS5sZW5ndGg7YSsrKXJbZVthXS5pZF09ITA7Zm9yKGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIGk9KHA9dFthXSkuaW5wdXRzO2Zvcih2YXIgcyBpbiBpKXtmb3IodmFyIHU9aVtzXSxjPSExLGw9MDtsPGUubGVuZ3RoO2wrKylpZihyW3UuaWRdKXtwLm91dHB1dHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHJbdC5pZF09ITB9KSksYz0hMCxvW3AuaWRdPSEwO2JyZWFrfWlmKGMpYnJlYWt9fXZhciBoPXt9O2hbbi5pZF09ITA7dmFyIGY9e307Zm9yKGE9dC5sZW5ndGgtMTthPj0wO2EtLSlmb3IoaT0ocD10W2FdKS5pbnB1dHMsbD0wO2w8cC5vdXRwdXRzLmxlbmd0aDtsKyspaWYoaFtwLm91dHB1dHNbbF0uaWRdKXtmb3IodmFyIHMgaW4gaSloW2lbc10uaWRdPSEwLGZbcC5pZF09ITA7YnJlYWt9dmFyIGQ9W107Zm9yKGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIHA7aWYob1socD10W2FdKS5pZF0mJmZbcC5pZF0pe3ZhciB2PXt9O2Zvcih2YXIgcyBpbiBwLmlucHV0cyl7dmFyIGc9cC5pbnB1dHNbc107cltnLmlkXSYmKHZbc109Zyl9dmFyIG09T2JqZWN0LmFzc2lnbih7fSxwKTttLmlucHV0cz12LG0ub3V0cHV0cz1wLm91dHB1dHMsZC5wdXNoKG0pfX1yZXR1cm4gZH0odGhpcy5zdGF0ZS5hY3RpdmVUYXBlLGUsYSk7aWYoIXImJjA9PT1pLmxlbmd0aCYmZS5sZW5ndGg+MCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSB0aGF0IHRoZSBmIHlvdSBwYXNzZWQgZW5jbG9zZXMgYWxsIG9wZXJhdGlvbnMgdGhhdCBsZWFkIGZyb20geCB0byB5LlwiKTtyZXR1cm4gdGhpcy50aWR5KFwiYmFja3dhcmRcIiwoZnVuY3Rpb24oKXt2YXIgdCxyLHM9e307c1thLmlkXT1udWxsPT1uPyh0PWEuc2hhcGUscj1aKGsodCksXCJmbG9hdDMyXCIpLEx0Lm1ha2VUZW5zb3Iocix0LFwiZmxvYXQzMlwiKSk6bixmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPWZ1bmN0aW9uKHIpe3ZhciBvPWVbcl0sYT1bXTtpZihvLm91dHB1dHMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49dFtlLmlkXTtudWxsIT1uP2EucHVzaChuKTphLnB1c2gobnVsbCl9KSksbnVsbD09by5ncmFkaWVudCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudDogZ3JhZGllbnQgZnVuY3Rpb24gbm90IGZvdW5kIGZvciBcIitvLmtlcm5lbE5hbWUrXCIuXCIpO3ZhciBpPW8uZ3JhZGllbnQoYSkscz1mdW5jdGlvbihlKXtpZighKGUgaW4gaSkpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGJhY2twcm9wIHRocm91Z2ggaW5wdXQgXCIrZStcIi4gQXZhaWxhYmxlIGdyYWRpZW50cyBmb3VuZDogXCIrT2JqZWN0LmtleXMoaSkrXCIuXCIpO3ZhciByPW4oKGZ1bmN0aW9uKCl7cmV0dXJuIGlbZV0oKX0pKTtpZihcImZsb2F0MzJcIiE9PXIuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gZ3JhZGllbnQgZm9yIG9wIFwiK28ua2VybmVsTmFtZStcIi4gVGhlIGdyYWRpZW50IG9mIGlucHV0IFwiK2UrXCIgbXVzdCBoYXZlICdmbG9hdDMyJyBkdHlwZSwgYnV0IGhhcyAnXCIrci5kdHlwZStcIidcIik7dmFyIGE9by5pbnB1dHNbZV07aWYoIVMoci5zaGFwZSxhLnNoYXBlKSl0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBncmFkaWVudCBmb3Igb3AgXCIrby5rZXJuZWxOYW1lK1wiLiBUaGUgZ3JhZGllbnQgb2YgaW5wdXQgJ1wiK2UrXCInIGhhcyBzaGFwZSAnXCIrci5zaGFwZStcIicsIHdoaWNoIGRvZXMgbm90IG1hdGNoIHRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgJ1wiK2Euc2hhcGUrXCInXCIpO2lmKG51bGw9PXRbYS5pZF0pdFthLmlkXT1yO2Vsc2V7dmFyIHM9dFthLmlkXTt0W2EuaWRdPXMuYWRkKHIpLHMuZGlzcG9zZSgpfX07Zm9yKHZhciB1IGluIG8uaW5wdXRzKXModSl9LG89ZS5sZW5ndGgtMTtvPj0wO28tLSlyKG8pfShzLGksKGZ1bmN0aW9uKHQpe3JldHVybiBvLnRpZHkodCl9KSk7dmFyIHU9ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBzW3QuaWRdfSkpO3JldHVybiAwPT09by5zdGF0ZS5ncmFkaWVudERlcHRoJiYoby5zdGF0ZS5hY3RpdmVUYXBlLmZvckVhY2goKGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49dC5zYXZlZDtlPG4ubGVuZ3RoO2UrKyl7bltlXS5kaXNwb3NlKCl9fSkpLG8uc3RhdGUuYWN0aXZlVGFwZT1udWxsKSx7dmFsdWU6YSxncmFkczp1fX0pKX0sdC5wcm90b3R5cGUuY3VzdG9tR3JhZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBDKFgodCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb24uXCJ9KSksZnVuY3Rpb24oKXtmb3IodmFyIG4scj1bXSxvPTA7bzxhcmd1bWVudHMubGVuZ3RoO28rKylyW29dPWFyZ3VtZW50c1tvXTtDKHIuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygd3R9KSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJncyBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSh4MSwgeDIsLi4uKSBtdXN0IGFsbCBiZSB0ZW5zb3JzXCJ9KSk7dmFyIGE9e307cmV0dXJuIHIuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXthW2VdPXR9KSksZS5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbihlLG8pe3JldHVybiBDKChuPXQuYXBwbHkodm9pZCAwLHIuY29uY2F0KFtvXSkpKS52YWx1ZSBpbnN0YW5jZW9mIHd0LChmdW5jdGlvbigpe3JldHVyblwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmoudmFsdWVgIGlzIGEgdGVuc29yXCJ9KSksQyhYKG4uZ3JhZEZ1bmMpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24uXCJ9KSksbi52YWx1ZX0pLGEsKGZ1bmN0aW9uKHQsZSl7dmFyIG89bi5ncmFkRnVuYyh0LGUpLGE9QXJyYXkuaXNBcnJheShvKT9vOltvXTtDKGEubGVuZ3RoPT09ci5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2hlcmUgYG9iai5ncmFkRnVuY2AgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHNhbWUgbnVtYmVyIG9mIHRlbnNvcnMgYXMgaW5wdXRzIHBhc3NlZCB0byBmKC4uLikuXCJ9KSksQyhhLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHd0fSkpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGZ1bmN0aW9uIGYgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIGBvYmouZ3JhZEZ1bmNgIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbGlzdCBvZiBvbmx5IHRlbnNvcnMuXCJ9KSk7dmFyIGk9e307cmV0dXJuIGEuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtpW2VdPWZ1bmN0aW9uKCl7cmV0dXJuIHR9fSkpLGl9KSl9fSx0LnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdGF0ZS50ZW5zb3JJbmZvLmdldCh0KS5iYWNrZW5kLnJlYWRTeW5jKHQpfSx0LnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnN0YXRlLnRlbnNvckluZm8uZ2V0KHQpLmJhY2tlbmQucmVhZCh0KX0sdC5wcm90b3R5cGUudGltZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBlPWV0KCksWzQsdGhpcy5iYWNrZW5kLnRpbWUodCldO2Nhc2UgMTpyZXR1cm4obj1yLnNlbnQoKSkud2FsbE1zPWV0KCktZSxbMixuXX19KSl9KSl9LHQucHJvdG90eXBlLnRyYWNrPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10aGlzLnN0YXRlLmFjdGl2ZVNjb3BlJiYodC5zY29wZUlkPXRoaXMuc3RhdGUuYWN0aXZlU2NvcGUuaWQsdGhpcy5zdGF0ZS5hY3RpdmVTY29wZS50cmFjay5wdXNoKHQpKSx0fSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJyZWdpc3RlcmVkVmFyaWFibGVzXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlLnJlZ2lzdGVyZWRWYXJpYWJsZXN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksdC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5wZW5kaW5nQmFja2VuZEluaXRJZCsrLHRoaXMuc3RhdGUuZGlzcG9zZSgpLHRoaXMuRU5WLnJlc2V0KCksdGhpcy5zdGF0ZT1uZXcgQnQsdGhpcy5yZWdpc3RyeSl0aGlzLmRpc3Bvc2VSZWdpc3RlcmVkS2VybmVscyh0KSx0aGlzLnJlZ2lzdHJ5W3RdLmRpc3Bvc2UoKSxkZWxldGUgdGhpcy5yZWdpc3RyeVt0XTt0aGlzLmJhY2tlbmROYW1lPW51bGwsdGhpcy5iYWNrZW5kSW5zdGFuY2U9bnVsbCx0aGlzLnBlbmRpbmdCYWNrZW5kSW5pdD1udWxsfSx0Lm5leHRUZW5zb3JJZD0wLHQubmV4dFZhcmlhYmxlSWQ9MCx0fSgpO3ZhciBMdD1mdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKCl7aWYobnVsbD09T3Qpe3ZhciB0PXZvaWQgMDtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93KXQ9d2luZG93O2Vsc2UgaWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbCl0PWdsb2JhbDtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBwcm9jZXNzKXQ9cHJvY2VzcztlbHNle2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgZ2xvYmFsIG9iamVjdFwiKTt0PXNlbGZ9T3Q9dH1yZXR1cm4gT3R9KCk7aWYobnVsbD09dC5fdGZlbmdpbmUpe3ZhciBlPW5ldyBvKHQpO3QuX3RmZW5naW5lPW5ldyBQdChlKX1yZXR1cm4gZnVuY3Rpb24odCl7cz10fSh0Ll90ZmVuZ2luZS5FTlYpLHl0PWZ1bmN0aW9uKCl7cmV0dXJuIHQuX3RmZW5naW5lfSx0Ll90ZmVuZ2luZX0oKTtmdW5jdGlvbiBXdCgpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJm51bGwhPXdpbmRvdy5kb2N1bWVudHx8XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlfXZhciBVdD1pKCk7VXQucmVnaXN0ZXJGbGFnKFwiREVCVUdcIiwoZnVuY3Rpb24oKXtyZXR1cm4hMX0pLChmdW5jdGlvbih0KXt0JiZjb25zb2xlLndhcm4oXCJEZWJ1Z2dpbmcgbW9kZSBpcyBPTi4gVGhlIG91dHB1dCBvZiBldmVyeSBtYXRoIGNhbGwgd2lsbCBiZSBkb3dubG9hZGVkIHRvIENQVSBhbmQgY2hlY2tlZCBmb3IgTmFOcy4gVGhpcyBzaWduaWZpY2FudGx5IGltcGFjdHMgcGVyZm9ybWFuY2UuXCIpfSkpLFV0LnJlZ2lzdGVyRmxhZyhcIklTX0JST1dTRVJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gV3QoKX0pKSxVdC5yZWdpc3RlckZsYWcoXCJJU19OT0RFXCIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJnZvaWQgMCE9PXByb2Nlc3MudmVyc2lvbnMmJnZvaWQgMCE9PXByb2Nlc3MudmVyc2lvbnMubm9kZX0pKSxVdC5yZWdpc3RlckZsYWcoXCJJU19DSFJPTUVcIiwoZnVuY3Rpb24oKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZudWxsIT1uYXZpZ2F0b3ImJm51bGwhPW5hdmlnYXRvci51c2VyQWdlbnQmJi9DaHJvbWUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJi9Hb29nbGUgSW5jLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpfSkpLFV0LnJlZ2lzdGVyRmxhZyhcIlBST0RcIiwoZnVuY3Rpb24oKXtyZXR1cm4hMX0pKSxVdC5yZWdpc3RlckZsYWcoXCJURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFV0LmdldEJvb2woXCJERUJVR1wiKX0pKSxVdC5yZWdpc3RlckZsYWcoXCJERVBSRUNBVElPTl9XQVJOSU5HU19FTkFCTEVEXCIsKGZ1bmN0aW9uKCl7cmV0dXJuITB9KSksVXQucmVnaXN0ZXJGbGFnKFwiSVNfVEVTVFwiLChmdW5jdGlvbigpe3JldHVybiExfSkpO3ZhciBWdCx6dCxHdCxIdD17fSxxdD17YWxwaGE6ITEsYW50aWFsaWFzOiExLHByZW11bHRpcGxpZWRBbHBoYTohMSxwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6ITEsZGVwdGg6ITEsc3RlbmNpbDohMSxmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiEwfTtmdW5jdGlvbiBLdCh0LGUpe0h0W3RdPWV9ZnVuY3Rpb24ganQodCl7dCBpbiBIdHx8KEh0W3RdPWZ1bmN0aW9uKHQpe2lmKDEhPT10JiYyIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LCBXZWJHTCBpcyBkaXNhYmxlZC5cIik7dmFyIGU9ZnVuY3Rpb24odCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIE9mZnNjcmVlbkNhbnZhcyYmMj09PXQpcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMzAwLDE1MCk7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50KXJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgYSBjYW52YXMgaW4gdGhpcyBjb250ZXh0XCIpfSh0KTtpZihlLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJnbGNvbnRleHRsb3N0XCIsKGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKSxkZWxldGUgSHRbdF19KSwhMSksMT09PXQpcmV0dXJuIGUuZ2V0Q29udGV4dChcIndlYmdsXCIscXQpfHxlLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIixxdCk7cmV0dXJuIGUuZ2V0Q29udGV4dChcIndlYmdsMlwiLHF0KX0odCkpO3ZhciBlPUh0W3RdO3JldHVybiBlLmlzQ29udGV4dExvc3QoKT8oZGVsZXRlIEh0W3RdLGp0KHQpKTooZS5kaXNhYmxlKGUuREVQVEhfVEVTVCksZS5kaXNhYmxlKGUuU1RFTkNJTF9URVNUKSxlLmRpc2FibGUoZS5CTEVORCksZS5kaXNhYmxlKGUuRElUSEVSKSxlLmRpc2FibGUoZS5QT0xZR09OX09GRlNFVF9GSUxMKSxlLmRpc2FibGUoZS5TQU1QTEVfQ09WRVJBR0UpLGUuZW5hYmxlKGUuU0NJU1NPUl9URVNUKSxlLmVuYWJsZShlLkNVTExfRkFDRSksZS5jdWxsRmFjZShlLkJBQ0spLEh0W3RdKX1mdW5jdGlvbiBYdCh0LGUpe3JldHVybltlLHRdfWZ1bmN0aW9uIFl0KHQpe3ZhciBlPWsodCk7cmV0dXJuIEQoTWF0aC5jZWlsKGUvNCkpfWZ1bmN0aW9uICR0KHQsZSl7cmV0dXJuW01hdGgubWF4KDEsTWF0aC5jZWlsKGUvMikpLE1hdGgubWF4KDEsTWF0aC5jZWlsKHQvMikpXX1mdW5jdGlvbiBRdCh0LGUpe3ZhciBuLHIsbyxhLHMsdSxjLGwsaCxmPXQ7cmV0dXJuIDI9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT8obj1mLlIzMkYscj1mLlIxNkYsbz1mLlJHQkExNkYsYT1mLlJHQkEzMkYscz1mLlJFRCx1PTQsYz0xLGw9Zi5IQUxGX0ZMT0FULGg9Zi5GTE9BVCk6KG49dC5SR0JBLHI9dC5SR0JBLG89dC5SR0JBLGE9Zi5SR0JBLHM9dC5SR0JBLHU9NCxjPTQsbD1udWxsIT1lP2UuSEFMRl9GTE9BVF9PRVM6bnVsbCxoPXQuRkxPQVQpLHtpbnRlcm5hbEZvcm1hdEZsb2F0Om4saW50ZXJuYWxGb3JtYXRIYWxmRmxvYXQ6cixpbnRlcm5hbEZvcm1hdFBhY2tlZEhhbGZGbG9hdDpvLGludGVybmFsRm9ybWF0UGFja2VkRmxvYXQ6YSx0ZXh0dXJlRm9ybWF0RmxvYXQ6cyxkb3dubG9hZFRleHR1cmVGb3JtYXQ6dC5SR0JBLGRvd25sb2FkVW5wYWNrTnVtQ2hhbm5lbHM6dSxkZWZhdWx0TnVtQ2hhbm5lbHM6Yyx0ZXh0dXJlVHlwZUhhbGZGbG9hdDpsLHRleHR1cmVUeXBlRmxvYXQ6aH19ZnVuY3Rpb24gSnQodCxlLG4pe3ZhciByPW4oKTtyZXR1cm4gZSYmZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFcnJvcigpO2lmKGUhPT10Lk5PX0VSUk9SKXRocm93IG5ldyBFcnJvcihcIldlYkdMIEVycm9yOiBcIituZSh0LGUpKX0odCkscn0hZnVuY3Rpb24odCl7dFt0LkRFTlNFPTBdPVwiREVOU0VcIix0W3QuU0hBUkVEX0JBVENIPTFdPVwiU0hBUkVEX0JBVENIXCJ9KFZ0fHwoVnQ9e30pKSxmdW5jdGlvbih0KXt0W3QuUkVOREVSPTBdPVwiUkVOREVSXCIsdFt0LlVQTE9BRD0xXT1cIlVQTE9BRFwiLHRbdC5QSVhFTFM9Ml09XCJQSVhFTFNcIix0W3QuRE9XTkxPQUQ9M109XCJET1dOTE9BRFwifSh6dHx8KHp0PXt9KSksZnVuY3Rpb24odCl7dFt0LlVOUEFDS0VEX0ZMT0FUMTY9MF09XCJVTlBBQ0tFRF9GTE9BVDE2XCIsdFt0LlVOUEFDS0VEX0ZMT0FUMzI9MV09XCJVTlBBQ0tFRF9GTE9BVDMyXCIsdFt0LlBBQ0tFRF80WDFfVU5TSUdORURfQllURT0yXT1cIlBBQ0tFRF80WDFfVU5TSUdORURfQllURVwiLHRbdC5QQUNLRURfMlgyX0ZMT0FUMzI9M109XCJQQUNLRURfMlgyX0ZMT0FUMzJcIix0W3QuUEFDS0VEXzJYMl9GTE9BVDE2PTRdPVwiUEFDS0VEXzJYMl9GTE9BVDE2XCJ9KEd0fHwoR3Q9e30pKTt2YXIgWnQ9NS45NmUtOCx0ZT02NTUwNDtmdW5jdGlvbiBlZSh0KXtyZXR1cm4hIShpKCkuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIil8fDA9PT10fHxadDxNYXRoLmFicyh0KSYmTWF0aC5hYnModCk8dGUpfWZ1bmN0aW9uIG5lKHQsZSl7c3dpdGNoKGUpe2Nhc2UgdC5OT19FUlJPUjpyZXR1cm5cIk5PX0VSUk9SXCI7Y2FzZSB0LklOVkFMSURfRU5VTTpyZXR1cm5cIklOVkFMSURfRU5VTVwiO2Nhc2UgdC5JTlZBTElEX1ZBTFVFOnJldHVyblwiSU5WQUxJRF9WQUxVRVwiO2Nhc2UgdC5JTlZBTElEX09QRVJBVElPTjpyZXR1cm5cIklOVkFMSURfT1BFUkFUSU9OXCI7Y2FzZSB0LklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOnJldHVyblwiSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT05cIjtjYXNlIHQuT1VUX09GX01FTU9SWTpyZXR1cm5cIk9VVF9PRl9NRU1PUllcIjtjYXNlIHQuQ09OVEVYVF9MT1NUX1dFQkdMOnJldHVyblwiQ09OVEVYVF9MT1NUX1dFQkdMXCI7ZGVmYXVsdDpyZXR1cm5cIlVua25vd24gZXJyb3IgY29kZSBcIitlfX1mdW5jdGlvbiByZSh0LGUsbil7cmV0dXJuIGtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5nZXRFeHRlbnNpb24obil9KSwnRXh0ZW5zaW9uIFwiJytuKydcIiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKX1mdW5jdGlvbiBvZSh0LGUsbil7dmFyIHI9a2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZVNoYWRlcih0LlZFUlRFWF9TSEFERVIpfSksXCJVbmFibGUgdG8gY3JlYXRlIHZlcnRleCBXZWJHTFNoYWRlci5cIik7aWYoSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnNoYWRlclNvdXJjZShyLG4pfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jb21waWxlU2hhZGVyKHIpfSkpLCExPT09dC5nZXRTaGFkZXJQYXJhbWV0ZXIocix0LkNPTVBJTEVfU1RBVFVTKSl0aHJvdyBjb25zb2xlLmxvZyh0LmdldFNoYWRlckluZm9Mb2cocikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXIuXCIpO3JldHVybiByfWZ1bmN0aW9uIGFlKHQsZSxuKXt2YXIgcj1rZSh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlU2hhZGVyKHQuRlJBR01FTlRfU0hBREVSKX0pLFwiVW5hYmxlIHRvIGNyZWF0ZSBmcmFnbWVudCBXZWJHTFNoYWRlci5cIik7aWYoSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnNoYWRlclNvdXJjZShyLG4pfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jb21waWxlU2hhZGVyKHIpfSkpLCExPT09dC5nZXRTaGFkZXJQYXJhbWV0ZXIocix0LkNPTVBJTEVfU1RBVFVTKSl0aHJvdyBmdW5jdGlvbih0LGUpe3ZhciBuPXVlLmV4ZWMoZSk7aWYobnVsbD09bilyZXR1cm4gY29uc29sZS5sb2coXCJDb3VsZG4ndCBwYXJzZSBsaW5lIG51bWJlciBpbiBlcnJvcjogXCIrZSksdm9pZCBjb25zb2xlLmxvZyh0KTtmb3IodmFyIHI9K25bMV0sbz10LnNwbGl0KFwiXFxuXCIpLGE9by5sZW5ndGgudG9TdHJpbmcoKS5sZW5ndGgrMixpPW8ubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiBOKChlKzEpLnRvU3RyaW5nKCksYSkrdH0pKSxzPTAsdT0wO3U8aS5sZW5ndGg7dSsrKXM9TWF0aC5tYXgoaVt1XS5sZW5ndGgscyk7dmFyIGM9aS5zbGljZSgwLHItMSksbD1pLnNsaWNlKHItMSxyKSxoPWkuc2xpY2Uocik7Y29uc29sZS5sb2coYy5qb2luKFwiXFxuXCIpKSxjb25zb2xlLmxvZyhlLnNwbGl0KFwiXFxuXCIpWzBdKSxjb25zb2xlLmxvZyhcIiVjIFwiK04obFswXSxzKSxcImJvcmRlcjoxcHggc29saWQgcmVkOyBiYWNrZ3JvdW5kLWNvbG9yOiNlM2QyZDI7IGNvbG9yOiNhNjE3MTdcIiksY29uc29sZS5sb2coaC5qb2luKFwiXFxuXCIpKX0obix0LmdldFNoYWRlckluZm9Mb2cocikpLG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb21waWxlIGZyYWdtZW50IHNoYWRlci5cIik7cmV0dXJuIHJ9dmFyIGllLHNlLHVlPS9FUlJPUjogWzAtOV0rOihbMC05XSspOi9nO2Z1bmN0aW9uIGNlKHQsZSl7cmV0dXJuIGtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVQcm9ncmFtKCl9KSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xQcm9ncmFtLlwiKX1mdW5jdGlvbiBsZSh0LGUsbil7aWYoSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmxpbmtQcm9ncmFtKG4pfSkpLCExPT09dC5nZXRQcm9ncmFtUGFyYW1ldGVyKG4sdC5MSU5LX1NUQVRVUykpdGhyb3cgY29uc29sZS5sb2codC5nZXRQcm9ncmFtSW5mb0xvZyhuKSksbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxpbmsgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLlwiKX1mdW5jdGlvbiBoZSh0LGUsbil7aWYoSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnZhbGlkYXRlUHJvZ3JhbShuKX0pKSwhMT09PXQuZ2V0UHJvZ3JhbVBhcmFtZXRlcihuLHQuVkFMSURBVEVfU1RBVFVTKSl0aHJvdyBjb25zb2xlLmxvZyh0LmdldFByb2dyYW1JbmZvTG9nKG4pKSxuZXcgRXJyb3IoXCJTaGFkZXIgcHJvZ3JhbSB2YWxpZGF0aW9uIGZhaWxlZC5cIil9ZnVuY3Rpb24gZmUodCxlLG4pe3ZhciByPWtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVCdWZmZXIoKX0pLFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlclwiKTtyZXR1cm4gSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5BUlJBWV9CVUZGRVIscil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJ1ZmZlckRhdGEodC5BUlJBWV9CVUZGRVIsbix0LlNUQVRJQ19EUkFXKX0pKSxyfWZ1bmN0aW9uIGRlKHQsZSxuKXt2YXIgcj1rZSh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuY3JlYXRlQnVmZmVyKCl9KSxcIlVuYWJsZSB0byBjcmVhdGUgV2ViR0xCdWZmZXJcIik7cmV0dXJuIEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuRUxFTUVOVF9BUlJBWV9CVUZGRVIscil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJ1ZmZlckRhdGEodC5FTEVNRU5UX0FSUkFZX0JVRkZFUixuLHQuU1RBVElDX0RSQVcpfSkpLHJ9ZnVuY3Rpb24gcGUodCxlKXtyZXR1cm4ga2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmNyZWF0ZVRleHR1cmUoKX0pLFwiVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTFRleHR1cmUuXCIpfWZ1bmN0aW9uIHZlKHQsZSl7dmFyIG49aSgpLmdldE51bWJlcihcIldFQkdMX01BWF9URVhUVVJFX1NJWkVcIik7aWYodDw9MHx8ZTw9MCl7dmFyIHI9XCJbXCIrdCtcInhcIitlK1wiXVwiO3Rocm93IG5ldyBFcnJvcihcIlJlcXVlc3RlZCB0ZXh0dXJlIHNpemUgXCIrcitcIiBpcyBpbnZhbGlkLlwiKX1pZih0Pm58fGU+bil7cj1cIltcIit0K1wieFwiK2UrXCJdXCI7dGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdGVkIHRleHR1cmUgc2l6ZSBcIityK1wiIGdyZWF0ZXIgdGhhbiBXZWJHTCBtYXhpbXVtIG9uIHRoaXMgYnJvd3NlciAvIEdQVSBcIisoXCJbXCIrbitcInhcIituK1wiXVwiKStcIi5cIil9fWZ1bmN0aW9uIGdlKHQsZSl7cmV0dXJuIGtlKHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5jcmVhdGVGcmFtZWJ1ZmZlcigpfSksXCJVbmFibGUgdG8gY3JlYXRlIFdlYkdMRnJhbWVidWZmZXIuXCIpfWZ1bmN0aW9uIG1lKHQsZSxuLHIsbyxhLGkscyl7dmFyIHU9dC5nZXRBdHRyaWJMb2NhdGlvbihuLHIpO3JldHVybi0xIT09dSYmKEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuQVJSQVlfQlVGRkVSLG8pfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHUsYSx0LkZMT0FULCExLGkscyl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHUpfSkpLCEwKX1mdW5jdGlvbiB5ZSh0LGUsbixyKXtTZSh0LHIpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5hY3RpdmVUZXh0dXJlKHQuVEVYVFVSRTArcil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxuKX0pKX1mdW5jdGlvbiB4ZSh0LGUsbixyKXtyZXR1cm4ga2UodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmdldFVuaWZvcm1Mb2NhdGlvbihuLHIpfSksJ3VuaWZvcm0gXCInK3IrJ1wiIG5vdCBwcmVzZW50IGluIHByb2dyYW0uJyl9ZnVuY3Rpb24gYmUodCxlLG4pe3JldHVybiB0LmdldFVuaWZvcm1Mb2NhdGlvbihlLG4pfWZ1bmN0aW9uIHdlKHQsZSxuLHIsbyxhKXtKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHllKHQsZSxyLGEpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC51bmlmb3JtMWkobyxhKX0pKX1mdW5jdGlvbiBDZSh0LGUsbixyKXtKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIscil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHQuRlJBTUVCVUZGRVIsdC5DT0xPUl9BVFRBQ0hNRU5UMCx0LlRFWFRVUkVfMkQsbiwwKX0pKX1mdW5jdGlvbiBFZSh0LGUsbil7SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG4pfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELG51bGwsMCl9KSl9ZnVuY3Rpb24gUmUodCl7dmFyIGU9dC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHQuRlJBTUVCVUZGRVIpO2lmKGUhPT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGJpbmRpbmcgZnJhbWVidWZmZXI6IFwiK0llKHQsZSkpfWZ1bmN0aW9uIEllKHQsZSl7c3dpdGNoKGUpe2Nhc2UgdC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIjtjYXNlIHQuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVFwiO2Nhc2UgdC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6cmV0dXJuXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlNcIjtjYXNlIHQuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6cmV0dXJuXCJGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRFwiO2RlZmF1bHQ6cmV0dXJuXCJ1bmtub3duIGVycm9yIFwiK2V9fWZ1bmN0aW9uIGtlKHQsZSxuLHIpe3ZhciBvPUp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gbigpfSkpO2lmKG51bGw9PW8pdGhyb3cgbmV3IEVycm9yKHIpO3JldHVybiBvfWZ1bmN0aW9uIFNlKHQsZSl7dmFyIG49dC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUy0xLHI9ZSt0LlRFWFRVUkUwO2lmKHI8dC5URVhUVVJFMHx8cj5uKXRocm93IG5ldyBFcnJvcihcInRleHR1cmVVbml0IG11c3QgYmUgaW4gXCIrKFwiW2dsLlRFWFRVUkUwLCBnbC5URVhUVVJFXCIrbitcIl1cIikrXCIuXCIpfWZ1bmN0aW9uIEFlKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPTIpLGsodC5zbGljZSgwLHQubGVuZ3RoLWUpKX1mdW5jdGlvbiBUZSh0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuXCIpO3JldHVyblt0Lmxlbmd0aD4xP3RbdC5sZW5ndGgtMl06MSx0W3QubGVuZ3RoLTFdXX1mdW5jdGlvbiBEZSh0KXt2YXIgZT1bMSwxLDFdO3JldHVybiAwPT09dC5sZW5ndGh8fDE9PT10Lmxlbmd0aCYmMT09PXRbMF18fChlPVtBZSh0KV0uY29uY2F0KFRlKHQpKSksZX1mdW5jdGlvbiBOZSh0LGUpe3ZhciBuO3ZvaWQgMD09PWUmJihlPSExKTt2YXIgcj1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfTUFYX1RFWFRVUkVfU0laRVwiKTtpZihlJiYocio9MiwxPT09KHQ9dC5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIG4+PXQubGVuZ3RoLTI/Yih0W25dKTp0W25dfSkpKS5sZW5ndGgmJih0PVsyLHRbMF1dKSksMiE9PXQubGVuZ3RoKXt2YXIgbz1NKHQpO3Q9by5uZXdTaGFwZX12YXIgYT1rKHQpO2lmKHQubGVuZ3RoPD0xJiZhPD1yKXJldHVyblsxLGFdO2lmKDI9PT10Lmxlbmd0aCYmdFswXTw9ciYmdFsxXTw9cilyZXR1cm4gdDtpZigzPT09dC5sZW5ndGgmJnRbMF0qdFsxXTw9ciYmdFsyXTw9cilyZXR1cm5bdFswXSp0WzFdLHRbMl1dO2lmKDM9PT10Lmxlbmd0aCYmdFswXTw9ciYmdFsxXSp0WzJdPD1yKXJldHVyblt0WzBdLHRbMV0qdFsyXV07aWYoND09PXQubGVuZ3RoJiZ0WzBdKnRbMV0qdFsyXTw9ciYmdFszXTw9cilyZXR1cm5bdFswXSp0WzFdKnRbMl0sdFszXV07aWYoND09PXQubGVuZ3RoJiZ0WzBdPD1yJiZ0WzFdKnRbMl0qdFszXTw9cilyZXR1cm5bdFswXSx0WzFdKnRbMl0qdFszXV07aWYoZSl7dmFyIHM9QWUodCksdT0yLGM9MjtyZXR1cm4gdC5sZW5ndGgmJih1PShuPVRlKHQpKVswXSxjPW5bMV0pLEQoYT1zKih1LzIpKihjLzIpKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiAyKnR9KSl9cmV0dXJuIEQoYSl9ZnVuY3Rpb24gRmUodCl7cmV0dXJuIHQlMj09MH1mdW5jdGlvbiBfZSh0LGUpe2lmKFModD10LnNsaWNlKC0yKSxlPWUuc2xpY2UoLTIpKSlyZXR1cm4hMDtpZighdC5sZW5ndGh8fCFlLmxlbmd0aClyZXR1cm4hMDtpZigwPT09dFswXXx8MD09PXRbMV18fDA9PT1lWzBdfHwwPT09ZVsxXSlyZXR1cm4hMDtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXt2YXIgbj10LnNsaWNlKC0xKVswXSxyPWUuc2xpY2UoLTEpWzBdO2lmKG49PT1yKXJldHVybiEwO2lmKEZlKG4pJiZGZShyKSYmKDE9PT10WzBdfHwxPT09ZVswXSkpcmV0dXJuITB9cmV0dXJuIHRbMV09PT1lWzFdJiZGZSh0WzBdKSYmRmUoZVswXSl9ZnVuY3Rpb24gT2UodCl7aWYobnVsbD09aWUpe3ZhciBlPWp0KHQpO2llPWUuZ2V0UGFyYW1ldGVyKGUuTUFYX1RFWFRVUkVfU0laRSl9cmV0dXJuIGllfWZ1bmN0aW9uIE1lKHQpe2lmKG51bGw9PXNlKXt2YXIgZT1qdCh0KTtzZT1lLmdldFBhcmFtZXRlcihlLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKX1yZXR1cm4gTWF0aC5taW4oMTYsc2UpfWZ1bmN0aW9uIEJlKHQpe2lmKDA9PT10KXJldHVybiAwO3ZhciBlPWp0KHQpO3JldHVybiBQZShlLFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMlwiKSYmMj09PXQ/MjpQZShlLFwiRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5XCIpPzE6MH1mdW5jdGlvbiBQZSh0LGUpe3JldHVybiBudWxsIT10LmdldEV4dGVuc2lvbihlKX1mdW5jdGlvbiBMZSh0KXt0cnl7aWYobnVsbCE9anQodCkpcmV0dXJuITB9Y2F0Y2godCl7cmV0dXJuITF9cmV0dXJuITF9ZnVuY3Rpb24gV2UodCl7aWYoMD09PXQpcmV0dXJuITE7dmFyIGU9anQodCk7aWYoMT09PXQpe2lmKCFQZShlLFwiT0VTX3RleHR1cmVfZmxvYXRcIikpcmV0dXJuITF9ZWxzZSBpZighUGUoZSxcIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIikpcmV0dXJuITE7cmV0dXJuIFZlKGUpfWZ1bmN0aW9uIFVlKHQpe2lmKDA9PT10KXJldHVybiExO3ZhciBlPWp0KHQpO2lmKDEhPT10KXtpZihQZShlLFwiRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdFwiKSlyZXR1cm4gVmUoZSk7aWYoUGUoZSxcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKSl7dmFyIG49ZS5nZXRFeHRlbnNpb24oXCJFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXRcIik7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49UXQodCxlKSxyPXQuY3JlYXRlVGV4dHVyZSgpO3QuYmluZFRleHR1cmUodC5URVhUVVJFXzJELHIpO3QudGV4SW1hZ2UyRCh0LlRFWFRVUkVfMkQsMCxuLmludGVybmFsRm9ybWF0SGFsZkZsb2F0LDEsMSwwLG4udGV4dHVyZUZvcm1hdEZsb2F0LG4udGV4dHVyZVR5cGVIYWxmRmxvYXQsbnVsbCk7dmFyIG89dC5jcmVhdGVGcmFtZWJ1ZmZlcigpO3QuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbyksdC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0LkZSQU1FQlVGRkVSLHQuQ09MT1JfQVRUQUNITUVOVDAsdC5URVhUVVJFXzJELHIsMCk7dmFyIGE9dC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHQuRlJBTUVCVUZGRVIpPT09dC5GUkFNRUJVRkZFUl9DT01QTEVURTtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCksdC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixudWxsKSx0LmRlbGV0ZVRleHR1cmUociksdC5kZWxldGVGcmFtZWJ1ZmZlcihvKSxhfShlLG4pfXJldHVybiExfXJldHVybiEhUGUoZSxcIk9FU190ZXh0dXJlX2Zsb2F0XCIpJiYoISFQZShlLFwiV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0XCIpJiZWZShlKSl9ZnVuY3Rpb24gVmUodCl7dmFyIGU9UXQodCksbj10LmNyZWF0ZVRleHR1cmUoKTt0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxuKTt0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsZS5pbnRlcm5hbEZvcm1hdEZsb2F0LDEsMSwwLGUudGV4dHVyZUZvcm1hdEZsb2F0LGUudGV4dHVyZVR5cGVGbG9hdCxudWxsKTt2YXIgcj10LmNyZWF0ZUZyYW1lYnVmZmVyKCk7dC5iaW5kRnJhbWVidWZmZXIodC5GUkFNRUJVRkZFUixyKSx0LmZyYW1lYnVmZmVyVGV4dHVyZTJEKHQuRlJBTUVCVUZGRVIsdC5DT0xPUl9BVFRBQ0hNRU5UMCx0LlRFWFRVUkVfMkQsbiwwKTt2YXIgbz10LmNoZWNrRnJhbWVidWZmZXJTdGF0dXModC5GUkFNRUJVRkZFUik9PT10LkZSQU1FQlVGRkVSX0NPTVBMRVRFO3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKSx0LmJpbmRGcmFtZWJ1ZmZlcih0LkZSQU1FQlVGRkVSLG51bGwpLHQuZGVsZXRlVGV4dHVyZShuKSx0LmRlbGV0ZUZyYW1lYnVmZmVyKHIpLG99ZnVuY3Rpb24gemUodCl7cmV0dXJuIDI9PT10JiZudWxsIT1qdCh0KS5mZW5jZVN5bmN9dmFyIEdlPU9iamVjdC5mcmVlemUoe2NhbGxBbmRDaGVjazpKdCxjYW5CZVJlcHJlc2VudGVkOmVlLGdldFdlYkdMRXJyb3JNZXNzYWdlOm5lLGdldEV4dGVuc2lvbk9yVGhyb3c6cmUsY3JlYXRlVmVydGV4U2hhZGVyOm9lLGNyZWF0ZUZyYWdtZW50U2hhZGVyOmFlLGNyZWF0ZVByb2dyYW06Y2UsbGlua1Byb2dyYW06bGUsdmFsaWRhdGVQcm9ncmFtOmhlLGNyZWF0ZVN0YXRpY1ZlcnRleEJ1ZmZlcjpmZSxjcmVhdGVTdGF0aWNJbmRleEJ1ZmZlcjpkZSxnZXROdW1DaGFubmVsczpmdW5jdGlvbigpe3JldHVybiAyPT09aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIik/MTo0fSxjcmVhdGVUZXh0dXJlOnBlLHZhbGlkYXRlVGV4dHVyZVNpemU6dmUsY3JlYXRlRnJhbWVidWZmZXI6Z2UsYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZTptZSxiaW5kVGV4dHVyZVVuaXQ6eWUsdW5iaW5kVGV4dHVyZVVuaXQ6ZnVuY3Rpb24odCxlLG4pe1NlKHQsbiksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmFjdGl2ZVRleHR1cmUodC5URVhUVVJFMCtuKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG51bGwpfSkpfSxnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdzp4ZSxnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uOmJlLGJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXI6d2UsYmluZENhbnZhc1RvRnJhbWVidWZmZXI6ZnVuY3Rpb24odCxlKXtKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEZyYW1lYnVmZmVyKHQuRlJBTUVCVUZGRVIsbnVsbCl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnZpZXdwb3J0KDAsMCx0LmNhbnZhcy53aWR0aCx0LmNhbnZhcy5oZWlnaHQpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5zY2lzc29yKDAsMCx0LmNhbnZhcy53aWR0aCx0LmNhbnZhcy5oZWlnaHQpfSkpfSxiaW5kQ29sb3JUZXh0dXJlVG9GcmFtZWJ1ZmZlcjpDZSx1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXI6RWUsdmFsaWRhdGVGcmFtZWJ1ZmZlcjpSZSxnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZTpJZSxnZXRCYXRjaERpbTpBZSxnZXRSb3dzQ29sczpUZSxnZXRTaGFwZUFzM0Q6RGUsZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZTpOZSxpc1Jlc2hhcGVGcmVlOl9lLGdldFdlYkdMTWF4VGV4dHVyZVNpemU6T2UscmVzZXRNYXhUZXh0dXJlU2l6ZTpmdW5jdGlvbigpe2llPW51bGx9LHJlc2V0TWF4VGV4dHVyZXNJblNoYWRlcjpmdW5jdGlvbigpe3NlPW51bGx9LGdldE1heFRleHR1cmVzSW5TaGFkZXI6TWUsZ2V0V2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJWZXJzaW9uOkJlLGhhc0V4dGVuc2lvbjpQZSxpc1dlYkdMVmVyc2lvbkVuYWJsZWQ6TGUsaXNDYXBhYmxlT2ZSZW5kZXJpbmdUb0Zsb2F0VGV4dHVyZTpXZSxpc0Rvd25sb2FkRmxvYXRUZXh0dXJlRW5hYmxlZDpVZSxpc1dlYkdMRmVuY2VFbmFibGVkOnplfSksSGU9aSgpO2Z1bmN0aW9uIHFlKCl7aSgpLnNldChcIlBST0RcIiwhMCl9ZnVuY3Rpb24gS2UoKXtpKCkuc2V0KFwiREVCVUdcIiwhMCl9ZnVuY3Rpb24gamUoKXtpKCkuc2V0KFwiREVQUkVDQVRJT05fV0FSTklOR1NfRU5BQkxFRFwiLCExKSxjb25zb2xlLndhcm4oXCJUZW5zb3JGbG93LmpzIGRlcHJlY2F0aW9uIHdhcm5pbmdzIGhhdmUgYmVlbiBkaXNhYmxlZC5cIil9ZnVuY3Rpb24gWGUodCl7aSgpLmdldEJvb2woXCJERVBSRUNBVElPTl9XQVJOSU5HU19FTkFCTEVEXCIpJiZjb25zb2xlLndhcm4odCtcIiBZb3UgY2FuIGRpc2FibGUgZGVwcmVjYXRpb24gd2FybmluZ3Mgd2l0aCB0Zi5kaXNhYmxlRGVwcmVjYXRpb25XYXJuaW5ncygpLlwiKX1mdW5jdGlvbiBZZSgpe0x0LmRpc3Bvc2VWYXJpYWJsZXMoKX1mdW5jdGlvbiAkZSgpe3JldHVybiBMdH1mdW5jdGlvbiBRZSgpe3JldHVybiBMdC5tZW1vcnkoKX1mdW5jdGlvbiBKZSh0KXtyZXR1cm4gTHQucHJvZmlsZSh0KX1mdW5jdGlvbiBaZSh0LGUpe3JldHVybiBMdC50aWR5KHQsZSl9ZnVuY3Rpb24gdG4odCl7X3QodCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGlzcG9zZSgpfSkpfWZ1bmN0aW9uIGVuKHQpe3JldHVybiBMdC5rZWVwKHQpfWZ1bmN0aW9uIG5uKHQpe3JldHVybiBMdC50aW1lKHQpfWZ1bmN0aW9uIHJuKHQpe3JldHVybiBMdC5zZXRCYWNrZW5kKHQpfWZ1bmN0aW9uIG9uKCl7cmV0dXJuIEx0LnJlYWR5KCl9ZnVuY3Rpb24gYW4oKXtyZXR1cm4gTHQuYmFja2VuZE5hbWV9ZnVuY3Rpb24gc24odCl7THQucmVtb3ZlQmFja2VuZCh0KX1mdW5jdGlvbiB1bih0KXtyZXR1cm4gTHQuZmluZEJhY2tlbmQodCl9ZnVuY3Rpb24gY24odCl7cmV0dXJuIEx0LmZpbmRCYWNrZW5kRmFjdG9yeSh0KX1mdW5jdGlvbiBsbih0LGUsbil7cmV0dXJuIHZvaWQgMD09PW4mJihuPTEpLEx0LnJlZ2lzdGVyQmFja2VuZCh0LGUsbil9ZnVuY3Rpb24gaG4oKXtyZXR1cm4gTHQuYmFja2VuZH1mdW5jdGlvbiBmbih0LGUpe2koKS5zZXRQbGF0Zm9ybSh0LGUpfWZ1bmN0aW9uIGRuKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdO2koKS5nZXRCb29sKFwiSVNfVEVTVFwiKXx8Y29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsdCl9ZnVuY3Rpb24gcG4odCxlKXt2YXIgbj10O2lmKFYodCkpcmV0dXJuXCJzdHJpbmdcIj09PWU/W106W3QubGVuZ3RoXTtpZighQXJyYXkuaXNBcnJheSh0KSlyZXR1cm5bXTtmb3IodmFyIHI9W107QXJyYXkuaXNBcnJheShuKXx8VihuKSYmXCJzdHJpbmdcIiE9PWU7KXIucHVzaChuLmxlbmd0aCksbj1uWzBdO3JldHVybiBBcnJheS5pc0FycmF5KHQpJiZpKCkuZ2V0Qm9vbChcIlRFTlNPUkxJS0VfQ0hFQ0tfU0hBUEVfQ09OU0lTVEVOQ1lcIikmJmZ1bmN0aW9uIHQoZSxuLHIpe2lmKHI9cnx8W10sIUFycmF5LmlzQXJyYXkoZSkmJiFWKGUpKXJldHVybiB2b2lkIEMoMD09PW4ubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRWxlbWVudCBhcnJbXCIrci5qb2luKFwiXVtcIikrXCJdIGlzIGEgcHJpbWl0aXZlLCBidXQgc2hvdWxkIGJlIGFuIGFycmF5L1R5cGVkQXJyYXkgb2YgXCIrblswXStcIiBlbGVtZW50c1wifSkpO0Mobi5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVsZW1lbnQgYXJyW1wiK3Iuam9pbihcIl1bXCIpK1wiXSBzaG91bGQgYmUgYSBwcmltaXRpdmUsIGJ1dCBpcyBhbiBhcnJheSBvZiBcIitlLmxlbmd0aCtcIiBlbGVtZW50c1wifSkpLEMoZS5sZW5ndGg9PT1uWzBdLChmdW5jdGlvbigpe3JldHVyblwiRWxlbWVudCBhcnJbXCIrci5qb2luKFwiXVtcIikrXCJdIHNob3VsZCBoYXZlIFwiK25bMF0rXCIgZWxlbWVudHMsIGJ1dCBoYXMgXCIrZS5sZW5ndGgrXCIgZWxlbWVudHNcIn0pKTtmb3IodmFyIG89bi5zbGljZSgxKSxhPTA7YTxlLmxlbmd0aDsrK2EpdChlW2FdLG8sci5jb25jYXQoYSkpfSh0LHIsW10pLHJ9ZnVuY3Rpb24gdm4odCxlLG4scil7aWYobnVsbCE9dCYmKFwibnVtZXJpY1wiIT09dCYmdCE9PWV8fFwibnVtZXJpY1wiPT09dCYmXCJzdHJpbmdcIj09PWUpKXRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50ICdcIituK1wiJyBwYXNzZWQgdG8gJ1wiK3IrXCInIG11c3QgYmUgXCIrdCtcIiB0ZW5zb3IsIGJ1dCBnb3QgXCIrZStcIiB0ZW5zb3JcIil9ZnVuY3Rpb24gZ24odCxlLG4scil7aWYodm9pZCAwPT09ciYmKHI9XCJudW1lcmljXCIpLHQgaW5zdGFuY2VvZiB3dClyZXR1cm4gdm4ocix0LmR0eXBlLGUsbiksdDt2YXIgbz1qKHQpO2lmKFwic3RyaW5nXCIhPT1vJiZbXCJib29sXCIsXCJpbnQzMlwiLFwiZmxvYXQzMlwiXS5pbmRleE9mKHIpPj0wJiYobz1yKSx2bihyLG8sZSxuKSxudWxsPT10fHwhVih0KSYmIUFycmF5LmlzQXJyYXkodCkmJlwibnVtYmVyXCIhPXR5cGVvZiB0JiZcImJvb2xlYW5cIiE9dHlwZW9mIHQmJlwic3RyaW5nXCIhPXR5cGVvZiB0KXt2YXIgYT1udWxsPT10P1wibnVsbFwiOnQuY29uc3RydWN0b3IubmFtZTt0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCAnXCIrZStcIicgcGFzc2VkIHRvICdcIituK1wiJyBtdXN0IGJlIGEgVGVuc29yIG9yIFRlbnNvckxpa2UsIGJ1dCBnb3QgJ1wiK2ErXCInXCIpfXZhciBzPXBuKHQsbyk7Vih0KXx8QXJyYXkuaXNBcnJheSh0KXx8KHQ9W3RdKTt2YXIgdT1cInN0cmluZ1wiIT09bz9RKHQsbyxpKCkuZ2V0Qm9vbChcIkRFQlVHXCIpKTpJKHQsW10sITApO3JldHVybiBMdC5tYWtlVGVuc29yKHUscyxvKX1mdW5jdGlvbiBtbih0LGUsbixyKXtpZih2b2lkIDA9PT1yJiYocj1cIm51bWVyaWNcIiksIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgXCIrZStcIiBwYXNzZWQgdG8gXCIrbitcIiBtdXN0IGJlIGEgYFRlbnNvcltdYCBvciBgVGVuc29yTGlrZVtdYFwiKTtyZXR1cm4gdC5tYXAoKGZ1bmN0aW9uKHQscil7cmV0dXJuIGduKHQsZStcIltcIityK1wiXVwiLG4pfSkscil9ZnVuY3Rpb24geW4odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoOysrbilpZih0W3QubGVuZ3RoLW4tMV0hPT1lLTEtbilyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiB4bih0LGUsbil7Zm9yKHZhciByPXQubGVuZ3RoK2UubGVuZ3RoLG89W10sYT0wLGk9MCxzPTA7czxyO3MrKyktMT09PW4uaW5kZXhPZihzKT9vLnB1c2godFthKytdKTpvLnB1c2goZVtpKytdKTtyZXR1cm4gb31mdW5jdGlvbiBibih0LGUpe2Zvcih2YXIgbj1bXSxyPXQubGVuZ3RoLG89MDtvPHI7bysrKS0xPT09ZS5pbmRleE9mKG8pJiZuLnB1c2godFtvXSk7cmV0dXJuW24sZS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfSkpXX1mdW5jdGlvbiB3bih0LGUpe3JldHVybiB4bih0LGUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gMX0pKSxlKX1mdW5jdGlvbiBDbih0LGUsbil7Qyh5bihlLG4pLChmdW5jdGlvbigpe3JldHVybiB0K1wiIHN1cHBvcnRzIG9ubHkgaW5uZXItbW9zdCBheGVzIGZvciBub3cuIEdvdCBheGVzIFwiK2UrXCIgYW5kIHJhbmstXCIrbitcIiBpbnB1dC5cIn0pKX1mdW5jdGlvbiBFbih0LGUpe2lmKHluKHQsZSkpcmV0dXJuIG51bGw7Zm9yKHZhciBuPVtdLHI9MDtyPGU7KytyKS0xPT09dC5pbmRleE9mKHIpJiZuLnB1c2gocik7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIG4ucHVzaCh0KX0pKSxufWZ1bmN0aW9uIFJuKHQpe3JldHVybiB0Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5bZSx0XX0pKS5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiB0WzFdLWVbMV19KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pKX1mdW5jdGlvbiBJbih0LGUpe2Zvcih2YXIgbj1bXSxyPWUtdDtyPGU7KytyKW4ucHVzaChyKTtyZXR1cm4gbn1mdW5jdGlvbiBrbih0LGUpe3ZhciBuPXRbMF0ubGVuZ3RoO3QuZm9yRWFjaCgoZnVuY3Rpb24odCxlKXtDKHQubGVuZ3RoPT09biwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbmNhdFwiK24rXCJEOiByYW5rIG9mIHRlbnNvcnNbXCIrZStcIl0gbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgcmFuayBvZiB0aGUgcmVzdCAoXCIrbitcIilcIn0pKX0pKSxDKGU+PTAmJmU8biwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbmNhdFwiK24rXCJEOiBheGlzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCBcIisobi0xKStcIi5cIn0pKTt2YXIgcj10WzBdO3QuZm9yRWFjaCgoZnVuY3Rpb24odCxvKXtmb3IodmFyIGE9MDthPG47YSsrKUMoYT09PWV8fHRbYV09PT1yW2FdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29uY2F0XCIrbitcIkQ6IFNoYXBlIG9mIHRlbnNvcnNbXCIrbytcIl0gKFwiK3QrXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBzaGFwZSBvZiB0aGUgcmVzdCAoXCIrcitcIikgYWxvbmcgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhpcyBcIitvK1wiLlwifSkpfSkpfWZ1bmN0aW9uIFNuKHQsZSl7Zm9yKHZhciBuPXRbMF0uc2xpY2UoKSxyPTE7cjx0Lmxlbmd0aDtyKyspbltlXSs9dFtyXVtlXTtyZXR1cm4gbn1mdW5jdGlvbiBBbih0KXt2YXIgZT1PYmplY3Qua2V5cyh0KTtpZigxIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHByb3ZpZGUgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5IChvcGVyYXRpb24gbmFtZSkgbWFwcGluZyB0byBhIGZ1bmN0aW9uLiBHb3QgYW4gb2JqZWN0IHdpdGggXCIrZS5sZW5ndGgrXCIga2V5cy5cIik7dmFyIG49ZVswXSxyPXRbbl07bi5lbmRzV2l0aChcIl9cIikmJihuPW4uc3Vic3RyaW5nKDAsbi5sZW5ndGgtMSkpO3ZhciBvPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXRbZV09YXJndW1lbnRzW2VdO0x0LnN0YXJ0U2NvcGUobik7dHJ5e3ZhciBvPXIuYXBwbHkodm9pZCAwLHQpO3JldHVybiBvIGluc3RhbmNlb2YgUHJvbWlzZSYmY29uc29sZS5lcnJvcihcIkNhbm5vdCByZXR1cm4gYSBQcm9taXNlIGluc2lkZSBvZiB0aWR5LlwiKSxMdC5lbmRTY29wZShvKSxvfWNhdGNoKHQpe3Rocm93IEx0LmVuZFNjb3BlKG51bGwpLHR9fTtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sXCJuYW1lXCIse3ZhbHVlOm4sY29uZmlndXJhYmxlOiEwfSksb31IZS5yZWdpc3RlckZsYWcoXCJIQVNfV0VCR0xcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKT4wfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1ZFUlNJT05cIiwoZnVuY3Rpb24oKXtyZXR1cm4gTGUoMik/MjpMZSgxKT8xOjB9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfQlVGRkVSX1NVUFBPUlRFRFwiLChmdW5jdGlvbigpe3JldHVybiAyPT09SGUuZ2V0KFwiV0VCR0xfVkVSU0lPTlwiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9DUFVfRk9SV0FSRFwiLChmdW5jdGlvbigpe3JldHVybiEwfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0ZPUkNFX0YxNl9URVhUVVJFU1wiLChmdW5jdGlvbigpe3JldHVybiExfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIkhBU19XRUJHTFwiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX05PUk1BTElaQVRJT05cIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19DTElQXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVlwiLChmdW5jdGlvbigpe3JldHVybiExfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEhlLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9QQUNLX0lNQUdFX09QRVJBVElPTlNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUEFDS19SRURVQ0VcIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIil9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfTEFaSUxZX1VOUEFDS1wiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9DT05WX0lNMkNPTFwiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9NQVhfVEVYVFVSRV9TSVpFXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIE9lKEhlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX01BWF9URVhUVVJFU19JTl9TSEFERVJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gTWUoSGUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIiwoZnVuY3Rpb24oKXt2YXIgdD1IZS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpO3JldHVybiAwPT09dD8wOkJlKHQpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiLChmdW5jdGlvbigpe3JldHVybiBIZS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wJiYodD1uYXZpZ2F0b3IudXNlckFnZW50fHxuYXZpZ2F0b3IudmVuZG9yfHx3aW5kb3cub3BlcmEsISgvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2kudGVzdCh0KXx8LzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdCh0LnN1YnN0cigwLDQpKSkpO3ZhciB0fSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0NBUEFCTEVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gV2UoSGUuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl9KSksSGUucmVnaXN0ZXJGbGFnKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRFwiLChmdW5jdGlvbigpe3JldHVybiFIZS5nZXRCb29sKFwiV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTXCIpJiZIZS5nZXRCb29sKFwiV0VCR0xfUkVOREVSX0ZMT0FUMzJfQ0FQQUJMRVwiKX0pKSxIZS5yZWdpc3RlckZsYWcoXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFVlKEhlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX0ZFTkNFX0FQSV9FTkFCTEVEXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIHplKEhlLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpfSkpLEhlLnJlZ2lzdGVyRmxhZyhcIldFQkdMX1NJWkVfVVBMT0FEX1VOSUZPUk1cIiwoZnVuY3Rpb24oKXtyZXR1cm4gSGUuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIik/NDowfSkpLGJ0PVhlO3ZhciBUbj1Bbih7Y29tcGxleF86ZnVuY3Rpb24odCxlKXt2YXIgbj1nbih0LFwicmVhbFwiLFwiY29tcGxleFwiKSxyPWduKGUsXCJpbWFnXCIsXCJjb21wbGV4XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcInJlYWwgYW5kIGltYWcgc2hhcGVzLCBcIituLnNoYXBlK1wiIGFuZCBcIityLnNoYXBlK1wiLCBtdXN0IG1hdGNoIGluIGNhbGwgdG8gdGYuY29tcGxleCgpLlwiKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb21wbGV4KG4scil9KSx7JHJlYWw6biwkaW1hZzpyfSl9fSksRG49QW4oe3JlYWxfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJpbnB1dFwiLFwicmVhbFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVhbChlKX0pLHskaW5wdXQ6ZX0pfX0pLE5uPUFuKHtpbWFnXzpmdW5jdGlvbih0KXt2YXIgZT1nbih0LFwiaW5wdXRcIixcImltYWdcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmltYWcoZSl9KSx7JGlucHV0OmV9KX19KTtmdW5jdGlvbiBGbih0LGUsbil7cmV0dXJuIF9uKHQsZSxwbih0LG4pLG4pfWZ1bmN0aW9uIF9uKHQsZSxuLHIpe2lmKG51bGw9PXImJihyPWoodCkpLFwiY29tcGxleDY0XCI9PT1yKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgYSBjb21wbGV4NjQgdGVuc29yIGRpcmVjdGx5LiBQbGVhc2UgdXNlIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO2lmKCFWKHQpJiYhQXJyYXkuaXNBcnJheSh0KSYmXCJudW1iZXJcIiE9dHlwZW9mIHQmJlwiYm9vbGVhblwiIT10eXBlb2YgdCYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKFwidmFsdWVzIHBhc3NlZCB0byB0ZW5zb3IodmFsdWVzKSBtdXN0IGJlIGEgbnVtYmVyL2Jvb2xlYW4vc3RyaW5nIG9yIGFuIGFycmF5IG9mIG51bWJlcnMvYm9vbGVhbnMvc3RyaW5ncywgb3IgYSBUeXBlZEFycmF5XCIpO2lmKG51bGwhPWUpe250KGUpO3ZhciBvPWsoZSksYT1rKG4pO0Mobz09PWEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJCYXNlZCBvbiB0aGUgcHJvdmlkZWQgc2hhcGUsIFtcIitlK1wiXSwgdGhlIHRlbnNvciBzaG91bGQgaGF2ZSBcIitvK1wiIHZhbHVlcyBidXQgaGFzIFwiK2F9KSk7Zm9yKHZhciBzPTA7czxuLmxlbmd0aDsrK3Mpe3ZhciB1PW5bc10sYz1zIT09bi5sZW5ndGgtMXx8dSE9PWsoZS5zbGljZShzKSk7QyhuW3NdPT09ZVtzXXx8IWMsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBjcmVhdGluZyBhIG5ldyBUZW5zb3IuIEluZmVycmVkIHNoYXBlIChcIituK1wiKSBkb2VzIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgc2hhcGUgKFwiK2UrXCIpLiBcIn0pKX19cmV0dXJuIFYodCl8fEFycmF5LmlzQXJyYXkodCl8fCh0PVt0XSksZT1lfHxuLHQ9XCJzdHJpbmdcIiE9PXI/USh0LHIsaSgpLmdldEJvb2woXCJERUJVR1wiKSk6SSh0LFtdLCEwKSxMdC5tYWtlVGVuc29yKHQsZSxyKX1mdW5jdGlvbiBPbih0LGUpe2lmKChWKHQpJiZcInN0cmluZ1wiIT09ZXx8QXJyYXkuaXNBcnJheSh0KSkmJlwiY29tcGxleDY0XCIhPT1lKXRocm93IG5ldyBFcnJvcihcIkVycm9yIGNyZWF0aW5nIGEgbmV3IFNjYWxhcjogdmFsdWUgbXVzdCBiZSBhIHByaW1pdGl2ZSAobnVtYmVyfGJvb2xlYW58c3RyaW5nKVwiKTtpZihcInN0cmluZ1wiPT09ZSYmVih0KSYmISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBtYWtpbmcgYSBzY2FsYXIgZnJvbSBlbmNvZGVkIHN0cmluZywgdGhlIHZhbHVlIG11c3QgYmUgYFVpbnQ4QXJyYXlgLlwiKTtyZXR1cm4gX24odCxbXSxbXSxlKX1mdW5jdGlvbiBNbih0LGUpe1IodCk7dmFyIG49cG4odCxlKTtpZigxIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMWQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgYSBmbGF0L1R5cGVkQXJyYXlcIik7cmV0dXJuIF9uKHQsbnVsbCxuLGUpfWZ1bmN0aW9uIEJuKHQsZSxuKXtpZihSKHQpLG51bGwhPWUmJjIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgdHdvIG51bWJlcnNcIik7dmFyIHI9cG4odCxuKTtpZigyIT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IyZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yMmQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQvVHlwZWRBcnJheVwiKTtyZXR1cm4gX24odCxlLHIsbil9ZnVuY3Rpb24gUG4odCxlLG4pe2lmKFIodCksbnVsbCE9ZSYmMyE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjNkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSB0aHJlZSBudW1iZXJzXCIpO3ZhciByPXBuKHQsbik7aWYoMyE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yM2QoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yM2QoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIF9uKHQsZSxyLG4pfWZ1bmN0aW9uIExuKHQsZSxuKXtpZihSKHQpLG51bGwhPWUmJjQhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I0ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgZm91ciBudW1iZXJzXCIpO3ZhciByPXBuKHQsbik7aWYoNCE9PXIubGVuZ3RoJiYxIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNGQoKSByZXF1aXJlcyB2YWx1ZXMgdG8gYmUgbnVtYmVyW11bXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I0ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gX24odCxlLHIsbil9ZnVuY3Rpb24gV24odCxlLG4pe2lmKFIodCksbnVsbCE9ZSYmNSE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRlbnNvcjVkKCkgcmVxdWlyZXMgc2hhcGUgdG8gaGF2ZSBmaXZlIG51bWJlcnNcIik7dmFyIHI9cG4odCxuKTtpZig1IT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I1ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXVtdIG9yIGZsYXQvVHlwZWRBcnJheVwiKTtpZigxPT09ci5sZW5ndGgmJm51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwidGVuc29yNWQoKSByZXF1aXJlcyBzaGFwZSB0byBiZSBwcm92aWRlZCB3aGVuIGB2YWx1ZXNgIGFyZSBhIGZsYXQgYXJyYXlcIik7cmV0dXJuIF9uKHQsZSxyLG4pfWZ1bmN0aW9uIFVuKHQsZSxuKXtpZihSKHQpLG51bGwhPWUmJjYhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I2ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGhhdmUgc2l4IG51bWJlcnNcIik7dmFyIHI9cG4odCxuKTtpZig2IT09ci5sZW5ndGgmJjEhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I2ZCgpIHJlcXVpcmVzIHZhbHVlcyB0byBiZSBudW1iZXJbXVtdW11bXVtdW10gb3IgZmxhdC9UeXBlZEFycmF5XCIpO2lmKDE9PT1yLmxlbmd0aCYmbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3I2ZCgpIHJlcXVpcmVzIHNoYXBlIHRvIGJlIHByb3ZpZGVkIHdoZW4gYHZhbHVlc2AgYXJlIGEgZmxhdCBhcnJheVwiKTtyZXR1cm4gX24odCxlPWV8fHIscixuKX1mdW5jdGlvbiBWbih0LGUsbixyKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITApLEx0Lm1ha2VWYXJpYWJsZSh0LGUsbixyKX1mdW5jdGlvbiB6bih0LGUpe2lmKHZvaWQgMD09PWUmJihlPVwiZmxvYXQzMlwiKSxcImNvbXBsZXg2NFwiPT09ZSl7dmFyIG49em4odCxcImZsb2F0MzJcIikscj1Hbih0LFwiZmxvYXQzMlwiKTtyZXR1cm4gVG4obixyKX12YXIgbz1aKGsodCksZSk7cmV0dXJuIEx0Lm1ha2VUZW5zb3Iobyx0LGUpfWZ1bmN0aW9uIEduKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9XCJmbG9hdDMyXCIpLFwiY29tcGxleDY0XCI9PT1lKXt2YXIgbj1Hbih0LFwiZmxvYXQzMlwiKSxyPUduKHQsXCJmbG9hdDMyXCIpO3JldHVybiBUbihuLHIpfXZhciBvPXR0KGsodCksZSk7cmV0dXJuIEx0Lm1ha2VUZW5zb3Iobyx0LGUpfWZ1bmN0aW9uIEhuKHQsZSxuKXtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24ocil7cmV0dXJuIHIuZmlsbCh0LGUsbil9KSx7fSl9ZnVuY3Rpb24gcW4odCxlLG4pe2lmKG48PTApdGhyb3cgbmV3IEVycm9yKFwiVGhlIG51bWJlciBvZiB2YWx1ZXMgc2hvdWxkIGJlIHBvc2l0aXZlLlwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24ocil7cmV0dXJuIHIubGluc3BhY2UodCxlLG4pfSkse30pfWZ1bmN0aW9uIEtuKHQsZSxuLHIpe2lmKHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKSwwPT09bil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaGF2ZSBhIHN0ZXAgb2YgemVyb1wiKTtpZih0PT09ZXx8dDxlJiZuPDB8fGU8dCYmbj4xKXJldHVybiBHbihbMF0scik7dmFyIG89dHQoTWF0aC5hYnMoTWF0aC5jZWlsKChlLXQpL24pKSxyKTtlPHQmJjE9PT1uJiYobj0tMSksb1swXT10O2Zvcih2YXIgYT0xO2E8by5sZW5ndGg7YSsrKW9bYV09b1thLTFdK247cmV0dXJuIE1uKG8scil9dmFyIGpuPUFuKHtvbmVzTGlrZV86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcIm9uZXNMaWtlXCIpO2lmKFwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXt2YXIgbj1qbihEbihlKSkscj1YbihObihlKSk7cmV0dXJuIFRuKG4scil9cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm9uZXNMaWtlKGUpfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pLFwiT25lc0xpa2VcIil9fSksWG49QW4oe3plcm9zTGlrZV86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcInplcm9zTGlrZVwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuemVyb3NMaWtlKGUpfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pLFwiWmVyb3NMaWtlXCIpfX0pO3ZhciBZbj1Bbih7Y29uY2F0XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApLEModC5sZW5ndGg+PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJQYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gY29uY2F0XCJ9KSk7dmFyIG49bW4odCxcInRlbnNvcnNcIixcImNvbmNhdFwiKTtcImNvbXBsZXg2NFwiPT09blswXS5kdHlwZSYmbi5mb3JFYWNoKChmdW5jdGlvbih0KXtpZihcImNvbXBsZXg2NFwiIT09dC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29uY2F0ZW5hdGUgY29tcGxleDY0IHRlbnNvcnMgd2l0aCBhIHRlbnNvclxcbiAgICAgICAgICB3aXRoIGR0eXBlIFwiK3QuZHR5cGUrXCIuIFwiKX0pKSxlPU8oZSxuWzBdLnNoYXBlKVswXTt2YXIgcj1TbihuLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSksZSk7aWYoMD09PWsocikpcmV0dXJuIEZuKFtdLHIpO2lmKDE9PT0obj1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2l6ZT4wfSkpKS5sZW5ndGgpcmV0dXJuIG5bMF07dmFyIG89bi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpO2tuKG8sZSk7dmFyIGE9bixpPXtheGlzOmV9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb25jYXQobixlKX0pLGEsKGZ1bmN0aW9uKHQpe3ZhciBuPW8ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFtlXX0pKTtyZXR1cm4gdHIodCxuLGUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHR9fSkpfSksXCJDb25jYXRcIixpKX19KSwkbj1Bbih7Y29uY2F0MWRfOmZ1bmN0aW9uKHQpe3JldHVybiBZbih0LDApfX0pLFFuPUFuKHtjb25jYXQyZF86ZnVuY3Rpb24odCxlKXtyZXR1cm4gWW4odCxlKX19KSxKbj1Bbih7Y29uY2F0M2RfOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIFluKHQsZSl9fSksWm49QW4oe2NvbmNhdDRkXzpmdW5jdGlvbih0LGUpe3JldHVybiBZbih0LGUpfX0pLHRyPUFuKHtzcGxpdF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPTApO3ZhciByLG89Z24odCxcInhcIixcInNwbGl0XCIpO3JldHVybiBuPU8obixvLnNoYXBlKVswXSxcIm51bWJlclwiPT10eXBlb2YgZT8oQyhvLnNoYXBlW25dJWU9PTAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJOdW1iZXIgb2Ygc3BsaXRzIG11c3QgZXZlbmx5IGRpdmlkZSB0aGUgYXhpcy5cIn0pKSxyPW5ldyBBcnJheShlKS5maWxsKG8uc2hhcGVbbl0vZSkpOihDKG8uc2hhcGVbbl09PT1lLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtlfSkpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIHN1bSBvZiBzaXplcyBtdXN0IG1hdGNoIHRoZSBzaXplIG9mIHRoZSBheGlzIGRpbWVuc2lvbi5cIn0pKSxyPWUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNwbGl0KG8scixuKX0pLHskeDpvfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFluKHQsbil9fX0pKX19KTtmdW5jdGlvbiBlcih0LGUsbil7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwiZmxvYXQzMlwiKSxlPWV8fFwiZmxvYXQzMlwiLG50KHQpLG5ldyBtdCh0LGUsbil9ZnVuY3Rpb24gbnIodCxlKXt2b2lkIDA9PT1lJiYoZT0hMSksY29uc29sZS5sb2codC50b1N0cmluZyhlKSl9dmFyIHJyPUFuKHtiYXRjaFRvU3BhY2VORF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPWduKHQsXCJ4XCIsXCJiYXRjaFRvU3BhY2VORFwiKSxvPWUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSk7cmV0dXJuIEMoci5yYW5rPj0xK2UubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiaW5wdXQgcmFuayBpcyBcIityLnJhbmsrXCIgYnV0IHNob3VsZCBiZSA+IHRoYW4gYmxvY2tTaGFwZS5sZW5ndGggXCIrZS5sZW5ndGh9KSksQyhuLmxlbmd0aD09PWUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiY3JvcHMubGVuZ3RoIGlzIFwiK24ubGVuZ3RoK1wiIGJ1dCBzaG91bGQgYmUgZXF1YWwgdG8gYmxvY2tTaGFwZS5sZW5ndGggIFwiK2UubGVuZ3RofSkpLEMoci5zaGFwZVswXSVvPT0wLChmdW5jdGlvbigpe3JldHVyblwiaW5wdXQgdGVuc29yIGJhdGNoIGlzIFwiK3Iuc2hhcGVbMF0rXCIgYnV0IGlzIG5vdCBkaXZpc2libGUgYnkgdGhlIHByb2R1Y3Qgb2YgdGhlIGVsZW1lbnRzIG9mIGJsb2NrU2hhcGUgXCIrZS5qb2luKFwiICogXCIpK1wiID09PSBcIitvfSkpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmJhdGNoVG9TcGFjZU5EKHIsZSxuKX0pLHskeDpyfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuc3BhY2VUb0JhdGNoTkQoZSxuKX19fSkpfX0pLG9yPUFuKHtjYXN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJ4XCIsXCJjYXN0XCIpO2lmKCFXKGUpKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjYXN0IHRvIHVua25vd24gZHR5cGUgXCIrZSk7aWYoXCJzdHJpbmdcIj09PWUmJlwic3RyaW5nXCIhPT1uLmR0eXBlfHxcInN0cmluZ1wiIT09ZSYmXCJzdHJpbmdcIj09PW4uZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiT25seSBzdHJpbmdzIGNhbiBiZSBjYXN0ZWQgdG8gc3RyaW5nc1wiKTt2YXIgcj17ZHR5cGU6ZX07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmNhc3QobixlKX0pLHt4Om59LChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LmNsb25lKCl9fX0pLFwiQ2FzdFwiLHIpfX0pLGFyPUFuKHtjdW1zdW1fOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PWUmJihlPTApLHZvaWQgMD09PW4mJihuPSExKSx2b2lkIDA9PT1yJiYocj0hMSk7dmFyIG89Z24odCxcInhcIixcImN1bXN1bVwiKSxhPUVuKFtlfD0wXSxvLnJhbmspLGk9bztudWxsIT1hJiYoaT1vLnRyYW5zcG9zZShhKSk7dmFyIHM9SW4oMSxvLnJhbmspWzBdLHU9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuY3Vtc3VtKGkscyxuLHIpfSkse3Blcm11dGVkWDppfSwoZnVuY3Rpb24odCl7cmV0dXJue3Blcm11dGVkWDpmdW5jdGlvbigpe3JldHVybiB0LmN1bXN1bShlLG4sIXIpfX19KSk7cmV0dXJuIG51bGwhPWEmJih1PXUudHJhbnNwb3NlKGEpKSx1fX0pLGlyPUFuKHtkZXB0aFRvU3BhY2VfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1cIk5IV0NcIik7dmFyIHI9Z24odCxcInhcIixcImRlcHRoVG9TcGFjZVwiKSxvPVwiTkhXQ1wiPT09bj9yLnNoYXBlWzFdOnIuc2hhcGVbMl0sYT1cIk5IV0NcIj09PW4/ci5zaGFwZVsyXTpyLnNoYXBlWzNdLGk9XCJOSFdDXCI9PT1uP3Iuc2hhcGVbM106ci5zaGFwZVsxXTtyZXR1cm4gQyhvKmU+PTAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJOZWdhdGl2ZSBkaW1lbnNpb24gc2l6ZSBjYXVzZWQgYnkgb3ZlcmZsb3cgd2hlbiBtdWx0aXBseWluZ1xcbiAgICAgIFwiK28rXCIgYW5kIFwiK2UrXCIgIGZvciBkZXB0aFRvU3BhY2Ugd2l0aCBpbnB1dCBzaGFwZVxcbiAgICAgIFwiK3Iuc2hhcGV9KSksQyhhKmU+PTAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJOZWdhdGl2ZSBkaW1lbnNpb24gc2l6ZSBjYXVzZWQgYnkgb3ZlcmZsb3cgd2hlbiBtdWx0aXBseWluZ1xcbiAgICAgIFwiK2ErXCIgYW5kIFwiK2UrXCIgZm9yIGRlcHRoVG9TcGFjZSB3aXRoIGlucHV0IHNoYXBlXFxuICAgICAgICAgIFwiK3Iuc2hhcGV9KSksQyhpJShlKmUpPT0wLChmdW5jdGlvbigpe3JldHVyblwiRGltZW5zaW9uIHNpemUgbXVzdCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IFwiK2UqZStcIiBidXQgaXMgXCIraStcIiBmb3IgZGVwdGhUb1NwYWNlIHdpdGggaW5wdXQgc2hhcGUgXCIrci5zaGFwZX0pKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXB0aFRvU3BhY2UocixlLG4pfSkseyR4OnJ9KX19KSxzcj1Bbih7ZXhwYW5kRGltc186ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj1nbih0LFwieFwiLFwiZXhwYW5kRGltc1wiLG51bGwpO0MoZTw9bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiQXhpcyBtdXN0IGJlIDw9IHJhbmsgb2YgdGhlIHRlbnNvclwifSkpO3ZhciByPW4uc2hhcGUuc2xpY2UoKTtyZXR1cm4gZTwwJiYoQygtKG4ucmFuaysxKTw9ZSwoZnVuY3Rpb24oKXtyZXR1cm5cIkF4aXMgbXVzdCBiZSBpbiB0aGUgaW50ZXJ2YWwgW1wiKy0obi5yYW5rKzEpK1wiLCBcIituLnJhbmsrXCJdXCJ9KSksZT1uLnJhbmsrZSsxKSxyLnNwbGljZShlLDAsMSksdXIobixyKX19KSx1cj1Bbih7cmVzaGFwZV86ZnVuY3Rpb24odCxlKXt2YXIgbj1nbih0LFwieFwiLFwicmVzaGFwZVwiLG51bGwpO2U9XyhlLG4uc2l6ZSksQyhuLnNpemU9PT1rKGUpLChmdW5jdGlvbigpe3JldHVyblwibmV3IHNoYXBlIGFuZCBvbGQgc2hhcGUgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy5cIn0pKTt2YXIgcj17c2hhcGU6ZX07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlc2hhcGUobixlKX0pLHt4Om59LChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LnJlc2hhcGUobi5zaGFwZSl9fX0pLFwiUmVzaGFwZVwiLHIpfX0pLGNyPUFuKHtzcGFjZVRvQmF0Y2hORF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPWduKHQsXCJ4XCIsXCJzcGFjZVRvQmF0Y2hORFwiKTtyZXR1cm4gQyhyLnJhbms+PTErZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJpbnB1dCByYW5rIFwiK3IucmFuaytcIiBzaG91bGQgYmUgPiB0aGFuIFtibG9ja1NoYXBlXSBcIitlLmxlbmd0aH0pKSxDKG4ubGVuZ3RoPT09ZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJwYWRkaW5ncy5zaGFwZVswXSBcIituLmxlbmd0aCtcIiBtdXN0IGJlIGVxdWFsIHRvIFtibG9ja1NoYXBlXSBcIitlLmxlbmd0aH0pKSxDKHIuc2hhcGUucmVkdWNlKChmdW5jdGlvbih0LHIsbyl7cmV0dXJuIG8+MCYmbzw9ZS5sZW5ndGg/dCYmKHIrbltvLTFdWzBdK25bby0xXVsxXSklZVtvLTFdPT0wOnR9KSwhMCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJpbnB1dCBzcGF0aWFsIGRpbWVuc2lvbnMgXCIrci5zaGFwZS5zbGljZSgxKStcIiB3aXRoIHBhZGRpbmdzIFwiK24udG9TdHJpbmcoKStcIiBtdXN0IGJlIGRpdmlzaWJsZSBieSBibG9ja1NoYXBlcyBcIitlLnRvU3RyaW5nKCl9KSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BhY2VUb0JhdGNoTkQocixlLG4pfSkseyR4OnJ9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5iYXRjaFRvU3BhY2VORChlLG4pfX19KSl9fSksbHI9QW4oe3NxdWVlemVfOmZ1bmN0aW9uKHQsZSl7dmFyIG49Z24odCxcInhcIixcInNxdWVlemVcIik7cmV0dXJuIHVyKG4sTShuLnNoYXBlLGUpLm5ld1NoYXBlKX19KSxocj1Bbih7c3RhY2tfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49bW4odCxcInRlbnNvcnNcIixcInN0YWNrXCIpO2lmKEMobi5sZW5ndGg+PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJQYXNzIGF0IGxlYXN0IG9uZSB0ZW5zb3IgdG8gdGYuc3RhY2tcIn0pKSwxPT09bi5sZW5ndGgpcmV0dXJuIG5bMF0uZXhwYW5kRGltcyhlKTt2YXIgcj1uWzBdLnJhbmssbz1uWzBdLnNoYXBlLGE9blswXS5kdHlwZTtDKGU8PXIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJBeGlzIG11c3QgYmUgPD0gcmFuayBvZiB0aGUgdGVuc29yXCJ9KSksbi5mb3JFYWNoKChmdW5jdGlvbih0KXtFKG8sdC5zaGFwZSxcIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgc2hhcGVzXCIpfSkpLG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7QyhhPT09dC5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cIkFsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgZHR5cGVzXCJ9KSl9KSk7dmFyIGk9bi5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmV4cGFuZERpbXMoZSl9KSk7cmV0dXJuIFluKGksZSl9fSksZnI9QW4oe3Vuc3RhY2tfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCksZT1lfHwwO3ZhciBuPWduKHQsXCJ4XCIsXCJ1bnN0YWNrXCIpO0MoZT49LW4uc2hhcGUubGVuZ3RoJiZlPG4uc2hhcGUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiQXhpcyA9IFwiK2UrXCIgaXMgbm90IGluIFstXCIrbi5zaGFwZS5sZW5ndGgrXCIsIFwiK24uc2hhcGUubGVuZ3RoK1wiKVwifSkpLGU8MCYmKGUrPW4uc2hhcGUubGVuZ3RoKTt2YXIgcj17YXhpczplfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQudW5zdGFjayhuLGUpfSkse3g6bn0sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGhyKHQsZSl9fX0pLFwiVW5wYWNrXCIscil9fSksZHI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sbyxhLGkscyx1LGMsbCxoLGY7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj1nbih0LFwieFwiLFwic2V0ZGlmZjFkXCIpLG89Z24oZSxcInlcIixcInNldGRpZmYxZFwiKSxDKG4uZHR5cGU9PT1vLmR0eXBlLChmdW5jdGlvbigpe3JldHVyblwieCBhbmQgeSBzaG91bGQgaGF2ZSB0aGUgc2FtZSBkdHlwZSwgYnV0IGdvdCB4IChcIituLmR0eXBlK1wiKSBhbmQgeSAoXCIrby5kdHlwZStcIikuXCJ9KSksQygxPT09bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwieCBzaG91bGQgYmUgMUQgdGVuc29yLCBidXQgZ290IHggKFwiK24uc2hhcGUrXCIpLlwifSkpLEMoMT09PW8ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cInkgc2hvdWxkIGJlIDFEIHRlbnNvciwgYnV0IGdvdCB5IChcIitvLnNoYXBlK1wiKS5cIn0pKSxbNCxuLmRhdGEoKV07Y2FzZSAxOnJldHVybiBhPXIuc2VudCgpLFs0LG8uZGF0YSgpXTtjYXNlIDI6Zm9yKGk9ci5zZW50KCkscz1uZXcgU2V0KGkpLHU9MCxoPTA7aDxhLmxlbmd0aDtoKyspcy5oYXMoYVtoXSl8fHUrKztmb3IoYz1uZXcgbXQoW3VdLG4uZHR5cGUpLGw9bmV3IG10KFt1XSxcImludDMyXCIpLGg9MCxmPTA7aDxhLmxlbmd0aDtoKyspcy5oYXMoYVtoXSl8fChjLnZhbHVlc1tmXT1hW2hdLGwudmFsdWVzW2ZdPWgsZisrKTtyZXR1cm5bMixbYy50b1RlbnNvcigpLGwudG9UZW5zb3IoKV1dfX0pKX0pKX07ZnVuY3Rpb24gcHIodCxlLG4scil7dm9pZCAwPT09ciYmKHI9ITApO3ZhciBvPVtdO2lmKHIpKG89by5jb25jYXQoZS5zbGljZSgwKSkpLnB1c2godFswXS9uKSxvPW8uY29uY2F0KHQuc2xpY2UoMSkpO2Vsc2V7bz1vLmNvbmNhdCh0WzBdKTtmb3IodmFyIGE9ZS5sZW5ndGgsaT0wO2k8YTsrK2kpbz1vLmNvbmNhdChbdFtpKzFdL2VbaV0sZVtpXV0pO289by5jb25jYXQodC5zbGljZShhKzEpKX1yZXR1cm4gb31mdW5jdGlvbiB2cih0LGUsbil7dm9pZCAwPT09biYmKG49ITApO3ZhciByPVtdO2lmKG4pe3IucHVzaChlKTtmb3IodmFyIG89ZSsxO288dDsrK28pbzw9MiplPyhyLnB1c2gobyksci5wdXNoKG8tKGUrMSkpKTpyLnB1c2gobyl9ZWxzZXt2YXIgYT1bXSxpPVtdO2ZvcihvPTE7bzx0OysrbylvPj0yKmUrMXx8byUyPT0xP2kucHVzaChvKTphLnB1c2gobyk7ci5wdXNoLmFwcGx5KHIsYSksci5wdXNoKDApLHIucHVzaC5hcHBseShyLGkpfXJldHVybiByfWZ1bmN0aW9uIGdyKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPSEwKTt2YXIgbz1bXTtyP28ucHVzaCh0WzBdL24pOm8ucHVzaCh0WzBdKm4pO2Zvcih2YXIgYT0xO2E8dC5sZW5ndGg7KythKWE8PWUubGVuZ3RoP3I/by5wdXNoKGVbYS0xXSp0W2FdKTpvLnB1c2godFthXS9lW2EtMV0pOm8ucHVzaCh0W2FdKTtyZXR1cm4gb31mdW5jdGlvbiBtcih0LGUpe2Zvcih2YXIgbj1bMF0scj0wO3I8ZTsrK3Ipbi5wdXNoKHRbcl1bMF0pO3JldHVybiBufWZ1bmN0aW9uIHlyKHQsZSxuKXtmb3IodmFyIHI9dC5zbGljZSgwLDEpLG89MDtvPG47KytvKXIucHVzaCh0W28rMV0tZVtvXVswXS1lW29dWzFdKTtyZXR1cm4gcn12YXIgeHI9XCJBZGRcIixicj1cIkFkZE5cIix3cj1cIkRpdlwiLENyPVwiRnVzZWRCYXRjaE5vcm1cIixFcj1cIlNxdWFyZWREaWZmZXJlbmNlXCIsUnI9XCJTcXVhcmVcIixJcj1cIlRyYW5zcG9zZVwiLGtyPVwiTm9uTWF4U3VwcHJlc3Npb25WNVwiLFNyPVwiQnJvYWRjYXN0VG9cIixBcj1cIk9uZUhvdFwiLFRyPVwiSWRlbnRpdHlcIixEcj1cIlRpbGVcIixOcj1cIlBhZFYyXCIsRnI9XCJGcm9tUGl4ZWxzXCIsX3I9XCJNYXhQb29sV2l0aEFyZ21heFwiO3ZhciBPcj1Bbih7YWRkXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9Z24odCxcImFcIixcImFkZFwiKSxvPWduKGUsXCJiXCIsXCJhZGRcIik7bj1OdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9e2E6cixiOm99O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuYWRkKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSxhLG51bGwseHIpfX0pO2Z1bmN0aW9uIE1yKHQsZSl7Zm9yKHZhciBuPXQubGVuZ3RoLHI9W10sbz0wO288bjtvKyspe3ZhciBhPW4tMS1vLGk9dFthXXx8MTsoZVtlLmxlbmd0aC0xLW9dfHwxKT4xJiYxPT09aSYmci51bnNoaWZ0KGEpfXJldHVybiByfWZ1bmN0aW9uIEJyKHQsZSl7Zm9yKHZhciBuPVtdLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIG89dFt0Lmxlbmd0aC1yLTFdLGE9ZS5sZW5ndGgtci0xLGk9ZVthXTsobnVsbD09b3x8MT09PW8mJmk+MSkmJm4udW5zaGlmdChhKX1yZXR1cm4gbn1mdW5jdGlvbiBQcih0LGUpe2Zvcih2YXIgbj1bXSxyPU1hdGgubWF4KHQubGVuZ3RoLGUubGVuZ3RoKSxvPTA7bzxyO28rKyl7dmFyIGE9dFt0Lmxlbmd0aC1vLTFdO251bGw9PWEmJihhPTEpO3ZhciBpPWVbZS5sZW5ndGgtby0xXTtpZihudWxsPT1pJiYoaT0xKSwxPT09YSluLnVuc2hpZnQoaSk7ZWxzZSBpZigxPT09aSluLnVuc2hpZnQoYSk7ZWxzZXtpZihhIT09aSl0aHJvdyBFcnJvcihcIk9wZXJhbmRzIGNvdWxkIG5vdCBiZSBicm9hZGNhc3QgdG9nZXRoZXIgd2l0aCBzaGFwZXMgXCIrdCtcIiBhbmQgXCIrZStcIi5cIik7bi51bnNoaWZ0KGEpfX1yZXR1cm4gbn12YXIgTHI9QW4oe2Fic186ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImFic1wiKTtyZXR1cm5cImNvbXBsZXg2NFwiPT09ZS5kdHlwZT9MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb21wbGV4QWJzKGUpfSkseyR4OmV9KTpMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuYWJzKGUpO3JldHVybiBuKFtlXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi50b0Zsb2F0KCkuc3RlcCgtMSkpfX19KSxcIkFic1wiKX19KSxXcj1Bbih7YWNvc186ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImFjb3NcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5hY29zKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChPbigxKS5zdWIobi50b0Zsb2F0KCkuc3F1YXJlKCkpLnNxcnQoKSkubmVnKCl9fX0pKX19KSxVcj1Bbih7YWNvc2hfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJhY29zaFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFjb3NoKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdlN0cmljdChuLnRvRmxvYXQoKS5zcXVhcmUoKS5zdWIoMSkuc3FydCgpKX19fSkpfX0pLFZyPUFuKHthc2luXzpmdW5jdGlvbih0KXt2YXIgZT1nbih0LFwieFwiLFwiYXNpblwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmFzaW4oZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KE9uKDEpLnN1YihuLnRvRmxvYXQoKS5zcXVhcmUoKSkuc3FydCgpKX19fSkpfX0pLHpyPUFuKHthc2luaF86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImFzaW5oXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuYXNpbmgoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2U3RyaWN0KE9uKDEpLmFkZChuLnRvRmxvYXQoKS5zcXVhcmUoKSkuc3FydCgpKX19fSkpfX0pLEdyPUFuKHthdGFuXzpmdW5jdGlvbih0KXt2YXIgZT1nbih0LFwieFwiLFwiYXRhblwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmF0YW4oZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4udG9GbG9hdCgpLnNxdWFyZSgpLmFkZCgxKSl9fX0pKX19KSxIcj1Bbih7YXRhbmhfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJhdGFuaFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmF0YW5oKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihPbigxKS5zdWIobi50b0Zsb2F0KCkuc3F1YXJlKCkpKX19fSkpfX0pLHFyPUFuKHtjZWlsXzpmdW5jdGlvbih0KXt2YXIgZT1nbih0LFwieFwiLFwiY2VpbFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2VpbChlKX0pLHskeDplfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksS3I9QW4oe2NsaXBCeVZhbHVlXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9Z24odCxcInhcIixcImNsaXBCeVZhbHVlXCIpO0MoZTw9biwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNsaXA6IG1pbiAoXCIrZStcIikgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4IChcIituK1wiKS5cIn0pKTt2YXIgbz1bcl0sYT17bWluOmUsbWF4Om59O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG8pe3ZhciBhPXQuY2xpcChyLGUsbik7cmV0dXJuIG8oW3JdKSxhfSkse3g6cn0sKGZ1bmN0aW9uKHQscil7dmFyIG89clswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LndoZXJlKG8uZ3JlYXRlckVxdWFsKGUpLmxvZ2ljYWxBbmQoby5sZXNzRXF1YWwobikpLFhuKHQpKX19fSksXCJDbGlwQnlWYWx1ZVwiLGEsbyl9fSksanI9QW4oe2Nvc186ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImNvc1wiKSxuPVtlXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmNvcyhlKTtyZXR1cm4gbihbZV0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIG4udG9GbG9hdCgpLnNpbigpLm5lZygpLm11bCh0KX19fSksXCJDb3NcIix7fSxuKX19KSxYcj1Bbih7Y29zaF86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImNvc2hcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5jb3NoKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5zaW5oKCkubXVsU3RyaWN0KHQpfX19KSl9fSksWXI9QW4oe2VyZl86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImVyZlwiKTtyZXR1cm4gQyhcImludDMyXCI9PT1lLmR0eXBlfHxcImZsb2F0MzJcIj09PWUuZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJJbnB1dCBkdHlwZSBtdXN0IGJlIGBpbnQzMmAgb3IgYGZsb2F0MzJgLlwifSkpLFwiaW50MzJcIj09PWUuZHR5cGUmJihlPWUudG9GbG9hdCgpKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuZXJmKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLnNxdWFyZSgpLm5lZygpLmV4cCgpLm11bCgyL01hdGguc3FydChNYXRoLlBJKSkpfX19KSl9fSksJHI9QW4oe2V4cF86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImV4cFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmV4cChlKTtyZXR1cm4gbihbcl0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0Lm11bFN0cmljdChlWzBdKX19fSksXCJFeHBcIix7fSxbXSxbITBdKX19KSxRcj1Bbih7ZXhwbTFfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJleHBtMVwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmV4cG0xKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0Lm11bChuLmV4cCgpKX19fSkpfX0pLEpyPUFuKHtmbG9vcl86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImZsb29yXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5mbG9vcihlKX0pLHskeDplfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksWnI9QW4oe2xvZ186ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImxvZ1wiKSxuPVtlXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmxvZyhlKTtyZXR1cm4gbihbZV0pLHJ9KSx7eDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4udG9GbG9hdCgpKX19fSksXCJMb2dcIix7fSxuKX19KSx0bz1Bbih7bG9nMXBfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJsb2cxcFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LmxvZzFwKGUpO3JldHVybiBuKFtlXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLmFkZCgxKSl9fX0pKX19KSxlbz1Bbih7bG9nU2lnbW9pZF86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImxvZ1NpZ21vaWRcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zb2Z0cGx1cyhlLm5lZygpKS5uZWcoKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5uZWcoKS5zaWdtb2lkKCkpfX19KSl9fSksbm89QW4oe25lZ186ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcIm5lZ1wiKSxuPVtlXTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubmVnKGUpfSkse3g6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubmVnKCl9fX0pLFwiTmVnXCIse30sbil9fSkscm89QW4oe3JlY2lwcm9jYWxfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJyZWNpcHJvY2FsXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQucmVjaXByb2NhbChlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi5zcXVhcmUoKS5uZWcoKSl9fX0pKX19KSxvbz1Bbih7cm91bmRfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJyb3VuZFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQucm91bmQoZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLGFvPUFuKHtyc3FydF86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcInJzcXJ0XCIpLG49W2VdO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQucnNxcnQoZSk7cmV0dXJuIG4oW2VdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LmRpdihuLnBvdygxLjUpLm11bCgyKSkubmVnKCl9fX0pLFwiUnNxcnRcIix7fSxuKX19KSxpbz1Bbih7c2lnbW9pZF86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcInNpZ21vaWRcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zaWdtb2lkKGUpO3JldHVybiBuKFtyXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5tdWwoT24oMSkuc3ViKG4pKSl9fX0pLFwiU2lnbW9pZFwiKX19KSxzbz1Bbih7c2lnbl86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcInNpZ25cIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNpZ24oZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLHVvPUFuKHtpc05hTl86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImlzTmFOXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5pc05hTihlKX0pLHskeDplfSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksY289QW4oe2lzSW5mXzpmdW5jdGlvbih0KXt2YXIgZT1nbih0LFwieFwiLFwiaXNJbmZcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlzSW5mKGUpfSkseyR4OmV9LChmdW5jdGlvbih0KXtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gWG4odCl9fX0pKX19KSxsbz1Bbih7aXNGaW5pdGVfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJpc0Zpbml0ZVwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNGaW5pdGUoZSl9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbih0KX19fSkpfX0pLGhvPUFuKHtzaW5fOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJzaW5cIiksbj1bZV07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC5zaW4oZSk7cmV0dXJuIG4oW2VdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBuLnRvRmxvYXQoKS5jb3MoKS5tdWwodCl9fX0pLFwiU2luXCIse30sbil9fSksZm89QW4oe3NpbmhfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJzaW5oXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuc2luaChlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gbi50b0Zsb2F0KCkuY29zaCgpLm11bFN0cmljdCh0KX19fSkpfX0pLHBvPUFuKHtzb2Z0cGx1c186ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcInNvZnRwbHVzXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuc29mdHBsdXMoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uc2lnbW9pZCgpKX19fSkpfX0pLHZvPUFuKHtzcXJ0XzpmdW5jdGlvbih0KXt2YXIgZT1nbih0LFwieFwiLFwic3FydFwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNxcnQoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIHQuZGl2KG4udG9GbG9hdCgpLnNxcnQoKS5tdWwoMikpfX19KSl9fSksZ289QW4oe3N0ZXBfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49Z24odCxcInhcIixcInN0ZXBcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN0ZXAobixlKX0pLHskeDpufSwoZnVuY3Rpb24odCl7cmV0dXJueyR4OmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHQpfX19KSl9fSksbW89QW4oe3Rhbl86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcInRhblwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnRhbihlKTtyZXR1cm4gbihbZV0pLHJ9KSx7JHg6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gdC5kaXYobi5jb3MoKS5zcXVhcmUoKSl9fX0pKX19KSx5bz1Bbih7dGFuaF86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcInRhbmhcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7dmFyIHI9dC50YW5oKGUpO3JldHVybiBuKFtyXSkscn0pLHt4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gT24oMSkuc3ViKG4uc3F1YXJlKCkpLm11bFN0cmljdCh0KX19fSksXCJUYW5oXCIse30sbnVsbCxbITBdKX19KTt2YXIgeG89QW4oe2FkZFN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1nbih0LFwiYVwiLFwiYWRkU3RyaWN0XCIpLHI9Z24oZSxcImJcIixcImFkZFN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBhZGRTdHJpY3Q6IFwiKSxuLmFkZChyKX19KSxibz1Bbih7YXRhbjJfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1nbih0LFwiYVwiLFwiYXRhbjJcIiksbz1nbihlLFwiYlwiLFwiYXRhbjJcIik7bj1OdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9UHIoci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmF0YW4yKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSx7JGE6ciwkYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57JGE6ZnVuY3Rpb24oKXt2YXIgZT1PcihuLnNxdWFyZSgpLHIuc3F1YXJlKCkpLG89dC5tdWwoci5kaXYoZSkpLGk9QnIobi5zaGFwZSxhKTtyZXR1cm4gaS5sZW5ndGg+MCYmKG89by5zdW0oaSkpLG8ucmVzaGFwZShuLnNoYXBlKX0sJGI6ZnVuY3Rpb24oKXt2YXIgZT1PcihuLnNxdWFyZSgpLHIuc3F1YXJlKCkpLG89bm8odC5tdWwobi5kaXYoZSkpKSxpPUJyKHIuc2hhcGUsYSk7cmV0dXJuIGkubGVuZ3RoPjAmJihvPW8uc3VtKGkpKSxvLnJlc2hhcGUoci5zaGFwZSl9fX0pKX19KSx3bz1Bbih7ZGl2U3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJhXCIsXCJkaXZcIikscj1nbihlLFwiYlwiLFwiZGl2XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGRpdmlkZVN0cmljdDogXCIpLG4uZGl2KHIpfX0pLENvPUFuKHtmbG9vckRpdl86ZnVuY3Rpb24odCxlKXt2YXIgbixyPWduKHQsXCJhXCIsXCJmbG9vckRpdlwiKSxvPWduKGUsXCJiXCIsXCJmbG9vckRpdlwiKTtuPU50KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1QcihyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZmxvb3JEaXYocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57YTpmdW5jdGlvbigpe3ZhciBlPXQuZGl2KHIudG9GbG9hdCgpKSxvPUJyKG4uc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShuLnNoYXBlKTplfSxiOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwobi50b0Zsb2F0KCkpLG89QnIoci5zaGFwZSxhKTtvLmxlbmd0aD4wJiYoZT1lLnN1bShvKS5yZXNoYXBlKHIuc2hhcGUpKTt2YXIgaT1yLnNxdWFyZSgpO3JldHVybiBlLmRpdihpLnRvRmxvYXQoKSkubmVnKCl9fX0pLFwiRmxvb3JEaXZcIil9fSksRW89QW4oe21heGltdW1fOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1nbih0LFwiYVwiLFwibWF4aW11bVwiKSxvPWduKGUsXCJiXCIsXCJtYXhpbXVtXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxcImJvb2xcIj09PXIuZHR5cGUmJihyPXIudG9JbnQoKSxvPW8udG9JbnQoKSksUHIoci5zaGFwZSxvLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWF4aW11bShyLG8pO3JldHVybiBlKFtyLG9dKSxufSkse2E6cixiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnthOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uZ3JlYXRlckVxdWFsKHIpLnRvRmxvYXQoKSl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5sZXNzKHIpLnRvRmxvYXQoKSl9fX0pLFwiTWF4aW11bVwiKX19KSxSbz1Bbih7bWF4aW11bVN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1nbih0LFwiYVwiLFwibWF4aW11bVN0cmljdFwiKSxyPWduKGUsXCJiXCIsXCJtYXhpbXVtU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG1heGltdW1TdHJpY3Q6IFwiKSxuLm1heGltdW0ocil9fSksSW89QW4oe21pbmltdW1fOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1nbih0LFwiYVwiLFwibWluaW11bVwiKSxvPWduKGUsXCJiXCIsXCJtaW5pbXVtXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxcImJvb2xcIj09PXIuZHR5cGUmJihyPXIudG9JbnQoKSxvPW8udG9JbnQoKSksUHIoci5zaGFwZSxvLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWluaW11bShyLG8pO3JldHVybiBlKFtyLG9dKSxufSkse2E6cixiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnthOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4ubGVzc0VxdWFsKHIpLnRvRmxvYXQoKSl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5ncmVhdGVyKHIpLnRvRmxvYXQoKSl9fX0pLFwiTWluaW11bVwiKX19KSxrbz1Bbih7bWluaW11bVN0cmljdF86ZnVuY3Rpb24odCxlKXt2YXIgbj1nbih0LFwiYVwiLFwibWluaW11bVN0cmljdFwiKSxyPWduKGUsXCJiXCIsXCJtaW5pbXVtU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG1pbmltdW1TdHJpY3Q6IFwiKSxuLm1pbmltdW0ocil9fSksU289QW4oe21vZF86ZnVuY3Rpb24odCxlKXt2YXIgbixyPWduKHQsXCJhXCIsXCJtb2RcIiksbz1nbihlLFwiYlwiLFwibW9kXCIpO249TnQocixvKSxyPW5bMF0sbz1uWzFdO3ZhciBhPVByKHIuc2hhcGUsby5zaGFwZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tb2QocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHskYTpyLCRiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnskYTpmdW5jdGlvbigpe3ZhciBlPUJyKG4uc2hhcGUsYSk7cmV0dXJuIGUubGVuZ3RoPjA/dC5zdW0oZSkucmVzaGFwZShuLnNoYXBlKTp0fSwkYjpmdW5jdGlvbigpe3ZhciBlPXQubXVsKG4uZGl2KHIpLmZsb29yKCkubmVnKCkpLG89QnIoci5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKHIuc2hhcGUpOmV9fX0pKX19KSxBbz1Bbih7bW9kU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJhXCIsXCJtb2RTdHJpY3RcIikscj1nbihlLFwiYlwiLFwibW9kU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIG1vZFN0cmljdDogXCIpLG4ubW9kKHIpfX0pLFRvPUFuKHttdWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1nbih0LFwiYVwiLFwibXVsXCIpLG89Z24oZSxcImJcIixcIm11bFwiKTtuPU50KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1QcihyLnNoYXBlLG8uc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubXVsdGlwbHkocixvKTtyZXR1cm4gZShbcixvXSksbn0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57YTpmdW5jdGlvbigpe3ZhciBlPXQubXVsKHIudG9GbG9hdCgpKSxvPUJyKG4uc2hhcGUsYSk7cmV0dXJuIG8ubGVuZ3RoPjA/ZS5zdW0obykucmVzaGFwZShuLnNoYXBlKTplfSxiOmZ1bmN0aW9uKCl7dmFyIGU9dC5tdWwobi50b0Zsb2F0KCkpLG89QnIoci5zaGFwZSxhKTtyZXR1cm4gby5sZW5ndGg+MD9lLnN1bShvKS5yZXNoYXBlKHIuc2hhcGUpOmV9fX0pLFwiTXVsXCIpfX0pLERvPUFuKHttdWxTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49Z24odCxcImFcIixcIm11bFwiKSxyPWduKGUsXCJiXCIsXCJtdWxcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbXVsdGlwbHlTdHJpY3Q6IFwiKSxuLm11bChyKX19KSxObz1Bbih7cG93XzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9Z24odCxcImJhc2VcIixcInBvd1wiKSxvPWduKGUsXCJleHBcIixcInBvd1wiKTtuPU50KHIsbykscj1uWzBdLG89blsxXTt2YXIgYT1QcihyLnNoYXBlLG8uc2hhcGUpLGk9W3Isb107cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5wb3cocixvKTtyZXR1cm4gZShbcixvLG5dKSxufSkse2E6cixiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdLG89ZVsyXTtyZXR1cm57YTpmdW5jdGlvbigpe3ZhciBlPXIudG9GbG9hdCgpLG89dC5tdWwoZS5tdWwobi5wb3coZS5zdWIoT24oMSkpKSkpLGk9QnIobi5zaGFwZSxhKTtyZXR1cm4gaS5sZW5ndGg+MCYmKG89by5zdW0oaSkpLG8ucmVzaGFwZShuLnNoYXBlKX0sYjpmdW5jdGlvbigpe3ZhciBlPW4uZ3JlYXRlcigwKSxpPW4ubG9nKCkud2hlcmUoZSxYbihuKSkscz10Lm11bChvLm11bChpKSksdT1CcihyLnNoYXBlLGEpO3JldHVybiB1Lmxlbmd0aD4wJiYocz1zLnN1bSh1KSkscy5yZXNoYXBlKHIuc2hhcGUpfX19KSxcIlBvd1wiLHt9LGksWyEwXSl9fSksRm89QW4oe3Bvd1N0cmljdF86ZnVuY3Rpb24odCxlKXtyZXR1cm4gRSh0LnNoYXBlLGUuc2hhcGUsXCJFcnJvciBpbiBwb3dTdHJpY3Q6IFwiKSx0LnBvdyhlKX19KSxfbz1Bbih7c3F1YXJlZERpZmZlcmVuY2VTdHJpY3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49Z24odCxcImFcIixcInNxdWFyZWREaWZmZXJlbmNlU3RyaWN0XCIpLHI9Z24oZSxcImJcIixcInNxdWFyZWREaWZmZXJlbmNlU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIHNxdWFyZWREaWZmZXJlbmNlU3RyaWN0OiBcIiksbi5zcXVhcmVkRGlmZmVyZW5jZShyKX19KSxPbz1Bbih7c3ViXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9Z24odCxcImFcIixcInN1YlwiKSxvPWduKGUsXCJiXCIsXCJzdWJcIik7bj1OdChyLG8pLHI9blswXSxvPW5bMV07dmFyIGE9UHIoci5zaGFwZSxvLnNoYXBlKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3VidHJhY3QocixvKX0pLHthOnIsYjpvfSwoZnVuY3Rpb24odCl7cmV0dXJue2E6ZnVuY3Rpb24oKXt2YXIgZT10LG49QnIoci5zaGFwZSxhKTtyZXR1cm4gbi5sZW5ndGg+MCYmKGU9ZS5zdW0obikpLGUucmVzaGFwZShyLnNoYXBlKX0sYjpmdW5jdGlvbigpe3ZhciBlPXQsbj1CcihvLnNoYXBlLGEpO3JldHVybiBuLmxlbmd0aD4wJiYoZT1lLnN1bShuKSksZS5uZWcoKS5yZXNoYXBlKG8uc2hhcGUpfX19KSxcIlN1YlwiKX19KSxNbz1Bbih7c3ViU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJhXCIsXCJzdWJTdHJpY3RcIikscj1nbihlLFwiYlwiLFwic3ViU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIHN1YlN0cmljdDogXCIpLG4uc3ViKHIpfX0pO3ZhciBCbz1Bbih7ZGl2XzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9Z24odCxcImFcIixcImRpdlwiKSxvPWduKGUsXCJiXCIsXCJkaXZcIik7aWYobj1OdChyLG8pLHI9blswXSxvPW5bMV0sXCJpbnQzMlwiPT09ci5kdHlwZSYmXCJpbnQzMlwiPT09by5kdHlwZSlyZXR1cm4gQ28ocixvKTt2YXIgYT17YTpyLGI6b307cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5yZWFsRGl2aWRlKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSxhLG51bGwsd3Ise30pfX0pO2Z1bmN0aW9uIFBvKHQsZSl7aWYodC5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwidGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbnB1dCB0byBiZSByYW5rIDEgb3IgaGlnaGVyLCBidXQgdGhlIHJhbmsgd2FzIFwiK3QucmFuaytcIi5cIik7aWYoZS5yYW5rPDEpdGhyb3cgbmV3IEVycm9yKFwidGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsIGJ1dCB0aGUgcmFuayB3YXMgXCIrZS5yYW5rK1wiLlwiKTtpZihcImludDMyXCIhPT1lLmR0eXBlKXRocm93IG5ldyBFcnJvcihcInRmLmdhdGhlck5EKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSBpbnQzMiB0eXBlLCBidXQgdGhlIGR0eXBlIHdhcyBcIitlLmR0eXBlK1wiLlwiKTtpZihlLnNoYXBlW2UucmFuay0xXT50LnJhbmspdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggaW5uZXJtb3N0IGRpbWVuc2lvbiBsZW5ndGggbXVzdCBiZSA8PSB0ZW5zb3IgcmFuazsgc2F3OiBcIitlLnNoYXBlW2UucmFuay0xXStcIiB2cy4gXCIrdC5yYW5rKTtpZigwPT09dC5zaXplKXRocm93IG5ldyBFcnJvcihcIlJlcXVlc3RlZCBtb3JlIHRoYW4gMCBlbnRyaWVzLCBidXQgaW5wdXQgaXMgZW1wdHkuIElucHV0IHNoYXBlOiBcIit0LnNoYXBlK1wiLlwiKTtmb3IodmFyIG49ZS5zaGFwZSxyPW5bbi5sZW5ndGgtMV0sbz0xLGE9MDthPG4ubGVuZ3RoLTE7KythKW8qPW5bYV07dmFyIGk9dC5zaGFwZSxzPW4uc2xpY2UoKTtzLnBvcCgpO3ZhciB1PTE7Zm9yKGE9cjthPHQucmFuazsrK2EpdSo9aVthXSxzLnB1c2goaVthXSk7dmFyIGM9JCh0LnNoYXBlKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0L3V9KSkuY29uY2F0KFsxXSkuc2xpY2UoMCxyKTtyZXR1cm5bcyxvLHUsY119dmFyIExvPU9iamVjdC5mcmVlemUoe3ByZXBhcmVBbmRWYWxpZGF0ZTpQb30pLFdvPTMwO2Z1bmN0aW9uIFVvKHQpe3JldHVybiB0PD1Xbz90OlkodCxNYXRoLmZsb29yKE1hdGguc3FydCh0KSkpfWZ1bmN0aW9uIFZvKHQsZSxuKXt2YXIgcj1lLnJhbms+MT9lLnNoYXBlW2UucmFuay0xXToxLG89ZS5yYW5rPjE/ZS5yYW5rLTE6MSxhPVwiTXVzdCBoYXZlIHVwZGF0ZXMuc2hhcGUgPSBpbmRpY2VzLnNoYXBlWzpiYXRjaERpbV0gKyBzaGFwZVtzbGljZURpbTpdLCBnb3QgdXBkYXRlcy5zaGFwZTogXCIrbi5zaGFwZStcIiwgaW5kaWNlcy5zaGFwZTogXCIrZS5zaGFwZStcIiwgc2hhcGU6IFwiK3QrXCIsIHNsaWNlRGltOiBcIityK1wiLCBhbmQgYmF0Y2hEaW06IFwiK28rXCIuXCI7aWYobi5yYW5rPG8pdGhyb3cgbmV3IEVycm9yKGErXCIgdXBkYXRlLnJhbmsgPCBcIitvK1wiLiBcIik7aWYodC5sZW5ndGg8cisobi5yYW5rLW8pKXRocm93IG5ldyBFcnJvcihhK1wiIE91dHB1dCBzaGFwZSBsZW5ndGggPCBcIisocisobi5yYW5rLW8pKSk7aWYobi5yYW5rIT09byt0Lmxlbmd0aC1yKXRocm93IG5ldyBFcnJvcihhK1wiIHVwZGF0ZS5yYW5rICE9IFwiKyhvK3QubGVuZ3RoLXIpKTtmb3IodmFyIGk9MDtpPG87KytpKWlmKG4uc2hhcGVbaV0hPT1lLnNoYXBlW2ldKXRocm93IG5ldyBFcnJvcihhK1wiIHVwZGF0ZXMuc2hhcGVbXCIraStcIl0gKFwiK24uc2hhcGVbaV0rXCIpICE9IGluZGljZXMuc2hhcGVbXCIraStcIl0gKFwiK2Uuc2hhcGVbaV0rXCIpLlwiKTtmb3IoaT0wO2k8bi5yYW5rLW87KytpKWlmKG4uc2hhcGVbaStvXSE9PXRbaStyXSl0aHJvdyBuZXcgRXJyb3IoYStcIiB1cGRhdGVzLnNoYXBlW1wiKyhpK28pK1wiXSAoXCIrbi5zaGFwZVtpK29dK1wiKSAhPSBzaGFwZVtcIisoaStvKStcIl0gKFwiK3RbaStvXStcIilcIil9ZnVuY3Rpb24gem8odCxlLG4pe2lmKGUucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIitlLnJhbmsrXCIuXCIpO2lmKHQucmFuazwxKXRocm93IG5ldyBFcnJvcihcInRmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIHVwZGF0ZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwgYnV0IHRoZSByYW5rIHdhcyBcIit0LnJhbmsrXCIuXCIpO2lmKFwiaW50MzJcIiE9PWUuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGR0eXBlIG9mICdpbmRpY2VzJyBzaG91bGQgYmUgaW50MzIsIGJ1dCBnb3QgZHR5cGU6IFwiK2UuZHR5cGUpO2lmKG4ubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiT3V0cHV0IHJhbmsgbXVzdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIDEsIGJ1dCBnb3Qgc2hhcGU6IFwiK24pO2lmKDA9PT1uLmxlbmd0aCl7aWYoMD09PWUuc2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJJbmRpY2VzIHNwZWNpZmllZCBmb3IgZW1wdHkgb3V0cHV0LiBpbmRpY2VzIHNoYXBlOiBcIitlLnNoYXBlKTtpZigwPT09dC5zaXplKXRocm93IG5ldyBFcnJvcihcIlVwZGF0ZXMgc3BlY2lmaWVkIGZvciBlbXB0eSBvdXRwdXQuIHVwZGF0ZXMgc2hhcGU6IFwiK3Quc2hhcGUpfVZvKG4sZSx0KX1mdW5jdGlvbiBHbyh0LGUsbil7Zm9yKHZhciByPWUuc2hhcGUubGVuZ3RoLG89cj4xP2Uuc2hhcGVbci0xXToxLGE9bi5sZW5ndGgsaT0xLHM9bztzPGE7KytzKWkqPW5bc107dmFyIHU9bzwxPzE6bztyZXR1cm57c2xpY2VSYW5rOm8sbnVtVXBkYXRlczprKGUuc2hhcGUpL3Usc2xpY2VTaXplOmksc3RyaWRlczokKG4uc2xpY2UoMCxvKSkuY29uY2F0KFsxXSksb3V0cHV0U2l6ZTprKG4pfX12YXIgSG89T2JqZWN0LmZyZWV6ZSh7dmFsaWRhdGVVcGRhdGVTaGFwZTpWbyx2YWxpZGF0ZUlucHV0OnpvLGNhbGN1bGF0ZVNoYXBlczpHb30pO2Z1bmN0aW9uIHFvKHQsZSxuKXtDKHQucmFuaz09PWUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2xpY2VcIit0LnJhbmsrXCJEOiBMZW5ndGggb2YgYmVnaW4gXCIrZStcIiBtdXN0IG1hdGNoIHRoZSByYW5rIG9mIHRoZSBhcnJheSAoXCIrdC5yYW5rK1wiKS5cIn0pKSxDKHQucmFuaz09PW4ubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2xpY2VcIit0LnJhbmsrXCJEOiBMZW5ndGggb2Ygc2l6ZSBcIituK1wiIG11c3QgbWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIit0LnJhbmsrXCIpLlwifSkpO2Zvcih2YXIgcj1mdW5jdGlvbihyKXtDKGVbcl0rbltyXTw9dC5zaGFwZVtyXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNsaWNlXCIrdC5yYW5rK1wiRDogYmVnaW5bXCIrcitcIl0gKyBzaXplW1wiK3IrXCJdIChcIisoZVtyXStuW3JdKStcIikgd291bGQgb3ZlcmZsb3cgaW5wdXQuc2hhcGVbXCIrcitcIl0gKFwiK3Quc2hhcGVbcl0rXCIpXCJ9KSl9LG89MDtvPHQucmFuazsrK28pcihvKX1mdW5jdGlvbiBLbyh0KXtmb3IodmFyIGU9W10sbj0wO3Q+MDspMSZ0JiZlLnB1c2gobiksdC89MixuKys7cmV0dXJuIGV9ZnVuY3Rpb24gam8odCxlLG4pe2Zvcih2YXIgcj1bXSxvPTA7bzx0Lmxlbmd0aDtvKyspcltvXT1NYXRoLmNlaWwoKGVbb10tdFtvXSkvbltvXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gWG8odCxlLG4scixvKXt2YXIgYT1lW29dLGk9bltvXXx8MTsodCYxPDxvfHxudWxsPT1hKSYmKGE9aT4wP051bWJlci5NSU5fU0FGRV9JTlRFR0VSOk51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTt2YXIgcz1yW29dO3JldHVybiBhPDAmJihhKz1zKSxhPXgoMCxhLHMtMSl9ZnVuY3Rpb24gWW8odCxlLG4scixvKXt2YXIgYT1lW29dLGk9bltvXXx8MTsodCYxPDxvfHxudWxsPT1hKSYmKGE9aT4wP051bWJlci5NQVhfU0FGRV9JTlRFR0VSOk51bWJlci5NSU5fU0FGRV9JTlRFR0VSKTt2YXIgcz1yW29dO3JldHVybiBhPDAmJihhKz1zKSxhPWk+MD94KDAsYSxzKTp4KC0xLGEscy0xKX1mdW5jdGlvbiAkbyh0LGUsbil7Zm9yKHZhciByPW4ubGVuZ3RoLG89MDtvPG4ubGVuZ3RoO28rKylpZihuW29dPjEpe3I9bzticmVha31mb3Iobz1yKzE7bzxuLmxlbmd0aDtvKyspaWYoZVtvXT4wfHxuW29dIT09dFtvXSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBRbyh0LGUpe2Zvcih2YXIgbj10Lmxlbmd0aD4wP3RbdC5sZW5ndGgtMV06MSxyPTA7cjx0Lmxlbmd0aC0xO3IrKyluKz10W3JdKmVbcl07cmV0dXJuIG59dmFyIEpvPU9iamVjdC5mcmVlemUoe2Fzc2VydFBhcmFtc1ZhbGlkOnFvLG1hc2tUb0F4ZXM6S28sY29tcHV0ZU91dFNoYXBlOmpvLHN0YXJ0Rm9yQXhpczpYbyxzdG9wRm9yQXhpczpZbyxpc1NsaWNlQ29udGlub3VzOiRvLGNvbXB1dGVGbGF0T2Zmc2V0OlFvfSk7ZnVuY3Rpb24gWm8odCl7cmV0dXJuIEMoWCh0KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiBncmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSkpLGZ1bmN0aW9uKGUsbil7dmFyIHI9Z24oZSxcInhcIixcInRmLmdyYWRcIixudWxsKSxvPW51bGwhPW4/Z24obixcImR5XCIsXCJ0Zi5ncmFkXCIpOm51bGw7cmV0dXJuIEx0LnRpZHkoKGZ1bmN0aW9uKCl7dmFyIGU9THQuZ3JhZGllbnRzKChmdW5jdGlvbigpe3JldHVybiB0KHIpfSksW3JdLG8pLG49ZS52YWx1ZSxhPWUuZ3JhZHM7cmV0dXJuIG51bGwhPW8mJkUobi5zaGFwZSxvLnNoYXBlLFwiVGhlIHNoYXBlIG9mIGR5IHBhc3NlZCBpbiBncmFkKGYpKHgsIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKHgpXCIpLGFhKGEpLGFbMF19KSl9fWZ1bmN0aW9uIHRhKHQpe3JldHVybiBDKFgodCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZiBwYXNzZWQgaW4gZ3JhZHMoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSksZnVuY3Rpb24oZSxuKXtDKEFycmF5LmlzQXJyYXkoZSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJncyBwYXNzZWQgaW4gZ3JhZHMoZikoYXJncykgbXVzdCBiZSBhbiBhcnJheSBvZiBgVGVuc29yYHMgb3IgYFRlbnNvckxpa2Vgc1wifSkpO3ZhciByPW1uKGUsXCJhcmdzXCIsXCJ0Zi5ncmFkc1wiLG51bGwpLG89bnVsbCE9bj9nbihuLFwiZHlcIixcInRmLmdyYWRzXCIpOm51bGw7cmV0dXJuIEx0LnRpZHkoKGZ1bmN0aW9uKCl7dmFyIGU9THQuZ3JhZGllbnRzKChmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KHZvaWQgMCxyKX0pLHIsbyksbj1lLnZhbHVlLGE9ZS5ncmFkcztyZXR1cm4gbnVsbCE9byYmRShuLnNoYXBlLG8uc2hhcGUsXCJUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIGdyYWRzKGYpKFt4MSwuLi5dLCBkeSkgbXVzdCBtYXRjaCB0aGUgc2hhcGUgcmV0dXJuZWQgYnkgZihbeDEsLi4uXSlcIiksYWEoYSksYX0pKX19ZnVuY3Rpb24gZWEodCl7cmV0dXJuIEMoWCh0KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uXCJ9KSksZnVuY3Rpb24oZSxuKXtDKGUgaW5zdGFuY2VvZiB3dCwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSB4IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikoeCkgbXVzdCBiZSBhIHRlbnNvclwifSkpLEMobnVsbD09bnx8biBpbnN0YW5jZW9mIHd0LChmdW5jdGlvbigpe3JldHVyblwiVGhlIGR5IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikoeCwgZHkpIG11c3QgYmUgYSB0ZW5zb3JcIn0pKTt2YXIgcj1MdC5ncmFkaWVudHMoKGZ1bmN0aW9uKCl7cmV0dXJuIHQoZSl9KSxbZV0sbiksbz1yLmdyYWRzLGE9ci52YWx1ZTtyZXR1cm4gYWEobykse2dyYWQ6b1swXSx2YWx1ZTphfX19ZnVuY3Rpb24gbmEodCl7cmV0dXJuIEMoWCh0KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSkpLGZ1bmN0aW9uKGUsbil7QyhBcnJheS5pc0FycmF5KGUpJiZlLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIHd0fSkpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGFyZ3MgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoYXJncykgbXVzdCBiZSBhcnJheSBvZiB0ZW5zb3JzXCJ9KSksQyhudWxsPT1ufHxuIGluc3RhbmNlb2Ygd3QsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoYXJncywgZHkpIG11c3QgYmUgYSB0ZW5zb3JcIn0pKTt2YXIgcj1MdC5ncmFkaWVudHMoKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkodm9pZCAwLGUpfSksZSxuKTtyZXR1cm4gbnVsbCE9biYmRShyLnZhbHVlLnNoYXBlLG4uc2hhcGUsXCJUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIHZhbHVlQW5kR3JhZHMoZikoW3gxLC4uLl0sIGR5KSBtdXN0IG1hdGNoIHRoZSBzaGFwZSByZXR1cm5lZCBieSBmKFt4MSwuLi5dKVwiKSxhYShyLmdyYWRzKSxyfX1mdW5jdGlvbiByYSh0LGUpe0MoWCh0KSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmIHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvblwifSkpLEMobnVsbD09ZXx8QXJyYXkuaXNBcnJheShlKSYmZS5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBTdH0pKSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSB2YXJMaXN0IHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYsIHZhckxpc3QpIG11c3QgYmUgYW4gYXJyYXkgb2YgdmFyaWFibGVzXCJ9KSk7dmFyIG49bnVsbCE9ZTtpZighbilmb3IodmFyIHIgaW4gZT1bXSxMdC5yZWdpc3RlcmVkVmFyaWFibGVzKWUucHVzaChMdC5yZWdpc3RlcmVkVmFyaWFibGVzW3JdKTt2YXIgbz1uP2UuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hdC50cmFpbmFibGV9KSk6bnVsbCxhPWUubGVuZ3RoO0MoKGU9ZS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRyYWluYWJsZX0pKSkubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJ2YXJpYWJsZUdyYWRzKCkgZXhwZWN0cyBhdCBsZWFzdCBvbmUgb2YgdGhlIGlucHV0IHZhcmlhYmxlcyB0byBiZSB0cmFpbmFibGUsIGJ1dCBub25lIG9mIHRoZSBcIithK1wiIHZhcmlhYmxlcyBpcyB0cmFpbmFibGUuXCJ9KSk7dmFyIGk9THQuZ3JhZGllbnRzKHQsZSxudWxsLCEwKSxzPWkudmFsdWUsdT1pLmdyYWRzO0ModS5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dH0pKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkNhbm5vdCBmaW5kIGEgY29ubmVjdGlvbiBiZXR3ZWVuIGFueSB2YXJpYWJsZSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgbG9zcyBmdW5jdGlvbiB5PWYoeCkuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIG9wZXJhdGlvbnMgdGhhdCB1c2UgdmFyaWFibGVzIGFyZSBpbnNpZGUgdGhlIGZ1bmN0aW9uIGYgcGFzc2VkIHRvIG1pbmltaXplKCkuXCJ9KSksQygwPT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiVGhlIGYgcGFzc2VkIGluIHZhcmlhYmxlR3JhZHMoZikgbXVzdCByZXR1cm4gYSBzY2FsYXIsIGJ1dCBpdCByZXR1cm5lZCBhIHJhbmstXCIrcy5yYW5rK1wiIHRlbnNvclwifSkpO3ZhciBjPXt9O3JldHVybiBlLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7bnVsbCE9dVtlXSYmKGNbdC5uYW1lXT11W2VdKX0pKSxudWxsIT1vJiZvLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBjW3QubmFtZV09bnVsbH0pKSx7dmFsdWU6cyxncmFkczpjfX1mdW5jdGlvbiBvYSh0KXtyZXR1cm4gTHQuY3VzdG9tR3JhZCh0KX1mdW5jdGlvbiBhYSh0KXtpZih0LmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXR9KSkubGVuZ3RoPjApdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQgb2YgeT1mKHgpIHdpdGggcmVzcGVjdCB0byB4LiBNYWtlIHN1cmUgdGhhdFxcbiAgICB0aGUgZiB5b3UgcGFzc2VkIGVuY2xvc2VzIGFsbCBvcGVyYXRpb25zIHRoYXQgbGVhZCBmcm9tIHggdG8geS5cIil9dmFyIGlhPUFuKHtzb2Z0bWF4XzpmdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPS0xKTt2YXIgbj1nbih0LFwibG9naXRzXCIsXCJzb2Z0bWF4XCIsXCJmbG9hdDMyXCIpO2lmKC0xPT09ZSYmKGU9bi5yYW5rLTEpLGUhPT1uLnJhbmstMSl0aHJvdyBFcnJvcihcIlNvZnRtYXggYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExvZ2l0cyB3YXMgcmFuayBcIituLnJhbmsrXCIgYW5kIGRpbSB3YXMgXCIrZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQscil7dmFyIG89dC5zb2Z0bWF4KG4sZSk7cmV0dXJuIHIoW29dKSxvfSkse2xvZ2l0czpufSwoZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLG89dC5tdWwocik7cmV0dXJue2xvZ2l0czpmdW5jdGlvbigpe3JldHVybiBvLnN1YihvLnN1bShbZV0sITApLm11bChyKSl9fX0pLFwiU29mdG1heFwiLHtkaW06ZX0sW10sWyEwXSl9fSksc2E9QW4oe2xvZ1NvZnRtYXhfOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9LTEpO3ZhciBuPWduKHQsXCJsb2dpdHNcIixcImxvZ1NvZnRtYXhcIik7aWYoLTE9PT1lJiYoZT1uLnJhbmstMSksZSE9PW4ucmFuay0xKXRocm93IEVycm9yKFwiTG9nIFNvZnRtYXggYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExvZ2l0cyB3YXMgcmFuayBcIituLnJhbmsrXCIgYW5kIGF4aXMgd2FzIFwiK2UpO3JldHVybiBvYSgoZnVuY3Rpb24odCxuKXt2YXIgcj10Lm1heChlLCEwKSxvPXQuc3ViKHIpLGE9by50b0Zsb2F0KCkuc3ViKG8uZXhwKCkuc3VtKGUsITApLmxvZygpKTtuKFthXSk7cmV0dXJue3ZhbHVlOmEsZ3JhZEZ1bmM6ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLmV4cCgpO3JldHVybiB0LnN1Yih0LnN1bShlLCEwKS5tdWwocikpfX19KSkobil9fSk7dmFyIHVhPUFuKHt0cmFuc3Bvc2VfOmZ1bmN0aW9uKHQsZSl7dmFyIG49Z24odCxcInhcIixcInRyYW5zcG9zZVwiKTtpZihudWxsPT1lJiYoZT1uLnNoYXBlLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gZX0pKS5yZXZlcnNlKCkpLEMobi5yYW5rPT09ZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiB0cmFuc3Bvc2U6IHJhbmsgb2YgaW5wdXQgXCIrbi5yYW5rK1wiIG11c3QgbWF0Y2ggbGVuZ3RoIG9mIHBlcm0gXCIrZStcIi5cIn0pKSxlLmZvckVhY2goKGZ1bmN0aW9uKHQpe0ModD49MCYmdDxuLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJBbGwgZW50cmllcyBpbiAncGVybScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIFwiKyhuLnJhbmstMSkrXCIgYnV0IGdvdCBcIitlfSkpfSkpLG4ucmFuazw9MSlyZXR1cm4gbi5jbG9uZSgpO3ZhciByPXtwZXJtOmV9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC50cmFuc3Bvc2UobixlKX0pLHt4Om59LG51bGwsXCJUcmFuc3Bvc2VcIixyKX19KSxjYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLmJhY2tlbmQ9dCx0aGlzLmRhdGFNb3Zlcj1lLHRoaXMuZGF0YT1uZXcgV2Vha01hcCx0aGlzLmRhdGFJZHNDb3VudD0wfXJldHVybiB0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YS5oYXModCl8fHRoaXMuZGF0YU1vdmVyLm1vdmVEYXRhKHRoaXMuYmFja2VuZCx0KSx0aGlzLmRhdGEuZ2V0KHQpfSx0LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxlKXt0aGlzLmRhdGFJZHNDb3VudCsrLHRoaXMuZGF0YS5zZXQodCxlKX0sdC5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuaGFzKHQpfSx0LnByb3RvdHlwZS5kZWxldGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGF0YUlkc0NvdW50LS0sdGhpcy5kYXRhLmRlbGV0ZSh0KX0sdC5wcm90b3R5cGUubnVtRGF0YUlkcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGFJZHNDb3VudH0sdH0oKSxsYT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLnRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwidGltZVwiKX0sdC5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJyZWFkXCIpfSx0LnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJyZWFkU3luY1wiKX0sdC5wcm90b3R5cGUubnVtRGF0YUlkcz1mdW5jdGlvbigpe3JldHVybiBoYShcIm51bURhdGFJZHNcIil9LHQucHJvdG90eXBlLmRpc3Bvc2VEYXRhPWZ1bmN0aW9uKHQpe3JldHVybiBoYShcImRpc3Bvc2VEYXRhXCIpfSx0LnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwid3JpdGVcIil9LHQucHJvdG90eXBlLm1vdmU9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIGhhKFwibW92ZVwiKX0sdC5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7cmV0dXJuIGhhKFwibWVtb3J5XCIpfSx0LnByb3RvdHlwZS5mbG9hdFByZWNpc2lvbj1mdW5jdGlvbigpe3JldHVybiBoYShcImZsb2F0UHJlY2lzaW9uXCIpfSx0LnByb3RvdHlwZS5lcHNpbG9uPWZ1bmN0aW9uKCl7cmV0dXJuIDMyPT09dGhpcy5mbG9hdFByZWNpc2lvbigpPzFlLTc6MWUtNH0sdC5wcm90b3R5cGUuYmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIGhhKFwiYmF0Y2hNYXRNdWxcIil9LHQucHJvdG90eXBlLmZ1c2VkQmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCl7dC5hLHQuYix0LnRyYW5zcG9zZUEsdC50cmFuc3Bvc2VCLHQuYmlhcyx0LmFjdGl2YXRpb24sdC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzO3JldHVybiBoYShcImZ1c2VkQmF0Y2hNYXRNdWxcIil9LHQucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaGEoXCJzbGljZVwiKX0sdC5wcm90b3R5cGUuc3RyaWRlZFNsaWNlPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBoYShcInN0cmlkZWRTbGljZVwiKX0sdC5wcm90b3R5cGUudW5zdGFjaz1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcInVuc3RhY2tcIil9LHQucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJyZXZlcnNlXCIpfSx0LnByb3RvdHlwZS5jb25jYXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJjb25jYXRcIil9LHQucHJvdG90eXBlLm5lZz1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJuZWdcIil9LHQucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcImFkZFwiKX0sdC5wcm90b3R5cGUuYWRkTj1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJhZGROXCIpfSx0LnByb3RvdHlwZS5zdWJ0cmFjdD1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcInN1YnRyYWN0XCIpfSx0LnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcIm11bHRpcGx5XCIpfSx0LnByb3RvdHlwZS5yZWFsRGl2aWRlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwicmVhbERpdmlkZVwiKX0sdC5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJmbG9vckRpdlwiKX0sdC5wcm90b3R5cGUuc3VtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwic3VtXCIpfSx0LnByb3RvdHlwZS5wcm9kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwicHJvZFwiKX0sdC5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaGEoXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIil9LHQucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcImFyZ01pblwiKX0sdC5wcm90b3R5cGUuYXJnTWF4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwiYXJnTWF4XCIpfSx0LnByb3RvdHlwZS5lcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcImVxdWFsXCIpfSx0LnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcIm5vdEVxdWFsXCIpfSx0LnByb3RvdHlwZS5sZXNzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwibGVzc1wiKX0sdC5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwibGVzc0VxdWFsXCIpfSx0LnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwiZ3JlYXRlclwiKX0sdC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwiZ3JlYXRlckVxdWFsXCIpfSx0LnByb3RvdHlwZS5sb2dpY2FsTm90PWZ1bmN0aW9uKHQpe3JldHVybiBoYShcImxvZ2ljYWxOb3RcIil9LHQucHJvdG90eXBlLmxvZ2ljYWxBbmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJsb2dpY2FsQW5kXCIpfSx0LnByb3RvdHlwZS5sb2dpY2FsT3I9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJsb2dpY2FsT3JcIil9LHQucHJvdG90eXBlLndoZXJlPWZ1bmN0aW9uKHQpe3JldHVybiBoYShcIndoZXJlXCIpfSx0LnByb3RvdHlwZS5zZWxlY3Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBoYShcInNlbGVjdFwiKX0sdC5wcm90b3R5cGUudG9waz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwidG9wa1wiKX0sdC5wcm90b3R5cGUubWluPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwibWluXCIpfSx0LnByb3RvdHlwZS5taW5pbXVtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwibWluaW11bVwiKX0sdC5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwibW9kXCIpfSx0LnByb3RvdHlwZS5tYXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJtYXhcIil9LHQucHJvdG90eXBlLm1heGltdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJtYXhpbXVtXCIpfSx0LnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJhbGxcIil9LHQucHJvdG90eXBlLmFueT1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcImFueVwiKX0sdC5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJzcXVhcmVkRGlmZmVyZW5jZVwiKX0sdC5wcm90b3R5cGUuY2VpbD1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJjZWlsXCIpfSx0LnByb3RvdHlwZS5mbG9vcj1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJmbG9vclwiKX0sdC5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwicm91bmRcIil9LHQucHJvdG90eXBlLnNpZ249ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwic2lnblwiKX0sdC5wcm90b3R5cGUuaXNOYU49ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwiaXNOYU5cIil9LHQucHJvdG90eXBlLmlzSW5mPWZ1bmN0aW9uKHQpe3JldHVybiBoYShcImlzSW5mXCIpfSx0LnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJpc0Zpbml0ZVwiKX0sdC5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwicG93XCIpfSx0LnByb3RvdHlwZS5leHA9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwiZXhwXCIpfSx0LnByb3RvdHlwZS5leHBtMT1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJleHBtMVwiKX0sdC5wcm90b3R5cGUuc29mdG1heD1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcInNvZnRtYXhcIil9LHQucHJvdG90eXBlLmxvZz1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJsb2dcIil9LHQucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKHQpe3JldHVybiBoYShcImxvZzFwXCIpfSx0LnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKHQpe3JldHVybiBoYShcInNxcnRcIil9LHQucHJvdG90eXBlLnJzcXJ0PWZ1bmN0aW9uKHQpe3JldHVybiBoYShcInJzcXJ0XCIpfSx0LnByb3RvdHlwZS5zcXVhcmU9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwic3F1YXJlXCIpfSx0LnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKHQpe3JldHVybiBoYShcInJlY2lwcm9jYWxcIil9LHQucHJvdG90eXBlLnJlbHU9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwicmVsdVwiKX0sdC5wcm90b3R5cGUucmVsdTY9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwicmVsdTZcIil9LHQucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwicHJlbHVcIil9LHQucHJvdG90eXBlLmVsdT1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJlbHVcIil9LHQucHJvdG90eXBlLmVsdURlcj1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcImVsdURlclwiKX0sdC5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJzZWx1XCIpfSx0LnByb3RvdHlwZS5pbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwiaW50XCIpfSx0LnByb3RvdHlwZS5jbGlwPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaGEoXCJjbGlwXCIpfSx0LnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwiYWJzXCIpfSx0LnByb3RvdHlwZS5jb21wbGV4QWJzPWZ1bmN0aW9uKHQpe3JldHVybiBoYShcImNvbXBsZXhBYnNcIil9LHQucHJvdG90eXBlLnNpZ21vaWQ9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwic2lnbW9pZFwiKX0sdC5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwic29mdHBsdXNcIil9LHQucHJvdG90eXBlLnNpbj1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJzaW5cIil9LHQucHJvdG90eXBlLmNvcz1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJjb3NcIil9LHQucHJvdG90eXBlLnRhbj1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJ0YW5cIil9LHQucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwiYXNpblwiKX0sdC5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJhY29zXCIpfSx0LnByb3RvdHlwZS5hdGFuPWZ1bmN0aW9uKHQpe3JldHVybiBoYShcImF0YW5cIil9LHQucHJvdG90eXBlLmF0YW4yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwiYXRhbjJcIil9LHQucHJvdG90eXBlLnNpbmg9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwic2luaFwiKX0sdC5wcm90b3R5cGUuY29zaD1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJjb3NoXCIpfSx0LnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKHQpe3JldHVybiBoYShcInRhbmhcIil9LHQucHJvdG90eXBlLmFzaW5oPWZ1bmN0aW9uKHQpe3JldHVybiBoYShcImFzaW5oXCIpfSx0LnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJhY29zaFwiKX0sdC5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24odCl7cmV0dXJuIGhhKFwiYXRhbmhcIil9LHQucHJvdG90eXBlLmVyZj1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJlcmZcIil9LHQucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJzdGVwXCIpfSx0LnByb3RvdHlwZS5mdXNlZENvbnYyZD1mdW5jdGlvbih0KXt0LmlucHV0LHQuZmlsdGVyLHQuY29udkluZm8sdC5iaWFzLHQuYWN0aXZhdGlvbix0LnByZWx1QWN0aXZhdGlvbldlaWdodHM7cmV0dXJuIGhhKFwiZnVzZWRDb252MmRcIil9LHQucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwiY29udjJkXCIpfSx0LnByb3RvdHlwZS5jb252MmREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwiY29udjJkRGVySW5wdXRcIil9LHQucHJvdG90eXBlLmNvbnYyZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwiY29udjJkRGVyRmlsdGVyXCIpfSx0LnByb3RvdHlwZS5mdXNlZERlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0KXt0LmlucHV0LHQuZmlsdGVyLHQuY29udkluZm8sdC5iaWFzLHQuYWN0aXZhdGlvbix0LnByZWx1QWN0aXZhdGlvbldlaWdodHM7cmV0dXJuIGhhKFwiZnVzZWREZXB0aHdpc2VDb252MkRcIil9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwiZGVwdGh3aXNlQ29udjJEXCIpfSx0LnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwiZGVwdGh3aXNlQ29udjJERGVySW5wdXRcIil9LHQucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwiZGVwdGh3aXNlQ29udjJERGVyRmlsdGVyXCIpfSx0LnByb3RvdHlwZS5jb252M2Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBoYShcImNvbnYzZFwiKX0sdC5wcm90b3R5cGUuY29udjNkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBoYShcImNvbnYzZERlcklucHV0XCIpfSx0LnByb3RvdHlwZS5jb252M2REZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBoYShcImNvbnYzZERlckZpbHRlclwiKX0sdC5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcIm1heFBvb2xcIil9LHQucHJvdG90eXBlLm1heFBvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gaGEoXCJtYXhQb29sQmFja3Byb3BcIil9LHQucHJvdG90eXBlLmF2Z1Bvb2w9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJhdmdQb29sXCIpfSx0LnByb3RvdHlwZS5hdmdQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBoYShcImF2Z1Bvb2xCYWNrcHJvcFwiKX0sdC5wcm90b3R5cGUuYXZnUG9vbDNkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwiYXZnUG9vbDNkXCIpfSx0LnByb3RvdHlwZS5hdmdQb29sM2RCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwiYXZnUG9vbDNkQmFja3Byb3BcIil9LHQucHJvdG90eXBlLm1heFBvb2wzZD1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcIm1heFBvb2wzZFwiKX0sdC5wcm90b3R5cGUubWF4UG9vbDNkQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIGhhKFwibWF4UG9vbDNkQmFja3Byb3BcIil9LHQucHJvdG90eXBlLnJlc2hhcGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJyZXNoYXBlXCIpfSx0LnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwiY2FzdFwiKX0sdC5wcm90b3R5cGUudGlsZT1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcInRpbGVcIil9LHQucHJvdG90eXBlLnBhZD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwicGFkXCIpfSx0LnByb3RvdHlwZS50cmFuc3Bvc2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGEoXCJ0cmFuc3Bvc2VcIil9LHQucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwiZ2F0aGVyXCIpfSx0LnByb3RvdHlwZS5nYXRoZXJORD1mdW5jdGlvbih0LGUpe3JldHVybiBoYShcImdhdGhlck5EXCIpfSx0LnByb3RvdHlwZS5zY2F0dGVyTkQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBoYShcInNjYXR0ZXJORFwiKX0sdC5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBoYShcImJhdGNoVG9TcGFjZU5EXCIpfSx0LnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwic3BhY2VUb0JhdGNoTkRcIil9LHQucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBoYShcInJlc2l6ZUJpbGluZWFyXCIpfSx0LnByb3RvdHlwZS5yZXNpemVCaWxpbmVhckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaGEoXCJyZXNpemVCaWxpbmVhckJhY2twcm9wXCIpfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3I9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIGhhKFwicmVzaXplTmVhcmVzdE5laWdoYm9yXCIpfSx0LnByb3RvdHlwZS5yZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwicmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3BcIil9LHQucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIGhhKFwiYmF0Y2hOb3JtYWxpemF0aW9uXCIpfSx0LnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIGhhKFwibG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RFwiKX0sdC5wcm90b3R5cGUuTFJOR3JhZD1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXtyZXR1cm4gaGEoXCJMUk5HcmFkXCIpfSx0LnByb3RvdHlwZS5tdWx0aW5vbWlhbD1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gaGEoXCJtdWx0aW5vbWlhbFwiKX0sdC5wcm90b3R5cGUub25lSG90PWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBoYShcIm9uZUhvdFwiKX0sdC5wcm90b3R5cGUuY3Vtc3VtPWZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiBoYShcImN1bXN1bVwiKX0sdC5wcm90b3R5cGUubm9uTWF4U3VwcHJlc3Npb249ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gaGEoXCJub25NYXhTdXBwcmVzc2lvblwiKX0sdC5wcm90b3R5cGUuZmZ0PWZ1bmN0aW9uKHQpe3JldHVybiBoYShcImZmdFwiKX0sdC5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJpZmZ0XCIpfSx0LnByb3RvdHlwZS5jb21wbGV4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhhKFwiY29tcGxleFwiKX0sdC5wcm90b3R5cGUucmVhbD1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJyZWFsXCIpfSx0LnByb3RvdHlwZS5pbWFnPWZ1bmN0aW9uKHQpe3JldHVybiBoYShcImltYWdcIil9LHQucHJvdG90eXBlLmNyb3BBbmRSZXNpemU9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiBoYShcImNyb3BBbmRSZXNpemVcIil9LHQucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwiZGVwdGhUb1NwYWNlXCIpfSx0LnByb3RvdHlwZS5zcGxpdD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGhhKFwic3BsaXRcIil9LHQucHJvdG90eXBlLnNwYXJzZVRvRGVuc2U9ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIGhhKFwic3BhcnNlVG9EZW5zZVwiKX0sdC5wcm90b3R5cGUuZGlhZz1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJkaWFnXCIpfSx0LnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaGEoXCJmaWxsXCIpfSx0LnByb3RvdHlwZS5vbmVzTGlrZT1mdW5jdGlvbih0KXtyZXR1cm4gaGEoXCJvbmVzTGlrZVwiKX0sdC5wcm90b3R5cGUuemVyb3NMaWtlPWZ1bmN0aW9uKHQpe3JldHVybiBoYShcInplcm9zTGlrZVwiKX0sdC5wcm90b3R5cGUubGluc3BhY2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBoYShcImxpbnNwYWNlXCIpfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIGhhKFwiZGlzcG9zZVwiKX0sdH0oKTtmdW5jdGlvbiBoYSh0KXt0aHJvdyBuZXcgRXJyb3IoXCInXCIrdCtcIicgbm90IHlldCBpbXBsZW1lbnRlZCBvciBub3QgZm91bmQgaW4gdGhlIHJlZ2lzdHJ5LiBEaWQgeW91IGZvcmdldCB0byBpbXBvcnQgdGhlIGtlcm5lbD9cIil9ZnVuY3Rpb24gZmEodCxlLG4scixvLGEsaSl7dm9pZCAwPT09aSYmKGk9XCJjaGFubmVsc0xhc3RcIik7dmFyIHMsdT1tYShlKSxjPXVbMF0sbD11WzFdO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1pKXM9W2MsbCx0WzNdLHRbM11dO2Vsc2V7aWYoXCJjaGFubmVsc0ZpcnN0XCIhPT1pKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIitpKTtzPVtjLGwsdFsxXSx0WzFdXX1yZXR1cm4gcGEodCxzLG4scixvLGEsITEsaSl9ZnVuY3Rpb24gZGEodCxlLG4scixvLGEsaSl7dm9pZCAwPT09aSYmKGk9XCJOREhXQ1wiKTt2YXIgcyx1LGM9eWEoZSksbD1jWzBdLGg9Y1sxXSxmPWNbMl07aWYoXCJOREhXQ1wiPT09aSl1PVwiY2hhbm5lbHNMYXN0XCIscz1bbCxoLGYsdFs0XSx0WzRdXTtlbHNle2lmKFwiTkNESFdcIiE9PWkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiK2kpO3U9XCJjaGFubmVsc0ZpcnN0XCIscz1bbCxoLGYsdFsxXSx0WzFdXX1yZXR1cm4gdmEodCxzLG4scixvLCExLHUsYSl9ZnVuY3Rpb24gcGEodCxlLG4scixvLGEsaSxzKXt2b2lkIDA9PT1pJiYoaT0hMSksdm9pZCAwPT09cyYmKHM9XCJjaGFubmVsc0xhc3RcIik7dmFyIHU9Wy0xLC0xLC0xLC0xXSxjPXVbMF0sbD11WzFdLGg9dVsyXSxmPXVbM107aWYoXCJjaGFubmVsc0xhc3RcIj09PXMpYz10WzBdLGw9dFsxXSxoPXRbMl0sZj10WzNdO2Vsc2V7aWYoXCJjaGFubmVsc0ZpcnN0XCIhPT1zKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIitzKTtjPXRbMF0sZj10WzFdLGw9dFsyXSxoPXRbM119dmFyIGQscD1lWzBdLHY9ZVsxXSxnPWVbM10sbT1tYShuKSx5PW1bMF0seD1tWzFdLGI9bWEociksdz1iWzBdLEU9YlsxXSxSPXhhKHAsdyksST14YSh2LEUpLGs9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzKXt2YXIgdSxjLGw7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpe3U9e3RvcDp0LGJvdHRvbTp0LGxlZnQ6dCxyaWdodDp0LHR5cGU6MD09PXQ/XCJWQUxJRFwiOlwiTlVNQkVSXCJ9O3ZhciBoPWZ1bmN0aW9uKHQsZSxuLHIsbyl7bnVsbD09ciYmKHI9Z2EodCxlLG4pKTt2YXIgYT10WzBdLGk9dFsxXSxzPWJhKChhLWUrMipyKS9uKzEsbyk7QyhBKHMpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIG91dHB1dCAjIG9mIHJvd3MgKFwiK3MrXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIn0pKTt2YXIgdT1iYSgoaS1lKzIqcikvbisxLG8pO3JldHVybiBDKEEodSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgb3V0cHV0ICMgb2YgY29sdW1ucyAoXCIrdStcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wifSkpLFtzLHVdfShbZSxuXSxhLHIsdCxzKTtjPWhbMF0sbD1oWzFdfWVsc2UgaWYoXCJzYW1lXCI9PT10KXtjPU1hdGguY2VpbChlL3IpLGw9TWF0aC5jZWlsKG4vbyk7dmFyIGY9TWF0aC5tYXgoMCwoYy0xKSpyK2EtZSksZD1NYXRoLm1heCgwLChsLTEpKm8raS1uKSxwPU1hdGguZmxvb3IoZi8yKSx2PWYtcCxnPU1hdGguZmxvb3IoZC8yKTt1PXt0b3A6cCxib3R0b206dixsZWZ0OmcscmlnaHQ6ZC1nLHR5cGU6XCJTQU1FXCJ9fWVsc2V7aWYoXCJ2YWxpZFwiIT09dCl0aHJvdyBFcnJvcihcIlVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6IFwiK3QpO3U9e3RvcDowLGJvdHRvbTowLGxlZnQ6MCxyaWdodDowLHR5cGU6XCJWQUxJRFwifSxjPU1hdGguY2VpbCgoZS1hKzEpL3IpLGw9TWF0aC5jZWlsKChuLWkrMSkvbyl9cmV0dXJue3BhZEluZm86dSxvdXRIZWlnaHQ6YyxvdXRXaWR0aDpsfX0obyxsLGgseSx4LFIsSSxhKSxTPWsucGFkSW5mbyxUPWsub3V0SGVpZ2h0LEQ9ay5vdXRXaWR0aCxOPWk/ZypmOmc7cmV0dXJuXCJjaGFubmVsc0ZpcnN0XCI9PT1zP2Q9W2MsTixULERdOlwiY2hhbm5lbHNMYXN0XCI9PT1zJiYoZD1bYyxULEQsTl0pLHtiYXRjaFNpemU6YyxkYXRhRm9ybWF0OnMsaW5IZWlnaHQ6bCxpbldpZHRoOmgsaW5DaGFubmVsczpmLG91dEhlaWdodDpULG91dFdpZHRoOkQsb3V0Q2hhbm5lbHM6TixwYWRJbmZvOlMsc3RyaWRlSGVpZ2h0Onksc3RyaWRlV2lkdGg6eCxmaWx0ZXJIZWlnaHQ6cCxmaWx0ZXJXaWR0aDp2LGVmZmVjdGl2ZUZpbHRlckhlaWdodDpSLGVmZmVjdGl2ZUZpbHRlcldpZHRoOkksZGlsYXRpb25IZWlnaHQ6dyxkaWxhdGlvbldpZHRoOkUsaW5TaGFwZTp0LG91dFNoYXBlOmQsZmlsdGVyU2hhcGU6ZX19ZnVuY3Rpb24gdmEodCxlLG4scixvLGEsaSxzKXt2b2lkIDA9PT1hJiYoYT0hMSksdm9pZCAwPT09aSYmKGk9XCJjaGFubmVsc0xhc3RcIik7dmFyIHU9Wy0xLC0xLC0xLC0xLC0xXSxjPXVbMF0sbD11WzFdLGg9dVsyXSxmPXVbM10sZD11WzRdO2lmKFwiY2hhbm5lbHNMYXN0XCI9PT1pKWM9dFswXSxsPXRbMV0saD10WzJdLGY9dFszXSxkPXRbNF07ZWxzZXtpZihcImNoYW5uZWxzRmlyc3RcIiE9PWkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhRm9ybWF0IFwiK2kpO2M9dFswXSxkPXRbMV0sbD10WzJdLGg9dFszXSxmPXRbNF19dmFyIHAsdj1lWzBdLGc9ZVsxXSxtPWVbMl0seT1lWzRdLHg9eWEobiksYj14WzBdLHc9eFsxXSxFPXhbMl0sUj15YShyKSxJPVJbMF0saz1SWzFdLFM9UlsyXSxUPXhhKHYsSSksRD14YShnLGspLE49eGEobSxTKSxGPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkscyx1LGMsbCl7dmFyIGgsZixkLHA7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpe2g9e3RvcDp0LGJvdHRvbTp0LGxlZnQ6dCxyaWdodDp0LGZyb250OnQsYmFjazp0LHR5cGU6MD09PXQ/XCJWQUxJRFwiOlwiTlVNQkVSXCJ9O3ZhciB2PWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtudWxsPT1vJiYobz1nYSh0LGUscikpO3ZhciBpPXRbMF0scz10WzFdLHU9dFsyXSxjPWJhKChpLWUrMipvKS9yKzEsYSk7QyhBKGMpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIG91dHB1dCAjIG9mIGRlcHRocyAoXCIrYytcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wifSkpO3ZhciBsPWJhKChzLWUrMipvKS9yKzEsYSk7QyhBKGwpLChmdW5jdGlvbigpe3JldHVyblwiVGhlIG91dHB1dCAjIG9mIHJvd3MgKFwiK2wrXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIn0pKTt2YXIgaD1iYSgodS1lKzIqbykvcisxLGEpO3JldHVybiBDKEEoaCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgb3V0cHV0ICMgb2YgY29sdW1ucyAoXCIraCtcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgdGhlIHN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wifSkpLFtjLGwsaCxuXX0oW2UsbixyLDFdLHMsMSxvLHQsbCk7Zj12WzBdLGQ9dlsxXSxwPXZbMl19ZWxzZSBpZihcInNhbWVcIj09PXQpe2Y9TWF0aC5jZWlsKGUvbyksZD1NYXRoLmNlaWwobi9hKSxwPU1hdGguY2VpbChyL2kpO3ZhciBnPShmLTEpKm8rcy1lLG09KGQtMSkqYSt1LW4seT0ocC0xKSppK2Mtcix4PU1hdGguZmxvb3IoZy8yKSxiPWcteCx3PU1hdGguZmxvb3IobS8yKSxFPW0tdyxSPU1hdGguZmxvb3IoeS8yKTtoPXt0b3A6dyxib3R0b206RSxsZWZ0OlIscmlnaHQ6eS1SLGZyb250OngsYmFjazpiLHR5cGU6XCJTQU1FXCJ9fWVsc2V7aWYoXCJ2YWxpZFwiIT09dCl0aHJvdyBFcnJvcihcIlVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6IFwiK3QpO2g9e3RvcDowLGJvdHRvbTowLGxlZnQ6MCxyaWdodDowLGZyb250OjAsYmFjazowLHR5cGU6XCJWQUxJRFwifSxmPU1hdGguY2VpbCgoZS1zKzEpL28pLGQ9TWF0aC5jZWlsKChuLXUrMSkvYSkscD1NYXRoLmNlaWwoKHItYysxKS9pKX1yZXR1cm57cGFkSW5mbzpoLG91dERlcHRoOmYsb3V0SGVpZ2h0OmQsb3V0V2lkdGg6cH19KG8sbCxoLGYsYix3LEUsVCxELE4scyksXz1GLnBhZEluZm8sTz1GLm91dERlcHRoLE09Ri5vdXRIZWlnaHQsQj1GLm91dFdpZHRoLFA9YT95KmQ6eTtyZXR1cm5cImNoYW5uZWxzRmlyc3RcIj09PWk/cD1bYyxQLE8sTSxCXTpcImNoYW5uZWxzTGFzdFwiPT09aSYmKHA9W2MsTyxNLEIsUF0pLHtiYXRjaFNpemU6YyxkYXRhRm9ybWF0OmksaW5EZXB0aDpsLGluSGVpZ2h0OmgsaW5XaWR0aDpmLGluQ2hhbm5lbHM6ZCxvdXREZXB0aDpPLG91dEhlaWdodDpNLG91dFdpZHRoOkIsb3V0Q2hhbm5lbHM6UCxwYWRJbmZvOl8sc3RyaWRlRGVwdGg6YixzdHJpZGVIZWlnaHQ6dyxzdHJpZGVXaWR0aDpFLGZpbHRlckRlcHRoOnYsZmlsdGVySGVpZ2h0OmcsZmlsdGVyV2lkdGg6bSxlZmZlY3RpdmVGaWx0ZXJEZXB0aDpULGVmZmVjdGl2ZUZpbHRlckhlaWdodDpELGVmZmVjdGl2ZUZpbHRlcldpZHRoOk4sZGlsYXRpb25EZXB0aDpJLGRpbGF0aW9uSGVpZ2h0OmssZGlsYXRpb25XaWR0aDpTLGluU2hhcGU6dCxvdXRTaGFwZTpwLGZpbHRlclNoYXBlOmV9fWZ1bmN0aW9uIGdhKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPTEpO3ZhciBvPXhhKGUscik7cmV0dXJuIE1hdGguZmxvb3IoKHRbMF0qKG4tMSktbitvKS8yKX1mdW5jdGlvbiBtYSh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdD9bdCx0LHRdOjI9PT10Lmxlbmd0aD9bdFswXSx0WzFdLDFdOnR9ZnVuY3Rpb24geWEodCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/W3QsdCx0XTp0fWZ1bmN0aW9uIHhhKHQsZSl7cmV0dXJuIGU8PTE/dDp0Kyh0LTEpKihlLTEpfWZ1bmN0aW9uIGJhKHQsZSl7aWYoIWUpcmV0dXJuIHQ7c3dpdGNoKGUpe2Nhc2VcInJvdW5kXCI6cmV0dXJuIE1hdGgucm91bmQodCk7Y2FzZVwiY2VpbFwiOnJldHVybiBNYXRoLmNlaWwodCk7Y2FzZVwiZmxvb3JcIjpyZXR1cm4gTWF0aC5mbG9vcih0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVua25vd24gcm91bmRpbmdNb2RlIFwiK2UpfX1mdW5jdGlvbiB3YSh0KXt2YXIgZT1tYSh0KSxuPWVbMF0scj1lWzFdLG89ZVsyXTtyZXR1cm4gMT09PW4mJjE9PT1yJiYxPT09b31mdW5jdGlvbiBDYSh0LGUpe3JldHVybiB3YSh0KXx8d2EoZSl9ZnVuY3Rpb24gRWEodCl7aWYoXCJOSFdDXCI9PT10KXJldHVyblwiY2hhbm5lbHNMYXN0XCI7aWYoXCJOQ0hXXCI9PT10KXJldHVyblwiY2hhbm5lbHNGaXJzdFwiO3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YUZvcm1hdCBcIit0KX1mdW5jdGlvbiBSYSh0LGUsbil7aWYoXCJjb21wbGV4NjRcIj09PWUpe2lmKFwiY29tcGxleDY0XCI9PT10LmR0eXBlKXJldHVybiB0LmNsb25lKCk7dmFyIHI9R24odC5zaGFwZSksbz10LnRvRmxvYXQoKSxhPW4uY29tcGxleChvLHIpO3JldHVybiByLmRpc3Bvc2UoKSxvLmRpc3Bvc2UoKSxhfWlmKCFVKHQuZHR5cGUsZSkpcmV0dXJuIEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKHQuZGF0YUlkLHQuc2hhcGUsZSk7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUpe3ZhciBpPW4ucmVhbCh0KTthPWkuY2FzdChlKTtyZXR1cm4gaS5kaXNwb3NlKCksYX1pZihcImludDMyXCI9PT1lKXJldHVybiBuLmludCh0KTtpZihcImJvb2xcIj09PWUpe3ZhciBzPU9uKDAsdC5kdHlwZSk7YT1uLm5vdEVxdWFsKHQscyk7cmV0dXJuIHMuZGlzcG9zZSgpLGF9dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gQ2FzdDogZmFpbGVkIHRvIGNhc3QgXCIrdC5kdHlwZStcIiB0byBcIitlKX1mdW5jdGlvbiBJYSh0LGUpe3JldHVybiBMdC5tYWtlVGVuc29yRnJvbURhdGFJZCh0LmRhdGFJZCxlLHQuZHR5cGUpfWZ1bmN0aW9uIGthKHQsZSxuKXt2YXIgcj0oZS10KS8obi0xKSxvPXR0KG4sXCJmbG9hdDMyXCIpO29bMF09dDtmb3IodmFyIGE9MTthPG8ubGVuZ3RoO2ErKylvW2FdPW9bYS0xXStyO3JldHVybiBNbihvLFwiZmxvYXQzMlwiKX12YXIgU2E9T2JqZWN0LmZyZWV6ZSh7Y2FzdFRlbnNvcjpSYSxyZXNoYXBlVGVuc29yOklhLGxpbnNwYWNlSW1wbDprYSx1cGNhc3RUeXBlOlR0LGF4ZXNBcmVJbm5lck1vc3REaW1zOnluLGNvbWJpbmVMb2NhdGlvbnM6eG4sY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlczpibixleHBhbmRTaGFwZVRvS2VlcERpbTp3bixhc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltczpDbixnZXRBeGVzUGVybXV0YXRpb246RW4sZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbjpSbixnZXRJbm5lck1vc3RBeGVzOkluLGdldEJyb2FkY2FzdERpbXM6TXIsZ2V0UmVkdWN0aW9uQXhlczpCcixhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZTpQcixhc3NlcnRQYXJhbXNDb25zaXN0ZW50OmtuLGNvbXB1dGVPdXRTaGFwZTpTbixjb21wdXRlUG9vbDJESW5mbzpmYSxjb21wdXRlUG9vbDNESW5mbzpkYSxjb21wdXRlQ29udjJESW5mbzpwYSxjb21wdXRlQ29udjNESW5mbzp2YSxjb21wdXRlRGVmYXVsdFBhZDpnYSx0dXBsZVZhbHVlc0FyZU9uZTp3YSxlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmU6Q2EsY29udmVydENvbnYyRERhdGFGb3JtYXQ6RWEsUEFSQUxMRUxJWkVfVEhSRVNIT0xEOldvLGNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZTpVb30pO2Z1bmN0aW9uIEFhKHQsZSl7aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgcmVhbCBhbmQgaW1hZyBhcnJheXMgb2YgZGlmZmVyZW50IGxlbmd0aHMuIHJlYWw6XCIrdC5sZW5ndGgrXCIsIGltYWc6IFwiK2UubGVuZ3RoK1wiLlwiKTtmb3IodmFyIG49bmV3IEZsb2F0MzJBcnJheSgyKnQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDtyKz0yKW5bcl09dFtyLzJdLG5bcisxXT1lW3IvMl07cmV0dXJuIG59ZnVuY3Rpb24gVGEodCxlKXtyZXR1cm57cmVhbDp0WzIqZV0saW1hZzp0WzIqZSsxXX19ZnVuY3Rpb24gRGEodCxlLG4scil7dFsyKnJdPWUsdFsyKnIrMV09bn1mdW5jdGlvbiBOYSh0LGUsbil7dmFyIHI9KG4/MjotMikqTWF0aC5QSSoodC9lKTtyZXR1cm57cmVhbDpNYXRoLmNvcyhyKSxpbWFnOk1hdGguc2luKHIpfX1mdW5jdGlvbiBGYSh0LGUsbil7dmFyIHI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBmdW5jdGlvbih0LGUsbil7dmFyIHI9MCxvPXQubGVuZ3RoLGE9MCxpPSExO2Zvcig7cjxvOyl7dmFyIHM9bihlLHRbYT1yKyhvLXI+Pj4xKV0pO3M+MD9yPWErMToobz1hLGk9IXMpfXJldHVybiBpP3I6LXItMX0odCxlLG58fF9hKX0odCxlLG4pLG89cjwwPy0ocisxKTpyO3Quc3BsaWNlKG8sMCxlKX1mdW5jdGlvbiBfYSh0LGUpe3JldHVybiB0PmU/MTp0PGU/LTE6MH1mdW5jdGlvbiBPYSh0LGUsbixyLG8pe3JldHVybiBCYSh0LGUsbixyLG8sMCkuc2VsZWN0ZWRJbmRpY2VzfWZ1bmN0aW9uIE1hKHQsZSxuLHIsbyxhKXt2YXIgaT1CYSh0LGUsbixyLG8sYSwhMCk7cmV0dXJuIGkubnVtVmFsaWRPdXRwdXRzLmRpc3Bvc2UoKSx7c2VsZWN0ZWRJbmRpY2VzOmkuc2VsZWN0ZWRJbmRpY2VzLHNlbGVjdGVkU2NvcmVzOmkuc2VsZWN0ZWRTY29yZXN9fWZ1bmN0aW9uIEJhKHQsZSxuLHIsbyxhLGkscyl7dm9pZCAwPT09aSYmKGk9ITEpLHZvaWQgMD09PXMmJihzPSExKTtmb3IodmFyIHU9QXJyYXkuZnJvbShlKS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJue3Njb3JlOnQsYm94SW5kZXg6ZSxzdXBwcmVzc0JlZ2luSW5kZXg6MH19KSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zY29yZT5vfSkpLnNvcnQoV2EpLGM9YT4wPy0uNS9hOjAsbD1bXSxoPVtdO2wubGVuZ3RoPG4mJnUubGVuZ3RoPjA7KXt2YXIgZj11LnBvcCgpLGQ9Zi5zY29yZSxwPWYuYm94SW5kZXgsdj1mLnN1cHByZXNzQmVnaW5JbmRleDtpZihkPG8pYnJlYWs7Zm9yKHZhciBnPSExLG09bC5sZW5ndGgtMTttPj12Oy0tbSl7dmFyIHk9UGEodCxwLGxbbV0pO2lmKHk+PXIpe2c9ITA7YnJlYWt9aWYoZi5zY29yZT1mLnNjb3JlKkxhKHIsYyx5KSxmLnNjb3JlPD1vKWJyZWFrfWYuc3VwcHJlc3NCZWdpbkluZGV4PWwubGVuZ3RoLGd8fChmLnNjb3JlPT09ZD8obC5wdXNoKHApLGgucHVzaChmLnNjb3JlKSk6Zi5zY29yZT5vJiZGYSh1LGYsV2EpKX12YXIgeD1sLmxlbmd0aDtyZXR1cm4gcyYmKGwuZmlsbCgwLHgpLGguZmlsbCgwLHgpKSx7c2VsZWN0ZWRJbmRpY2VzOk1uKGwsXCJpbnQzMlwiKSxzZWxlY3RlZFNjb3JlczpNbihoLFwiZmxvYXQzMlwiKSxudW1WYWxpZE91dHB1dHM6T24oeCxcImludDMyXCIpfX1mdW5jdGlvbiBQYSh0LGUsbil7dmFyIHI9dC5zdWJhcnJheSg0KmUsNCplKzQpLG89dC5zdWJhcnJheSg0Km4sNCpuKzQpLGE9TWF0aC5taW4oclswXSxyWzJdKSxpPU1hdGgubWluKHJbMV0sclszXSkscz1NYXRoLm1heChyWzBdLHJbMl0pLHU9TWF0aC5tYXgoclsxXSxyWzNdKSxjPU1hdGgubWluKG9bMF0sb1syXSksbD1NYXRoLm1pbihvWzFdLG9bM10pLGg9TWF0aC5tYXgob1swXSxvWzJdKSxmPU1hdGgubWF4KG9bMV0sb1szXSksZD0ocy1hKSoodS1pKSxwPShoLWMpKihmLWwpO2lmKGQ8PTB8fHA8PTApcmV0dXJuIDA7dmFyIHY9TWF0aC5tYXgoYSxjKSxnPU1hdGgubWF4KGksbCksbT1NYXRoLm1pbihzLGgpLHk9TWF0aC5taW4odSxmKSx4PU1hdGgubWF4KG0tdiwwKSpNYXRoLm1heCh5LWcsMCk7cmV0dXJuIHgvKGQrcC14KX1mdW5jdGlvbiBMYSh0LGUsbil7dmFyIHI9TWF0aC5leHAoZSpuKm4pO3JldHVybiBuPD10P3I6MH1mdW5jdGlvbiBXYSh0LGUpe3JldHVybiB0LnNjb3JlLWUuc2NvcmV8fHQuc2NvcmU9PT1lLnNjb3JlJiZlLmJveEluZGV4LXQuYm94SW5kZXh9ZnVuY3Rpb24gVWEodCxlLG4pe3ZhciByPW5ldyBBcnJheSh0LnJhbmspLmZpbGwoMCksbz10LnNoYXBlLnNsaWNlKCk7cmV0dXJuIGUubWFwKChmdW5jdGlvbihlKXtvW25dPWU7dmFyIGE9dC5zbGljZShyLG8pO3JldHVybiByW25dKz1lLGF9KSl9ZnVuY3Rpb24gVmEodCxlKXtmb3IodmFyIG49bmV3IEFycmF5KHQucmFuaykscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dC5zaGFwZVtyXSplW3JdO3ZhciBvPWVyKG4sdC5kdHlwZSk7Zm9yKHI9MDtyPG8udmFsdWVzLmxlbmd0aDsrK3Ipe2Zvcih2YXIgYT1vLmluZGV4VG9Mb2MociksaT1uZXcgQXJyYXkodC5yYW5rKSxzPTA7czxpLmxlbmd0aDtzKyspaVtzXT1hW3NdJXQuc2hhcGVbc107dmFyIHU9dC5sb2NUb0luZGV4KGkpO28udmFsdWVzW3JdPXQudmFsdWVzW3VdfXJldHVybiBvLnRvVGVuc29yKCl9ZnVuY3Rpb24gemEodCxlLG4scixvKXtmb3IodmFyIGE9ZVtlLmxlbmd0aC0xXSxpPVt0Lmxlbmd0aC9hLGFdLHM9aVswXSx1PWlbMV0sYz1CKG4scypyKSxsPUIoXCJpbnQzMlwiLHMqciksaD0wO2g8cztoKyspe2Zvcih2YXIgZj1oKnUsZD10LnN1YmFycmF5KGYsZit1KSxwPVtdLHY9MDt2PGQubGVuZ3RoO3YrKylwLnB1c2goe3ZhbHVlOmRbdl0saW5kZXg6dn0pO3Auc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gZS52YWx1ZS10LnZhbHVlfSkpO3ZhciBnPWgqcixtPWMuc3ViYXJyYXkoZyxnK3IpLHk9bC5zdWJhcnJheShnLGcrcik7Zm9yKHY9MDt2PHI7disrKW1bdl09cFt2XS52YWx1ZSx5W3ZdPXBbdl0uaW5kZXh9dmFyIHg9ZS5zbGljZSgpO3JldHVybiB4W3gubGVuZ3RoLTFdPXIsW0ZuKGMseCxuKSxGbihsLHgsXCJpbnQzMlwiKV19ZnVuY3Rpb24gR2EodCxlKXtmb3IodmFyIG49W10scj0wO3I8ZS5sZW5ndGg7cisrKWVbcl0mJm4ucHVzaChyKTt2YXIgbz1lcih0LFwiaW50MzJcIiksYT1lcihbbi5sZW5ndGgsdC5sZW5ndGhdLFwiaW50MzJcIik7Zm9yKHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIGk9by5pbmRleFRvTG9jKG5bcl0pLHM9cip0Lmxlbmd0aDthLnZhbHVlcy5zZXQoaSxzKX1yZXR1cm4gYS50b1RlbnNvcigpfXZhciBIYT1mdW5jdGlvbih0LGUpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudmFyaWFibGVOYW1lcz1lLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cIlRcIitlfSkpO3ZhciBuPVtdO3RoaXMudmFyaWFibGVOYW1lcy5mb3JFYWNoKChmdW5jdGlvbih0KXtuLnB1c2goXCJmbG9hdCB2XCIrdCtcIiA9IGdldFwiK3QrXCJBdE91dENvb3JkcygpO1wiKX0pKTt2YXIgcj10aGlzLnZhcmlhYmxlTmFtZXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cInZcIit0fSkpLmpvaW4oXCIgKyBcIik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK24uam9pbihcIlxcbiAgICAgICAgXCIpK1wiXFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSBcIityK1wiO1xcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0scWE9ZnVuY3Rpb24odCxlKXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnZhcmlhYmxlTmFtZXM9ZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJUXCIrZX0pKTt2YXIgbj1bXTt0aGlzLnZhcmlhYmxlTmFtZXMuZm9yRWFjaCgoZnVuY3Rpb24odCl7bi5wdXNoKFwidmVjNCB2XCIrdCtcIiA9IGdldFwiK3QrXCJBdE91dENvb3JkcygpO1wiKX0pKTt2YXIgcj10aGlzLnZhcmlhYmxlTmFtZXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cInZcIit0fSkpLmpvaW4oXCIgKyBcIik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK24uam9pbihcIlxcbiAgICAgICAgXCIpK1wiXFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IFwiK3IrXCI7XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxLYT1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07dmFyIHI9dC53aW5kb3dTaXplLG89dC5iYXRjaFNpemUsYT10LmluU2l6ZSxpPU1hdGguY2VpbChhL3IpO258fHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmVzdEluZGljZXNBXCIpLHRoaXMub3V0cHV0U2hhcGU9W28saV07dmFyIHM9XCJtYXhcIj09PWU/XCI+XCI6XCI8XCIsdT1uP1wiaW5PZmZzZXQgKyBpO1wiOlwicm91bmQoZ2V0QmVzdEluZGljZXNBKGJhdGNoLCBpbk9mZnNldCArIGkpKTtcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIrcitcIjtcXG5cXG4gICAgICAgIGludCBiZXN0SW5kZXggPSBpbk9mZnNldDtcXG4gICAgICAgIGZsb2F0IGJlc3RWYWx1ZSA9IGdldEEoYmF0Y2gsIGJlc3RJbmRleCk7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3IrXCI7IGkrKykge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBcIit1K1wiO1xcbiAgICAgICAgICBmbG9hdCBjYW5kaWRhdGUgPSBnZXRBKGJhdGNoLCBpbklkeCk7XFxuICAgICAgICAgIGlmIChjYW5kaWRhdGUgXCIrcytcIiBiZXN0VmFsdWUpIHtcXG4gICAgICAgICAgICBiZXN0VmFsdWUgPSBjYW5kaWRhdGU7XFxuICAgICAgICAgICAgYmVzdEluZGV4ID0gaW5JZHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChiZXN0SW5kZXgpKTtcXG4gICAgICB9XFxuICAgIFwifTtmdW5jdGlvbiBqYSh0LGUpe3JldHVybltcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl0uc2xpY2UoMCxlKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiB0K1wiLlwiK2V9KSl9ZnVuY3Rpb24gWGEodCxlKXtyZXR1cm4gMT09PWU/W3RdOmphKHQsZSl9ZnVuY3Rpb24gWWEoKXt2YXIgdCxlLG4scixvLGEscyx1LGMsbDtyZXR1cm4gMj09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpPyh0PVwiI3ZlcnNpb24gMzAwIGVzXCIsZT1cImluXCIsbj1cIm91dFwiLHI9XCJpblwiLG89XCJ0ZXh0dXJlXCIsYT1cIm91dHB1dENvbG9yXCIscz1cIm91dCB2ZWM0IG91dHB1dENvbG9yO1wiLHU9XCJcXG4gICAgICBib29sIGlzbmFuX2N1c3RvbShmbG9hdCB2YWwpIHtcXG4gICAgICAgIHJldHVybiAodmFsID4gMC4wIHx8IHZhbCA8IDAuMCkgPyBmYWxzZSA6IHZhbCAhPSAwLjA7XFxuICAgICAgfVxcblxcbiAgICAgIGJ2ZWM0IGlzbmFuX2N1c3RvbSh2ZWM0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuIGJ2ZWM0KGlzbmFuX2N1c3RvbSh2YWwueCksXFxuICAgICAgICAgIGlzbmFuX2N1c3RvbSh2YWwueSksIGlzbmFuX2N1c3RvbSh2YWwueiksIGlzbmFuX2N1c3RvbSh2YWwudykpO1xcbiAgICAgIH1cXG5cXG4gICAgICAjZGVmaW5lIGlzbmFuKHZhbHVlKSBpc25hbl9jdXN0b20odmFsdWUpXFxuICAgIFwiLGM9XCJcIixsPVwiXFxuICAgICAgI2RlZmluZSByb3VuZCh2YWx1ZSkgbmV3Um91bmQodmFsdWUpXFxuICAgICAgaW50IG5ld1JvdW5kKGZsb2F0IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaW50KGZsb29yKHZhbHVlICsgMC41KSk7XFxuICAgICAgfVxcblxcbiAgICAgIGl2ZWM0IG5ld1JvdW5kKHZlYzQgdmFsdWUpIHtcXG4gICAgICAgIHJldHVybiBpdmVjNChmbG9vcih2YWx1ZSArIHZlYzQoMC41KSkpO1xcbiAgICAgIH1cXG4gICAgXCIpOih0PVwiXCIsZT1cImF0dHJpYnV0ZVwiLG49XCJ2YXJ5aW5nXCIscj1cInZhcnlpbmdcIixvPVwidGV4dHVyZTJEXCIsYT1cImdsX0ZyYWdDb2xvclwiLHM9XCJcIix1PVwiXFxuICAgICAgI2RlZmluZSBpc25hbih2YWx1ZSkgaXNuYW5fY3VzdG9tKHZhbHVlKVxcbiAgICAgIGJvb2wgaXNuYW5fY3VzdG9tKGZsb2F0IHZhbCkge1xcbiAgICAgICAgcmV0dXJuICh2YWwgPiAwLiB8fCB2YWwgPCAxLiB8fCB2YWwgPT0gMC4pID8gZmFsc2UgOiB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBidmVjNCBpc25hbl9jdXN0b20odmVjNCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBidmVjNChpc25hbih2YWwueCksIGlzbmFuKHZhbC55KSwgaXNuYW4odmFsLnopLCBpc25hbih2YWwudykpO1xcbiAgICAgIH1cXG4gICAgXCIsYz1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgSU5GSU5JVFk7XFxuXFxuICAgICAgYm9vbCBpc2luZihmbG9hdCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBhYnModmFsKSA9PSBJTkZJTklUWTtcXG4gICAgICB9XFxuICAgICAgYnZlYzQgaXNpbmYodmVjNCB2YWwpIHtcXG4gICAgICAgIHJldHVybiBlcXVhbChhYnModmFsKSwgdmVjNChJTkZJTklUWSkpO1xcbiAgICAgIH1cXG4gICAgXCIsbD1cIlxcbiAgICAgIGludCByb3VuZChmbG9hdCB2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIGludChmbG9vcih2YWx1ZSArIDAuNSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpdmVjNCByb3VuZCh2ZWM0IHZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaXZlYzQoZmxvb3IodmFsdWUgKyB2ZWM0KDAuNSkpKTtcXG4gICAgICB9XFxuICAgIFwiKSx7dmVyc2lvbjp0LGF0dHJpYnV0ZTplLHZhcnlpbmdWczpuLHZhcnlpbmdGczpyLHRleHR1cmUyRDpvLG91dHB1dDphLGRlZmluZU91dHB1dDpzLGRlZmluZVNwZWNpYWxOYU46dSxkZWZpbmVTcGVjaWFsSW5mOmMsZGVmaW5lUm91bmQ6bH19ZnVuY3Rpb24gJGEodCxlLG4pe3ZvaWQgMD09PW4mJihuPVwiaW5kZXhcIik7dmFyIHI9JChlKTtyZXR1cm4gci5tYXAoKGZ1bmN0aW9uKGUsbyl7cmV0dXJuXCJpbnQgXCIrdFtvXStcIiA9IFwiK24rXCIgLyBcIitlK1wiOyBcIisobz09PXIubGVuZ3RoLTE/XCJpbnQgXCIrdFtvKzFdK1wiID0gXCIrbitcIiAtIFwiK3Rbb10rXCIgKiBcIitlOlwiaW5kZXggLT0gXCIrdFtvXStcIiAqIFwiK2UpK1wiO1wifSkpLmpvaW4oXCJcIil9ZnVuY3Rpb24gUWEodCl7dmFyIGU9JCh0KS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvU3RyaW5nKCl9KSk7cmV0dXJuXCJcXG4gIGludCBnZXRGbGF0SW5kZXgoaXZlYzMgY29vcmRzKSB7XFxuICAgIHJldHVybiBjb29yZHMueCAqIFwiK2VbMF0rXCIgKyBjb29yZHMueSAqIFwiK2VbMV0rXCIgKyBjb29yZHMuejtcXG4gIH1cXG5cIn12YXIgSmE9XCJcXG4gIGNvbnN0IGZsb2F0IEZMT0FUX01BWCA9IDEuNzAxNDExODRlMzg7XFxuICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcXG5cXG4gIGxvd3AgdmVjNCBlbmNvZGVfZmxvYXQoaGlnaHAgZmxvYXQgdikge1xcbiAgICBpZiAoaXNuYW4odikpIHtcXG4gICAgICByZXR1cm4gdmVjNCgyNTUsIDI1NSwgMjU1LCAyNTUpO1xcbiAgICB9XFxuXFxuICAgIGhpZ2hwIGZsb2F0IGF2ID0gYWJzKHYpO1xcblxcbiAgICBpZihhdiA8IEZMT0FUX01JTikge1xcbiAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XFxuICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDEyOC4wLCAxMjcuMCkgLyAyNTUuMDtcXG4gICAgfSBlbHNlIGlmKHYgPCAtRkxPQVRfTUFYKSB7XFxuICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XFxuICAgIH1cXG5cXG4gICAgaGlnaHAgdmVjNCBjID0gdmVjNCgwLDAsMCwwKTtcXG5cXG4gICAgaGlnaHAgZmxvYXQgZSA9IGZsb29yKGxvZzIoYXYpKTtcXG4gICAgaGlnaHAgZmxvYXQgbSA9IGV4cDIoZnJhY3QobG9nMihhdikpKSAtIDEuMDtcXG5cXG4gICAgY1syXSA9IGZsb29yKDEyOC4wICogbSk7XFxuICAgIG0gLT0gY1syXSAvIDEyOC4wO1xcbiAgICBjWzFdID0gZmxvb3IoMzI3NjguMCAqIG0pO1xcbiAgICBtIC09IGNbMV0gLyAzMjc2OC4wO1xcbiAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XFxuXFxuICAgIGhpZ2hwIGZsb2F0IGViaWFzID0gZSArIDEyNy4wO1xcbiAgICBjWzNdID0gZmxvb3IoZWJpYXMgLyAyLjApO1xcbiAgICBlYmlhcyAtPSBjWzNdICogMi4wO1xcbiAgICBjWzJdICs9IGZsb29yKGViaWFzKSAqIDEyOC4wO1xcblxcbiAgICBjWzNdICs9IDEyOC4wICogc3RlcCgwLjAsIC12KTtcXG5cXG4gICAgcmV0dXJuIGMgLyAyNTUuMDtcXG4gIH1cXG5cIjtmdW5jdGlvbiBaYSh0LGUsbixyKXt2YXIgbz1bXTt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPWsodC5zaGFwZUluZm8ubG9naWNhbFNoYXBlKTt0LnNoYXBlSW5mby5pc1VuaWZvcm0/by5wdXNoKFwidW5pZm9ybSBmbG9hdCBcIit0Lm5hbWUrKGU+MT9cIltcIitlK1wiXVwiOlwiXCIpK1wiO1wiKTooby5wdXNoKFwidW5pZm9ybSBzYW1wbGVyMkQgXCIrdC5uYW1lK1wiO1wiKSxvLnB1c2goXCJ1bmlmb3JtIGludCBvZmZzZXRcIit0Lm5hbWUrXCI7XCIpKX0pKTt2YXIgYSxpLHM9by5qb2luKFwiXFxuXCIpLHU9dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciByPVwiXCI7cis9bj9laSh0KTp0aSh0KTt2YXIgbz10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsYT1lLmxvZ2ljYWxTaGFwZTtvLmxlbmd0aDw9YS5sZW5ndGgmJihyKz1uP2Z1bmN0aW9uKHQsZSl7dmFyIG4scj10Lm5hbWUsbz1yLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK3Iuc2xpY2UoMSksYT1cImdldFwiK28rXCJBdE91dENvb3Jkc1wiLGk9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCxzPWUubG9naWNhbFNoYXBlLmxlbmd0aCx1PU1yKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxlLmxvZ2ljYWxTaGFwZSksYz11aShzKSxsPXMtaSxoPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl07bj0wPT09aT9cIlwiOnM8MiYmdS5sZW5ndGg+PTE/XCJjb29yZHMgPSAwO1wiOnUubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cImNvb3Jkcy5cIitoW3QrbF0rXCIgPSAwO1wifSkpLmpvaW4oXCJcXG5cIik7dmFyIGY9XCJcIjtmPXM8MiYmaT4wP1wiY29vcmRzXCI6dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cImNvb3Jkcy5cIitoW2UrbF19KSkuam9pbihcIiwgXCIpO3ZhciBkPVwicmV0dXJuIG91dHB1dFZhbHVlO1wiLHA9MT09PWsodC5zaGFwZUluZm8ubG9naWNhbFNoYXBlKSx2PTE9PT1rKGUubG9naWNhbFNoYXBlKTtpZigxIT09aXx8cHx8dil7aWYocCYmIXYpZD0xPT09cz9cIlxcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueCwgMC4sIDAuKTtcXG4gICAgICBcIjpcIlxcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XFxuICAgICAgXCI7ZWxzZSBpZih1Lmxlbmd0aCl7dmFyIGc9aS0yLG09aS0xO3UuaW5kZXhPZihnKT4tMSYmdS5pbmRleE9mKG0pPi0xP2Q9XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTtcIjp1LmluZGV4T2YoZyk+LTE/ZD1cInJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnksIG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLnkpO1wiOnUuaW5kZXhPZihtKT4tMSYmKGQ9XCJyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54eCwgb3V0cHV0VmFsdWUuenopO1wiKX19ZWxzZSBkPVwiXFxuICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHksIG91dHB1dFZhbHVlLnh5KTtcXG4gICAgXCI7cmV0dXJuXCJcXG4gICAgdmVjNCBcIithK1wiKCkge1xcbiAgICAgIFwiK2MrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgXCIrbitcIlxcbiAgICAgIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRcIitvK1wiKFwiK2YrXCIpO1xcbiAgICAgIFwiK2QrXCJcXG4gICAgfVxcbiAgXCJ9KHQsZSk6ZnVuY3Rpb24odCxlKXt2YXIgbj10Lm5hbWUscj1uLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1cImdldFwiK3IrXCJBdE91dENvb3Jkc1wiLGE9ZS50ZXhTaGFwZSxpPXQuc2hhcGVJbmZvLnRleFNoYXBlLHM9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aCx1PWUubG9naWNhbFNoYXBlLmxlbmd0aDtpZighdC5zaGFwZUluZm8uaXNVbmlmb3JtJiZzPT09dSYmbnVsbD09dC5zaGFwZUluZm8uZmxhdE9mZnNldCYmUyhpLGEpKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbytcIigpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHJlc3VsdFVWKTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBjLGw9dWkodSksaD1Ncih0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsZS5sb2dpY2FsU2hhcGUpLGY9dS1zLGQ9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXTtjPTA9PT1zP1wiXCI6dTwyJiZoLmxlbmd0aD49MT9cImNvb3JkcyA9IDA7XCI6aC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwiY29vcmRzLlwiK2RbdCtmXStcIiA9IDA7XCJ9KSkuam9pbihcIlxcblwiKTt2YXIgcD1cIlwiO3A9dTwyJiZzPjA/XCJjb29yZHNcIjp0LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubWFwKChmdW5jdGlvbih0LGUpe3JldHVyblwiY29vcmRzLlwiK2RbZStmXX0pKS5qb2luKFwiLCBcIik7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrbytcIigpIHtcXG4gICAgICBcIitsK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIFwiK2MrXCJcXG4gICAgICByZXR1cm4gZ2V0XCIrcitcIihcIitwK1wiKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSkpO3JldHVybiByfSh0LGUscil9KSkuam9pbihcIlxcblwiKSxjPWUudGV4U2hhcGUsbD1ZYSgpLGg9ZnVuY3Rpb24odCl7cmV0dXJuXCJcXG4gICAgZmxvYXQgc2FtcGxlVGV4dHVyZShzYW1wbGVyMkQgdGV4dHVyZVNhbXBsZXIsIHZlYzIgdXYpIHtcXG4gICAgICByZXR1cm4gXCIrdC50ZXh0dXJlMkQrXCIodGV4dHVyZVNhbXBsZXIsIHV2KS5yO1xcbiAgICB9XFxuICBcIn0obCksZj1mdW5jdGlvbih0KXtyZXR1cm4gdC52ZXJzaW9uK1wiXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGludDtcXG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcXG4gICAgXCIrdC52YXJ5aW5nRnMrXCIgdmVjMiByZXN1bHRVVjtcXG4gICAgXCIrdC5kZWZpbmVPdXRwdXQrXCJcXG4gICAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gICAgc3RydWN0IGl2ZWM1XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgfTtcXG5cXG4gICAgc3RydWN0IGl2ZWM2XFxuICAgIHtcXG4gICAgICBpbnQgeDtcXG4gICAgICBpbnQgeTtcXG4gICAgICBpbnQgejtcXG4gICAgICBpbnQgdztcXG4gICAgICBpbnQgdTtcXG4gICAgICBpbnQgdjtcXG4gICAgfTtcXG5cXG4gICAgdW5pZm9ybSBmbG9hdCBOQU47XFxuICAgIFwiK3QuZGVmaW5lU3BlY2lhbE5hTitcIlxcbiAgICBcIit0LmRlZmluZVNwZWNpYWxJbmYrXCJcXG4gICAgXCIrdC5kZWZpbmVSb3VuZCtcIlxcblxcbiAgICBpbnQgaW1vZChpbnQgeCwgaW50IHkpIHtcXG4gICAgICByZXR1cm4geCAtIHkgKiAoeCAvIHkpO1xcbiAgICB9XFxuXFxuICAgIGludCBpZGl2KGludCBhLCBpbnQgYiwgZmxvYXQgc2lnbikge1xcbiAgICAgIGludCByZXMgPSBhIC8gYjtcXG4gICAgICBpbnQgbW9kID0gaW1vZChhLCBiKTtcXG4gICAgICBpZiAoc2lnbiA8IDAuICYmIG1vZCAhPSAwKSB7XFxuICAgICAgICByZXMgLT0gMTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlcztcXG4gICAgfVxcblxcbiAgICAvL0Jhc2VkIG9uIHRoZSB3b3JrIG9mIERhdmUgSG9za2luc1xcbiAgICAvL2h0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80ZGpTUldcXG4gICAgI2RlZmluZSBIQVNIU0NBTEUxIDQ0My44OTc1XFxuICAgIGZsb2F0IHJhbmRvbShmbG9hdCBzZWVkKXtcXG4gICAgICB2ZWMyIHAgPSByZXN1bHRVViAqIHNlZWQ7XFxuICAgICAgdmVjMyBwMyAgPSBmcmFjdCh2ZWMzKHAueHl4KSAqIEhBU0hTQ0FMRTEpO1xcbiAgICAgIHAzICs9IGRvdChwMywgcDMueXp4ICsgMTkuMTkpO1xcbiAgICAgIHJldHVybiBmcmFjdCgocDMueCArIHAzLnkpICogcDMueik7XFxuICAgIH1cXG5cXG4gICAgXCIrbmkrXCJcXG4gICAgXCIrcmkrXCJcXG4gICAgXCIrb2krXCJcXG4gIFwifShsKTtyZXR1cm4gZS5pc1BhY2tlZD8oYT1mdW5jdGlvbih0LGUpe3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAwOnJldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gIFwiO2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgbj1bTWF0aC5jZWlsKGVbMF0vMiksTWF0aC5jZWlsKGVbMV0vMildO2lmKDE9PT1uWzBdKXJldHVyblwiXFxuICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIHJldHVybiAyICogaW50KHJlc3VsdFVWLnggKiBcIituWzFdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PW5bMV0pcmV0dXJuXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIDIgKiBpbnQocmVzdWx0VVYueSAqIFwiK25bMF0rXCIuMCk7XFxuICAgICAgfVxcbiAgICBcIjtyZXR1cm5cIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuICAgICAgcmV0dXJuIDIgKiAocmVzVGV4UkMueCAqIFwiK25bMV0rXCIgKyByZXNUZXhSQy55KTtcXG4gICAgfVxcbiAgXCJ9KDAsZSk7Y2FzZSAyOnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPVtNYXRoLmNlaWwoZVswXS8yKSxNYXRoLmNlaWwoZVsxXS8yKV07aWYoUyh0LGUpKXJldHVyblwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIDIgKiBpdmVjMihyZXN1bHRVVi55eCAqIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIHI9TWF0aC5jZWlsKHRbMV0vMik7cmV0dXJuXCJcXG4gICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIituWzBdK1wiLCBcIituWzFdK1wiKSk7XFxuXFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK25bMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiK3IrXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIrcitcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7Y2FzZSAzOnJldHVybiBuPXQscj1lLG89W01hdGguY2VpbChyWzBdLzIpLE1hdGguY2VpbChyWzFdLzIpXSxhPU1hdGguY2VpbChuWzJdLzIpLGk9YSpNYXRoLmNlaWwoblsxXS8yKSxcIlxcbiAgICBpdmVjMyBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK29bMF0rXCIsIFwiK29bMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrb1sxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgaW50IGIgPSBpbmRleCAvIFwiK2krXCI7XFxuICAgICAgaW5kZXggLT0gYiAqIFwiK2krXCI7XFxuXFxuICAgICAgaW50IHIgPSAyICogKGluZGV4IC8gXCIrYStcIik7XFxuICAgICAgaW50IGMgPSBpbW9kKGluZGV4LCBcIithK1wiKSAqIDI7XFxuXFxuICAgICAgcmV0dXJuIGl2ZWMzKGIsIHIsIGMpO1xcbiAgICB9XFxuICBcIjtkZWZhdWx0OnJldHVybiBmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1bTWF0aC5jZWlsKGVbMF0vMiksTWF0aC5jZWlsKGVbMV0vMildLHI9TWF0aC5jZWlsKHRbdC5sZW5ndGgtMV0vMiksbz1yKk1hdGguY2VpbCh0W3QubGVuZ3RoLTJdLzIpLGE9byxpPVwiXCIscz1cImIsIHIsIGNcIix1PTI7dTx0Lmxlbmd0aC0xO3UrKylhKj10W3QubGVuZ3RoLXUtMV0saT1cIlxcbiAgICAgIGludCBiXCIrdStcIiA9IGluZGV4IC8gXCIrYStcIjtcXG4gICAgICBpbmRleCAtPSBiXCIrdStcIiAqIFwiK2ErXCI7XFxuICAgIFwiK2kscz1cImJcIit1K1wiLCBcIitzO3JldHVyblwiXFxuICAgIGl2ZWNcIit0Lmxlbmd0aCtcIiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK25bMF0rXCIsIFwiK25bMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrblsxXStcIiArIHJlc1RleFJDLnk7XFxuXFxuICAgICAgXCIraStcIlxcblxcbiAgICAgIGludCBiID0gaW5kZXggLyBcIitvK1wiO1xcbiAgICAgIGluZGV4IC09IGIgKiBcIitvK1wiO1xcblxcbiAgICAgIGludCByID0gMiAqIChpbmRleCAvIFwiK3IrXCIpO1xcbiAgICAgIGludCBjID0gaW1vZChpbmRleCwgXCIrcitcIikgKiAyO1xcblxcbiAgICAgIHJldHVybiBpdmVjXCIrdC5sZW5ndGgrXCIoXCIrcytcIik7XFxuICAgIH1cXG4gIFwifSh0LGUpfXZhciBuLHIsbyxhLGl9KGUubG9naWNhbFNoYXBlLGMpLGk9ZnVuY3Rpb24odCl7cmV0dXJuXCJcXG4gICAgdm9pZCBzZXRPdXRwdXQodmVjNCB2YWwpIHtcXG4gICAgICBcIit0Lm91dHB1dCtcIiA9IHZhbDtcXG4gICAgfVxcbiAgXCJ9KGwpKTooYT1mdW5jdGlvbih0LGUpe3N3aXRjaCh0Lmxlbmd0aCl7Y2FzZSAwOnJldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gIFwiO2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24odCxlKXtpZigxPT09ZVswXSlyZXR1cm5cIlxcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaW50KHJlc3VsdFVWLnggKiBcIitlWzFdK1wiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoMT09PWVbMV0pcmV0dXJuXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi55ICogXCIrZVswXStcIi4wKTtcXG4gICAgICB9XFxuICAgIFwiO3JldHVyblwiXFxuICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICByZXR1cm4gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICB9XFxuICBcIn0oMCxlKTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYoUyh0LGUpKXJldHVyblwiXFxuICAgICAgaXZlYzIgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09dFsxXSlyZXR1cm5cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMihpbmRleCwgMCk7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09dFswXSlyZXR1cm5cIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMigwLCBpbmRleCk7XFxuICAgICAgfVxcbiAgICBcIjtyZXR1cm5cIlxcbiAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihyZXN1bHRVVi55eCAqXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIrZVsxXStcIiArIHJlc1RleFJDLnk7XFxuICAgICAgaW50IHIgPSBpbmRleCAvIFwiK3RbMV0rXCI7XFxuICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiBcIit0WzFdK1wiO1xcbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7Y2FzZSAzOnJldHVybiBuPWUscj0kYShbXCJyXCIsXCJjXCIsXCJkXCJdLHQpLFwiXFxuICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrblswXStcIiwgXCIrblsxXStcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIituWzFdK1wiICsgcmVzVGV4UkMueTtcXG4gICAgICBcIityK1wiXFxuICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xcbiAgICB9XFxuICBcIjtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49JGEoW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIl0sdCk7cmV0dXJuXCJcXG4gICAgaXZlYzQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIFwiK24rXCJcXG4gICAgICByZXR1cm4gaXZlYzQociwgYywgZCwgZDIpO1xcbiAgICB9XFxuICBcIn0odCxlKTtjYXNlIDU6cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49JGEoW1wiclwiLFwiY1wiLFwiZFwiLFwiZDJcIixcImQzXCJdLHQpO3JldHVyblwiXFxuICAgIGl2ZWM1IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICogdmVjMihcIitlWzBdK1wiLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIrZVsxXStcIikpO1xcblxcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIitlWzFdK1wiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBcIituK1wiXFxuXFxuICAgICAgaXZlYzUgb3V0U2hhcGUgPSBpdmVjNShyLCBjLCBkLCBkMiwgZDMpO1xcbiAgICAgIHJldHVybiBvdXRTaGFwZTtcXG4gICAgfVxcbiAgXCJ9KHQsZSk7Y2FzZSA2OnJldHVybiBmdW5jdGlvbih0LGUpe3ZhciBuPSRhKFtcInJcIixcImNcIixcImRcIixcImQyXCIsXCJkM1wiLFwiZDRcIl0sdCk7cmV0dXJuXCJcXG4gICAgaXZlYzYgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgdmVjMihcIitlWzBdK1wiLCBcIitlWzFdK1wiKSk7XFxuICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55O1xcblxcbiAgICAgIFwiK24rXCJcXG5cXG4gICAgICBpdmVjNiByZXN1bHQgPSBpdmVjNihyLCBjLCBkLCBkMiwgZDMsIGQ0KTtcXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuICBcIn0odCxlKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcih0Lmxlbmd0aCtcIi1EIG91dHB1dCBzYW1wbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX12YXIgbixyfShlLmxvZ2ljYWxTaGFwZSxjKSxpPWZ1bmN0aW9uKHQpe3JldHVyblwiXFxuICAgIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHZhbCkge1xcbiAgICAgIFwiK3Qub3V0cHV0K1wiID0gdmVjNCh2YWwsIDAsIDAsIDApO1xcbiAgICB9XFxuICBcIn0obCkpLHImJihmKz1haSksW2YsaCxpLHMsYSx1LG5dLmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gdGkodCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlO3N3aXRjaChlLmxlbmd0aCl7Y2FzZSAwOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lm5hbWUsbj1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKTtpZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJmbG9hdCBcIituK1wiKCkge3JldHVybiBcIitlK1wiO31cIjt2YXIgcj10LnNoYXBlSW5mby50ZXhTaGFwZSxvPXJbMF0sYT1yWzFdO2lmKDE9PT1vJiYxPT09YSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoKSB7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCBoYWxmQ1IpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIGk9dC5zaGFwZUluZm8udGV4U2hhcGUscz1pWzBdLHU9aVsxXSxjPWlpKGUpO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK24rXCIoKSB7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrcytcIiwgXCIrdStcIiwgXCIrYytcIik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSAxOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lm5hbWUsbj1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKTtpZih0LnNoYXBlSW5mby5pc1VuaWZvcm0pcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgICAgXCIrc2kodCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciByPXQuc2hhcGVJbmZvLnRleFNoYXBlLG89clswXSxhPXJbMV07aWYoMT09PWEmJjE9PT1vKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrbitcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK2UrXCIsIGhhbGZDUik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgaT1paShlKTtpZigxPT09YSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCArIFwiK2krXCIpICsgMC41KSAvIFwiK28rXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtpZigxPT09bylyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXggKyBcIitpK1wiKSArIDAuNSkgLyBcIithK1wiLjAsIDAuNSk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIitlK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIituK1wiKGludCBpbmRleCkge1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK28rXCIsIFwiK2ErXCIsIGluZGV4ICsgXCIraStcIik7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrZStcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSAyOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPXQuc2hhcGVJbmZvLnRleFNoYXBlO2lmKG51bGwhPW8mJlMoZSxvKSl7dmFyIGE9b1swXSxpPW9bMV07cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKFwiK2krXCIuMCwgXCIrYStcIi4wKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifXZhciBzPU0oZSksdT1zLm5ld1NoYXBlLGM9cy5rZXB0RGltcyxsPXU7aWYobC5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBoPWNpKHQsbCk7cmV0dXJuXCJcXG4gICAgICBcIit0aShoKStcIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrbGkoW1wicm93XCIsXCJjb2xcIl0sYykrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QodmVjMihyb3csIGNvbCksIHZlYzIoXCIrZVsxXStcIiwgMSkpKTtcXG4gICAgICAgIFwiK3NpKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgZj1vWzBdLGQ9b1sxXSxwPWlpKG4pO2lmKDE9PT1kKXJldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGZsb2F0IGluZGV4ID0gZG90KHZlYzMocm93LCBjb2wsIFwiK3ArXCIpLCB2ZWMzKFwiK2VbMV0rXCIsIDEsIDEpKTtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyBcIitmK1wiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7aWYoMT09PWYpcmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgXCIrcCtcIiksIHZlYzMoXCIrZVsxXStcIiwgMSwgMSkpO1xcbiAgICAgIHZlYzIgdXYgPSB2ZWMyKChpbmRleCArIDAuNSkgLyBcIitkK1wiLjAsIDAuNSk7XFxuICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtyZXR1cm5cIlxcbiAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgIC8vIEV4cGxpY2l0bHkgdXNlIGludGVnZXIgb3BlcmF0aW9ucyBhcyBkb3QoKSBvbmx5IHdvcmtzIG9uIGZsb2F0cy5cXG4gICAgaW50IGluZGV4ID0gcm93ICogXCIrZVsxXStcIiArIGNvbCArIFwiK3ArXCI7XFxuICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK2YrXCIsIFwiK2QrXCIsIGluZGV4KTtcXG4gICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgfVxcblwifSh0KTtjYXNlIDM6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89ZVsxXSplWzJdLGE9ZVsyXSxpPU0oZSkscz1pLm5ld1NoYXBlLHU9aS5rZXB0RGltcyxjPXM7aWYoYy5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBsPWNpKHQsYyk7cmV0dXJuXCJcXG4gICAgICAgIFwiK3RpKGwpK1wiXFxuICAgICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICByZXR1cm4gXCIrcitcIihcIitsaShbXCJyb3dcIixcImNvbFwiLFwiZGVwdGhcIl0sdSkrXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifWlmKHQuc2hhcGVJbmZvLmlzVW5pZm9ybSlyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChkb3QodmVjMyhyb3csIGNvbCwgZGVwdGgpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMyhcIitvK1wiLCBcIithK1wiLCAxKSkpO1xcbiAgICAgICAgXCIrc2kodCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBoPXQuc2hhcGVJbmZvLnRleFNoYXBlLGY9aFswXSxkPWhbMV0scD10LnNoYXBlSW5mby5mbGF0T2Zmc2V0O2lmKGQ9PT1vJiZudWxsPT1wKXJldHVyblwiXFxuICAgICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgICBmbG9hdCB0ZXhSID0gZmxvYXQocm93KTtcXG4gICAgICAgICAgZmxvYXQgdGV4QyA9IGRvdCh2ZWMyKGNvbCwgZGVwdGgpLCB2ZWMyKFwiK2ErXCIsIDEpKTtcXG4gICAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitkK1wiLjAsIFwiK2YrXCIuMCk7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtpZihkPT09YSYmbnVsbD09cClyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjMihyb3csIGNvbCksIHZlYzIoXCIrZVsxXStcIiwgMSkpO1xcbiAgICAgIGZsb2F0IHRleEMgPSBmbG9hdChkZXB0aCk7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIrZCtcIi4wLCBcIitmK1wiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7dmFyIHY9aWkobik7cmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgICAgaW50IGluZGV4ID0gcm93ICogXCIrbytcIiArIGNvbCAqIFwiK2ErXCIgKyBkZXB0aCArIFwiK3YrXCI7XFxuICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdChcIitmK1wiLCBcIitkK1wiLCBpbmRleCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgXCJ9KHQpO2Nhc2UgNDpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1lWzNdLGE9ZVsyXSpvLGk9ZVsxXSphLHM9TShlKSx1PXMubmV3U2hhcGUsYz1zLmtlcHREaW1zO2lmKHUubGVuZ3RoPGUubGVuZ3RoKXt2YXIgbD1jaSh0LHUpO3JldHVyblwiXFxuICAgICAgXCIrdGkobCkrXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrbGkoW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIl0sYykrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGRvdCh2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQoXCIraStcIiwgXCIrYStcIiwgXCIrbytcIiwgMSkpKTtcXG4gICAgICAgIFwiK3NpKHQpK1wiXFxuICAgICAgfVxcbiAgICBcIjt2YXIgaD10LnNoYXBlSW5mby5mbGF0T2Zmc2V0LGY9dC5zaGFwZUluZm8udGV4U2hhcGUsZD1mWzBdLHA9ZlsxXTtpZihwPT09aSYmbnVsbD09aClyZXR1cm5cIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICBmbG9hdCB0ZXhSID0gZmxvYXQocm93KTtcXG4gICAgICAgIGZsb2F0IHRleEMgPVxcbiAgICAgICAgICAgIGRvdCh2ZWMzKGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgICAgICAgIHZlYzMoXCIrYStcIiwgXCIrbytcIiwgMSkpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrcCtcIi4wLCBcIitkK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYocD09PW8mJm51bGw9PWgpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgZmxvYXQgdGV4UiA9IGRvdCh2ZWMzKHJvdywgY29sLCBkZXB0aCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzMoXCIrZVsxXSplWzJdK1wiLCBcIitlWzJdK1wiLCAxKSk7XFxuICAgICAgICBmbG9hdCB0ZXhDID0gZmxvYXQoZGVwdGgyKTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgIHZlYzIoXCIrcCtcIi4wLCBcIitkK1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIHY9aWkobik7cmV0dXJuXCJcXG4gICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICAgICAgaW50IGluZGV4ID0gcm93ICogXCIraStcIiArIGNvbCAqIFwiK2ErXCIgK1xcbiAgICAgICAgICBkZXB0aCAqIFwiK28rXCIgKyBkZXB0aDI7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrZCtcIiwgXCIrcCtcIiwgaW5kZXggKyBcIit2K1wiKTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDU6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89ZVs0XSxhPWVbM10qbyxpPWVbMl0qYSxzPWVbMV0qaSx1PU0oZSksYz11Lm5ld1NoYXBlLGw9dS5rZXB0RGltcztpZihjLmxlbmd0aDxlLmxlbmd0aCl7dmFyIGg9Y2kodCxjKTtyZXR1cm5cIlxcbiAgICAgIFwiK3RpKGgpK1wiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIHJldHVybiBcIityK1wiKFwiK2xpKFtcInJvd1wiLFwiY29sXCIsXCJkZXB0aFwiLFwiZGVwdGgyXCIsXCJkZXB0aDNcIl0sbCkrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGZsb2F0IGluZGV4ID0gZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitzK1wiLCBcIitpK1wiLCBcIithK1wiLCBcIitvK1wiKSkgK1xcbiAgICAgICAgICBkZXB0aDM7XFxuICAgICAgICBcIitzaSh0KStcIlxcbiAgICAgIH1cXG4gICAgXCI7dmFyIGY9dC5zaGFwZUluZm8uZmxhdE9mZnNldCxkPXQuc2hhcGVJbmZvLnRleFNoYXBlLHA9ZFswXSx2PWRbMV07aWYodj09PXMmJm51bGw9PWYpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xcbiAgICAgICAgaW50IHRleFIgPSByb3c7XFxuICAgICAgICBmbG9hdCB0ZXhDID0gZG90KHZlYzQoY29sLCBkZXB0aCwgZGVwdGgyLCBkZXB0aDMpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZWM0KFwiK2krXCIsIFwiK2ErXCIsIFwiK28rXCIsIDEpKTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiK3YrXCIuMCwgXCIrcCtcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO2lmKHY9PT1vJiZudWxsPT1mKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QoXFxuICAgICAgICAgIHZlYzQocm93LCBjb2wsIGRlcHRoLCBkZXB0aDIpLFxcbiAgICAgICAgICB2ZWM0KFwiK2VbMV0qZVsyXSplWzNdK1wiLFxcbiAgICAgICAgICAgICAgIFwiK2VbMl0qZVszXStcIiwgXCIrZVszXStcIiwgMSkpO1xcbiAgICAgICAgaW50IHRleEMgPSBkZXB0aDM7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICB2ZWMyKFwiK3YrXCIuMCwgXCIrcCtcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO3ZhciBnPWlpKG4pO3JldHVyblwiXFxuICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzKSB7XFxuICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiK3MrXCIgKyBjb2wgKiBcIitpK1wiICsgZGVwdGggKiBcIithK1wiICtcXG4gICAgICAgICAgZGVwdGgyICogXCIrbytcIiArIGRlcHRoMyArIFwiK2crXCI7XFxuICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoXCIrcCtcIiwgXCIrditcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKFwiK24rXCIsIHV2KTtcXG4gICAgfVxcbiAgXCJ9KHQpO2Nhc2UgNjpyZXR1cm4gZnVuY3Rpb24odCl7dmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49dC5uYW1lLHI9XCJnZXRcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSksbz1NKGUpLGE9by5uZXdTaGFwZSxpPW8ua2VwdERpbXM7aWYoYS5sZW5ndGg8ZS5sZW5ndGgpe3ZhciBzPWNpKHQsYSk7cmV0dXJuXCJcXG4gICAgICBcIit0aShzKStcIlxcbiAgICAgIGZsb2F0IFwiK3IrXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrbGkoW1wicm93XCIsXCJjb2xcIixcImRlcHRoXCIsXCJkZXB0aDJcIixcImRlcHRoM1wiLFwiZGVwdGg0XCJdLGkpK1wiKTtcXG4gICAgICB9XFxuICAgIFwifXZhciB1PWVbNV0sYz1lWzRdKnUsbD1lWzNdKmMsaD1lWzJdKmwsZj1lWzFdKmg7aWYodC5zaGFwZUluZm8uaXNVbmlmb3JtKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgaW50IGRlcHRoMiwgaW50IGRlcHRoMywgaW50IGRlcHRoNCkge1xcbiAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZG90KFxcbiAgICAgICAgICB2ZWM0KHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKSxcXG4gICAgICAgICAgdmVjNChcIitmK1wiLCBcIitoK1wiLCBcIitsK1wiLCBcIitjK1wiKSkgK1xcbiAgICAgICAgICBkb3QoXFxuICAgICAgICAgICAgdmVjMihkZXB0aDMsIGRlcHRoNCksXFxuICAgICAgICAgICAgdmVjMihcIit1K1wiLCAxKSkpO1xcbiAgICAgICAgXCIrc2kodCkrXCJcXG4gICAgICB9XFxuICAgIFwiO3ZhciBkPXQuc2hhcGVJbmZvLmZsYXRPZmZzZXQscD10LnNoYXBlSW5mby50ZXhTaGFwZSx2PXBbMF0sZz1wWzFdO2lmKGc9PT1mJiZudWxsPT1kKXJldHVyblwiXFxuICAgICAgZmxvYXQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXFxuICAgICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgICBpbnQgdGV4UiA9IHJvdztcXG4gICAgICAgIGZsb2F0IHRleEMgPSBkb3QodmVjNChjb2wsIGRlcHRoLCBkZXB0aDIsIGRlcHRoMyksXFxuICAgICAgICAgIHZlYzQoXCIraCtcIiwgXCIrbCtcIiwgXCIrYytcIiwgXCIrdStcIikpICtcXG4gICAgICAgICAgICAgICBmbG9hdChkZXB0aDQpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrZytcIi4wLCBcIit2K1wiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7aWYoZz09PXUmJm51bGw9PWQpcmV0dXJuXCJcXG4gICAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcXG4gICAgICAgIGZsb2F0IHRleFIgPSBkb3QodmVjNChyb3csIGNvbCwgZGVwdGgsIGRlcHRoMiksXFxuICAgICAgICAgIHZlYzQoXCIrZVsxXSplWzJdKmVbM10qZVs0XStcIixcXG4gICAgICAgICAgICAgICBcIitlWzJdKmVbM10qZVs0XStcIixcXG4gICAgICAgICAgICAgICBcIitlWzNdKmVbNF0rXCIsXFxuICAgICAgICAgICAgICAgXCIrZVs0XStcIikpICsgZmxvYXQoZGVwdGgzKTtcXG4gICAgICAgIGludCB0ZXhDID0gZGVwdGg0O1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIitnK1wiLjAsIFwiK3YrXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjt2YXIgbT1paShuKTtyZXR1cm5cIlxcbiAgICBmbG9hdCBcIityK1wiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCxcXG4gICAgICAgICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XFxuICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiK2YrXCIgKyBjb2wgKiBcIitoK1wiICsgZGVwdGggKiBcIitsK1wiICtcXG4gICAgICAgICAgZGVwdGgyICogXCIrYytcIiArIGRlcHRoMyAqIFwiK3UrXCIgKyBkZXB0aDQgKyBcIittK1wiO1xcbiAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KFwiK3YrXCIsIFwiK2crXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZShcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihlLmxlbmd0aCtcIi1EIGlucHV0IHNhbXBsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfX1mdW5jdGlvbiBlaSh0KXt2YXIgZSxuLHI7c3dpdGNoKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gZT10Lm5hbWUsbj1cImdldFwiK2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxyPVlhKCksXCJcXG4gICAgdmVjNCBcIituK1wiKCkge1xcbiAgICAgIHJldHVybiBcIityLnRleHR1cmUyRCtcIihcIitlK1wiLCBoYWxmQ1IpO1xcbiAgICB9XFxuICBcIjtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQubmFtZSxuPVwiZ2V0XCIrZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpLHI9dC5zaGFwZUluZm8udGV4U2hhcGUsbz1bTWF0aC5jZWlsKHJbMF0vMiksTWF0aC5jZWlsKHJbMV0vMildLGE9WWEoKTtyZXR1cm5cIlxcbiAgICB2ZWM0IFwiK24rXCIoaW50IGluZGV4KSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxcbiAgICAgICAgXCIrb1swXStcIiwgXCIrb1sxXStcIiwgaW5kZXgpO1xcbiAgICAgIHJldHVybiBcIithLnRleHR1cmUyRCtcIihcIitlK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSxuPXQubmFtZSxyPVwiZ2V0XCIrbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpLG89dC5zaGFwZUluZm8udGV4U2hhcGUsYT1vWzBdLGk9b1sxXSxzPVlhKCk7aWYobnVsbCE9byYmUyhlLG8pKXJldHVyblwiXFxuICAgICAgdmVjNCBcIityK1wiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihjb2wsIHJvdykgKyBoYWxmQ1IpIC8gdmVjMihcIitpK1wiLjAsIFwiK2ErXCIuMCk7XFxuXFxuICAgICAgICByZXR1cm4gXCIrcy50ZXh0dXJlMkQrXCIoXCIrbitcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7dmFyIHU9W01hdGguY2VpbChvWzBdLzIpLE1hdGguY2VpbChvWzFdLzIpXSxjPU1hdGguY2VpbChlWzFdLzIpO3JldHVyblwiXFxuICAgIHZlYzQgXCIrcitcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTJEKFwiK2MrXCIsIFwiK3VbMF0rXCIsIFwiK3VbMV0rXCIsIHJvdywgY29sKTtcXG4gICAgICByZXR1cm4gXCIrcy50ZXh0dXJlMkQrXCIoXCIrbitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10LnNoYXBlSW5mby5sb2dpY2FsU2hhcGUsbj10Lm5hbWUscj1cImdldFwiK24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrbi5zbGljZSgxKSxvPXQuc2hhcGVJbmZvLnRleFNoYXBlLGE9W01hdGguY2VpbChvWzBdLzIpLE1hdGguY2VpbChvWzFdLzIpXTtpZigxPT09ZVswXSl7dmFyIGk9ZS5zbGljZSgxKSxzPWNpKHQsaSk7cmV0dXJuXCJcXG4gICAgICAgIFwiK2VpKHMpK1wiXFxuICAgICAgICB2ZWM0IFwiK3IrXCIoaW50IGIsIGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgICAgcmV0dXJuIFwiK3IrXCIoXCIrbGkoW1wiYlwiLFwicm93XCIsXCJjb2xcIl0sWzEsMl0pK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIn12YXIgdT1hWzBdLGM9YVsxXSxsPU1hdGguY2VpbChlWzJdLzIpLGg9bCpNYXRoLmNlaWwoZVsxXS8yKSxmPVlhKCk7cmV0dXJuXCJcXG4gICAgdmVjNCBcIityK1wiKGludCBiLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxcbiAgICAgICAgXCIrdStcIiwgXCIrYytcIiwgXCIraCtcIiwgXCIrbCtcIiwgYiwgcm93LCBjb2wpO1xcbiAgICAgIHJldHVybiBcIitmLnRleHR1cmUyRCtcIihcIituK1wiLCB1dik7XFxuICAgIH1cXG4gIFwifSh0KTtkZWZhdWx0OnJldHVybiBmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5zaGFwZUluZm8ubG9naWNhbFNoYXBlLG49ZS5sZW5ndGgscj10Lm5hbWUsbz1cImdldFwiK3IuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrci5zbGljZSgxKSxhPXQuc2hhcGVJbmZvLnRleFNoYXBlLGk9W01hdGguY2VpbChhWzBdLzIpLE1hdGguY2VpbChhWzFdLzIpXSxzPWlbMF0sdT1pWzFdLGM9TWF0aC5jZWlsKGVbbi0xXS8yKSxsPWMqTWF0aC5jZWlsKGVbbi0yXS8yKSxoPVwiaW50IGIsIGludCByb3csIGludCBjb2xcIixmPVwiYiAqIFwiK2wrXCIgKyAocm93IC8gMikgKiBcIitjK1wiICsgKGNvbCAvIDIpXCIsZD0yO2Q8bi0xO2QrKyloPVwiaW50IGJcIitkK1wiLCBcIitoLGwqPWVbbi1kLTFdLGY9XCJiXCIrZCtcIiAqIFwiK2wrXCIgKyBcIitmO3ZhciBwPVlhKCk7cmV0dXJuXCJcXG4gICAgdmVjNCBcIitvK1wiKFwiK2grXCIpIHtcXG4gICAgICBpbnQgaW5kZXggPSBcIitmK1wiO1xcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLyBcIit1K1wiO1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogXCIrdStcIjtcXG4gICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMihcIit1K1wiLCBcIitzK1wiKTtcXG4gICAgICByZXR1cm4gXCIrcC50ZXh0dXJlMkQrXCIoXCIrcitcIiwgdXYpO1xcbiAgICB9XFxuICBcIn0odCl9fXZhciBuaT1cIlxcbnZlYzIgdXZGcm9tRmxhdChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxudmVjMiBwYWNrZWRVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xcbiAgaW50IHRleGVsSW5kZXggPSBpbmRleCAvIDI7XFxuICBpbnQgdGV4UiA9IHRleGVsSW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCIscmk9XCJcXG52ZWMyIHBhY2tlZFVWZnJvbTJEKGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCB0ZXhOdW1SLFxcbiAgaW50IHRleE51bUMsIGludCByb3csIGludCBjb2wpIHtcXG4gIGludCB0ZXhlbEluZGV4ID0gKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xcbiAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiLG9pPVwiXFxudmVjMiBwYWNrZWRVVmZyb20zRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsXFxuICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcXG4gICAgaW50IHJvdywgaW50IGNvbCkge1xcbiAgaW50IGluZGV4ID0gYiAqIHRleGVsc0luQmF0Y2ggKyAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIixhaT1cIlxcbiAgZmxvYXQgZ2V0Q2hhbm5lbCh2ZWM0IGZyYWcsIHZlYzIgaW5uZXJEaW1zKSB7XFxuICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XFxuICAgIHJldHVybiBtb2RDb29yZC54ID09IDAuID9cXG4gICAgICAobW9kQ29vcmQueSA9PSAwLiA/IGZyYWcuciA6IGZyYWcuZykgOlxcbiAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcXG4gIH1cXG4gIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XFxuICAgIGZsb2F0IG1vZENvb3JkID0gbW9kKGZsb2F0KGRpbSksIDIuKTtcXG4gICAgcmV0dXJuIG1vZENvb3JkID09IDAuID8gZnJhZy5yIDogZnJhZy5nO1xcbiAgfVxcblwiO2Z1bmN0aW9uIGlpKHQpe3JldHVyblwib2Zmc2V0XCIrdH1mdW5jdGlvbiBzaSh0KXt2YXIgZT10Lm5hbWUsbj1rKHQuc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7cmV0dXJuIG48Mj9cInJldHVybiBcIitlK1wiO1wiOlwiXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrbitcIjsgaSsrKSB7XFxuICAgICAgaWYgKGkgPT0gaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBcIitlK1wiW2ldO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgXCJ9ZnVuY3Rpb24gdWkodCl7aWYodDw9MSlyZXR1cm5cImludFwiO2lmKDI9PT10KXJldHVyblwiaXZlYzJcIjtpZigzPT09dClyZXR1cm5cIml2ZWMzXCI7aWYoND09PXQpcmV0dXJuXCJpdmVjNFwiO2lmKDU9PT10KXJldHVyblwiaXZlYzVcIjtpZig2PT09dClyZXR1cm5cIml2ZWM2XCI7dGhyb3cgRXJyb3IoXCJHUFUgZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX1mdW5jdGlvbiBjaSh0LGUpe3ZhciBuPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodCkpO3JldHVybiBuLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU9ZSxufWZ1bmN0aW9uIGxpKHQsZSl7cmV0dXJuIGUubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0pKS5qb2luKFwiLCBcIil9dmFyIGhpPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLEModC5sZW5ndGg+MiwoZnVuY3Rpb24oKXtyZXR1cm5cIlBhY2tlZCBhcmdcIisobi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStuLnNsaWNlKDEpKStcIiBzdXBwb3J0cyBvbmx5IGlucHV0cyB3aXRoIHJhbmsgYWJvdmUgMi5cIn0pKTt2YXIgbz10W3QubGVuZ3RoLTFdLGE9TWF0aC5jZWlsKG8vZSk7dGhpcy5vdXRwdXRTaGFwZT10LnNsaWNlKDAsLTEpLGE+MSYmdGhpcy5vdXRwdXRTaGFwZS5wdXNoKGEpLHJ8fHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmVzdEluZGljZXNBXCIpO3ZhciBpLHMsdT10aGlzLm91dHB1dFNoYXBlLGM9dS5sZW5ndGgsbD11aShjKSxoPVhhKFwiY29vcmRzXCIsYyk7aWYoMT09PWEpe3ZhciBmPXVpKHM9YysxKTtpPVwiXFxuICAgICAgICBcIitmK1wiIHNvdXJjZUxvY1IgPSBcIitmK1wiKFwiK2guam9pbigpK1wiLCAwKTtcXG4gICAgICAgICsrXCIraFtjLTFdK1wiO1xcbiAgICAgICAgXCIrZitcIiBzb3VyY2VMb2NHID0gXCIrZitcIihcIitoLmpvaW4oKStcIiwgMCk7XFxuICAgICAgICArK1wiK2hbYy0yXStcIjtcXG4gICAgICAgIFwiK2YrXCIgc291cmNlTG9jQSA9IFwiK2YrXCIoXCIraC5qb2luKCkrXCIsIDApO1xcbiAgICAgICAgLS1cIitoW2MtMV0rXCI7XFxuICAgICAgICBcIitmK1wiIHNvdXJjZUxvY0IgPSBcIitmK1wiKFwiK2guam9pbigpK1wiLCAwKTtcXG4gICAgICAgIC0tXCIraFtjLTJdK1wiO1wifWVsc2Ugcz1jLGk9XCJcXG4gICAgICAgIFwiK2wrXCIgc291cmNlTG9jUiA9IGNvb3JkcztcXG4gICAgICAgICsrXCIraFtjLTFdK1wiO1xcbiAgICAgICAgXCIrbCtcIiBzb3VyY2VMb2NHID0gY29vcmRzO1xcbiAgICAgICAgKytcIitoW2MtMl0rXCI7XFxuICAgICAgICBcIitsK1wiIHNvdXJjZUxvY0EgPSBjb29yZHM7XFxuICAgICAgICAtLVwiK2hbYy0xXStcIjtcXG4gICAgICAgIFwiK2wrXCIgc291cmNlTG9jQiA9IGNvb3JkcztcXG4gICAgICAgIC0tXCIraFtjLTJdK1wiO1wiO3ZhciBkPVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl0uc2xpY2UoMCxzKSxwPVwiLlwiK2Rbcy0xXSx2PWQubWFwKChmdW5jdGlvbih0KXtyZXR1cm5cImludCBcIit0fSkpLGc9WGEoXCJzb3VyY2VMb2NSXCIscy0xKS5jb25jYXQoXCJpbklkeC5yXCIpLG09WGEoXCJzb3VyY2VMb2NHXCIscy0xKS5jb25jYXQoXCJpbklkeC5nXCIpLHk9WGEoXCJzb3VyY2VMb2NCXCIscy0xKS5jb25jYXQoXCJpbklkeC5iXCIpLHg9WGEoXCJzb3VyY2VMb2NBXCIscy0xKS5jb25jYXQoXCJpbklkeC5hXCIpLGI9XCJtYXhcIj09PW4/XCJncmVhdGVyVGhhblwiOlwibGVzc1RoYW5cIix3PXI/XCJcIjpcIlxcbiAgICAgICAgICBpbklkeCA9IHJvdW5kKHZlYzQoZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIitnLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCZXN0SW5kaWNlc0FDaGFubmVsKFwiK20uam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIreS5qb2luKCkrXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QmVzdEluZGljZXNBQ2hhbm5lbChcIit4LmpvaW4oKStcIikpKTtcIixFPVwidmVjNChcXG4gICAgICAgICAgICBnZXRBQ2hhbm5lbChcIitnLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgaGFzTmV4dENvbCA/IGdldEFDaGFubmVsKFwiK20uam9pbigpK1wiKSA6IDAuLFxcbiAgICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBQ2hhbm5lbChcIit5LmpvaW4oKStcIikgOiAwLixcXG4gICAgICAgICAgICBoYXNOZXh0Um93ICYmIGhhc05leHRDb2wgPyBnZXRBQ2hhbm5lbChcIit4LmpvaW4oKStcIikgOiAwLilcIixSPXI/XCJcIjpcIlxcbiAgICAgIGZsb2F0IGdldEJlc3RJbmRpY2VzQUNoYW5uZWwoXCIrdi5qb2luKCkrXCIpIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEJlc3RJbmRpY2VzQShcIitkLmpvaW4oKStcIiksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitkLnNsaWNlKC0yKS5qb2luKCkrXCIpKTtcXG4gICAgICB9XCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGdldEFDaGFubmVsKFwiK3Yuam9pbigpK1wiKSB7XFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKFwiK2Quam9pbigpK1wiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIitkLnNsaWNlKC0yKS5qb2luKCkrXCIpKTtcXG4gICAgICB9XFxuICAgICAgXCIrUitcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2wrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBcIitoW2MtMV0rXCIgPCBcIisodVtjLTFdLTEpK1wiO1xcbiAgICAgICAgYm9vbCBoYXNOZXh0Um93ID0gXCIraFtjLTJdK1wiIDwgXCIrKHVbYy0yXS0xKStcIjtcXG4gICAgICAgIFwiK2krXCJcXG4gICAgICAgIGl2ZWM0IHNyY0lkeCA9IGl2ZWM0KHNvdXJjZUxvY1JcIitwK1wiLCBzb3VyY2VMb2NHXCIrcCtcIixcXG4gICAgICAgICAgc291cmNlTG9jQlwiK3ArXCIsIHNvdXJjZUxvY0FcIitwK1wiKSAqIFwiK2UrXCI7XFxuICAgICAgICBpdmVjNCBpbklkeCA9IHNyY0lkeDtcXG4gICAgICAgIHZlYzQgYmVzdEluZGV4ID0gdmVjNChpbklkeCk7XFxuICAgICAgICB2ZWM0IGJlc3RWYWx1ZSA9IFwiK0UrXCI7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK2UrXCI7IGkrKykge1xcbiAgICAgICAgICBpbklkeCA9IHNyY0lkeDtcXG4gICAgICAgICAgXCIrdytcIlxcbiAgICAgICAgICB2ZWM0IGNhbmRpZGF0ZSA9IFwiK0UrXCI7XFxuICAgICAgICAgIGJ2ZWM0IG5hbiA9IGlzbmFuKGNhbmRpZGF0ZSk7XFxuICAgICAgICAgIGJ2ZWM0IHJlcGxhY2UgPSBidmVjNChcXG4gICAgICAgICAgICB2ZWM0KFwiK2IrXCIoY2FuZGlkYXRlLCBiZXN0VmFsdWUpKSAqICh2ZWM0KDEuMCkgLSB2ZWM0KG5hbikpKTtcXG5cXG4gICAgICAgICAgYmVzdFZhbHVlID0gdmVjNChyZXBsYWNlLnggID8gY2FuZGlkYXRlLnggOiBiZXN0VmFsdWUueCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLnkgID8gY2FuZGlkYXRlLnkgOiBiZXN0VmFsdWUueSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLnogID8gY2FuZGlkYXRlLnogOiBiZXN0VmFsdWUueixcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlLncgID8gY2FuZGlkYXRlLncgOiBiZXN0VmFsdWUudyk7XFxuICAgICAgICAgIGJlc3RJbmRleCA9IG1peChiZXN0SW5kZXgsIHZlYzQoaW5JZHgpLCB2ZWM0KHJlcGxhY2UpKTtcXG4gICAgICAgICAgc3JjSWR4Kys7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoYmVzdEluZGV4KTtcXG4gICAgICB9XFxuICAgIFwifSxmaT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmluU2hhcGU7dmFyIGU9dC5maWx0ZXJIZWlnaHQsbj10LmZpbHRlcldpZHRoLHI9dC5zdHJpZGVIZWlnaHQsbz10LnN0cmlkZVdpZHRoLGE9dC5kaWxhdGlvbkhlaWdodCxpPXQuZGlsYXRpb25XaWR0aCxzPXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHU9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxjPXMtMS10LnBhZEluZm8udG9wLGw9dS0xLXQucGFkSW5mby5sZWZ0LGg9MS8oZSpuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2MrXCIsIFwiK2wrXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGF2Z011bHRpcGxpZXIgPSBmbG9hdChcIitoK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiBkeVJDQ29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeVJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZCkgd2l0aCBwb3MgbWFzayg6LCA6LCBkKSB0byBnZXQgZHgoeFIsIHhDLCBkKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitzK1wiO1xcbiAgICAgICAgICAgIHdSICs9IFwiK2ErXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrcitcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrdStcIjtcXG4gICAgICAgICAgICB3Qys9IFwiK2krXCIpIHtcXG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitvK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBhdmdNdWx0aXBsaWVyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sZGk9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuZmlsdGVyRGVwdGgsbj10LmZpbHRlckhlaWdodCxyPXQuZmlsdGVyV2lkdGgsbz10LnN0cmlkZURlcHRoLGE9dC5zdHJpZGVIZWlnaHQsaT10LnN0cmlkZVdpZHRoLHM9dC5kaWxhdGlvbkRlcHRoLHU9dC5kaWxhdGlvbkhlaWdodCxjPXQuZGlsYXRpb25XaWR0aCxsPXQuZWZmZWN0aXZlRmlsdGVyRGVwdGgsaD10LmVmZmVjdGl2ZUZpbHRlckhlaWdodCxmPXQuZWZmZWN0aXZlRmlsdGVyV2lkdGgsZD1sLTEtdC5wYWRJbmZvLmZyb250LHA9aC0xLXQucGFkSW5mby50b3Asdj1mLTEtdC5wYWRJbmZvLmxlZnQsZz0xLyhlKm4qcik7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIitkK1wiLCBcIitwK1wiLCBcIit2K1wiKTtcXG4gICAgICBjb25zdCBmbG9hdCBhdmdNdWx0aXBsaWVyID0gZmxvYXQoXCIrZytcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGludCBjaCA9IGNvb3Jkcy51O1xcblxcbiAgICAgICAgaXZlYzMgZHlDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlEQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLno7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIDosIGNoKSB0byBnZXRcXG4gICAgICAgIC8vIGR4KHhELCB4UiwgeEMsIGNoKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdEID0gMDsgd0QgPCBcIitsK1wiO1xcbiAgICAgICAgICAgIHdEICs9IFwiK3MrXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlEID0gZmxvYXQoZHlEQ29ybmVyICsgd0QpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlEIDwgMC4wIHx8IGR5RCA+PSBcIit0Lm91dERlcHRoK1wiLjAgfHwgZnJhY3QoZHlEKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlEID0gaW50KGR5RCk7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitoK1wiO1xcbiAgICAgICAgICAgICAgd1IgKz0gXCIrdStcIikge1xcbiAgICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK2ErXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitmK1wiO1xcbiAgICAgICAgICAgICAgICB3QyArPSBcIitjK1wiKSB7XFxuICAgICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyBcIitpK1wiLjA7XFxuXFxuICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiYXRjaCwgaWR5RCwgaWR5UiwgaWR5QywgY2gpO1xcblxcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogYXZnTXVsdGlwbGllcjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxwaT1mdW5jdGlvbih0LGUsbixyLG8sYSl7dGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwibWVhblwiLFwidmFyaWFuY2VcIl0sUHIodCxlKSxQcih0LG4pO3ZhciBpPVwiMC4wXCI7bnVsbCE9ciYmKFByKHQsciksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJvZmZzZXRcIiksaT1cImdldE9mZnNldEF0T3V0Q29vcmRzKClcIik7dmFyIHM9XCIxLjBcIjtudWxsIT1vJiYoUHIodCxvKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInNjYWxlXCIpLHM9XCJnZXRTY2FsZUF0T3V0Q29vcmRzKClcIiksdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0WEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBtZWFuID0gZ2V0TWVhbkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB2YXJpYW5jZSA9IGdldFZhcmlhbmNlQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG9mZnNldCA9IFwiK2krXCI7XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IFwiK3MrXCI7XFxuICAgICAgICBmbG9hdCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgZmxvYXQoXCIrYStcIikpO1xcbiAgICAgICAgc2V0T3V0cHV0KGRvdCh2ZWMzKHgsIC1tZWFuLCBvZmZzZXQpLCB2ZWMzKGludiwgaW52LCAxKSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHZpPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwibWVhblwiLFwidmFyaWFuY2VcIl0sUHIodCxlKSxQcih0LG4pO3ZhciBpPVwidmVjNCgwLjApXCI7bnVsbCE9ciYmKFByKHQsciksdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJvZmZzZXRcIiksaT1cImdldE9mZnNldEF0T3V0Q29vcmRzKClcIik7dmFyIHM9XCJ2ZWM0KDEuMClcIjtudWxsIT1vJiYoUHIodCxvKSx0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInNjYWxlXCIpLHM9XCJnZXRTY2FsZUF0T3V0Q29vcmRzKClcIiksdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IG9mZnNldCA9IFwiK2krXCI7XFxuICAgICAgICB2ZWM0IHNjYWxlID0gXCIrcytcIjtcXG5cXG4gICAgICAgIHZlYzQgeCA9IGdldFhBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCBtZWFuID0gZ2V0TWVhbkF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHZhcmlhbmNlID0gZ2V0VmFyaWFuY2VBdE91dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCBpbnYgPSBzY2FsZSAqIGludmVyc2VzcXJ0KHZhcmlhbmNlICsgdmVjNChcIithK1wiKSk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XFxuICAgICAgfVxcbiAgICBcIn0sZ2k9XCJyZXR1cm4gYXJlYWwgKiBicmVhbCAtIGFpbWFnICogYmltYWc7XCIsbWk9XCJyZXR1cm4gYXJlYWwgKiBiaW1hZyArIGFpbWFnICogYnJlYWw7XCIseWk9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBUmVhbFwiLFwiQUltYWdcIixcIkJSZWFsXCIsXCJCSW1hZ1wiXSx0aGlzLm91dHB1dFNoYXBlPVByKGUsbiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wQ29tcGxleChcXG4gICAgICAgICAgZmxvYXQgYXJlYWwsIGZsb2F0IGFpbWFnLCBmbG9hdCBicmVhbCwgZmxvYXQgYmltYWcpIHtcXG4gICAgICAgIFwiK3QrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYXJlYWwgPSBnZXRBUmVhbEF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCBhaW1hZyA9IGdldEFJbWFnQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGJyZWFsID0gZ2V0QlJlYWxBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYmltYWcgPSBnZXRCSW1hZ0F0T3V0Q29vcmRzKCk7XFxuICAgICAgICBzZXRPdXRwdXQoYmluYXJ5T3BDb21wbGV4KGFyZWFsLCBhaW1hZywgYnJlYWwsIGJpbWFnKSk7XFxuICAgICAgfVxcbiAgICBcIn0seGk9XCJyZXR1cm4gYSArIGI7XCIsYmk9XCJyZXR1cm4gYSAtIGI7XCIsd2k9XCJyZXR1cm4gYSAqIGI7XCIsQ2k9XCJcXG5pZiAoYSA9PSBiKSB7XFxuICByZXR1cm4gMS4wO1xcbn07XFxucmV0dXJuIGEgLyBiO1wiLEVpPVwicmV0dXJuIChhIDwgMC4pID8gYiAqIGEgOiBhO1wiLFJpPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiLFwiQlwiXSx0aGlzLm91dHB1dFNoYXBlPVByKGUsbiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wZXJhdGlvbihmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgICAgICBcIit0K1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGIgPSBnZXRCQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChiaW5hcnlPcGVyYXRpb24oYSwgYikpO1xcbiAgICAgIH1cXG4gICAgXCJ9LElpPVwiXFxuICAvLyB2ZWM0IG9uZSA9IHZlYzQoZXF1YWwoYSwgYikpO1xcbiAgLy8gcmV0dXJuIG9uZSArICh2ZWM0KDEuMCkgLSBvbmUpICogYSAvIGI7XFxuICB2ZWM0IHJlc3VsdCA9IGEgLyBiO1xcbiAgaWYoYS54ID09IGIueCkge1xcbiAgICByZXN1bHQueCA9IDEuO1xcbiAgfVxcbiAgaWYoYS55ID09IGIueSkge1xcbiAgICByZXN1bHQueSA9IDEuO1xcbiAgfVxcbiAgaWYoYS56ID09IGIueikge1xcbiAgICByZXN1bHQueiA9IDEuO1xcbiAgfVxcbiAgaWYoYS53ID09IGIudykge1xcbiAgICByZXN1bHQudyA9IDEuO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIixraT1cIlxcbiAgdmVjNCBhTGVzc1RoYW5aZXJvID0gdmVjNChsZXNzVGhhbihhLCB2ZWM0KDAuKSkpO1xcbiAgcmV0dXJuIChhTGVzc1RoYW5aZXJvICogKGIgKiBhKSkgKyAoKHZlYzQoMS4wKSAtIGFMZXNzVGhhblplcm8pICogYSk7XFxuXCIsU2k9ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJBXCIsXCJCXCJdLHRoaXMuc3VwcG9ydHNCcm9hZGNhc3Rpbmc9ITAsdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1QcihlLG4pO3ZhciBvPXRoaXMub3V0cHV0U2hhcGUubGVuZ3RoLGE9XCJcIjtpZihyKWlmKDA9PT1vfHwxPT09ayh0aGlzLm91dHB1dFNoYXBlKSlhPVwiXFxuICAgICAgICAgIHJlc3VsdC55ID0gMC47XFxuICAgICAgICAgIHJlc3VsdC56ID0gMC47XFxuICAgICAgICAgIHJlc3VsdC53ID0gMC47XFxuICAgICAgICBcIjtlbHNlIGlmKGE9XCJcXG4gICAgICAgICAgXCIrdWkobykrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBcIiwxPT09bylhKz1cIlxcbiAgICAgICAgICAgIHJlc3VsdC55ID0gKGNvb3JkcyArIDEpID49IFwiK3RoaXMub3V0cHV0U2hhcGVbMF0rXCIgPyAwLiA6IHJlc3VsdC55O1xcbiAgICAgICAgICAgIHJlc3VsdC56ID0gMC47XFxuICAgICAgICAgICAgcmVzdWx0LncgPSAwLjtcXG4gICAgICAgICAgXCI7ZWxzZXt2YXIgaT1YYShcImNvb3Jkc1wiLG8pO2ErPVwiXFxuICAgICAgICAgICAgYm9vbCBuZXh0Um93T3V0T2ZCb3VuZHMgPVxcbiAgICAgICAgICAgICAgKFwiK2lbby0yXStcIiArIDEpID49IFwiK3RoaXMub3V0cHV0U2hhcGVbby0yXStcIjtcXG4gICAgICAgICAgICBib29sIG5leHRDb2xPdXRPZkJvdW5kcyA9XFxuICAgICAgICAgICAgICAoXCIraVtvLTFdK1wiICsgMSkgPj0gXCIrdGhpcy5vdXRwdXRTaGFwZVtvLTFdK1wiO1xcbiAgICAgICAgICAgIHJlc3VsdC55ID0gbmV4dENvbE91dE9mQm91bmRzID8gMC4gOiByZXN1bHQueTtcXG4gICAgICAgICAgICByZXN1bHQueiA9IG5leHRSb3dPdXRPZkJvdW5kcyA/IDAuIDogcmVzdWx0Lno7XFxuICAgICAgICAgICAgcmVzdWx0LncgPSBuZXh0Q29sT3V0T2ZCb3VuZHMgfHwgbmV4dFJvd091dE9mQm91bmRzID8gMC4gOiByZXN1bHQudztcXG4gICAgICAgICAgXCJ9dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZlYzQgYmluYXJ5T3BlcmF0aW9uKHZlYzQgYSwgdmVjNCBiKSB7XFxuICAgICAgICBcIit0K1wiXFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgYSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgdmVjNCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IGJpbmFyeU9wZXJhdGlvbihhLCBiKTtcXG4gICAgICAgIFwiK2ErXCJcXG5cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEFpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWluVmFsO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgbWF4VmFsO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBpZiAoaXNuYW4odmFsdWUpKSB7XFxuICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNldE91dHB1dChjbGFtcCh2YWx1ZSwgbWluVmFsLCBtYXhWYWwpKTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiBmdW5jdGlvbihyLG8pe251bGw9PW4ubWluTG9jJiYobi5taW5Mb2M9ci5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KG8sXCJtaW5WYWxcIiksbi5tYXhMb2M9ci5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KG8sXCJtYXhWYWxcIikpLHIuZ2wudW5pZm9ybTFmKG4ubWluTG9jLHQpLHIuZ2wudW5pZm9ybTFmKG4ubWF4TG9jLGUpfX0sdH0oKSxUaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1pblZhbDtcXG4gICAgICB1bmlmb3JtIGZsb2F0IG1heFZhbDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHZhbHVlID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuXFxuICAgICAgICBpZiAoYW55KGlzbmFuKHZhbHVlKSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGNsYW1wKHZhbHVlLCB2ZWM0KG1pblZhbCksIHZlYzQobWF4VmFsKSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKHIsbyl7bnVsbD09bi5taW5Mb2MmJihuLm1pbkxvYz1yLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cobyxcIm1pblZhbFwiKSxuLm1heExvYz1yLmdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3cobyxcIm1heFZhbFwiKSksci5nbC51bmlmb3JtMWYobi5taW5Mb2MsdCksci5nbC51bmlmb3JtMWYobi5tYXhMb2MsZSl9fSx0fSgpLERpPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJyZWFsXCIsXCJpbWFnXCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgcmUgPSBhYnMoZ2V0UmVhbEF0T3V0Q29vcmRzKCkpO1xcbiAgICAgICAgZmxvYXQgaW0gPSBhYnMoZ2V0SW1hZ0F0T3V0Q29vcmRzKCkpO1xcbiAgICAgICAgZmxvYXQgbXggPSBtYXgocmUsIGltKTtcXG5cXG4gICAgICAgIC8vIHNhZGx5IHRoZSBsZW5ndGggZnVuY3Rpb24gaW4gZ2xzbCBpcyBub3QgdW5kZXJmbG93LXNhZmVcXG4gICAgICAgIC8vIChhdCBsZWFzdCBub3Qgb24gSW50ZWwgR1BVcykuIFNvIHRoZSBzYWZlIHNvbHV0aW9uIGlzXFxuICAgICAgICAvLyB0byBlbnN1cmUgdW5kZXJmbG93LXNhZmV0eSBpbiBhbGwgY2FzZXMuXFxuICAgICAgICBzZXRPdXRwdXQoXFxuICAgICAgICAgIG14ID09IDAuMCA/IDAuMCA6IG14ICogbGVuZ3RoKHZlYzIoMSwgbWluKHJlLCBpbSkvbXgpKVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgIFwifSxOaT1mdW5jdGlvbih0KXt0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9U24odCwxKSx0aGlzLnZhcmlhYmxlTmFtZXM9dC5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJUXCIrZX0pKTt2YXIgZT1uZXcgQXJyYXkodC5sZW5ndGgtMSk7ZVswXT10WzBdWzFdO2Zvcih2YXIgbj0xO248ZS5sZW5ndGg7bisrKWVbbl09ZVtuLTFdK3Rbbl1bMV07dmFyIHI9W1wiaWYgKHlDIDwgXCIrZVswXStcIikgc2V0T3V0cHV0KGdldFQwKHlSLCB5QykpO1wiXTtmb3Iobj0xO248ZS5sZW5ndGg7bisrKXt2YXIgbz1lW24tMV07ci5wdXNoKFwiZWxzZSBpZiAoeUMgPCBcIitlW25dK1wiKSBzZXRPdXRwdXQoZ2V0VFwiK24rXCIoeVIsIHlDLVwiK28rXCIpKTtcIil9dmFyIGE9ZS5sZW5ndGgsaT1lW2UubGVuZ3RoLTFdO3IucHVzaChcImVsc2Ugc2V0T3V0cHV0KGdldFRcIithK1wiKHlSLCB5Qy1cIitpK1wiKSk7XCIpLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB5UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHlDID0gY29vcmRzLnk7XFxuXFxuICAgICAgICBcIityLmpvaW4oXCJcXG4gICAgICAgIFwiKStcIlxcbiAgICAgIH1cXG4gICAgXCJ9LEZpPWZ1bmN0aW9uKHQsZSl7dGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPVNuKHQsZSk7dmFyIG49dGhpcy5vdXRwdXRTaGFwZSxyPW4ubGVuZ3RoLG89dWkociksYT1YYShcImNvb3Jkc1wiLHIpLGk9W1wieFwiLFwieVwiLFwielwiLFwid1wiLFwidVwiLFwidlwiXS5zbGljZSgwLHIpO3RoaXMudmFyaWFibGVOYW1lcz10Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cIlRcIitlfSkpO3ZhciBzPW5ldyBBcnJheSh0Lmxlbmd0aC0xKTtzWzBdPXRbMF1bZV07Zm9yKHZhciB1PTE7dTxzLmxlbmd0aDt1Kyspc1t1XT1zW3UtMV0rdFt1XVtlXTt2YXIgYz1pW2VdLGw9aS5zbGljZSgtMiksaD1pLmpvaW4oKSxmPVwiaWYgKFwiK2MrXCIgPCBcIitzWzBdK1wiKSB7XFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICBnZXRUMChcIitoK1wiKSwgdmVjMihcIitsLmpvaW4oKStcIikpO1xcbiAgICAgICAgfVwiO2Zvcih1PTE7dTxzLmxlbmd0aDt1Kyspe3ZhciBkPXNbdS0xXTtmKz1cIlxcbiAgICAgICAgaWYgKFwiK2MrXCIgPCBcIitzW3VdK1wiICAmJiBcIitjK1wiID49IFwiK3NbdS0xXStcIikge1xcbiAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICBnZXRUXCIrdStcIihcIitfaShpLGMsZCkrXCIpLFxcbiAgICAgICAgICAgIHZlYzIoXCIrX2kobCxjLGQpK1wiKSk7XFxuICAgICAgICB9XCJ9dmFyIHA9cy5sZW5ndGgsdj1zW3MubGVuZ3RoLTFdO2YrPVwiXFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgZ2V0VFwiK3ArXCIoXCIrX2koaSxjLHYpK1wiKSxcXG4gICAgICAgICAgdmVjMihcIitfaShsLGMsdikrXCIpKTtcIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoXCIraS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblwiaW50IFwiK3R9KSkrXCIpIHtcXG4gICAgICAgIFwiK2YrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZShcIithK1wiKSwgMC4sIDAuLCAwLik7XFxuXFxuICAgICAgICBcIithW3ItMV0rXCIgPSBcIithW3ItMV0rXCIgKyAxO1xcbiAgICAgICAgaWYgKFwiK2Fbci0xXStcIiA8IFwiK25bci0xXStcIikge1xcbiAgICAgICAgICByZXN1bHQuZyA9IGdldFZhbHVlKFwiK2ErXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrYVtyLTJdK1wiID0gXCIrYVtyLTJdK1wiICsgMTtcXG4gICAgICAgIGlmIChcIithW3ItMl0rXCIgPCBcIituW3ItMl0rXCIpIHtcXG4gICAgICAgICAgcmVzdWx0LmEgPSBnZXRWYWx1ZShcIithK1wiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiK2Fbci0xXStcIiA9IFwiK2Fbci0xXStcIiAtIDE7XFxuICAgICAgICBpZiAoXCIrYVtyLTJdK1wiIDwgXCIrbltyLTJdK1wiICYmXFxuICAgICAgICAgICAgXCIrYVtyLTFdK1wiIDwgXCIrbltyLTFdK1wiKSB7XFxuICAgICAgICAgIHJlc3VsdC5iID0gZ2V0VmFsdWUoXCIrYStcIik7XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifTtmdW5jdGlvbiBfaSh0LGUsbil7dmFyIHI9dC5pbmRleE9mKGUpO3JldHVybiB0Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gZT09PXI/dCtcIiAtIFwiK246dH0pKS5qb2luKCl9dmFyIE9pPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJkeVwiXSx0aGlzLm91dHB1dFNoYXBlPXQuZmlsdGVyU2hhcGU7dmFyIGU9dC5zdHJpZGVIZWlnaHQsbj10LnN0cmlkZVdpZHRoLHI9dC5wYWRJbmZvLnRvcCxvPXQucGFkSW5mby5sZWZ0LGE9XCJjaGFubmVsc0xhc3RcIj09PXQuZGF0YUZvcm1hdDt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggZHkoOiwgOiwgZDIpIHRvIGdldCBkdyh3Uiwgd0MsIGQxLCBkMikuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiK3QuYmF0Y2hTaXplK1wiOyBiKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8IFwiK3Qub3V0SGVpZ2h0K1wiOyB5UisrKSB7XFxuICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqIFwiK2UrXCIgLSBcIityK1wiO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIit0Lm91dFdpZHRoK1wiOyB5QysrKSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogXCIrbitcIiAtIFwiK28rXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGlmIChcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCB5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgZDIsIHlSLCB5Qyk7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgZDEsIHhSLCB4Qyk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LE1pPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LmZpbHRlckhlaWdodCxuPXQuZmlsdGVyV2lkdGgscj10LnN0cmlkZUhlaWdodCxvPXQuc3RyaWRlV2lkdGgsYT1cImNoYW5uZWxzTGFzdFwiPT09dC5kYXRhRm9ybWF0LGk9ZS0xLXQucGFkSW5mby50b3Ascz1uLTEtdC5wYWRJbmZvLmxlZnQsdT1hPzE6MixjPWE/MjozLGw9YT8zOjE7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIitpK1wiLCBcIitzK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1tcIitsK1wiXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gaXZlYzIoY29vcmRzW1wiK3UrXCJdLCBjb29yZHNbXCIrYytcIl0pIC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitlK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK3IrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiK2UrXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIituK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIrbitcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMiA9IDA7IGQyIDwgXCIrdC5vdXRDaGFubmVscytcIjsgZDIrKykge1xcblxcbiAgICAgICAgICAgICAgaWYgKFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXREeShiYXRjaCwgZDIsIGlkeVIsIGlkeUMpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxCaT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT10LmZpbHRlclNoYXBlO3ZhciBlPXQuc3RyaWRlRGVwdGgsbj10LnN0cmlkZUhlaWdodCxyPXQuc3RyaWRlV2lkdGgsbz10LnBhZEluZm8uZnJvbnQsYT10LnBhZEluZm8udG9wLGk9dC5wYWRJbmZvLmxlZnQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHdGID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueTtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy56O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLnc7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudTtcXG5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8IFwiK3QuYmF0Y2hTaXplK1wiOyBiKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgeUYgPSAwOyB5RiA8IFwiK3Qub3V0RGVwdGgrXCI7IHlGKyspIHtcXG4gICAgICAgICAgICBpbnQgeEYgPSB3RiArIHlGICogXCIrZStcIiAtIFwiK28rXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSBcIit0LmluRGVwdGgrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIrdC5vdXRIZWlnaHQrXCI7IHlSKyspIHtcXG4gICAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiBcIituK1wiIC0gXCIrYStcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCBcIit0Lm91dFdpZHRoK1wiOyB5QysrKSB7XFxuICAgICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIityK1wiIC0gXCIraStcIjtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeUYsIHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhGLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSAoeFZhbHVlICogZHlWYWx1ZSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sUGk9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuZmlsdGVyRGVwdGgsbj10LmZpbHRlckhlaWdodCxyPXQuZmlsdGVyV2lkdGgsbz10LnN0cmlkZURlcHRoLGE9dC5zdHJpZGVIZWlnaHQsaT10LnN0cmlkZVdpZHRoLHM9ZS0xLXQucGFkSW5mby5mcm9udCx1PW4tMS10LnBhZEluZm8udG9wLGM9ci0xLXQucGFkSW5mby5sZWZ0O3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIrcytcIiwgXCIrdStcIiwgXCIrYytcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy51O1xcblxcblxcbiAgICAgICAgaXZlYzMgZHlDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlGQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLno7XFxuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd0YgPSAwOyB3RiA8IFwiK2UrXCI7IHdGKyspIHtcXG4gICAgICAgICAgZmxvYXQgZHlGID0gZmxvYXQoZHlGQ29ybmVyICsgd0YpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlGIDwgMC4wIHx8IGR5RiA+PSBcIit0Lm91dERlcHRoK1wiLjAgfHwgZnJhY3QoZHlGKSA+IDAuMCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGludCBpZHlGID0gaW50KGR5Rik7XFxuXFxuICAgICAgICAgIGludCB3RlBlcm0gPSBcIitlK1wiIC0gMSAtIHdGO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrbitcIjsgd1IrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK2ErXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8XFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgICBpbnQgd1JQZXJtID0gXCIrbitcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrcitcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIraStcIi4wO1xcblxcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIrcitcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCBcIit0Lm91dENoYW5uZWxzK1wiOyBkMisrKSB7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlGLCBpZHlSLCBpZHlDLCBkMik7XFxuICAgICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod0ZQZXJtLCB3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sTGk9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9dC5maWx0ZXJTaGFwZTt2YXIgZT10LnN0cmlkZUhlaWdodCxuPXQuc3RyaWRlV2lkdGgscj10LnBhZEluZm8udG9wLG89dC5wYWRJbmZvLmxlZnQsYT10Lm91dENoYW5uZWxzL3QuaW5DaGFubmVsczt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XFxuICAgICAgICBpbnQgZG0gPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMiA9IGQxICogXCIrYStcIiArIGRtO1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIC8vIFRPIERPOiBWZWM0IG92ZXIgdGhlIGJhdGNoIHNpemVcXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgXCIrdC5iYXRjaFNpemUrXCI7IGIrKykge1xcbiAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgXCIrdC5vdXRIZWlnaHQrXCI7IHlSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB3UiArIHlSICogXCIrZStcIiAtIFwiK3IrXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8IFwiK3Qub3V0V2lkdGgrXCI7IHlDKyspIHtcXG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiBcIituK1wiIC0gXCIrbytcIjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlSLCB5QywgZDIpO1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0WChiLCB4UiwgeEMsIGQxKTtcXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFdpPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwiV1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LmZpbHRlckhlaWdodCxuPXQuZmlsdGVyV2lkdGgscj10LnN0cmlkZUhlaWdodCxvPXQuc3RyaWRlV2lkdGgsYT1lLTEtdC5wYWRJbmZvLnRvcCxpPW4tMS10LnBhZEluZm8ubGVmdCxzPXQub3V0Q2hhbm5lbHMvdC5pbkNoYW5uZWxzO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrYStcIiwgXCIraStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHNbM107XFxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xcblxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitlK1wiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiK3IrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgaW50IHdSUGVybSA9IFwiK2UrXCIgLSAxIC0gd1I7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIituK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrbytcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiK3Qub3V0V2lkdGgrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcXG5cXG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gXCIrbitcIiAtIDEgLSB3QztcXG5cXG4gICAgICAgICAgICAvLyBUTyBETzogVmVjNCBvdmVyIHRoZSBjaGFubmVsTXVsXFxuICAgICAgICAgICAgZm9yIChpbnQgZG0gPSAwOyBkbSA8IFwiK3MrXCI7IGRtKyspIHtcXG4gICAgICAgICAgICAgIGludCBkMiA9IGQxICogXCIrcytcIiArIGRtO1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkbSk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwifSxVaT1mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09biYmKG49bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgbz10LnBhZEluZm8udG9wLGE9dC5wYWRJbmZvLmxlZnQsaT10LnN0cmlkZUhlaWdodCxzPXQuc3RyaWRlV2lkdGgsdT10LmRpbGF0aW9uSGVpZ2h0LGM9dC5kaWxhdGlvbldpZHRoLGw9dC5maWx0ZXJIZWlnaHQsaD10LmZpbHRlcldpZHRoLGY9NCpNYXRoLmZsb29yKHQuaW5DaGFubmVscy80KSxkPXQuaW5DaGFubmVscyU0LHA9XCJjaGFubmVsc0xhc3RcIj09PXQuZGF0YUZvcm1hdCx2PXA/MToyLGc9cD8yOjMsbT1wPzM6MSx5PVwiXCIseD1cIlwiO24mJih5PXI/XCJmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IGEpIHtcXG4gICAgICAgICAgZmxvYXQgYiA9IGdldFByZWx1QWN0aXZhdGlvbldlaWdodHNBdE91dENvb3JkcygpO1xcbiAgICAgICAgICBcIituK1wiXFxuICAgICAgICB9XCI6XCJcXG4gICAgICAgICAgZmxvYXQgYWN0aXZhdGlvbihmbG9hdCB4KSB7XFxuICAgICAgICAgICAgXCIrbitcIlxcbiAgICAgICAgICB9XFxuICAgICAgICBcIix4PVwicmVzdWx0ID0gYWN0aXZhdGlvbihyZXN1bHQpO1wiKTt2YXIgYj1lP1wicmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpO1wiOlwiXCI7ZSYmdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goXCJiaWFzXCIpLHImJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwicHJlbHVBY3RpdmF0aW9uV2VpZ2h0c1wiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIreStcIlxcblxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIitpK1wiLCBcIitzK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIrbytcIiwgXCIrYStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHNbXCIrbStcIl07XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPVxcbiAgICAgICAgICAgIGl2ZWMyKGNvb3Jkc1tcIit2K1wiXSwgY29vcmRzW1wiK2crXCJdKSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2wrXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiK3UrXCI7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitoK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK2MrXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgXCIrZitcIjsgZDEgKz0gNCkge1xcbiAgICAgICAgICAgICAgdmVjNCB3VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDEsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMiwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAzLCBkMilcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBpZiAoXCIrcCtcIikge1xcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDMpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmVjNCB4VmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSwgeFIsIHhDKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDEsIHhSLCB4QyksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAyLCB4UiwgeEMpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMywgeFIsIHhDKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKFwiKygxPT09ZCkrXCIpIHtcXG5cXG4gICAgICAgICAgICAgIGlmIChcIitwK1wiKSB7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz1cXG4gICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrZitcIikgKlxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2YrXCIsIGQyKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz1cXG4gICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiK2YrXCIsIHhSLCB4QykgKlxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2YrXCIsIGQyKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09ZCkrXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitmK1wiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitmK1wiICsgMSwgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgaWYgKFwiK3ArXCIpIHtcXG4gICAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2YrXCIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrZitcIiArIDEpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBcIitmK1wiLCB4UiwgeEMpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiK2YrXCIgKyAxLCB4UiwgeEMpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1kKStcIikge1xcbiAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2YrXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiK2YrXCIgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIitmK1wiICsgMiwgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgaWYgKFwiK3ArXCIpIHtcXG4gICAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiK2YrXCIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrZitcIiArIDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIrZitcIiArIDIpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBcIitmK1wiLCB4UiwgeEMpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiK2YrXCIgKyAxLCB4UiwgeEMpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIFwiK2YrXCIgKyAyLCB4UiwgeEMpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gZG90UHJvZDtcXG4gICAgICAgIFwiK2IrXCJcXG4gICAgICAgIFwiK3grXCJcXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFZpPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgZT10LnBhZEluZm8uZnJvbnQsbj10LnBhZEluZm8udG9wLHI9dC5wYWRJbmZvLmxlZnQsbz10LnN0cmlkZURlcHRoLGE9dC5zdHJpZGVIZWlnaHQsaT10LnN0cmlkZVdpZHRoLHM9dC5kaWxhdGlvbkRlcHRoLHU9dC5kaWxhdGlvbkhlaWdodCxjPXQuZGlsYXRpb25XaWR0aCxsPXQuZmlsdGVyRGVwdGgsaD10LmZpbHRlckhlaWdodCxmPXQuZmlsdGVyV2lkdGgsZD00Kk1hdGguZmxvb3IodC5pbkNoYW5uZWxzLzQpLHA9dC5pbkNoYW5uZWxzJTQ7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHN0cmlkZXMgPSBpdmVjMyhcIitvK1wiLCBcIithK1wiLCBcIitpK1wiKTtcXG4gICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIrZStcIiwgXCIrbitcIiwgXCIrcitcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzUgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy51O1xcblxcbiAgICAgICAgaXZlYzMgeEZSQ0Nvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeEZDb3JuZXIgPSB4RlJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4RlJDQ29ybmVyLnk7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sID8sIGQxKSB3aXRoIHcoOiwgOiwgOiwgZDEsIGQyKSB0byBnZXRcXG4gICAgICAgIC8vIHkoeUYsIHlSLCB5QywgZDIpLiA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGxcXG4gICAgICAgIC8vIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd0YgPSAwOyB3RiA8IFwiK2wrXCI7IHdGKyspIHtcXG4gICAgICAgICAgaW50IHhGID0geEZDb3JuZXIgKyB3RiAqIFwiK3MrXCI7XFxuXFxuICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0gXCIrdC5pbkRlcHRoK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2grXCI7IHdSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogXCIrdStcIjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrZitcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK2MrXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IFwiK3QuaW5XaWR0aCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCBcIitkK1wiOyBkMSArPSA0KSB7XFxuICAgICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMSksXFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDMpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIHZlYzQgd1ZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDIsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMywgZDIpXFxuICAgICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgaWYgKFwiKygxPT09cCkrXCIpIHtcXG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2QrXCIpICpcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2QrXCIsIGQyKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1wKStcIikge1xcbiAgICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2QrXCIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2QrXCIgKyAxKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZCtcIiwgZDIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgXCIrZCtcIiArIDEsIGQyKVxcbiAgICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDM9PT1wKStcIikge1xcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2QrXCIpLFxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIFwiK2QrXCIgKyAxKSxcXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBcIitkK1wiICsgMilcXG4gICAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2QrXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIFwiK2QrXCIgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBcIitkK1wiICsgMiwgZDIpXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHppPWZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PWUmJihlPSExKSx2b2lkIDA9PT1uJiYobj1udWxsKSx2b2lkIDA9PT1yJiYocj0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIixcIldcIl0sdGhpcy5vdXRwdXRTaGFwZT10Lm91dFNoYXBlO3ZhciBvPXQuaW5IZWlnaHQsYT10LmluV2lkdGgsaT10LnBhZEluZm8udG9wLHM9dC5wYWRJbmZvLmxlZnQsdT10LnN0cmlkZUhlaWdodCxjPXQuc3RyaWRlV2lkdGgsbD10LmRpbGF0aW9uSGVpZ2h0LGg9dC5kaWxhdGlvbldpZHRoLGY9dC5maWx0ZXJIZWlnaHQsZD10LmZpbHRlcldpZHRoLHA9dC5vdXRDaGFubmVscy90LmluQ2hhbm5lbHMsdj1cIlwiLGc9XCJcIjtuJiYodj1yP1wiZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XFxuICAgICAgICAgIGZsb2F0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcXG4gICAgICAgICAgXCIrbitcIlxcbiAgICAgICAgfVwiOlwiXFxuICAgICAgICAgIGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgeCkge1xcbiAgICAgICAgICAgIFwiK24rXCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCIsZz1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7dmFyIG09ZT9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO2UmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSxyJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInByZWx1QWN0aXZhdGlvbldlaWdodHNcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK3YrXCJcXG5cXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrdStcIiwgXCIrYytcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2krXCIsIFwiK3MrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQxID0gZDIgLyBcIitwK1wiO1xcbiAgICAgICAgaW50IHEgPSBkMiAtIGQxICogXCIrcCtcIjtcXG5cXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIHEpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgLy8gVE8gRE8oZHNtaWxrb3YpOiBGbGF0dGVuIHRoZSB0d28gZm9yIGxvb3BzIGFuZCB2ZWM0IHRoZSBvcGVyYXRpb25zLlxcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2YrXCI7IHdSKyspIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqIFwiK2wrXCI7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrbytcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitkK1wiOyB3QysrKSB7XFxuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIFwiK2grXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIithK1wiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKHdSLCB3QywgZDEsIHEpO1xcbiAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbCAqIHdWYWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdCA9IGRvdFByb2Q7XFxuICAgICAgICBcIittK1wiXFxuICAgICAgICBcIitnK1wiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxHaT1mdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1lJiYoZT0hMSksdm9pZCAwPT09biYmKG49bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJXXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTtmb3IodmFyIG89dC5pbkhlaWdodCxhPXQuaW5XaWR0aCxpPXQucGFkSW5mby50b3Ascz10LnBhZEluZm8ubGVmdCx1PXQuc3RyaWRlSGVpZ2h0LGM9dC5zdHJpZGVXaWR0aCxsPXQuZGlsYXRpb25IZWlnaHQsaD10LmRpbGF0aW9uV2lkdGgsZj10LmZpbHRlckhlaWdodCxkPXQuZmlsdGVyV2lkdGgscD1kLHY9XCJpbnQgeFI7IGludCB4QzsgaW50IHhDT2Zmc2V0O1wiLGc9MDtnPGY7ZysrKWZvcih2YXIgbT0wO208ZDttKyspdis9XCJcXG4gICAgICAgICAgdmVjNCB4VGV4ZWxSXCIrZytcIkNcIisyKm0rXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgdmVjNCB3UlwiK2crXCJDXCIrbStcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICB2ZWM0IHhSXCIrZytcIkNcIittK1wiID0gdmVjNCgwLik7XCI7Zm9yKGc9MDtnPGY7ZysrKWZvcih2YXIgeT0wO3k8cDt5Kyspe2lmKHYrPVwiXFxuICAgICAgICAgIHhSID0geFJDb3JuZXIgKyBcIitnKmwrXCI7XFxuICAgICAgICAgIHhDID0geENDb3JuZXIgKyBcIisobT0yKnkpKmgrXCI7XFxuICAgICAgICBcIiwxPT09Yyl7aWYobTxkJiYodis9cyUyPT0xP1wiXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxO1xcbiAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrbytcIiAmJiB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitnK1wiQ1wiK20rXCIgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcXG5cXG4gICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXFxuICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXFxuICAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgKyAxID49IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitnK1wiQ1wiK20rXCIuencgPSB2ZWMyKDAuKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2crXCJDXCIrbStcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gMjtcXG4gICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK28rXCIgJiYgeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICB2ZWM0IHByZXZpb3VzID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuXFxuICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBtYW51YWxseSBjbGVhciB1bnVzZWQgY2hhbm5lbHMgaW4gY2FzZVxcbiAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxcbiAgICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ICsgMSA+PSBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy56dyA9IHZlYzIoMC4pO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICB4UlwiK2crXCJDXCIrbStcIiA9IHZlYzQocHJldmlvdXMuencsIHhUZXhlbFJcIitnK1wiQ1wiK20rXCIueHkpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhSXCIrZytcIkNcIittK1wiID0gdmVjNCgwLCAwLCB4VGV4ZWxSXCIrZytcIkNcIittK1wiLnh5KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgXCI6XCJcXG4gICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK28rXCIgJiYgeEMgPj0gMCAmJiB4QyA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZytcIkNcIittK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2crXCJDXCIrbStcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhSXCIrZytcIkNcIittK1wiID0geFRleGVsUlwiK2crXCJDXCIrbStcIjtcXG4gICAgICAgICAgICAgIFwiLG0rMTxkKSl7dmFyIHg9cyUyPT0wP2IoaCk6aDtoJTI9PTAmJnMlMj09MXx8aCUyIT0wJiZzJTIhPTE/KHYrPVwiXFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIFwiK3MlMitcIiArIFwiK3grXCI7XFxuXFxuICAgICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK28rXCIgJiZcXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZytcIkNcIisobSsyKStcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXCIsaD4xJiYodis9XCJcXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0IC09IDI7XFxuICAgICAgICAgICAgICAgICAgICBpZih4UiA+PSAwICYmIHhSIDwgXCIrbytcIiAmJlxcbiAgICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZytcIkNcIittK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZytcIkNcIittK1wiID0gdmVjNCgwLik7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgXCIpLHYrPVwiXFxuICAgICAgICAgICAgICAgICAgeFJcIitnK1wiQ1wiKyhtKzEpK1wiID0gdmVjNChcXG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitnK1wiQ1wiK20rXCIuencsIHhUZXhlbFJcIitnK1wiQ1wiKyhtKzIpK1wiLnh5KTtcXG4gICAgICAgICAgICAgICAgXCIpOnYrPVwiXFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIFwiK3grXCI7XFxuXFxuICAgICAgICAgICAgICAgICAgaWYoeFIgPj0gMCAmJiB4UiA8IFwiK28rXCIgJiZcXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZytcIkNcIisobSsyKStcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICB4UlwiK2crXCJDXCIrKG0rMSkrXCIgPSB4VGV4ZWxSXCIrZytcIkNcIisobSsyKStcIjtcXG4gICAgICAgICAgICAgICAgXCJ9fWVsc2UgbTxkJiYodis9XCJcXG4gICAgICAgICAgICAgIGlmKHhSID49IDAgJiYgeFIgPCBcIitvK1wiKSB7XFxuICAgICAgICAgICAgXCIscyUyPT0xPyh2Kz1cIlxcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSAtIFwiK2MrXCI7XFxuICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2crXCJDXCIrbStcIiA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitnK1wiQ1wiK20rXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZih4QyArIDEgPj0gMCAmJiB4QyArIDEgPCBcIithK1wiKSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2crXCJDXCIrKG0rMikrXCIgPSBnZXRYKGJhdGNoLCB4UiwgeEMgKyAxLCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2crXCJDXCIrKG0rMikrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4UlwiK2crXCJDXCIrbStcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2crXCJDXCIrbStcIi56dywgeFRleGVsUlwiK2crXCJDXCIrKG0rMikrXCIuencpO1xcbiAgICAgICAgICAgICAgXCIsbSsxPGQmJih2Kz1cIlxcbiAgICAgICAgICAgICAgICAgIHZlYzQgZmluYWwgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSArIFwiK2MrXCI7XFxuICAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIHhSXCIrZytcIkNcIisobSsxKStcIiA9IHZlYzQoeFRleGVsUlwiK2crXCJDXCIrKG0rMikrXCIueHksIGZpbmFsLnh5KTtcXG4gICAgICAgICAgICAgICAgXCIpKToodis9XCJcXG4gICAgICAgICAgICAgICAgaWYoeEMgPj0gMCAmJiB4QyA8IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZytcIkNcIittK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2crXCJDXCIrbStcIiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyBcIitjK1wiO1xcbiAgICAgICAgICAgICAgICBpZih4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgXCIrYStcIikge1xcbiAgICAgICAgICAgICAgICAgIHhUZXhlbFJcIitnK1wiQ1wiKyhtKzIpK1wiID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2crXCJDXCIrKG0rMikrXCIgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB4UlwiK2crXCJDXCIrbStcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgeFRleGVsUlwiK2crXCJDXCIrbStcIi54eSwgeFRleGVsUlwiK2crXCJDXCIrKG0rMikrXCIueHkpO1xcbiAgICAgICAgICAgICAgXCIsbSsxPGQmJih2Kz1cIlxcbiAgICAgICAgICAgICAgICAgIHhSXCIrZytcIkNcIisobSsxKStcIiA9IHZlYzQoXFxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxSXCIrZytcIkNcIittK1wiLnp3LCB4VGV4ZWxSXCIrZytcIkNcIisobSsyKStcIi56dyk7XFxuICAgICAgICAgICAgICAgIFwiKSksdis9XCJ9XCIpO208ZCYmKHYrPVwiXFxuICAgICAgICAgICAgdmVjNCB3VGV4ZWxSXCIrZytcIkNcIittK1wiID0gZ2V0VyhcIitnK1wiLCBcIittK1wiLCBkMSwgcSk7XFxuICAgICAgICAgICAgd1JcIitnK1wiQ1wiK20rXCIgPSB2ZWM0KHdUZXhlbFJcIitnK1wiQ1wiK20rXCIueHosIHdUZXhlbFJcIitnK1wiQ1wiK20rXCIueHopO1xcbiAgICAgICAgICBcIixtKzE8ZCYmKHYrPVwiXFxuICAgICAgICAgICAgICB2ZWM0IHdUZXhlbFJcIitnK1wiQ1wiKyhtKzEpK1wiID0gZ2V0VyhcIitnK1wiLCBcIisobSsxKStcIiwgZDEsIHEpO1xcbiAgICAgICAgICAgICAgd1JcIitnK1wiQ1wiKyhtKzEpK1wiID1cXG4gICAgICAgICAgICAgICAgdmVjNCh3VGV4ZWxSXCIrZytcIkNcIisobSsxKStcIi54eiwgd1RleGVsUlwiK2crXCJDXCIrKG0rMSkrXCIueHopO1wiKSl9Zm9yKGc9MDtnPGY7ZysrKWZvcihtPTA7bTxkO20rKyl2Kz1cImRvdFByb2QgKz0geFJcIitnK1wiQ1wiK20rXCIgKiB3UlwiK2crXCJDXCIrbStcIjtcIjt2YXIgdz1cIlwiLEM9XCJcIjtuJiYodz1yP1widmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcXG4gICAgICAgICAgXCIrbitcIlxcbiAgICAgICAgfVwiOlwidmVjNCBhY3RpdmF0aW9uKHZlYzQgeCkge1xcbiAgICAgICAgICBcIituK1wiXFxuICAgICAgICB9XCIsQz1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7dmFyIEU9ZT9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO2UmJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSxyJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInByZWx1QWN0aXZhdGlvbldlaWdodHNcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK3crXCJcXG5cXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIrdStcIiwgXCIrYytcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2krXCIsIFwiK3MrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG5cXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcbiAgICAgICAgaW50IGQxID0gZDI7XFxuICAgICAgICBpbnQgcSA9IDA7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgdmVjNCBkb3RQcm9kID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBcIit2K1wiXFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IGRvdFByb2Q7XFxuICAgICAgICBcIitFK1wiXFxuICAgICAgICBcIitDK1wiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxIaT1mdW5jdGlvbih0LGUsbixyLG8pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJJbWFnZVwiLFwiQm94ZXNcIixcIkJveEluZFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdO3ZhciBhPXRbMF0saT10WzFdLHM9dFsyXSx1PXRbM10sYz1lWzBdLGw9blswXSxoPW5bMV07dGhpcy5vdXRwdXRTaGFwZT1bYyxsLGgsdV07dmFyIGY9XCJiaWxpbmVhclwiPT09cj8xOjAsZD1baS0xK1wiLjBcIixzLTErXCIuMFwiXSxwPWRbMF0sdj1kWzFdLGc9bD4xP1tcIlwiKyhpLTEpLyhsLTEpLFwiKHkyLXkxKSAqIGhlaWdodF9yYXRpb1wiLFwieTEqXCIrcCtcIiArIGZsb2F0KHkpKihoZWlnaHRfc2NhbGUpXCJdOltcIjAuMFwiLFwiMC4wXCIsXCIwLjUgKiAoeTEreTIpICogXCIrcF0sbT1nWzBdLHk9Z1sxXSx4PWdbMl0sYj1oPjE/W1wiXCIrKHMtMSkvKGgtMSksXCIoeDIteDEpICogd2lkdGhfcmF0aW9cIixcIngxKlwiK3YrXCIgKyBmbG9hdCh4KSood2lkdGhfc2NhbGUpXCJdOltcIjAuMFwiLFwiMC4wXCIsXCIwLjUgKiAoeDEreDIpICogXCIrdl0sdz1iWzBdLEM9YlsxXSxFPWJbMl07dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGhlaWdodF9yYXRpbyA9IGZsb2F0KFwiK20rXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IHdpZHRoX3JhdGlvID0gZmxvYXQoXCIrdytcIik7XFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCB5ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IHggPSBjb29yZHNbMl07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIC8vIGdldCBib3ggdmFsc1xcbiAgICAgICAgZmxvYXQgeTEgPSBnZXRCb3hlcyhiLDApO1xcbiAgICAgICAgZmxvYXQgeDEgPSBnZXRCb3hlcyhiLDEpO1xcbiAgICAgICAgZmxvYXQgeTIgPSBnZXRCb3hlcyhiLDIpO1xcbiAgICAgICAgZmxvYXQgeDIgPSBnZXRCb3hlcyhiLDMpO1xcblxcbiAgICAgICAgLy8gZ2V0IGltYWdlIGluIGJhdGNoIGluZGV4XFxuICAgICAgICBpbnQgYkluZCA9IHJvdW5kKGdldEJveEluZChiKSk7XFxuICAgICAgICBpZihiSW5kIDwgMCB8fCBiSW5kID49IFwiK2ErXCIpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmxvYXQgaGVpZ2h0X3NjYWxlID0gXCIreStcIjtcXG4gICAgICAgIGZsb2F0IHdpZHRoX3NjYWxlID0gXCIrQytcIjtcXG5cXG4gICAgICAgIGZsb2F0IGluX3kgPSBcIit4K1wiO1xcbiAgICAgICAgaWYoIGluX3kgPCAwLjAgfHwgaW5feSA+IFwiK3ArXCIgKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIitvK1wiKSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGZsb2F0IGluX3ggPSBcIitFK1wiO1xcbiAgICAgICAgaWYoIGluX3ggPCAwLjAgfHwgaW5feCA+IFwiK3YrXCIgKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIitvK1wiKSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4Q1IgPSB2ZWMyKGluX3gsaW5feSk7XFxuICAgICAgICBpZihcIitmK1wiID09IDEpIHtcXG4gICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZm91ciBpbnRlZ2VyIGluZGljZXMuXFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yQ1IgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhDUik7XFxuICAgICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxDUiA9IGl2ZWMyKGNlaWwoc291cmNlRnJhY0luZGV4Q1IpKTtcXG5cXG4gICAgICAgICAgZmxvYXQgdG9wTGVmdCA9IGdldEltYWdlKGIsIHNvdXJjZUZsb29yQ1IueSwgc291cmNlRmxvb3JDUi54LCBkKTtcXG4gICAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEltYWdlKGIsIHNvdXJjZUNlaWxDUi55LCBzb3VyY2VGbG9vckNSLngsIGQpO1xcbiAgICAgICAgICBmbG9hdCB0b3BSaWdodCA9IGdldEltYWdlKGIsIHNvdXJjZUZsb29yQ1IueSwgc291cmNlQ2VpbENSLngsIGQpO1xcbiAgICAgICAgICBmbG9hdCBib3R0b21SaWdodCA9IGdldEltYWdlKGIsIHNvdXJjZUNlaWxDUi55LCBzb3VyY2VDZWlsQ1IueCwgZCk7XFxuXFxuICAgICAgICAgIHZlYzIgZnJhY0NSID0gc291cmNlRnJhY0luZGV4Q1IgLSB2ZWMyKHNvdXJjZUZsb29yQ1IpO1xcblxcbiAgICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjQ1IueDtcXG4gICAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY0NSLng7XFxuICAgICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gdG9wICsgKGJvdHRvbSAtIHRvcCkgKiBmcmFjQ1IueTtcXG4gICAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGNvb3JkaW5hdG9ycyBvZiBuZWFyZXN0IG5laWdoYm9yIHBvaW50LlxcbiAgICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0Q1IgPSBpdmVjMihmbG9vcihcXG4gICAgICAgICAgICBzb3VyY2VGcmFjSW5kZXhDUiArIHZlYzIoMC41LDAuNSkpKTtcXG4gICAgICAgICAgZmxvYXQgbmV3VmFsdWUgPSBnZXRJbWFnZShiLCBzb3VyY2VOZWFyZXN0Q1IueSwgc291cmNlTmVhcmVzdENSLngsIGQpO1xcbiAgICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCJ9LHFpPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIHI9dC5sZW5ndGgsbz10W3QubGVuZ3RoLTFdLGE9bj9cIjxcIjpcIj5cIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgaW50IGdldEluZGV4KGludCBpKSB7XFxuICAgICAgICBcIisobj9cInJldHVybiBcIitvK1wiIC1pIC0gMTtcIjpcInJldHVybiBpO1wiKStcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIit1aShyKStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBlbmQgPSBcIitLaShyLFwiY29vcmRzXCIpK1wiO1xcbiAgICAgICAgZmxvYXQgdmFsID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IFwiK28rXCIgLSAxOyBpID49IDA7IGkgLT0gMSkge1xcbiAgICAgICAgICBpbnQgaWR4ID0gZ2V0SW5kZXgoaSk7XFxuICAgICAgICAgIGlmIChpZHggXCIrYStcIiBlbmQpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoaWR4ID09IGVuZCAmJiBcIitlK1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgXCIrS2kocixcImNvb3Jkc1wiKStcIiA9IGlkeDtcXG4gICAgICAgICAgdmFsICs9IGdldFgoXCIrZnVuY3Rpb24odCxlKXtpZigxPT09dClyZXR1cm5cIlwiK2U7aWYoMj09PXQpcmV0dXJuIGUrXCIueCwgXCIrZStcIi55XCI7aWYoMz09PXQpcmV0dXJuIGUrXCIueCwgXCIrZStcIi55LCBcIitlK1wiLnpcIjtpZig0PT09dClyZXR1cm4gZStcIi54LCBcIitlK1wiLnksIFwiK2UrXCIueiwgXCIrZStcIi53XCI7dGhyb3cgRXJyb3IoXCJDdW11bGF0aXZlIHN1bSBmb3IgcmFuayBcIit0K1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpfShyLFwiY29vcmRzXCIpK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dCh2YWwpO1xcbiAgICAgIH1cXG4gICAgXCJ9O2Z1bmN0aW9uIEtpKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJcIitlO2lmKDI9PT10KXJldHVybiBlK1wiLnlcIjtpZigzPT09dClyZXR1cm4gZStcIi56XCI7aWYoND09PXQpcmV0dXJuIGUrXCIud1wiO3Rocm93IEVycm9yKFwiQ3VtdWxhdGl2ZSBzdW0gZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX12YXIgamk9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITEsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRQYWNraW5nU2NoZW1lPVZ0LkRFTlNFO3ZhciBlPVl0KHQpLG49WWEoKTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGl2ZWMzIG91dENvb3Jkc0Zyb21GbGF0SW5kZXgoaW50IGluZGV4KSB7XFxuICAgICAgICBcIiskYShbXCJyXCIsXCJjXCIsXCJkXCJdLHQpK1wiXFxuICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IDQgKiAocmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55KTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBmb3IgKGludCBpPTA7IGk8NDsgaSsrKSB7XFxuICAgICAgICAgIGludCBmbGF0SW5kZXggPSBpbmRleCArIGk7XFxuICAgICAgICAgIGl2ZWMzIHJjID0gb3V0Q29vcmRzRnJvbUZsYXRJbmRleChmbGF0SW5kZXgpO1xcbiAgICAgICAgICByZXN1bHRbaV0gPSBnZXRBKHJjLngsIHJjLnksIHJjLnopO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrbi5vdXRwdXQrXCIgPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBcIn0sWGk9ZnVuY3Rpb24odCl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRQYWNraW5nU2NoZW1lPVZ0LkRFTlNFO3ZhciBlPVl0KHQpLG49WWEoKTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGl2ZWMzIG91dENvb3Jkc0Zyb21GbGF0SW5kZXgoaW50IGluZGV4KSB7XFxuICAgICAgICBcIiskYShbXCJyXCIsXCJjXCIsXCJkXCJdLHQpK1wiXFxuICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICB2ZWMyKFwiK2VbMF0rXCIsIFwiK2VbMV0rXCIpKTtcXG4gICAgICAgIGludCBpbmRleCA9IDQgKiAocmVzVGV4UkMueCAqIFwiK2VbMV0rXCIgKyByZXNUZXhSQy55KTtcXG5cXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuXFxuICAgICAgICBmb3IgKGludCBpPTA7IGk8NDsgaSsrKSB7XFxuICAgICAgICAgIGludCBmbGF0SW5kZXggPSBpbmRleCArIGk7XFxuICAgICAgICAgIGl2ZWMzIHJjID0gb3V0Q29vcmRzRnJvbUZsYXRJbmRleChmbGF0SW5kZXgpO1xcbiAgICAgICAgICByZXN1bHRbaV0gPSBnZXRDaGFubmVsKGdldEEocmMueCwgcmMueSwgcmMueiksIHZlYzIocmMueSwgcmMueikpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrbi5vdXRwdXQrXCIgPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBcIn0sWWk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSx0aGlzLm91dHB1dFNoYXBlPVtdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLmJsb2NrU2l6ZT1lLHRoaXMuZGF0YUZvcm1hdD1uLHRoaXMudXNlckNvZGU9XCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgIGludCBoID0gXCIrdGhpcy5nZXRIZWlnaHRDb29yZFN0cmluZygpK1wiO1xcbiAgICAgIGludCB3ID0gXCIrdGhpcy5nZXRXaWR0aENvb3JkU3RyaW5nKCkrXCI7XFxuICAgICAgaW50IGQgPSBcIit0aGlzLmdldERlcHRoQ29vcmRTdHJpbmcoKStcIjtcXG5cXG4gICAgICBpbnQgaW5faCA9IGggLyBcIitlK1wiO1xcbiAgICAgIGludCBvZmZzZXRfaCA9IGltb2QoaCwgXCIrZStcIik7XFxuICAgICAgaW50IGluX3cgPSB3IC8gXCIrZStcIjtcXG4gICAgICBpbnQgb2Zmc2V0X3cgPSBpbW9kKHcsIFwiK2UrXCIpO1xcbiAgICAgIGludCBvZmZzZXRfZCA9IChvZmZzZXRfaCAqIFwiK2UrXCIgKyBvZmZzZXRfdykgKlxcbiAgICAgICAgXCIrdGhpcy5nZXRPdXRwdXREZXB0aFNpemUoKStcIjtcXG4gICAgICBpbnQgaW5fZCA9IGQgKyBvZmZzZXRfZDtcXG5cXG4gICAgICBmbG9hdCByZXN1bHQgPSBcIit0aGlzLmdldElucHV0U2FtcGxpbmdTdHJpbmcoKStcIjtcXG4gICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgfVxcbiAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEhlaWdodENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbMV1cIjpcImNvb3Jkc1syXVwifSx0LnByb3RvdHlwZS5nZXRXaWR0aENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbMl1cIjpcImNvb3Jkc1szXVwifSx0LnByb3RvdHlwZS5nZXREZXB0aENvb3JkU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuXCJOSFdDXCI9PT10aGlzLmRhdGFGb3JtYXQ/XCJjb29yZHNbM11cIjpcImNvb3Jkc1sxXVwifSx0LnByb3RvdHlwZS5nZXRPdXRwdXREZXB0aFNpemU9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD90aGlzLm91dHB1dFNoYXBlWzNdOnRoaXMub3V0cHV0U2hhcGVbMV19LHQucHJvdG90eXBlLmdldElucHV0U2FtcGxpbmdTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIk5IV0NcIj09PXRoaXMuZGF0YUZvcm1hdD9cImdldFgoYiwgaW5faCwgaW5fdywgaW5fZClcIjpcImdldFgoYiwgaW5fZCwgaW5faCwgaW5fdylcIn0sdH0oKSwkaT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiWFwiXSx0aGlzLm91dHB1dFNoYXBlPVt0LHRdLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBmbG9hdCB2YWwgPSBjb29yZHNbMF0gPT0gY29vcmRzWzFdID8gZ2V0WChjb29yZHNbMF0pIDogMC4wO1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICB9XFxuICAgIFwifSxRaT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLm91dFRleFVzYWdlPXp0LkRPV05MT0FEO3ZhciBlPVlhKCk7dGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcIitKYStcIlxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIFwiK2Uub3V0cHV0K1wiID0gZW5jb2RlX2Zsb2F0KHgpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEppPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSExLHRoaXMub3V0VGV4VXNhZ2U9enQuRE9XTkxPQUQ7dmFyIGU9WWEoKTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK0phK1wiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0Q2hhbm5lbChnZXRBQXRPdXRDb29yZHMoKSwgdmVjMihjb29yZHMueSwgY29vcmRzLnopKTtcXG4gICAgICAgIFwiK2Uub3V0cHV0K1wiID0gZW5jb2RlX2Zsb2F0KHgpO1xcbiAgICAgIH1cXG4gICAgXCJ9LFppPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07dmFyIHI9WWEoKSxvPWVbMF0sYT1lWzFdO3RoaXMub3V0cHV0U2hhcGU9dDt2YXIgaT1cInJlc3VsdFwiO24mJihpPVwiZmxvb3IocmVzdWx0ICogMjU1LiArIDAuNSlcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK1FhKHQpK1wiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICBpbnQgZmxhdEluZGV4ID0gZ2V0RmxhdEluZGV4KGNvb3Jkcyk7XFxuICAgICAgICBpbnQgb2Zmc2V0ID0gaW1vZChmbGF0SW5kZXgsIDQpO1xcblxcbiAgICAgICAgZmxhdEluZGV4ID0gaWRpdihmbGF0SW5kZXgsIDQsIDEuKTtcXG4gICAgICAgIFxcbiAgICAgICAgaW50IHIgPSBmbGF0SW5kZXggLyBcIithK1wiO1xcbiAgICAgICAgaW50IGMgPSBpbW9kKGZsYXRJbmRleCwgXCIrYStcIik7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoYywgcikgKyBoYWxmQ1IpIC8gdmVjMihcIithK1wiLjAsIFwiK28rXCIuMCk7XFxuICAgICAgICB2ZWM0IHZhbHVlcyA9IFwiK3IudGV4dHVyZTJEK1wiKEEsIHV2KTtcXG5cXG4gICAgICAgIGZsb2F0IHJlc3VsdDtcXG5cXG4gICAgICAgIGlmKG9mZnNldCA9PSAwKSB7XFxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlc1swXTtcXG4gICAgICAgIH0gZWxzZSBpZihvZmZzZXQgPT0gMSkge1xcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZXNbMV07XFxuICAgICAgICB9IGVsc2UgaWYob2Zmc2V0ID09IDIpIHtcXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzJdO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzNdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrci5vdXRwdXQrXCIgPSB2ZWM0KFwiK2krXCIsIDAuLCAwLiwgMC4pO1xcbiAgICAgIH1cXG4gICAgXCJ9LHRzPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITEsdGhpcy5wYWNrZWRPdXRwdXQ9ITA7dmFyIHI9WWEoKSxvPWVbMF0sYT1lWzFdO3RoaXMub3V0cHV0U2hhcGU9dDt2YXIgaT1cIlwiLHM9XCJyZXN1bHRcIjtuJiYocz1cImZsb29yKHJlc3VsdCAqIDI1NS4gKyAwLjUpXCIpO2Zvcih2YXIgdT0wO3U8PTE7dSsrKWZvcih2YXIgYz0wO2M8PTE7YysrKXt2YXIgbD0yKnUrYztpKz1cIlxcbiAgICAgICAgICBsb2NhbENvb3JkcyA9IGNvb3JkcztcXG4gICAgICAgICAgaWYobG9jYWxDb29yZHNbMl0gKyBcIitjK1wiIDwgXCIrdFsyXStcIikge1xcbiAgICAgICAgICAgIGxvY2FsQ29vcmRzWzJdICs9IFwiK2MrXCI7XFxuICAgICAgICAgICAgaWYobG9jYWxDb29yZHNbMV0gKyBcIit1K1wiIDwgXCIrdFsxXStcIikge1xcbiAgICAgICAgICAgICAgbG9jYWxDb29yZHNbMV0gKz0gXCIrdStcIjtcXG5cXG4gICAgICAgICAgICAgIGZsYXRJbmRleCA9IGdldEZsYXRJbmRleChsb2NhbENvb3Jkcyk7XFxuICAgICAgICAgICAgICBvZmZzZXQgPSBpbW9kKGZsYXRJbmRleCwgNCk7XFxuXFxuICAgICAgICAgICAgICBmbGF0SW5kZXggPSBpZGl2KGZsYXRJbmRleCwgNCwgMS4pO1xcblxcbiAgICAgICAgICAgICAgciA9IGZsYXRJbmRleCAvIFwiK2ErXCI7XFxuICAgICAgICAgICAgICBjID0gaW1vZChmbGF0SW5kZXgsIFwiK2ErXCIpO1xcbiAgICAgICAgICAgICAgdXYgPSAodmVjMihjLCByKSArIGhhbGZDUikgLyB2ZWMyKFwiK2ErXCIuMCwgXCIrbytcIi4wKTtcXG4gICAgICAgICAgICAgIHZhbHVlcyA9IFwiK3IudGV4dHVyZTJEK1wiKEEsIHV2KTtcXG5cXG4gICAgICAgICAgICAgIGlmKG9mZnNldCA9PSAwKSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdFtcIitsK1wiXSA9IHZhbHVlc1swXTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZihvZmZzZXQgPT0gMSkge1xcbiAgICAgICAgICAgICAgICByZXN1bHRbXCIrbCtcIl0gPSB2YWx1ZXNbMV07XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYob2Zmc2V0ID09IDIpIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0W1wiK2wrXCJdID0gdmFsdWVzWzJdO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0W1wiK2wrXCJdID0gdmFsdWVzWzNdO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJ9dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK1FhKHQpK1wiXFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcbiAgICAgICAgaW50IGZsYXRJbmRleCwgciwgYywgb2Zmc2V0O1xcbiAgICAgICAgaXZlYzMgbG9jYWxDb29yZHM7XFxuICAgICAgICB2ZWMyIHV2O1xcbiAgICAgICAgdmVjNCB2YWx1ZXM7XFxuXFxuICAgICAgICBcIitpK1wiXFxuXFxuICAgICAgICBcIityLm91dHB1dCtcIiA9IFwiK3MrXCI7XFxuICAgICAgfVxcbiAgICBcIn0sZXM9XCJyZXR1cm4gcmVhbCAqIGV4cFIgLSBpbWFnICogZXhwSTtcIixucz1cInJldHVybiByZWFsICogZXhwSSArIGltYWcgKiBleHBSO1wiLHJzPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicmVhbFwiLFwiaW1hZ1wiXTt2YXIgcj1lWzFdO3RoaXMub3V0cHV0U2hhcGU9ZTt2YXIgbz1uP1wiMi4wICogXCIrTWF0aC5QSTpcIi0yLjAgKiBcIitNYXRoLlBJLGE9bj9yK1wiLjBcIjpcIjEuMFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBmbG9hdCBleHBvbmVudE11bHRpcGxpZXIgPSBcIitvK1wiO1xcblxcbiAgICAgIGZsb2F0IHVuYXJ5T3BDb21wbGV4KGZsb2F0IHJlYWwsIGZsb2F0IGV4cFIsIGZsb2F0IGltYWcsIGZsb2F0IGV4cEkpIHtcXG4gICAgICAgIFwiK3QrXCJcXG4gICAgICB9XFxuXFxuICAgICAgZmxvYXQgbXVsTWF0REZUKGludCBiYXRjaCwgaW50IGluZGV4KSB7XFxuICAgICAgICBmbG9hdCBpbmRleFJhdGlvID0gZmxvYXQoaW5kZXgpIC8gZmxvYXQoXCIrcitcIik7XFxuICAgICAgICBmbG9hdCBleHBvbmVudE11bHRpcGxpZXJUaW1lc0luZGV4UmF0aW8gPVxcbiAgICAgICAgICAgIGV4cG9uZW50TXVsdGlwbGllciAqIGluZGV4UmF0aW87XFxuXFxuICAgICAgICBmbG9hdCByZXN1bHQgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3IrXCI7IGkrKykge1xcbiAgICAgICAgICAvLyB4ID0gKC0yfDIgKiBQSSAvIE4pICogaW5kZXggKiBpO1xcbiAgICAgICAgICBmbG9hdCB4ID0gZXhwb25lbnRNdWx0aXBsaWVyVGltZXNJbmRleFJhdGlvICogZmxvYXQoaSk7XFxuICAgICAgICAgIGZsb2F0IGV4cFIgPSBjb3MoeCk7XFxuICAgICAgICAgIGZsb2F0IGV4cEkgPSBzaW4oeCk7XFxuICAgICAgICAgIGZsb2F0IHJlYWwgPSBnZXRSZWFsKGJhdGNoLCBpKTtcXG4gICAgICAgICAgZmxvYXQgaW1hZyA9IGdldEltYWcoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICByZXN1bHQgKz1cXG4gICAgICAgICAgICAgIHVuYXJ5T3BDb21wbGV4KHJlYWwsIGV4cFIsIGltYWcsIGV4cEkpIC8gXCIrYStcIjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KG11bE1hdERGVChjb29yZHNbMF0sIGNvb3Jkc1sxXSkpO1xcbiAgICAgIH1cXG4gICAgXCJ9LG9zPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe3RoaXMub3V0cHV0U2hhcGU9W10sdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IHZhbHVlO1xcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIC8vIElucHV0IGNhbiBiZSBvYnRhaW5lZCBmcm9tIHVuaWZvcm0gdmFsdWUuXFxuICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbihuLHIpe251bGw9PWUudmFsdWVMb2MmJihlLnZhbHVlTG9jPW4uZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhyLFwidmFsdWVcIikpLG4uZ2wudW5pZm9ybTFmKGUudmFsdWVMb2MsdCl9fSx0fSgpLGFzPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiLFwiaW5kaWNlc1wiXTt2YXIgcj10LnNsaWNlKCk7cltuXT1lLHRoaXMub3V0cHV0U2hhcGU9cix0aGlzLnJhbms9ci5sZW5ndGg7dmFyIG89dWkodGhpcy5yYW5rKSxhPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5sZW5ndGg7aWYobj40KXRocm93IEVycm9yKFwiR2F0aGVyIGZvciByYW5rIFwiK24rXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYoMT09PW4pcmV0dXJuXCJpbnQoZ2V0SW5kaWNlcyhyZXNSQykpXCI7Zm9yKHZhciByPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIl0sbz1bXSxhPTA7YTx0Lmxlbmd0aDthKyspYT09PWU/by5wdXNoKFwiaW50KGdldEluZGljZXMoXCIrclthXStcIikpXCIpOm8ucHVzaChcIlwiK3JbYV0pO3JldHVybiBvLmpvaW4oKX0odCxuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIrYStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9O3ZhciBpcz1mdW5jdGlvbih0LGUsbil7dGhpcy5zbGljZURpbT10LHRoaXMuc3RyaWRlcz1lLHRoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJpbmRpY2VzXCJdLHRoaXMub3V0cHV0U2hhcGU9bjt2YXIgcj11aShlLmxlbmd0aCksbz11aShuLmxlbmd0aCksYT10aGlzLnNsaWNlRGltPjE/XCJzdHJpZGVzW2pdXCI6XCJzdHJpZGVzXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgXCIrcitcIiBzdHJpZGVzID0gXCIrcitcIihcIit0aGlzLnN0cmlkZXMrXCIpO1xcbiAgICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIrbytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGZsYXR0ZW5JbmRleCA9IDA7XFxuICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgXCIrdGhpcy5zbGljZURpbStcIjsgaisrKSB7XFxuICAgICAgICAgICAgaW50IGluZGV4ID0gcm91bmQoZ2V0SW5kaWNlcyhjb29yZHNbMF0sIGopKTtcXG4gICAgICAgICAgICBmbGF0dGVuSW5kZXggKz0gaW5kZXggKiBcIithK1wiO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChnZXRYKGZsYXR0ZW5JbmRleCwgY29vcmRzWzFdKSk7XFxuICAgICAgICB9XFxuICAgICAgXCJ9O2Z1bmN0aW9uIHNzKHQsZSl7dmFyIG49WWEoKTtyZXR1cm4gb2UodCxlLG4udmVyc2lvbitcIlxcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICAgIFwiK24uYXR0cmlidXRlK1wiIHZlYzMgY2xpcFNwYWNlUG9zO1xcbiAgICBcIituLmF0dHJpYnV0ZStcIiB2ZWMyIHV2O1xcbiAgICBcIituLnZhcnlpbmdWcytcIiB2ZWMyIHJlc3VsdFVWO1xcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBTcGFjZVBvcywgMSk7XFxuICAgICAgcmVzdWx0VVYgPSB1djtcXG4gICAgfVwiKX1mdW5jdGlvbiB1cyh0LGUpe3JldHVybiBmZSh0LGUsbmV3IEZsb2F0MzJBcnJheShbLTEsMSwwLDAsMSwtMSwtMSwwLDAsMCwxLDEsMCwxLDEsMSwtMSwwLDEsMF0pKX1mdW5jdGlvbiBjcyh0LGUpe3JldHVybiBkZSh0LGUsbmV3IFVpbnQxNkFycmF5KFswLDEsMiwyLDEsM10pKX1mdW5jdGlvbiBscyh0LGUsbixyLG8sYSxpKXt2ZShuLHIpO3ZhciBzPXBlKHQsZSksdT10LlRFWFRVUkVfMkQ7cmV0dXJuIEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh1LHMpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhQYXJhbWV0ZXJpKHUsdC5URVhUVVJFX1dSQVBfUyx0LkNMQU1QX1RPX0VER0UpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhQYXJhbWV0ZXJpKHUsdC5URVhUVVJFX1dSQVBfVCx0LkNMQU1QX1RPX0VER0UpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhQYXJhbWV0ZXJpKHUsdC5URVhUVVJFX01JTl9GSUxURVIsdC5ORUFSRVNUKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQudGV4UGFyYW1ldGVyaSh1LHQuVEVYVFVSRV9NQUdfRklMVEVSLHQuTkVBUkVTVCl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnRleEltYWdlMkQodSwwLG8sbixyLDAsYSxpLG51bGwpfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbnVsbCl9KSksc31mdW5jdGlvbiBocyh0LGUsbixyLG8pe3ZhciBhPVh0KG4scik7cmV0dXJuIGxzKHQsZSxhWzBdLGFbMV0sby5pbnRlcm5hbEZvcm1hdEZsb2F0LG8udGV4dHVyZUZvcm1hdEZsb2F0LHQuRkxPQVQpfWZ1bmN0aW9uIGZzKHQsZSxuLHIsbyl7dmFyIGE9WHQobixyKTtyZXR1cm4gbHModCxlLGFbMF0sYVsxXSxvLmludGVybmFsRm9ybWF0SGFsZkZsb2F0LG8udGV4dHVyZUZvcm1hdEZsb2F0LG8udGV4dHVyZVR5cGVIYWxmRmxvYXQpfWZ1bmN0aW9uIGRzKHQsZSxuLHIsbyl7dmFyIGE9WHQobixyKTtyZXR1cm4gbHModCxlLGFbMF0sYVsxXSx0LlJHQkEsdC5SR0JBLHQuVU5TSUdORURfQllURSl9ZnVuY3Rpb24gcHModCxlLG4scixvKXt2YXIgYT0kdChuLHIpO3JldHVybiBscyh0LGUsYVswXSxhWzFdLG8uaW50ZXJuYWxGb3JtYXRQYWNrZWRGbG9hdCx0LlJHQkEsdC5GTE9BVCl9ZnVuY3Rpb24gdnModCxlLG4scixvKXt2YXIgYT0kdChuLHIpO3JldHVybiBscyh0LGUsYVswXSxhWzFdLG8uaW50ZXJuYWxGb3JtYXRQYWNrZWRIYWxmRmxvYXQsdC5SR0JBLG8udGV4dHVyZVR5cGVIYWxmRmxvYXQpfWZ1bmN0aW9uIGdzKHQsZSxuLHIpe3JldHVybiBKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZEJ1ZmZlcih0LkFSUkFZX0JVRkZFUixyKX0pKSxtZSh0LGUsbixcImNsaXBTcGFjZVBvc1wiLHIsMywyMCwwKSYmbWUodCxlLG4sXCJ1dlwiLHIsMiwyMCwxMil9ZnVuY3Rpb24gbXModCxlLG4scixvLGEsaSl7dmFyIHMsdSxjO0p0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kVGV4dHVyZSh0LlRFWFRVUkVfMkQsbil9KSksYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/KHM9bmV3IFVpbnQ4QXJyYXkocipvKjQpLHU9dC5VTlNJR05FRF9CWVRFLGM9dC5SR0JBKToocz1uZXcgRmxvYXQzMkFycmF5KHIqbyo0KSx1PXQuRkxPQVQsYz1pLmludGVybmFsRm9ybWF0UGFja2VkRmxvYXQpLHMuc2V0KGEpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC50ZXhJbWFnZTJEKHQuVEVYVFVSRV8yRCwwLGMscixvLDAsdC5SR0JBLHUscyl9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKX0pKX1mdW5jdGlvbiB5cyh0LGUsbixyKXtKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuYmluZFRleHR1cmUodC5URVhUVVJFXzJELG4pfSkpLHIuZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk/SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsdC5SR0JBLHIud2lkdGgsci5oZWlnaHQsMCx0LlJHQkEsdC5VTlNJR05FRF9CWVRFLHIuZGF0YSl9KSk6SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnRleEltYWdlMkQodC5URVhUVVJFXzJELDAsdC5SR0JBLHQuUkdCQSx0LlVOU0lHTkVEX0JZVEUscil9KSksSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRUZXh0dXJlKHQuVEVYVFVSRV8yRCxudWxsKX0pKX1mdW5jdGlvbiB4cyh0LGUsbixyLG8pe3ZhciBhPXQuY3JlYXRlQnVmZmVyKCk7SnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LmJpbmRCdWZmZXIodC5QSVhFTF9QQUNLX0JVRkZFUixhKX0pKTt2YXIgaT0xNipuKnI7cmV0dXJuIEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5idWZmZXJEYXRhKHQuUElYRUxfUEFDS19CVUZGRVIsaSx0LlNUUkVBTV9SRUFEKX0pKSxKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQucmVhZFBpeGVscygwLDAscixuLHQuUkdCQSx0LkZMT0FULDApfSkpLEp0KHQsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdC5iaW5kQnVmZmVyKHQuUElYRUxfUEFDS19CVUZGRVIsbnVsbCl9KSksYX1mdW5jdGlvbiBicyh0LGUsbil7dmFyIHI9dCxvPW5ldyBGbG9hdDMyQXJyYXkobik7cmV0dXJuIHIuYmluZEJ1ZmZlcihyLlBJWEVMX1BBQ0tfQlVGRkVSLGUpLHIuZ2V0QnVmZmVyU3ViRGF0YShyLlBJWEVMX1BBQ0tfQlVGRkVSLDAsbyksci5iaW5kQnVmZmVyKHIuUElYRUxfUEFDS19CVUZGRVIsbnVsbCksb31mdW5jdGlvbiB3cyh0LGUsbixyLG8pe3ZhciBhPVh0KG4sciksaT1hWzBdLHM9YVsxXSx1PW5ldyBVaW50OEFycmF5KG4qcio0KTtyZXR1cm4gSnQodCxlLChmdW5jdGlvbigpe3JldHVybiB0LnJlYWRQaXhlbHMoMCwwLGkscyxvLmRvd25sb2FkVGV4dHVyZUZvcm1hdCx0LlVOU0lHTkVEX0JZVEUsdSl9KSksbmV3IEZsb2F0MzJBcnJheSh1LmJ1ZmZlcil9ZnVuY3Rpb24gQ3ModCxlLG4scixvLGEsaSxzKXt2YXIgdT10LGM9bmV3IEZsb2F0MzJBcnJheShmdW5jdGlvbih0LGUpe3ZhciBuPSR0KHQsZSk7cmV0dXJuIG5bMF0qblsxXSo0fShhLGkpKTtyZXR1cm4gdS5iaW5kQnVmZmVyKHUuUElYRUxfUEFDS19CVUZGRVIsZSksdS5nZXRCdWZmZXJTdWJEYXRhKHUuUElYRUxfUEFDS19CVUZGRVIsMCxjKSx1LmJpbmRCdWZmZXIodS5QSVhFTF9QQUNLX0JVRkZFUixudWxsKSxjfWZ1bmN0aW9uIEVzKHQsZSxuLHIpe3ZhciBvPW5ldyBGbG9hdDMyQXJyYXkobipyKjQpO3JldHVybiBKdCh0LGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHQucmVhZFBpeGVscygwLDAscixuLHQuUkdCQSx0LkZMT0FULG8pfSkpLG99dmFyIFJzPU9iamVjdC5mcmVlemUoe2NyZWF0ZVZlcnRleFNoYWRlcjpzcyxjcmVhdGVWZXJ0ZXhCdWZmZXI6dXMsY3JlYXRlSW5kZXhCdWZmZXI6Y3MsY3JlYXRlRmxvYXQzMk1hdHJpeFRleHR1cmU6aHMsY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmU6ZnMsY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmU6ZHMsY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZTpwcyxjcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZTp2cyxiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXM6Z3MsdXBsb2FkRGVuc2VNYXRyaXhUb1RleHR1cmU6bXMsdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlOnlzLGNyZWF0ZUJ1ZmZlckZyb21PdXRwdXRUZXh0dXJlOnhzLGRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXI6YnMsZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmU6d3MsZG93bmxvYWRQYWNrZWRNYXRyaXhGcm9tQnVmZmVyOkNzLGRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmU6RXN9KSxJcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5vdXRwdXRUZXh0dXJlPW51bGwsdGhpcy5wcm9ncmFtPW51bGwsdGhpcy5kaXNwb3NlZD0hMSx0aGlzLnZlcnRleEF0dHJzQXJlQm91bmQ9ITEsdGhpcy5pdGVtc1RvUG9sbD1bXTt2YXIgZT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKTtudWxsIT10Pyh0aGlzLmdsPXQsS3QoZSx0KSk6dGhpcy5nbD1qdChlKTt2YXIgbj1cIldFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdFwiO2lmKDE9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl7aWYodGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb249cmUodGhpcy5nbCx0aGlzLmRlYnVnLFwiT0VTX3RleHR1cmVfZmxvYXRcIiksUGUodGhpcy5nbCxcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIikpdGhpcy50ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uPXJlKHRoaXMuZ2wsdGhpcy5kZWJ1ZyxcIk9FU190ZXh0dXJlX2hhbGZfZmxvYXRcIik7ZWxzZSBpZihpKCkuZ2V0KFwiV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTXCIpKXRocm93IG5ldyBFcnJvcihcIkdMIGNvbnRleHQgZG9lcyBub3Qgc3VwcG9ydCBoYWxmIGZsb2F0IHRleHR1cmVzLCB5ZXQgdGhlIGVudmlyb25tZW50IGZsYWcgV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTIGlzIHNldCB0byB0cnVlLlwiKTtpZih0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb249dGhpcy5nbC5nZXRFeHRlbnNpb24obiksUGUodGhpcy5nbCxcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKSl0aGlzLmNvbG9yQnVmZmVySGFsZkZsb2F0RXh0ZW5zaW9uPXJlKHRoaXMuZ2wsdGhpcy5kZWJ1ZyxcIkVYVF9jb2xvcl9idWZmZXJfaGFsZl9mbG9hdFwiKTtlbHNlIGlmKGkoKS5nZXQoXCJXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVNcIikpdGhyb3cgbmV3IEVycm9yKFwiR0wgY29udGV4dCBkb2VzIG5vdCBzdXBwb3J0IGNvbG9yIHJlbmRlcmFibGUgaGFsZiBmbG9hdHMsIHlldCB0aGUgZW52aXJvbm1lbnQgZmxhZyBXRUJHTF9GT1JDRV9GMTZfVEVYVFVSRVMgaXMgc2V0IHRvIHRydWUuXCIpfWVsc2UgaWYobj1cIkVYVF9jb2xvcl9idWZmZXJfZmxvYXRcIixQZSh0aGlzLmdsLG4pKXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbj10aGlzLmdsLmdldEV4dGVuc2lvbihuKTtlbHNle2lmKCFQZSh0aGlzLmdsLFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpKXRocm93IG5ldyBFcnJvcihcIkdMIGNvbnRleHQgZG9lcyBub3Qgc3VwcG9ydCBjb2xvciByZW5kZXJhYmxlIGZsb2F0c1wiKTt0aGlzLmNvbG9yQnVmZmVySGFsZkZsb2F0RXh0ZW5zaW9uPXRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0XCIpfXRoaXMudmVydGV4QnVmZmVyPXVzKHRoaXMuZ2wsdGhpcy5kZWJ1ZyksdGhpcy5pbmRleEJ1ZmZlcj1jcyh0aGlzLmdsLHRoaXMuZGVidWcpLHRoaXMuZnJhbWVidWZmZXI9Z2UodGhpcy5nbCx0aGlzLmRlYnVnKSx0aGlzLnRleHR1cmVDb25maWc9UXQodGhpcy5nbCx0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24pfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJkZWJ1Z1wiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaSgpLmdldEJvb2woXCJERUJVR1wiKX0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZighdGhpcy5kaXNwb3NlZCl7bnVsbCE9dGhpcy5wcm9ncmFtJiZjb25zb2xlLndhcm4oXCJEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBXZWJHTFByb2dyYW0uIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIHByb2dyYW0gd2l0aCBHUEdQVUNvbnRleHQuZGVsZXRlUHJvZ3JhbSBiZWZvcmUgZGlzcG9zaW5nLlwiKSxudWxsIT10aGlzLm91dHB1dFRleHR1cmUmJmNvbnNvbGUud2FybihcIkRpc3Bvc2luZyBhIEdQR1BVQ29udGV4dCB0aGF0IHN0aWxsIGhhcyBhIGJvdW5kIG91dHB1dCBtYXRyaXggdGV4dHVyZS4gIFRoaXMgaXMgcHJvYmFibHkgYSByZXNvdXJjZSBsZWFrLCBkZWxldGUgdGhlIG91dHB1dCBtYXRyaXggdGV4dHVyZSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVNYXRyaXhUZXh0dXJlIGJlZm9yZSBkaXNwb3NpbmcuXCIpO3ZhciBlPXRoaXMuZ2w7SnQoZSx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmZpbmlzaCgpfSkpLEp0KGUsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5iaW5kRnJhbWVidWZmZXIoZS5GUkFNRUJVRkZFUixudWxsKX0pKSxKdChlLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGVsZXRlRnJhbWVidWZmZXIodC5mcmFtZWJ1ZmZlcil9KSksSnQoZSx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmJpbmRCdWZmZXIoZS5BUlJBWV9CVUZGRVIsbnVsbCl9KSksSnQoZSx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiBlLmJpbmRCdWZmZXIoZS5FTEVNRU5UX0FSUkFZX0JVRkZFUixudWxsKX0pKSxKdChlLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZGVsZXRlQnVmZmVyKHQuaW5kZXhCdWZmZXIpfSkpLHRoaXMuZGlzcG9zZWQ9ITB9fSx0LnByb3RvdHlwZS5jcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLGhzKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsdGhpcy50ZXh0dXJlQ29uZmlnKX0sdC5wcm90b3R5cGUuY3JlYXRlRmxvYXQxNk1hdHJpeFRleHR1cmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxmcyh0aGlzLmdsLHRoaXMuZGVidWcsdCxlLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmNyZWF0ZVVuc2lnbmVkQnl0ZXNNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksZHModGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmU9ZnVuY3Rpb24odCxlKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHlzKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUpfSx0LnByb3RvdHlwZS51cGxvYWREZW5zZU1hdHJpeFRvVGV4dHVyZT1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLG1zKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUsbixyLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmNyZWF0ZUZsb2F0MTZQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdnModGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCkscHModGhpcy5nbCx0aGlzLmRlYnVnLHQsZSx0aGlzLnRleHR1cmVDb25maWcpfSx0LnByb3RvdHlwZS5kZWxldGVNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLm91dHB1dFRleHR1cmU9PT10JiYoRWUodGhpcy5nbCx0aGlzLmRlYnVnLHRoaXMuZnJhbWVidWZmZXIpLHRoaXMub3V0cHV0VGV4dHVyZT1udWxsKSxKdCh0aGlzLmdsLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuZ2wuZGVsZXRlVGV4dHVyZSh0KX0pKX0sdC5wcm90b3R5cGUuZG93bmxvYWRCeXRlRW5jb2RlZEZsb2F0TWF0cml4RnJvbU91dHB1dFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodCwoZnVuY3Rpb24oKXtyZXR1cm4gd3Moci5nbCxyLmRlYnVnLGUsbixyLnRleHR1cmVDb25maWcpfSkpfSx0LnByb3RvdHlwZS5kb3dubG9hZFBhY2tlZE1hdHJpeEZyb21CdWZmZXI9ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiBDcyh0aGlzLmdsLHQsMCwwLDAsbyxhLHRoaXMudGV4dHVyZUNvbmZpZyl9LHQucHJvdG90eXBlLmRvd25sb2FkRmxvYXQzMk1hdHJpeEZyb21CdWZmZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gYnModGhpcy5nbCx0LGUpfSx0LnByb3RvdHlwZS5jcmVhdGVCdWZmZXJGcm9tVGV4dHVyZT1mdW5jdGlvbih0LGUsbil7dGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIodCk7dmFyIHI9eHModGhpcy5nbCx0aGlzLmRlYnVnLGUsbix0aGlzLnRleHR1cmVDb25maWcpO3JldHVybiB0aGlzLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKCkscn0sdC5wcm90b3R5cGUuY3JlYXRlQW5kV2FpdEZvckZlbmNlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jcmVhdGVGZW5jZSh0aGlzLmdsKTtyZXR1cm4gdGhpcy5wb2xsRmVuY2UodCl9LHQucHJvdG90eXBlLmNyZWF0ZUZlbmNlPWZ1bmN0aW9uKHQpe3ZhciBlLG4scj10aGlzO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfRkVOQ0VfQVBJX0VOQUJMRURcIikpe3ZhciBvPXQsYT1vLmZlbmNlU3luYyhvLlNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFLDApO3QuZmx1c2goKSxuPWZ1bmN0aW9uKCl7dmFyIHQ9by5jbGllbnRXYWl0U3luYyhhLDAsMCk7cmV0dXJuIHQ9PT1vLkFMUkVBRFlfU0lHTkFMRUR8fHQ9PT1vLkNPTkRJVElPTl9TQVRJU0ZJRUR9LGU9YX1lbHNlIGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT4wPyhlPXRoaXMuYmVnaW5RdWVyeSgpLHRoaXMuZW5kUXVlcnkoKSxuPWZ1bmN0aW9uKCl7cmV0dXJuIHIuaXNRdWVyeUF2YWlsYWJsZShlLGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSl9KTpuPWZ1bmN0aW9uKCl7cmV0dXJuITB9O3JldHVybntxdWVyeTplLGlzRmVuY2VQYXNzZWQ6bn19LHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZFRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXM7cmV0dXJuIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXIodCwoZnVuY3Rpb24oKXtyZXR1cm4gRXMoci5nbCxyLmRlYnVnLGUsbil9KSl9LHQucHJvdG90eXBlLmNyZWF0ZVByb2dyYW09ZnVuY3Rpb24odCl7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgZT10aGlzLmdsLG49YWUoZSx0aGlzLmRlYnVnLHQpLHI9c3MoZSx0aGlzLmRlYnVnKSxvPWNlKGUsdGhpcy5kZWJ1Zyk7cmV0dXJuIEp0KGUsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5hdHRhY2hTaGFkZXIobyxyKX0pKSxKdChlLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIGUuYXR0YWNoU2hhZGVyKG8sbil9KSksbGUoZSx0aGlzLmRlYnVnLG8pLHRoaXMuZGVidWcmJmhlKGUsdGhpcy5kZWJ1ZyxvKSx0aGlzLnZlcnRleEF0dHJzQXJlQm91bmR8fCh0aGlzLnNldFByb2dyYW0obyksdGhpcy52ZXJ0ZXhBdHRyc0FyZUJvdW5kPWdzKGUsdGhpcy5kZWJ1Zyx0aGlzLnByb2dyYW0sdGhpcy52ZXJ0ZXhCdWZmZXIpKSxvfSx0LnByb3RvdHlwZS5kZWxldGVQcm9ncmFtPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0PT09dGhpcy5wcm9ncmFtJiYodGhpcy5wcm9ncmFtPW51bGwpLG51bGwhPXQmJkp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5nbC5kZWxldGVQcm9ncmFtKHQpfSkpfSx0LnByb3RvdHlwZS5zZXRQcm9ncmFtPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSx0aGlzLnByb2dyYW09dCxudWxsIT10aGlzLnByb2dyYW0mJnRoaXMuZGVidWcmJmhlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLnByb2dyYW0pLEp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gZS5nbC51c2VQcm9ncmFtKHQpfSkpfSx0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb249ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0hMCksdGhpcy50aHJvd0lmRGlzcG9zZWQoKSxuP3hlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0LGUpOmJlKHRoaXMuZ2wsdCxlKX0sdC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTG9jYXRpb249ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiB0aGlzLnRocm93SWZEaXNwb3NlZCgpLEp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gbi5nbC5nZXRBdHRyaWJMb2NhdGlvbih0LGUpfSkpfSx0LnByb3RvdHlwZS5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCksdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odCxlKX0sdC5wcm90b3R5cGUuc2V0SW5wdXRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpLHdlKHRoaXMuZ2wsdGhpcy5kZWJ1Zyx0aGlzLnByb2dyYW0sdCxlLG4pfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIodCxuLGUpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpO3ZhciByPSR0KGUsbiksbz1yWzBdLGE9clsxXTt0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIodCxvLGEpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbj1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyKG4sdCxyLGUpfSx0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbj1mdW5jdGlvbih0LGUsbixyKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiBub3QgaW1wbGVtZW50ZWQuXCIpfSx0LnByb3RvdHlwZS5kZWJ1Z1ZhbGlkYXRlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5wcm9ncmFtJiZoZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5wcm9ncmFtKSxSZSh0aGlzLmdsKX0sdC5wcm90b3R5cGUuZXhlY3V0ZVByb2dyYW09ZnVuY3Rpb24oKXt0aGlzLnRocm93SWZEaXNwb3NlZCgpLHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO3ZhciB0PXRoaXMuZ2w7dGhpcy5kZWJ1ZyYmdGhpcy5kZWJ1Z1ZhbGlkYXRlKCksSnQodCx0aGlzLmRlYnVnLChmdW5jdGlvbigpe3JldHVybiB0LmRyYXdFbGVtZW50cyh0LlRSSUFOR0xFUyw2LHQuVU5TSUdORURfU0hPUlQsMCl9KSl9LHQucHJvdG90eXBlLmJsb2NrVW50aWxBbGxQcm9ncmFtc0NvbXBsZXRlZD1mdW5jdGlvbigpe3ZhciB0PXRoaXM7dGhpcy50aHJvd0lmRGlzcG9zZWQoKSxKdCh0aGlzLmdsLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZ2wuZmluaXNoKCl9KSl9LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09dGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb24mJih0aGlzLmRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbj1yZSh0aGlzLmdsLHRoaXMuZGVidWcsMj09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKT9cIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDJcIjpcIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeVwiKSksdGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb259LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCl9LHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCl9LHQucHJvdG90eXBlLmJlZ2luUXVlcnk9ZnVuY3Rpb24oKXtpZigyPT09aSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKXt2YXIgdD10aGlzLmdsLGU9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyKCksbj10LmNyZWF0ZVF1ZXJ5KCk7cmV0dXJuIHQuYmVnaW5RdWVyeShlLlRJTUVfRUxBUFNFRF9FWFQsbiksbn12YXIgcj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKSxvPXIuY3JlYXRlUXVlcnlFWFQoKTtyZXR1cm4gci5iZWdpblF1ZXJ5RVhUKHIuVElNRV9FTEFQU0VEX0VYVCxvKSxvfSx0LnByb3RvdHlwZS5lbmRRdWVyeT1mdW5jdGlvbigpe2lmKDIhPT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT05cIikpe3ZhciB0PXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO3QuZW5kUXVlcnlFWFQodC5USU1FX0VMQVBTRURfRVhUKX1lbHNle3ZhciBlPXRoaXMuZ2wsbj10aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKTtlLmVuZFF1ZXJ5KG4uVElNRV9FTEFQU0VEX0VYVCl9fSx0LnByb3RvdHlwZS53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsRigoZnVuY3Rpb24oKXtyZXR1cm4gZS5kaXNwb3NlZHx8ZS5pc1F1ZXJ5QXZhaWxhYmxlKHQsaSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OXCIpKX0pKV07Y2FzZSAxOnJldHVybiBuLnNlbnQoKSxbMix0aGlzLmdldFF1ZXJ5VGltZSh0LGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTlwiKSldfX0pKX0pKX0sdC5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lPWZ1bmN0aW9uKHQsZSl7aWYoMD09PWUpcmV0dXJuIG51bGw7aWYoMj09PWUpe3ZhciBuPXRoaXMuZ2w7cmV0dXJuIG4uZ2V0UXVlcnlQYXJhbWV0ZXIodCxuLlFVRVJZX1JFU1VMVCkvMWU2fXZhciByPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO3JldHVybiByLmdldFF1ZXJ5T2JqZWN0RVhUKHQsci5RVUVSWV9SRVNVTFRfRVhUKS8xZTZ9LHQucHJvdG90eXBlLmlzUXVlcnlBdmFpbGFibGU9ZnVuY3Rpb24odCxlKXtpZigwPT09ZSlyZXR1cm4hMDtpZigyPT09ZSl7dmFyIG49dGhpcy5nbCxyPXRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpLG89bi5nZXRRdWVyeVBhcmFtZXRlcih0LG4uUVVFUllfUkVTVUxUX0FWQUlMQUJMRSk7cmV0dXJuIG51bGw9PXRoaXMuZGlzam9pbnQmJih0aGlzLmRpc2pvaW50PXRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHIuR1BVX0RJU0pPSU5UX0VYVCkpLG8mJiF0aGlzLmRpc2pvaW50fW89KHI9dGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCkpLmdldFF1ZXJ5T2JqZWN0RVhUKHQsci5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFX0VYVCk7cmV0dXJuIG51bGw9PXRoaXMuZGlzam9pbnQmJih0aGlzLmRpc2pvaW50PXRoaXMuZ2wuZ2V0UGFyYW1ldGVyKHIuR1BVX0RJU0pPSU5UX0VYVCkpLG8mJiF0aGlzLmRpc2pvaW50fSx0LnByb3RvdHlwZS5wb2xsRmVuY2U9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKG4pe2UuYWRkSXRlbVRvUG9sbCgoZnVuY3Rpb24oKXtyZXR1cm4gdC5pc0ZlbmNlUGFzc2VkKCl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gbigpfSkpfSkpfSx0LnByb3RvdHlwZS5wb2xsSXRlbXM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDsrK2Upe2lmKCF0W2VdKCkpYnJlYWt9cmV0dXJuIGUtMX0odGhpcy5pdGVtc1RvUG9sbC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlzRG9uZUZufSkpKSxlPTA7ZTw9dDsrK2UpeygwLHRoaXMuaXRlbXNUb1BvbGxbZV0ucmVzb2x2ZUZuKSgpfXRoaXMuaXRlbXNUb1BvbGw9dGhpcy5pdGVtc1RvUG9sbC5zbGljZSh0KzEpfSx0LnByb3RvdHlwZS5hZGRJdGVtVG9Qb2xsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpczt0aGlzLml0ZW1zVG9Qb2xsLnB1c2goe2lzRG9uZUZuOnQscmVzb2x2ZUZuOmV9KSx0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aD4xfHxGKChmdW5jdGlvbigpe3JldHVybiBuLnBvbGxJdGVtcygpLDA9PT1uLml0ZW1zVG9Qb2xsLmxlbmd0aH0pKX0sdC5wcm90b3R5cGUuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyPWZ1bmN0aW9uKHQpe3RoaXMudGhyb3dJZkRpc3Bvc2VkKCksQ2UodGhpcy5nbCx0aGlzLmRlYnVnLHQsdGhpcy5mcmFtZWJ1ZmZlciksdGhpcy5kZWJ1ZyYmUmUodGhpcy5nbCl9LHQucHJvdG90eXBlLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5vdXRwdXRUZXh0dXJlPyhDZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5vdXRwdXRUZXh0dXJlLHRoaXMuZnJhbWVidWZmZXIpLHRoaXMuZGVidWcmJlJlKHRoaXMuZ2wpKTpFZSh0aGlzLmdsLHRoaXMuZGVidWcsdGhpcy5mcmFtZWJ1ZmZlcil9LHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyPWZ1bmN0aW9uKHQsZSl7dGhpcy5iaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIodCk7dmFyIG49ZSgpO3JldHVybiB0aGlzLnVuYmluZFRleHR1cmVUb0ZyYW1lQnVmZmVyKCksbn0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZURyaXZlcj1mdW5jdGlvbih0LGUsbil7dGhpcy50aHJvd0lmRGlzcG9zZWQoKTt2YXIgcj10aGlzLmdsO0NlKHIsdGhpcy5kZWJ1Zyx0LHRoaXMuZnJhbWVidWZmZXIpLHRoaXMuZGVidWcmJlJlKHIpLHRoaXMub3V0cHV0VGV4dHVyZT10LEp0KHIsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gci52aWV3cG9ydCgwLDAsZSxuKX0pKSxKdChyLHRoaXMuZGVidWcsKGZ1bmN0aW9uKCl7cmV0dXJuIHIuc2Npc3NvcigwLDAsZSxuKX0pKX0sdC5wcm90b3R5cGUuc2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXI9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89dGhpczt0aGlzLnRocm93SWZEaXNwb3NlZCgpLEp0KHRoaXMuZ2wsdGhpcy5kZWJ1ZywoZnVuY3Rpb24oKXtyZXR1cm4gby5nbC5zY2lzc29yKHQsZSxuLHIpfSkpfSx0LnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQ9ZnVuY3Rpb24oKXtpZih0aGlzLmRpc3Bvc2VkKXRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byB1c2UgZGlzcG9zZWQgR1BHUFVDb250ZXh0LlwiKX0sdC5wcm90b3R5cGUudGhyb3dJZk5vUHJvZ3JhbT1mdW5jdGlvbigpe2lmKG51bGw9PXRoaXMucHJvZ3JhbSl0aHJvdyBuZXcgRXJyb3IoXCJObyBHUFUgcHJvZ3JhbSBpcyBjdXJyZW50bHkgc2V0LlwiKX0sdH0oKTtmdW5jdGlvbiBrcyh0LGUpe2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggXCIrdC5sZW5ndGgrXCIgaW5wdXRzLCBidXQgd2FzIGV4ZWN1dGVkIHdpdGggXCIrZS5sZW5ndGgrXCIgaW5wdXRzXCIpO3QuZm9yRWFjaCgoZnVuY3Rpb24odCxuKXt2YXIgcj10LmxvZ2ljYWxTaGFwZSxvPWVbbl0sYT1vLnNoYXBlO2lmKCFTKHIsYSkpdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHNoYXBlcyB0aGFuIHRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlcyBcIityK1wiIGFuZCBcIithK1wiIG11c3QgbWF0Y2hcIik7aWYoIXQuaXNVbmlmb3JtfHwhby5pc1VuaWZvcm0pe3ZhciBpPXQudGV4U2hhcGUscz1vLmlzVW5pZm9ybT9udWxsOm8udGV4RGF0YS50ZXhTaGFwZTtpZighUyhpLHMpKXRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIGRpZmZlcmVudCB0ZXh0dXJlIHNoYXBlcyB0aGFuIHRoZSBjdXJyZW50IGFyZ3MuIFNoYXBlIFwiK2krXCIgYW5kIFwiK3MrXCIgbXVzdCBtYXRjaFwiKX19KSl9dmFyIFNzPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPXQ7Zm9yKHZhciByPW4uZmlsdGVyV2lkdGgsbz1uLmluQ2hhbm5lbHMsYT1uLnN0cmlkZVdpZHRoLGk9bi5zdHJpZGVIZWlnaHQscz1uLnBhZEluZm8sdT1uLm91dFdpZHRoLGM9bi5kaWxhdGlvbldpZHRoLGw9bi5kaWxhdGlvbkhlaWdodCxoPW4uZGF0YUZvcm1hdCxmPXMubGVmdCxkPXMudG9wLHA9bypyLHY9WWEoKSxnPVwiY2hhbm5lbHNMYXN0XCI9PT1oLG09Zz8wOjEseT1nPzE6Mix4PVwiXCIsYj0wO2I8PTE7YisrKWZvcih2YXIgdz0wO3c8PTE7dysrKXgrPVwiXFxuICAgICAgICAgIGJsb2NrSW5kZXggPSByYy55ICsgXCIrdytcIjtcXG4gICAgICAgICAgcG9zID0gcmMueCArIFwiK2IrXCI7XFxuXFxuICAgICAgICAgIGlmKGJsb2NrSW5kZXggPCBcIit0WzFdK1wiICYmIHBvcyA8IFwiK3RbMF0rXCIpIHtcXG4gICAgICAgICAgICBvZmZzZXRZID0gaW50KGJsb2NrSW5kZXggLyAoXCIrdStcIikpICogXCIraStcIiAtIFwiK2QrXCI7XFxuICAgICAgICAgICAgZDAgPSBvZmZzZXRZICsgXCIrbCtcIiAqIChwb3MgLyBcIitwK1wiKTtcXG5cXG4gICAgICAgICAgICBpZihkMCA8IFwiK2VbbV0rXCIgJiYgZDAgPj0gMCkge1xcblxcbiAgICAgICAgICAgICAgb2Zmc2V0WCA9IGludChtb2QoZmxvYXQoYmxvY2tJbmRleCksIFwiK3UrXCIuKSAqIFwiK2ErXCIuIC0gXCIrZitcIi4pO1xcbiAgICAgICAgICAgICAgZDEgPSBvZmZzZXRYICsgXCIrYytcIiAqIChpbnQobW9kKGZsb2F0KHBvcyksIFwiK3ArXCIuKSAvIFwiK28rXCIuKSk7XFxuXFxuICAgICAgICAgICAgICBpZihkMSA8IFwiK2VbeV0rXCIgJiYgZDEgPj0gMCkge1xcblxcbiAgICAgICAgICAgICAgICBjaCA9IGludChtb2QoZmxvYXQocG9zKSwgXCIrbytcIi4pKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKFwiK2crXCIpIHtcXG4gICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQxLCBjaCk7XFxuICAgICAgICAgICAgICAgICAgcmVzdWx0W1wiKygyKmIrdykrXCJdID0gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgICAgICAgIGdldEEoZDAsIGludChpbm5lckRpbXMueCksXFxuICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQwLCBkMSk7XFxuICAgICAgICAgICAgICAgICAgcmVzdWx0W1wiKygyKmIrdykrXCJdID0gZ2V0Q2hhbm5lbChcXG4gICAgICAgICAgICAgICAgICAgIGdldEEoY2gsIGludChpbm5lckRpbXMueCksXFxuICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMCk7XFxuXFxuICAgICAgICBpbnQgYmxvY2tJbmRleCwgcG9zLCBvZmZzZXRZLCBkMCwgb2Zmc2V0WCwgZDEsIGNoO1xcbiAgICAgICAgdmVjMiBpbm5lckRpbXM7XFxuXFxuICAgICAgICBcIit4K1wiXFxuXFxuICAgICAgICBcIit2Lm91dHB1dCtcIiA9IHJlc3VsdDtcXG4gICAgICB9XFxuICAgIFwifSxBcz1mdW5jdGlvbih0LGUsbixyLG8pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIGEsaT1lLHM9dFszXS0xO3RoaXMub3V0cHV0U2hhcGU9dDt2YXIgdT1cImZsb2F0KFwiK24rXCIpICsgZmxvYXQoXCIrcitcIikgKiBzdW1cIjthPS41PT09bz9cImludmVyc2VzcXJ0KFwiK3UrXCIpXCI6MT09PW8/XCIxLjAvKFwiK3UrXCIpXCI6XCJleHAobG9nKFwiK3UrXCIpICogZmxvYXQoLVwiK28rXCIpKTtcIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYKGIsIHIsIGMsIGQpO1xcbiAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgaiA9IC1cIitpK1wiOyBqIDw9IFwiK2krXCI7IGorKykge1xcbiAgICAgICAgICBpbnQgaWR4ID0gZCArIGo7XFxuICAgICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPD0gIFwiK3MrXCIpIHtcXG4gICAgICAgICAgICBmbG9hdCB6ID0gZ2V0WChiLCByLCBjLCBpZHgpO1xcbiAgICAgICAgICAgIHN1bSArPSB6ICogejtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgZmxvYXQgdmFsID0geCAqIFwiK2ErXCI7XFxuICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICB9XFxuICAgIFwifSxUcz1mdW5jdGlvbih0LGUsbixyLG8pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJpbnB1dEltYWdlXCIsXCJvdXRwdXRJbWFnZVwiLFwiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy5kZXB0aD10WzNdLHRoaXMuZGVwdGhSYWRpdXM9ZSx0aGlzLmJpYXM9bix0aGlzLmFscGhhPXIsdGhpcy5iZXRhPW8sdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgZCA9IDA7IGQgPCBcIit0aGlzLmRlcHRoK1wiOyArK2QpIHtcXG4gICAgICAgICAgaW50IGRlcHRoQmVnaW4gPSBpbnQobWF4KDAuMCwgZmxvYXQoZCAtIFwiK2UrXCIpKSk7XFxuICAgICAgICAgIGludCBkZXB0aEVuZCA9IGludChtaW4oZmxvYXQoXCIrdGhpcy5kZXB0aCtcIiksXFxuICAgICAgICAgICAgICBmbG9hdChkICsgXCIrZStcIiArIDEpKSk7XFxuXFxuICAgICAgICAgIGNvbnN0IGludCBNSU5fREVQVEhfQkVHSU4gPSAwO1xcbiAgICAgICAgICBjb25zdCBpbnQgTUFYX0RFUFRIX0VORCA9IFwiK3RoaXMuZGVwdGgrXCI7XFxuXFxuICAgICAgICAgIGZsb2F0IG5vcm0gPSAwLjA7XFxuICAgICAgICAgIGZvciAoaW50IGsgPSBNSU5fREVQVEhfQkVHSU47IGsgPCBNQVhfREVQVEhfRU5EOyArK2spIHtcXG4gICAgICAgICAgICBpZiAoayA8IGRlcHRoQmVnaW4pe1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPj0gZGVwdGhCZWdpbiAmJiBrIDwgZGVwdGhFbmQpIHtcXG4gICAgICAgICAgICAgIG5vcm0gKz0gZ2V0SW5wdXRJbWFnZShiLCByLCBjLCBrKSAqIGdldElucHV0SW1hZ2UoYiwgciwgYywgayk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG5vcm0gPSBmbG9hdChcIityK1wiKSAqIG5vcm0gKyBmbG9hdChcIituK1wiKTtcXG5cXG4gICAgICAgICAgZm9yKGludCBrID0gTUlOX0RFUFRIX0JFR0lOOyBrIDwgTUFYX0RFUFRIX0VORDsgKytrKXtcXG4gICAgICAgICAgICBpZiAoayA8IGRlcHRoQmVnaW4pe1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPj0gZGVwdGhCZWdpbiAmJiBrIDwgZGVwdGhFbmQpe1xcbiAgICAgICAgICAgICAgZmxvYXQgZHlpID0gLTIuMCAqIGZsb2F0KFwiK3IrXCIpXFxuICAgICAgICAgICAgICAgICogZmxvYXQoXCIrbytcIilcXG4gICAgICAgICAgICAgICAgKiBnZXRJbnB1dEltYWdlKGIgLHIgLGMsIGspICogZ2V0T3V0cHV0SW1hZ2UoYiwgciwgYywgZClcXG4gICAgICAgICAgICAgICAgLyBub3JtO1xcbiAgICAgICAgICAgICAgaWYgKGsgPT0gZCkge1xcbiAgICAgICAgICAgICAgICBkeWkgKz0gcG93KG5vcm0sIC0xLjAgKiBcIitvK1wiKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGlmIChrID09IGNvb3Jkc1szXSkge1xcbiAgICAgICAgICAgICAgICBkeWkgKj0gZ2V0RHkoYiwgciwgYywgZCk7XFxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBkeWk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9LERzPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMDt2YXIgYSxpPWUscz10WzNdLTE7dGhpcy5vdXRwdXRTaGFwZT10O3ZhciB1PVwiZmxvYXQoXCIrbitcIikgKyBmbG9hdChcIityK1wiKSAqIHN1bVwiO2E9LjU9PT1vP1wiaW52ZXJzZXNxcnQoXCIrdStcIilcIjoxPT09bz9cIjEuMC8oXCIrdStcIilcIjpcImV4cChsb2coXCIrdStcIikgKiBmbG9hdCgtXCIrbytcIikpO1wiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzLng7XFxuICAgICAgICBpbnQgciA9IGNvb3Jkcy55O1xcbiAgICAgICAgaW50IGMgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkID0gY29vcmRzLnc7XFxuXFxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBkIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVszXStcIjtcXG4gICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IGMgPCBcIit0aGlzLm91dHB1dFNoYXBlWzJdK1wiO1xcblxcbiAgICAgICAgdmVjNCBzdW0gPSB2ZWM0KDAuKTtcXG4gICAgICAgIHZlYzQgeEZyYWdBdE91dHB1dENvb3JkcyA9IGdldFgoYiwgciwgYywgZCk7XFxuXFxuICAgICAgICB2ZWM0IHhBdE91dHB1dENvb3JkcyA9IHZlYzQoXFxuICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcywgdmVjMihjLCBkKSksXFxuICAgICAgICAgIGhhc05leHRDb2wgP1xcbiAgICAgICAgICAgIGdldENoYW5uZWwoeEZyYWdBdE91dHB1dENvb3JkcywgdmVjMihjLCBkICsgMSkpIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID9cXG4gICAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMgLCB2ZWMyKGMgKyAxLCBkKSkgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRDaGFubmVsKHhGcmFnQXRPdXRwdXRDb29yZHMsIHZlYzIoYyArIDEsIGQgKyAxKSkgOiAwLjBcXG4gICAgICAgICk7XFxuXFxuICAgICAgICBpbnQgZmlyc3RDaGFubmVsID0gZCAtIFwiK2krXCI7XFxuICAgICAgICB2ZWMyIGNhY2hlID0gdmVjMigwLik7XFxuICAgICAgICBpZihmaXJzdENoYW5uZWwgPj0gMCl7XFxuICAgICAgICAgIHZlYzQgZmlyc3RDaGFubmVsRnJhZyA9IGdldFgoYiwgciwgYywgZmlyc3RDaGFubmVsKTtcXG4gICAgICAgICAgY2FjaGUueCA9IGdldENoYW5uZWwoZmlyc3RDaGFubmVsRnJhZywgdmVjMihjLCBmaXJzdENoYW5uZWwpKTtcXG4gICAgICAgICAgICBpZihoYXNOZXh0Um93KXtcXG4gICAgICAgICAgICAgIGNhY2hlLnkgPSBnZXRDaGFubmVsKGZpcnN0Q2hhbm5lbEZyYWcsIHZlYzIoYyArIDEsIGZpcnN0Q2hhbm5lbCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGl2ZWMyIGRlcHRoID0gaXZlYzIoZCwgZCArIDEpO1xcbiAgICAgICAgZm9yIChpbnQgaiA9IC0gXCIraStcIjsgaiA8PSBcIitpK1wiOyBqKyspIHtcXG4gICAgICAgICAgaXZlYzIgaWR4ID0gZGVwdGggKyBqO1xcbiAgICAgICAgICBidmVjMiBhYm92ZUxvd2VyQm91bmQgPSBncmVhdGVyVGhhbkVxdWFsKGlkeCwgaXZlYzIoMCkpO1xcbiAgICAgICAgICBidmVjMiBiZWxvd1VwcGVyQm91bmQgPSBsZXNzVGhhbkVxdWFsKGlkeCwgaXZlYzIoXCIrcytcIikpO1xcblxcbiAgICAgICAgICBib29sIGRlcHRoSW5SYW5nZSA9IGFib3ZlTG93ZXJCb3VuZC54ICYmIGJlbG93VXBwZXJCb3VuZC54O1xcbiAgICAgICAgICBib29sIGRlcHRoUGx1c09uZUluUmFuZ2UgPSBhYm92ZUxvd2VyQm91bmQueSAmJiBiZWxvd1VwcGVyQm91bmQueTtcXG5cXG4gICAgICAgICAgaWYoZGVwdGhJblJhbmdlIHx8IGRlcHRoUGx1c09uZUluUmFuZ2Upe1xcbiAgICAgICAgICAgIHZlYzQgeiA9IHZlYzQoMC4pO1xcbiAgICAgICAgICAgIHZlYzQgeEZyYWdBdEN1cnJlbnREZXB0aDtcXG4gICAgICAgICAgICB6Lnh6ID0gY2FjaGUueHk7XFxuICAgICAgICAgICAgaWYoZGVwdGhQbHVzT25lSW5SYW5nZSAmJiBoYXNOZXh0Q29sKXtcXG4gICAgICAgICAgICAgIHhGcmFnQXRDdXJyZW50RGVwdGggPSBpZHgueSAhPSBkID9cXG4gICAgICAgICAgICAgICAgZ2V0WChiLCByLCBjLCBpZHgueSkgOiB4RnJhZ0F0T3V0cHV0Q29vcmRzO1xcbiAgICAgICAgICAgICAgei55ID0gZ2V0Q2hhbm5lbCh4RnJhZ0F0Q3VycmVudERlcHRoLCB2ZWMyKGMsIGlkeC55KSk7XFxuICAgICAgICAgICAgICBpZihoYXNOZXh0Um93KXtcXG4gICAgICAgICAgICAgICAgei53ID0gZ2V0Q2hhbm5lbCh4RnJhZ0F0Q3VycmVudERlcHRoLCB2ZWMyKGMgKyAxLCBpZHgueSkpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBjYWNoZS54eSA9IHoueXc7XFxuICAgICAgICAgICAgc3VtICs9IHogKiB6O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHhBdE91dHB1dENvb3JkcyAqIFwiK2ErXCI7XFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxOcz1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIixcIm1heFBvc1wiXSx0aGlzLm91dHB1dFNoYXBlPXQuaW5TaGFwZTt2YXIgZT10LnN0cmlkZUhlaWdodCxuPXQuc3RyaWRlV2lkdGgscj10LmRpbGF0aW9uSGVpZ2h0LG89dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsYT10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGk9by0xLXQucGFkSW5mby50b3Ascz1hLTEtdC5wYWRJbmZvLmxlZnQsdT1vKmEtMTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2krXCIsIFwiK3MrXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5UkNDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5UkNDb3JuZXIueDtcXG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeVJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkKSB3aXRoIHBvcyBtYXNrKDosIDosIGQpIHRvIGdldCBkeCh4UiwgeEMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK28rXCI7XFxuICAgICAgICAgIHdSICs9IFwiK3IrXCIpIHtcXG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gXCIrZStcIi4wO1xcblxcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSBcIit0Lm91dEhlaWdodCtcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrYStcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiK24rXCIuMDtcXG5cXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSBcIit0Lm91dFdpZHRoK1wiLjAgfHxcXG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIGlkeVIsIGlkeUMsIGQpO1xcbiAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9IFwiK3UrXCIgLSBpbnQoZ2V0TWF4UG9zKGIsIGlkeVIsIGlkeUMsIGQpKTtcXG5cXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXFxuICAgICAgICAgICAgLy8gcG9zaXRpb24gbWF0cml4LlxcbiAgICAgICAgICAgIGludCBjdXJQb3NWYWx1ZSA9IHdSICogXCIrYStcIiArIHdDO1xcbiAgICAgICAgICAgIGZsb2F0IG1hc2sgPSBmbG9hdChtYXhQb3NWYWx1ZSA9PSBjdXJQb3NWYWx1ZSA/IDEuMCA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogbWFzaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEZzPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJkeVwiLFwibWF4UG9zXCJdLHRoaXMub3V0cHV0U2hhcGU9dC5pblNoYXBlO3ZhciBlPXQuc3RyaWRlRGVwdGgsbj10LnN0cmlkZUhlaWdodCxyPXQuc3RyaWRlV2lkdGgsbz10LmRpbGF0aW9uRGVwdGgsYT10LmRpbGF0aW9uSGVpZ2h0LGk9dC5kaWxhdGlvbldpZHRoLHM9dC5lZmZlY3RpdmVGaWx0ZXJEZXB0aCx1PXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGM9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxsPXMtMS10LnBhZEluZm8uZnJvbnQsaD11LTEtdC5wYWRJbmZvLnRvcCxmPWMtMS10LnBhZEluZm8ubGVmdCxkPXMqdSpjLTE7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMyhcIitsK1wiLCBcIitoK1wiLCBcIitmK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IGNoID0gY29vcmRzLnU7XFxuXFxuICAgICAgICBpdmVjMyBkeUNvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpIC0gcGFkcztcXG4gICAgICAgIGludCBkeURDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLnk7XFxuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIuejtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sID8sIGNoKSB3aXRoIHBvcyBtYXNrKDosIDosIDosIGQpIHRvIGdldFxcbiAgICAgICAgLy8gZHgoeEQsIHhSLCB4QywgY2gpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd0QgPSAwOyB3RCA8IFwiK3MrXCI7XFxuICAgICAgICAgICB3RCArPSBcIitvK1wiKSB7XFxuICAgICAgICAgIGZsb2F0IGR5RCA9IGZsb2F0KGR5RENvcm5lciArIHdEKSAvIFwiK2UrXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5RCA8IDAuMCB8fCBkeUQgPj0gXCIrdC5vdXREZXB0aCtcIi4wIHx8IGZyYWN0KGR5RCkgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5RCA9IGludChkeUQpO1xcblxcbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrdStcIjtcXG4gICAgICAgICAgICAgIHdSICs9IFwiK2ErXCIpIHtcXG4gICAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIituK1wiLjA7XFxuXFxuICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIrdC5vdXRIZWlnaHQrXCIuMCB8fFxcbiAgICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIrYytcIjtcXG4gICAgICAgICAgICAgICAgd0MgKz0gXCIraStcIikge1xcbiAgICAgICAgICAgICAgZmxvYXQgZHlDID0gZmxvYXQoZHlDQ29ybmVyICsgd0MpIC8gXCIrcitcIi4wO1xcblxcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gXCIrdC5vdXRXaWR0aCtcIi4wIHx8XFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XFxuXFxuICAgICAgICAgICAgICBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeUQsIGlkeVIsIGlkeUMsIGNoKTtcXG4gICAgICAgICAgICAgIGludCBtYXhQb3NWYWx1ZSA9IFwiK2QrXCIgLVxcbiAgICAgICAgICAgICAgICAgIGludChnZXRNYXhQb3MoYmF0Y2gsIGlkeUQsIGlkeVIsIGlkeUMsIGNoKSk7XFxuXFxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUsIGNoZWNrIGl0IGFnYWluc3QgdGhlIHZhbHVlIGZyb20gdGhlXFxuICAgICAgICAgICAgICAvLyBwb3NpdGlvbiBtYXRyaXguXFxuICAgICAgICAgICAgICBpbnQgY3VyUG9zVmFsdWUgPVxcbiAgICAgICAgICAgICAgICAgIHdEICogXCIrdStcIiAqIFwiK2MrXCIgK1xcbiAgICAgICAgICAgICAgICAgIHdSICogXCIrYytcIiArIHdDO1xcbiAgICAgICAgICAgICAgZmxvYXQgbWFzayA9IGZsb2F0KG1heFBvc1ZhbHVlID09IGN1clBvc1ZhbHVlID8gMS4wIDogMC4wKTtcXG5cXG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gZHlWYWx1ZSAqIG1hc2s7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIn0sX3M9ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1vJiYobz0hMSksdm9pZCAwPT09YSYmKGE9bnVsbCksdm9pZCAwPT09aSYmKGk9ITEpLHRoaXMudmFyaWFibGVOYW1lcz1bXCJtYXRyaXhBXCIsXCJtYXRyaXhCXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9ZTt2YXIgcz1uP3RbMV06dFsyXSx1PU1hdGguY2VpbChzLzIpLGM9bj9cImkgKiAyLCByYy55XCI6XCJyYy55LCBpICogMlwiLGw9cj9cInJjLnosIGkgKiAyXCI6XCJpICogMiwgcmMuelwiLGg9bj9bXCJhLnh4eXlcIixcImEuenp3d1wiXTpbXCJhLnh4enpcIixcImEueXl3d1wiXSxmPXI/W1wiYi54enh6XCIsXCJiLnl3eXdcIl06W1wiYi54eXh5XCIsXCJiLnp3endcIl0sZD1cIlwiLHA9XCJcIjthJiYoZD1pP1widmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcXG4gICAgICAgICAgXCIrYStcIlxcbiAgICAgICAgfVwiOlwidmVjNCBhY3RpdmF0aW9uKHZlYzQgeCkge1xcbiAgICAgICAgICBcIithK1wiXFxuICAgICAgICB9XCIscD1cInJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtcIik7dmFyIHY9bz9cInJlc3VsdCArPSBnZXRCaWFzQXRPdXRDb29yZHMoKTtcIjpcIlwiO28mJnRoaXMudmFyaWFibGVOYW1lcy5wdXNoKFwiYmlhc1wiKSxpJiZ0aGlzLnZhcmlhYmxlTmFtZXMucHVzaChcInByZWx1QWN0aXZhdGlvbldlaWdodHNcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIFwiK2QrXCJcXG5cXG4gICAgICBjb25zdCBmbG9hdCBzaGFyZWREaW1lbnNpb24gPSBcIit1K1wiLjA7XFxuXFxuICAgICAgdmVjNCBkb3QyeDJBUm93QkNvbChpdmVjMyByYykge1xcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDApO1xcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIit1K1wiOyBpKyspIHtcXG4gICAgICAgICAgdmVjNCBhID0gZ2V0TWF0cml4QShyYy54LCBcIitjK1wiKTtcXG4gICAgICAgICAgdmVjNCBiID0gZ2V0TWF0cml4QihyYy54LCBcIitsK1wiKTtcXG5cXG4gICAgICAgICAgLy8gVGhlc2Ugc3dpenpsZWQgcHJvZHVjdHMgbmVlZCB0byBiZSBzZXBhcmF0ZWx5IGFkZGVkLlxcbiAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvaXNzdWVzLzE3MzVcXG4gICAgICAgICAgcmVzdWx0ICs9IChcIitoWzBdK1wiICogXCIrZlswXStcIik7XFxuICAgICAgICAgIHJlc3VsdCArPSAoXCIraFsxXStcIiAqIFwiK2ZbMV0rXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gZG90MngyQVJvd0JDb2wocmMpO1xcblxcbiAgICAgICAgXCIrditcIlxcblxcbiAgICAgICAgXCIrcCtcIlxcblxcbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICBcIn0sT3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wicHJvYnNcIl0sdGhpcy5vdXRwdXRTaGFwZT1bdCxuXSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdW5pZm9ybSBmbG9hdCBzZWVkO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcblxcbiAgICAgICAgZmxvYXQgciA9IHJhbmRvbShzZWVkKTtcXG4gICAgICAgIGZsb2F0IGNkZiA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrKGUtMSkrXCI7IGkrKykge1xcbiAgICAgICAgICBjZGYgKz0gZ2V0UHJvYnMoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICBpZiAociA8IGNkZikge1xcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChpKSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBJZiBubyBvdGhlciBldmVudCBoYXBwZW5lZCwgbGFzdCBldmVudCBoYXBwZW5lZC5cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChcIisoZS0xKStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbihuLHIpe251bGw9PWUuc2VlZExvYyYmKGUuc2VlZExvYz1uLmdldFVuaWZvcm1Mb2NhdGlvbihyLFwic2VlZFwiKSksbi5nbC51bmlmb3JtMWYoZS5zZWVkTG9jLHQpfX0sdH0oKSxNcz1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiaW5kaWNlc1wiXSx0aGlzLm91dHB1dFNoYXBlPVt0LGVdLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBpbmRleCA9IHJvdW5kKGdldEluZGljZXMoY29vcmRzLngpKTtcXG4gICAgICAgIHNldE91dHB1dChtaXgoZmxvYXQoXCIrcitcIiksIGZsb2F0KFwiK24rXCIpLFxcbiAgICAgICAgICAgICAgICAgICAgICBmbG9hdChpbmRleCA9PSBjb29yZHMueSkpKTtcXG4gICAgICB9XFxuICAgIFwifSxCcz1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMSx0aGlzLnBhY2tlZE91dHB1dD0hMCx0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIGU9dC5sZW5ndGg7aWYoMD09PWUpdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBzZXRPdXRwdXQodmVjNChnZXRBKCksIDAuLCAwLiwgMC4pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtlbHNle3ZhciBuPVhhKFwicmNcIixlKSxyPXVpKGUpLG89ZnVuY3Rpb24odCxlLG4pe2lmKDE9PT10KXJldHVyblwicmMgPiBcIitlWzBdO2Zvcih2YXIgcj1cIlwiLG89dC0yO288dDtvKyspcis9bltvXStcIiA+PSBcIitlW29dLG88dC0xJiYocis9XCJ8fFwiKTtyZXR1cm4gcn0oZSx0LG4pLGE9ZnVuY3Rpb24odCxlLG4scil7aWYoMT09PXQpcmV0dXJuXCJcIjt2YXIgbz1yLnNsaWNlKC0yKTtyZXR1cm5cIlxcbiAgICBpbnQgciA9IFwiK29bMF0rXCI7XFxuICAgIGludCBjID0gXCIrb1sxXStcIjtcXG4gICAgaW50IHJwMSA9IHIgKyAxO1xcbiAgICBpbnQgY3AxID0gYyArIDE7XFxuXFxuICAgIGJvb2wgY0VkZ2UgPSBjcDEgPj0gXCIrZStcIjtcXG4gICAgYm9vbCByRWRnZSA9IHJwMSA+PSBcIituK1wiO1xcbiAgXCJ9KGUsdFt0Lmxlbmd0aC0xXSx0W3QubGVuZ3RoLTJdLG4pLGk9ZnVuY3Rpb24odCxlKXt2YXIgbj10Lmxlbmd0aCxyPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPVtdLHI9MDtyPD0xO3IrKylmb3IodmFyIG89MDtvPD0xO28rKyl7Zm9yKHZhciBhPSgwPT09cj9cInJcIjpcInJwMVwiKStcIiwgXCIrKDA9PT1vP1wiY1wiOlwiY3AxXCIpLGk9MjtpPHQ7aSsrKWE9ZVtlLmxlbmd0aC0xLWldK1wiLFwiK2E7bi5wdXNoKGEpfXJldHVybiBufShuLGUpO3JldHVybiAxPT09bj9cImdldEEocmMpLFxcbiAgICAgICAgICAgIHJjICsgMSA+PSBcIit0WzBdK1wiID8gMC4gOiBnZXRBKHJjICsgMSksXFxuICAgICAgICAgICAgMCwgMFwiOlwiZ2V0QShcIityWzBdK1wiKSxcXG4gICAgICAgICAgY0VkZ2UgPyAwLiA6IGdldEEoXCIrclsxXStcIiksXFxuICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKFwiK3JbMl0rXCIpLFxcbiAgICAgICAgICByRWRnZSB8fCBjRWRnZSA/IDAuIDogZ2V0QShcIityWzNdK1wiKVwifSh0LG4pO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIrcitcIiByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgICBpZihcIitvK1wiKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KHZlYzQoMCkpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIFwiK2ErXCJcXG5cXG4gICAgICAgICAgICBzZXRPdXRwdXQodmVjNChcIitpK1wiKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIn19O3ZhciBQcz1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1lLm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZVswXSt0W25dK2VbMV19KSk7dmFyIHI9dC5sZW5ndGgsbz11aShyKSxhPWUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pKS5qb2luKFwiLFwiKSxpPWUubWFwKChmdW5jdGlvbihlLG4pe3JldHVybiBlWzBdK3Rbbl19KSkuam9pbihcIixcIikscz1bXCJjb29yZHNbMF1cIixcImNvb3Jkc1sxXVwiLFwiY29vcmRzWzJdXCIsXCJjb29yZHNbM11cIl0uc2xpY2UoMCxyKTt0aGlzLnVzZXJDb2RlPTEhPT1yP1wiXFxuICAgICAgXCIrbytcIiBzdGFydCA9IFwiK28rXCIoXCIrYStcIik7XFxuICAgICAgXCIrbytcIiBlbmQgPSBcIitvK1wiKFwiK2krXCIpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaWYgKGFueShsZXNzVGhhbihvdXRDLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKG91dEMsIGVuZCkpKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIituK1wiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBcIitvK1wiIGNvb3JkcyA9IG91dEMgLSBzdGFydDtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIrcytcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCI6XCJcXG4gICAgICAgIGludCBzdGFydCA9IFwiK2ErXCI7XFxuICAgICAgICBpbnQgZW5kID0gXCIraStcIjtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaW50IG91dEMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaWYgKG91dEMgPCBzdGFydCB8fCBvdXRDID49IGVuZCkge1xcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIituK1wiKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGdldFgob3V0QyAtIHN0YXJ0KSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIn0sTHM9ZnVuY3Rpb24odCxlLG4pe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9ZS5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdFtuXStlWzFdfSkpO2Zvcih2YXIgcj10Lmxlbmd0aCxvPXVpKHIpLGE9ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSkpLmpvaW4oXCIsXCIpLGk9ZS5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdFtuXX0pKS5qb2luKFwiLFwiKSxzPVhhKFwicmNcIixyKSx1PVhhKFwic291cmNlXCIsciksYz1zW3ItMV0rXCIgPCBcIit0aGlzLm91dHB1dFNoYXBlW3ItMV0sbD0xPT09cj9cInNvdXJjZVwiOlwidmVjMihcIit1LnNsaWNlKC0yKS5qb2luKCkrXCIpXCIsaD1bbytcIiByYyA9IG91dHB1dExvYztcIixzW3ItMV0rXCIgKz0gMTtcXG4gICAgICAgaWYoXCIrYytcIikge1xcbiAgICAgIFwiLDE9PT1yP1wiXCI6XCJ9XFxuICAgICAgIHJjID0gb3V0cHV0TG9jO1xcbiAgICAgICBcIitzW3ItMl0rXCIgKz0gMTtcXG4gICAgICAgaWYoXCIrc1tyLTJdK1wiIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVtyLTJdK1wiKSB7XCIsMT09PXI/XCJcIjpcIiAgXCIrc1tyLTFdK1wiICs9IDE7XFxuICAgICAgICAgaWYoXCIrYytcIikge1wiXSxmPTE9PT1yP1wicmMgPCBzdGFydCB8fCByYyA+PSBlbmRcIjpcImFueShsZXNzVGhhbihyYywgc3RhcnQpKSB8fCBhbnkoZ3JlYXRlclRoYW5FcXVhbChyYywgZW5kKSlcIixkPVwiXCIscD0wLHY9MT09PXI/Mjo0O3A8djtwKyspZCs9XCJcXG4gICAgICAgIFwiK2hbcF0rXCJcXG4gICAgICAgIGlmIChcIitmK1wiKSB7XFxuICAgICAgICAgIHJlc3VsdFtcIitwK1wiXSA9IGZsb2F0KFwiK24rXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIrbytcIiBzb3VyY2UgPSByYyAtIHN0YXJ0O1xcbiAgICAgICAgICByZXN1bHRbXCIrcCtcIl0gPSBnZXRDaGFubmVsKGdldFgoXCIrdS5qb2luKCkrXCIpLCBcIitsK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtkKz0xPT09cj9cIn0gXCI6XCJ9fVwiLHRoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBcIitvK1wiIHN0YXJ0ID0gXCIrbytcIihcIithK1wiKTtcXG4gICAgICBjb25zdCBcIitvK1wiIGVuZCA9IFwiK28rXCIoXCIraStcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBvdXRwdXRMb2MgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICBcIitkK1wiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifSxXcz1mdW5jdGlvbih0LGUsbixyLG8pe2lmKHZvaWQgMD09PXImJihyPSExKSx2b2lkIDA9PT1vJiYobz0hMSksdGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sXCJhdmdcIj09PWUmJm4pdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgcG9zaXRpb25zIGZvciBhdmVyYWdlIHBvb2wuXCIpO3ZhciBhPXQuZmlsdGVyV2lkdGgsaT10LnN0cmlkZUhlaWdodCxzPXQuc3RyaWRlV2lkdGgsdT10LmRpbGF0aW9uSGVpZ2h0LGM9dC5kaWxhdGlvbldpZHRoLGw9dC5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsaD10LmVmZmVjdGl2ZUZpbHRlcldpZHRoLGY9dC5wYWRJbmZvLnRvcCxkPXQucGFkSW5mby5sZWZ0O3RoaXMub3V0cHV0U2hhcGU9dC5vdXRTaGFwZTt2YXIgcD1cImF2Z1wiPT09ZSx2PVwiKChiYXRjaCAgKiBcIit0LmluSGVpZ2h0K1wiICsgeFIpICogXCIrdC5pbldpZHRoK1wiICsgeEMpICogXCIrdC5pbkNoYW5uZWxzK1wiICsgZFwiLGc9XCIoeFIgKiBcIit0LmluV2lkdGgrXCIgKyB4QykgKiBcIit0LmluQ2hhbm5lbHMrXCIgKyBkXCIsbT1cIjAuMFwiO2lmKHB8fChtPVwiLTEuMCAvIDFlLTIwXCIpLG4pdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiK2krXCIsIFwiK3MrXCIpO1xcbiAgICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2YrXCIsIFwiK2QrXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xcbiAgICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiK2wrXCI7XFxuICAgICAgICAgICAgICB3UiArPSBcIit1K1wiKSB7XFxuICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiK3QuaW5IZWlnaHQrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgXCIraCtcIjtcXG4gICAgICAgICAgICAgICAgd0MgKz0gXCIrYytcIikge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIrdC5pbldpZHRoK1wiKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcblxcbiAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXFxuICAgICAgICAgICAgICAvLyB1c2UgdGhlIGN1cnJlbnQgdmFsdWUuXFxuICAgICAgICAgICAgICBmbG9hdCBjdXJyTWluTWF4VmFsdWUgPSBtaXgoXFxuICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBjdXJyTWluTWF4VmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWUgPSB2YWx1ZTtcXG4gICAgICAgICAgICAgICAgbWluTWF4VmFsdWVGb3VuZCA9IDEuMDtcXG4gICAgICAgICAgICAgICAgbWluTWF4UG9zaXRpb24gPSBcIisocj9vP3Y6ZzpcIndSICogXCIraCtcIiArIHdDXCIpK1wiO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQobWluTWF4UG9zaXRpb24pKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtlbHNle3ZhciB5PWUrXCIoXCIrZStcIihcIitlK1wiKG1pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pXCI7XCJhdmdcIj09PWUmJih5PVwiYXZnVmFsdWUgLyBjb3VudFwiKTt2YXIgeD00Kk1hdGguZmxvb3IoYS80KSxiPWElNCx3PVwiXFxuICAgICAgaWYgKFwiK3ArXCIpIHtcXG4gICAgICAgIGF2Z1ZhbHVlICs9IGRvdCh2YWx1ZXMsIG9uZXMpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IG1heCh2YWx1ZXMsIG1pbk1heFZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICBjb25zdCBpdmVjMiBzdHJpZGVzID0gaXZlYzIoXCIraStcIiwgXCIrcytcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiK2YrXCIsIFwiK2QrXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSBcIittK1wiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBjb3VudCA9IDAuMDtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCB4UiwgaW50IHhDLCBpbnQgZCkge1xcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBjb3VudCArPSAxLjA7XFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgeFIsIHhDLCBkKTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIHhSQ0Nvcm5lciA9IGNvb3Jkcy55eiAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XFxuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIG1heC9taW4geCg/LCA/LCBkKSB0byBnZXQgeSh5UiwgeUMsIGQpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcXG4gICAgICAgIHZlYzQgbWluTWF4VmFsdWUgPSB2ZWM0KFwiK20rXCIpO1xcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuICAgICAgICBjb3VudCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitsK1wiO1xcbiAgICAgICAgICAgIHdSICs9IFwiK3UrXCIpIHtcXG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBcIit0LmluSGVpZ2h0K1wiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiK3grXCI7IHdDICs9IDQpIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIrYytcIjtcXG5cXG4gICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyBcIitjK1wiLCBkKSxcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMgKyAyICogXCIrYytcIiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMyAqIFwiK2MrXCIsIGQpXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIit3K1wiXFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyBcIit4K1wiO1xcbiAgICAgICAgICBpZiAoXCIrKDE9PT1iKStcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIit3K1wiXFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1iKStcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIFwiK2MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiK3crXCJcXG4gICAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PWIpK1wiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgXCIrYytcIiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiAqIFwiK2MrXCIsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgXCIrdytcIlxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoXCIreStcIik7XFxuICAgICAgfVxcbiAgICBcIn19LFVzPWZ1bmN0aW9uKHQsZSxuLHIsbyl7aWYodm9pZCAwPT09ciYmKHI9ITEpLHZvaWQgMD09PW8mJihvPSExKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXSxcImF2Z1wiPT09ZSYmbil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBwb3NpdGlvbnMgZm9yIGF2ZXJhZ2UgcG9vbC5cIik7dmFyIGE9dC5maWx0ZXJXaWR0aCxpPXQuc3RyaWRlRGVwdGgscz10LnN0cmlkZUhlaWdodCx1PXQuc3RyaWRlV2lkdGgsYz10LmRpbGF0aW9uRGVwdGgsbD10LmRpbGF0aW9uSGVpZ2h0LGg9dC5kaWxhdGlvbldpZHRoLGY9dC5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxkPXQuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHA9dC5lZmZlY3RpdmVGaWx0ZXJXaWR0aCx2PXQucGFkSW5mby5mcm9udCxnPXQucGFkSW5mby50b3AsbT10LnBhZEluZm8ubGVmdDt0aGlzLm91dHB1dFNoYXBlPXQub3V0U2hhcGU7dmFyIHk9XCJhdmdcIj09PWUseD1cIjAuMFwiO2lmKHl8fCh4PVwiLTEuMCAvIDFlLTIwXCIpLG4pdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgY29uc3QgaXZlYzMgc3RyaWRlcyA9XFxuICAgICAgICAgICAgaXZlYzMoXCIraStcIiwgXCIrcytcIiwgXCIrdStcIik7XFxuICAgICAgICBjb25zdCBpdmVjMyBwYWRzID0gaXZlYzMoXCIrditcIiwgXCIrZytcIiwgXCIrbStcIik7XFxuXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcXG4gICAgICAgICAgaW50IGNoID0gY29vcmRzLnU7XFxuXFxuICAgICAgICAgIGl2ZWMzIHhDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAqIHN0cmlkZXMgLSBwYWRzO1xcbiAgICAgICAgICBpbnQgeERDb3JuZXIgPSB4Q29ybmVyLng7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhDb3JuZXIueTtcXG4gICAgICAgICAgaW50IHhDQ29ybmVyID0geENvcm5lci56O1xcblxcbiAgICAgICAgICAvLyBtYXgvbWluIHgoPywgPywgPywgY2gpIHRvIGdldCB5KHlELCB5UiwgeUMsIGNoKS5cXG4gICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWRcXG4gICAgICAgICAgZmxvYXQgbWluTWF4VmFsdWUgPSAwLjA7XFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlRm91bmQgPSAwLjA7XFxuICAgICAgICAgIGludCBtaW5NYXhQb3NpdGlvbiA9IDA7XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdEID0gMDsgd0QgPCBcIitmK1wiO1xcbiAgICAgICAgICAgICAgd0QgKz0gXCIrYytcIikge1xcbiAgICAgICAgICAgIGludCB4RCA9IHhEQ29ybmVyICsgd0Q7XFxuXFxuICAgICAgICAgICAgaWYgKHhEIDwgMCB8fCB4RCA+PSBcIit0LmluRGVwdGgrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIrZCtcIjtcXG4gICAgICAgICAgICAgICAgd1IgKz0gXCIrbCtcIikge1xcbiAgICAgICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UjtcXG5cXG4gICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIitwK1wiO1xcbiAgICAgICAgICAgICAgICAgIHdDICs9IFwiK2grXCIpIHtcXG4gICAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFgoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBtaW4gLyBtYXggdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBmb3VuZCwgdXNlIGl0LiBJZiBub3QsXFxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VycmVudCB2YWx1ZS5cXG4gICAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsIG1pbk1heFZhbHVlLCBtaW5NYXhWYWx1ZUZvdW5kKTtcXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IGN1cnJNaW5NYXhWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gdmFsdWU7XFxuICAgICAgICAgICAgICAgICAgbWluTWF4VmFsdWVGb3VuZCA9IDEuMDtcXG4gICAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9IFwiKyhyP28/XCIoKChiYXRjaCAqIFwiK3QuaW5EZXB0aCtcIiArIHhEKSAqIFwiK3QuaW5IZWlnaHQrXCIgKyB4UikgKiBcIit0LmluV2lkdGgrXCIgKyB4QykgKiBcIit0LmluQ2hhbm5lbHMrXCIgKyBjaFwiOlwiKCh4RCAqIFwiK3QuaW5IZWlnaHQrXCIgKyB4UikgKiBcIit0LmluV2lkdGgrXCIgKyB4QykgKiBcIit0LmluQ2hhbm5lbHMrXCIgKyBjaFwiOlwid0QgKiBcIitkK1wiICogXCIrcCtcIiArXFxuICAgICAgICAgICAgICAgICAgICAgIHdSICogXCIrcCtcIiArIHdDXCIpK1wiO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO2Vsc2V7dmFyIGI9ZStcIihcIitlK1wiKFwiK2UrXCIobWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSlcIjtcImF2Z1wiPT09ZSYmKGI9XCJhdmdWYWx1ZSAvIGNvdW50XCIpO3ZhciB3PTQqTWF0aC5mbG9vcihhLzQpLEM9YSU0LEU9XCJcXG4gICAgICBpZiAoXCIreStcIikge1xcbiAgICAgICAgYXZnVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1pbk1heFZhbHVlID0gbWF4KHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGl2ZWMzIHN0cmlkZXMgPVxcbiAgICAgICAgaXZlYzMoXCIraStcIiwgXCIrcytcIiwgXCIrdStcIik7XFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKFwiK3YrXCIsIFwiK2crXCIsIFwiK20rXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSBcIit4K1wiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBjb3VudCA9IDAuMDtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCB4RCwgaW50IHhSLCBpbnQgeEMsIGludCBjaCkge1xcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIit0LmluV2lkdGgrXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGluaXRpYWxpemF0aW9uVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBjb3VudCArPSAxLjA7XFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgeEQsIHhSLCB4QywgY2gpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IGNoID0gY29vcmRzLnU7XFxuXFxuICAgICAgICBpdmVjMyB4Q29ybmVyID0gaXZlYzMoY29vcmRzLnksIGNvb3Jkcy56LCBjb29yZHMudykgKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4RENvcm5lciA9IHhDb3JuZXIueDtcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhDb3JuZXIueTtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhDb3JuZXIuejtcXG5cXG4gICAgICAgIC8vIG1heC9taW4geCg/LCA/LCA/LCBkKSB0byBnZXQgeSh5RCwgeVIsIHlDLCBjaCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIreCtcIik7XFxuICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG4gICAgICAgIGNvdW50ID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgd0QgPSAwOyB3RCA8IFwiK2YrXCI7XFxuICAgICAgICAgICAgd0QgKz0gXCIrYytcIikge1xcbiAgICAgICAgICBpbnQgeEQgPSB4RENvcm5lciArIHdEO1xcblxcbiAgICAgICAgICBpZiAoeEQgPCAwIHx8IHhEID49IFwiK3QuaW5EZXB0aCtcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIitkK1wiO1xcbiAgICAgICAgICAgIHdSICs9IFwiK2wrXCIpIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIrdC5pbkhlaWdodCtcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIit3K1wiOyB3QyArPSA0KSB7XFxuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogXCIraCtcIjtcXG5cXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyBcIitoK1wiLCBjaCksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgMiAqIFwiK2grXCIsIGNoKSxcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyAzICogXCIraCtcIiwgY2gpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgXCIrRStcIlxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIFwiK3crXCI7XFxuICAgICAgICAgICAgaWYgKFwiKygxPT09QykrXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICAgIFwiK0UrXCJcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiKygyPT09QykrXCIpIHtcXG4gICAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMsIGNoKSxcXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhELCB4UiwgeEMgKyBcIitoK1wiLCBjaCksXFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBcIitFK1wiXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PUMpK1wiKSB7XFxuICAgICAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDLCBjaCksXFxuICAgICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4RCwgeFIsIHhDICsgXCIraCtcIiwgY2gpLFxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeEQsIHhSLCB4QyArIDIgKiBcIitoK1wiLCBjaCksXFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICAgICk7XFxuXFxuICAgICAgICAgICAgICBcIitFK1wiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChcIitiK1wiKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwifX0sVnM9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wieFwiXTt2YXIgbj10LndpbmRvd1NpemUscj10LmJhdGNoU2l6ZSxvPXQuaW5TaXplLGE9TWF0aC5jZWlsKG8vbik7dGhpcy5vdXRwdXRTaGFwZT1bcixhXTt2YXIgaT1cIjAuMFwiLHM9XCJcIjtcInByb2RcIj09PWU/aT1cIjEuMFwiOlwibWluXCI9PT1lPyhpPVwiMS4wIC8gMWUtMjBcIixzPVwibWluXCIpOlwibWF4XCI9PT1lJiYoaT1cIi0xLjAgLyAxZS0yMFwiLHM9XCJtYXhcIik7dmFyIHU9ZStcIihcIitlK1wiKFwiK2UrXCIobWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSlcIjtcInN1bVwiPT09ZT91PVwic3VtVmFsdWVcIjpcInByb2RcIj09PWU/dT1cInByb2RWYWx1ZVwiOlwiYWxsXCI9PT1lP3U9XCJhbGxWYWx1ZVwiOlwiYW55XCI9PT1lJiYodT1cImFueVZhbHVlXCIpO3ZhciBjPTQqTWF0aC5mbG9vcihuLzQpLGw9biU0LGg9XCJcXG4gICAgICBpZiAoXCIrKFwic3VtXCI9PT1lKStcIikge1xcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIGlmIChcIisoXCJwcm9kXCI9PT1lKStcIikge1xcbiAgICAgICAgdmVjMiB0bXAgPSB2ZWMyKHZhbHVlc1swXSwgdmFsdWVzWzFdKSAqIHZlYzIodmFsdWVzWzJdLCB2YWx1ZXNbM10pO1xcbiAgICAgICAgcHJvZFZhbHVlICo9IHRtcFswXSAqIHRtcFsxXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBcIitzK1wiKHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCIsZj1cInZlYzRcIjtcImFsbFwiPT09ZT8oaT1cIjEuMFwiLGg9XCJcXG4gICAgICAgIGJvb2wgcmVkdWNlZEFsbFZhbHVlID0gYWxsKHZhbHVlcyk7XFxuICAgICAgICBmbG9hdCBmbG9hdGVkUmVkdWNlZEFsbFZhbHVlID0gZmxvYXQocmVkdWNlZEFsbFZhbHVlKTtcXG4gICAgICAgIGFsbFZhbHVlID0gZmxvYXQoYWxsVmFsdWUgPj0gMS4wICYmIGZsb2F0ZWRSZWR1Y2VkQWxsVmFsdWUgPj0gMS4wKTtcXG4gICAgICBcIixmPVwiYnZlYzRcIik6XCJhbnlcIj09PWUmJihpPVwiMC4wXCIsaD1cIlxcbiAgICAgICAgYm9vbCByZWR1Y2VkQW55VmFsdWUgPSBhbnkodmFsdWVzKTtcXG4gICAgICAgIGZsb2F0IGZsb2F0ZWRSZWR1Y2VkQW55VmFsdWUgPSBmbG9hdChyZWR1Y2VkQW55VmFsdWUpO1xcbiAgICAgICAgYW55VmFsdWUgPSBmbG9hdChhbnlWYWx1ZSA+PSAxLjAgfHwgZmxvYXRlZFJlZHVjZWRBbnlWYWx1ZSA+PSAxLjApO1xcbiAgICAgIFwiLGY9XCJidmVjNFwiKTt2YXIgZD1cIlwiO28lbj4wJiYoZD1cIlxcbiAgICAgICAgaWYgKGluSWR4IDwgMCB8fCBpbklkeCA+PSBcIitvK1wiKSB7XFxuICAgICAgICAgIHJldHVybiBpbml0aWFsaXphdGlvblZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIFwiKSx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiK2krXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XFxuICAgICAgICBcIitkK1wiXFxuICAgICAgICByZXR1cm4gZ2V0WChiYXRjaCwgaW5JZHgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiBcIituK1wiO1xcblxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIraStcIik7XFxuICAgICAgICBmbG9hdCBwcm9kVmFsdWUgPSAxLjA7XFxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcXG4gICAgICAgIGZsb2F0IGFsbFZhbHVlID0gMS4wO1xcbiAgICAgICAgZmxvYXQgYW55VmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK2MrXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIFwiK2YrXCIgdmFsdWVzID0gXCIrZitcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2grXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIrYytcIjtcXG4gICAgICAgIGlmIChcIisoMT09PWwpK1wiKSB7XFxuICAgICAgICAgIFwiK2YrXCIgdmFsdWVzID0gXCIrZitcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIFwiK2grXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIrKDI9PT1sKStcIikge1xcbiAgICAgICAgICBcIitmK1wiIHZhbHVlcyA9IFwiK2YrXCIoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIraCtcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PWwpK1wiKSB7XFxuICAgICAgICAgIFwiK2YrXCIgdmFsdWVzID0gXCIrZitcIihcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIraCtcIlxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiK3UrXCIpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHpzPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITAsdGhpcy5vdXRwdXRTaGFwZT10O2Zvcih2YXIgbj1cIlwiLHI9MDtyPDQ7cisrKXt2YXIgbz1cInRoaXNSQyA9IHJjO1wiO3IlMj09MSYmKG8rPVwidGhpc1JDLnogKz0gMTtcIikscj4xJiYobys9XCJ0aGlzUkMueSArPSAxO1wiKSxuKz1cIlxcbiAgICAgICAgXCIrbytcIlxcbiAgICAgICAgXCIrKHI+MD9cImlmKHRoaXNSQy55IDwgcm93cyAmJiB0aGlzUkMueiA8IGNvbHMpe1wiOlwiXCIpK1wiXFxuICAgICAgICAgIGludCBmbGF0SW5kZXggPSBnZXRGbGF0SW5kZXgodGhpc1JDKTtcXG5cXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXRJbmRleCk7XFxuICAgICAgICAgIHZlYzIgaW5wdXRSQ0lubmVyRGltcyA9IHZlYzIoZmxvYXQoaW5wdXRSQy55KSxmbG9hdChpbnB1dFJDLnopKTtcXG5cXG4gICAgICAgICAgcmVzdWx0W1wiK3IrXCJdID1cXG4gICAgICAgICAgICBnZXRDaGFubmVsKGdldEEoaW5wdXRSQy54LCBpbnB1dFJDLnksIGlucHV0UkMueiksIGlucHV0UkNJbm5lckRpbXMpO1xcbiAgICAgICAgXCIrKHI+MD9cIn1cIjpcIlwiKStcIlxcbiAgICAgIFwifXRoaXMudXNlckNvZGU9XCJcXG4gICAgICBcXG4gICAgaXZlYzMgaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoaW50IGluZGV4KSB7XFxuICAgICAgXCIrJGEoW1wiclwiLFwiY1wiLFwiZFwiXSxlKStcIlxcbiAgICAgIHJldHVybiBpdmVjMyhyLCBjLCBkKTtcXG4gICAgfVxcbiAgXFxuICAgICAgXCIrUWEodCkrXCJcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyByYyA9IGdldE91dHB1dENvb3JkcygpO1xcblxcbiAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG5cXG4gICAgICAgIGl2ZWMzIHRoaXNSQztcXG4gICAgICAgIGludCByb3dzID0gXCIrdFsxXStcIjtcXG4gICAgICAgIGludCBjb2xzID0gXCIrdFsyXStcIjtcXG5cXG4gICAgICAgIFwiK24rXCJcXG5cXG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgIH1cXG4gICAgXCJ9O3ZhciBHcz1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcImR5XCJdLHRoaXMub3V0cHV0U2hhcGU9W10sdGhpcy5vdXRwdXRTaGFwZT1lLnNoYXBlO3ZhciByPWUuc2hhcGUsbz1yWzFdLGE9clsyXSxpPXQuc2hhcGUscz1pWzFdLHU9aVsyXSxjPVtuJiZzPjE/by0xOm8sbiYmdT4xP2EtMTphXSxsPVtuJiZzPjE/cy0xOnMsbiYmdT4xP3UtMTp1XSxoPWNbMF0vbFswXSxmPWNbMV0vbFsxXSxkPTEvaCxwPTEvZix2PTIqTWF0aC5jZWlsKGQpKzIsZz0yKk1hdGguY2VpbChwKSsyO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBjID0gY29vcmRzWzJdO1xcblxcbiAgICAgICAgZmxvYXQgYWNjdW11bGF0b3IgPSAwLjA7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBoZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2grXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgd2lkdGhTY2FsZSA9IGZsb2F0KFwiK2YrXCIpO1xcblxcbiAgICAgICAgY29uc3QgZmxvYXQgaW52SGVpZ2h0U2NhbGUgPSBmbG9hdChcIitkK1wiKTtcXG4gICAgICAgIGNvbnN0IGZsb2F0IGludldpZHRoU2NhbGUgPSBmbG9hdChcIitwK1wiKTtcXG5cXG4gICAgICAgIGNvbnN0IGludCB3aW5IZWlnaHQgPSBpbnQoXCIrditcIik7XFxuICAgICAgICBjb25zdCBpbnQgd2luV2lkdGggPSBpbnQoXCIrZytcIik7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIGJvdW5kcyBmb3Igd2hlcmUgaW4gZHkgd2Ugd2lsbCBsb29rXFxuICAgICAgICBmbG9hdCBzdGFydFJMZXJwID0gZmxvb3IoZmxvYXQocikgKiBpbnZIZWlnaHRTY2FsZSk7XFxuICAgICAgICBpbnQgc3RhcnREeVIgPSBpbnQoc3RhcnRSTGVycCAtIGZsb2F0KHdpbkhlaWdodCAvIDIpKTtcXG5cXG4gICAgICAgIGZsb2F0IHN0YXJ0Q0xlcnAgPSBmbG9vcihmbG9hdChjKSAqIGludldpZHRoU2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlDID0gaW50KHN0YXJ0Q0xlcnAgLSBmbG9hdCh3aW5XaWR0aCAvIDIpKTtcXG5cXG4gICAgICAgIC8vIExvb3Agb3ZlciBkeVxcbiAgICAgICAgZm9yIChpbnQgZHlST2Zmc2V0ID0gMDsgZHlST2Zmc2V0IDwgd2luSGVpZ2h0OyBkeVJPZmZzZXQrKykge1xcbiAgICAgICAgICBpbnQgZHlSID0gZHlST2Zmc2V0ICsgc3RhcnREeVI7XFxuXFxuICAgICAgICAgIC8vIEd1YXJkIGFnYWluc3QgdGhlIHdpbmRvdyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiBkeVxcbiAgICAgICAgICBpZiAoZHlSIDwgMCB8fCBkeVIgPj0gXCIrcytcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IGR5Q09mZnNldCA9IDA7IGR5Q09mZnNldCA8IHdpbldpZHRoOyBkeUNPZmZzZXQrKykge1xcbiAgICAgICAgICAgIGludCBkeUMgPSBkeUNPZmZzZXQgKyBzdGFydER5QztcXG5cXG4gICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gXCIrdStcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZsb2F0IGR4UiA9IGZsb2F0KGR5UikgKiBoZWlnaHRTY2FsZTtcXG4gICAgICAgICAgICBpbnQgdG9wRHhSSW5kZXggPSBpbnQoZmxvb3IoZHhSKSk7XFxuICAgICAgICAgICAgaW50IGJvdHRvbUR4UkluZGV4ID0gaW50KG1pbihjZWlsKGR4UiksIFwiKyhvLTEpK1wiLjApKTtcXG4gICAgICAgICAgICBmbG9hdCBkeFJMZXJwID0gZHhSIC0gZmxvYXQodG9wRHhSSW5kZXgpO1xcbiAgICAgICAgICAgIGZsb2F0IGludmVyc2VEeFJMZXJwID0gMS4wIC0gZHhSTGVycDtcXG5cXG4gICAgICAgICAgICBmbG9hdCBkeEMgPSBmbG9hdChkeUMpICogd2lkdGhTY2FsZTtcXG4gICAgICAgICAgICBpbnQgbGVmdER4Q0luZGV4ID0gaW50KGZsb29yKGR4QykpO1xcbiAgICAgICAgICAgIGludCByaWdodER4Q0luZGV4ID0gaW50KG1pbihjZWlsKGR4QyksIFwiKyhhLTEpK1wiLjApKTtcXG4gICAgICAgICAgICBmbG9hdCBkeENMZXJwID0gZHhDIC0gZmxvYXQobGVmdER4Q0luZGV4KTtcXG4gICAgICAgICAgICBmbG9hdCBpbnZlcnNlRHhDTGVycCA9IDEuMCAtIGR4Q0xlcnA7XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gdG9wRHhSSW5kZXggJiYgYyA9PSBsZWZ0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIHRvcExlZnRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9XFxuICAgICAgICAgICAgICAgIGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGludmVyc2VEeFJMZXJwICogaW52ZXJzZUR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyID09IHRvcER4UkluZGV4ICYmIGMgPT0gcmlnaHREeENJbmRleCkge1xcbiAgICAgICAgICAgICAgLy8gdG9wUmlnaHRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGludmVyc2VEeFJMZXJwICogZHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gYm90dG9tRHhSSW5kZXggJiYgYyA9PSBsZWZ0RHhDSW5kZXgpIHtcXG4gICAgICAgICAgICAgIC8vIGJvdHRvbUxlZnRcXG4gICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IGdldER5KGIsIGR5UiwgZHlDLCBkKSAqIGR4UkxlcnAgKiBpbnZlcnNlRHhDTGVycDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHIgPT0gYm90dG9tRHhSSW5kZXggJiYgYyA9PSByaWdodER4Q0luZGV4KSB7XFxuICAgICAgICAgICAgICAvLyBib3R0b21SaWdodFxcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgKz0gZ2V0RHkoYiwgZHlSLCBkeUMsIGQpICogZHhSTGVycCAqIGR4Q0xlcnA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAvLyBFbmQgbG9vcCBvdmVyIGR5XFxuXFxuICAgICAgICBzZXRPdXRwdXQoYWNjdW11bGF0b3IpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEhzPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG89dFswXSxhPXRbMV0saT10WzJdLHM9dFszXTt0aGlzLm91dHB1dFNoYXBlPVtvLGUsbixzXTt2YXIgdT1bciYmZT4xP2EtMTphLHImJm4+MT9pLTE6aV0sYz1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl07dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXFxuICAgICAgICAgIFwiK3VbMF0vY1swXStcIixcXG4gICAgICAgICAgXCIrdVsxXS9jWzFdK1wiKTtcXG4gICAgICBjb25zdCB2ZWMyIGlucHV0U2hhcGVSQyA9IHZlYzIoXCIrYStcIi4wLCBcIitpK1wiLjApO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIHlSQyA9IGNvb3Jkcy55ejtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yUkMgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhSQyk7XFxuICAgICAgICBpdmVjMiBzb3VyY2VDZWlsUkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbUxlZnQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgdG9wUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuXFxuICAgICAgICB2ZWMyIGZyYWNSQyA9IHNvdXJjZUZyYWNJbmRleFJDIC0gdmVjMihzb3VyY2VGbG9vclJDKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY1JDLng7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHFzPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG89dFswXSxhPXRbMV0saT10WzJdLHM9dFszXTt0aGlzLm91dHB1dFNoYXBlPVtvLGUsbixzXTt2YXIgdT1bciYmZT4xP2EtMTphLHImJm4+MT9pLTE6aV0sYz1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl07dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IHZlYzMgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzMoXFxuICAgICAgICAgIFwiK3VbMF0vY1swXStcIixcXG4gICAgICAgICAgXCIrdVsxXS9jWzFdK1wiLFxcbiAgICAgICAgICBcIit1WzFdL2NbMV0rXCIpO1xcbiAgICAgIGNvbnN0IHZlYzMgaW5wdXRTaGFwZVJDID0gdmVjMyhcIithK1wiLjAsIFwiK2krXCIuMCxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIraStcIi4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRBVmFsdWUoaW50IGIsIGludCByLCBpbnQgYywgaW50IGQpIHtcXG4gICAgICAgIHJldHVybiBnZXRDaGFubmVsKGdldEEoYiwgciwgYywgZCksIHZlYzIoYywgZCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICAvLyBDYWxjdWxhdGUgdmFsdWVzIGZvciBuZXh0IGNvbHVtbiBpbiB5UkMuei5cXG4gICAgICAgIGl2ZWMzIHlSQyA9IGNvb3Jkcy55enogKyBpdmVjMygwLCAwLCAxKTtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMyBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzMoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgIGl2ZWMzIHNvdXJjZUZsb29yUkMgPSBpdmVjMyhzb3VyY2VGcmFjSW5kZXhSQyk7XFxuICAgICAgICBpdmVjMyBzb3VyY2VDZWlsUkMgPSBpdmVjMyhcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG5cXG4gICAgICAgIC8vIFNob3VsZCB3ZSBjYWxjdWxhdGUgbmV4dCBjb2x1bW4gYW5kIHJvdyBlbGVtZW50cyBpbiAyeDIgcGFja2VkIGNlbGwuXFxuICAgICAgICBib29sIGhhc05leHRDb2wgPSBkIDwgXCIrKHMtMSkrXCI7XFxuICAgICAgICBib29sIGhhc05leHRSb3cgPSBjb29yZHMueiA8IFwiKyhuLTEpK1wiO1xcblxcbiAgICAgICAgLy8gSW4gcGFyYWxsZWwsIGNvbnN0cnVjdCBmb3VyIGNvcm5lcnMgZm9yIGFsbCBmb3VyIGNvbXBvbmVudHMgaW5cXG4gICAgICAgIC8vIHBhY2tlZCAyeDIgY2VsbC5cXG4gICAgICAgIHZlYzQgdG9wTGVmdCA9IHZlYzQoXFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUZsb29yUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VGbG9vclJDLnksIGQgKyAxKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy56LCBkKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjNCBib3R0b21MZWZ0ID0gdmVjNChcXG4gICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQgKyAxKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnosIGQpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID9cXG4gICAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUZsb29yUkMueiwgZCArIDEpIDogMC4wKTtcXG5cXG4gICAgICAgIHZlYzQgdG9wUmlnaHQgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCksXFxuICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlRmxvb3JSQy54LCBzb3VyY2VDZWlsUkMueiwgZClcXG4gICAgICAgICAgICAgICAgICAgICA6IDAuMCxcXG4gICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgP1xcbiAgICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VGbG9vclJDLngsIHNvdXJjZUNlaWxSQy56LCBkICsgMSkgOiAwLjApO1xcblxcbiAgICAgICAgdmVjNCBib3R0b21SaWdodCA9IHZlYzQoXFxuICAgICAgICAgIGdldEFWYWx1ZShiLCBzb3VyY2VDZWlsUkMueCwgc291cmNlQ2VpbFJDLnksIGQpLFxcbiAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCArIDEpXFxuICAgICAgICAgICAgICAgICAgICAgOiAwLjAsXFxuICAgICAgICAgIGhhc05leHRSb3cgPyBnZXRBVmFsdWUoYiwgc291cmNlQ2VpbFJDLngsIHNvdXJjZUNlaWxSQy56LCBkKVxcbiAgICAgICAgICAgICAgICAgICAgIDogMC4wLFxcbiAgICAgICAgICAoaGFzTmV4dFJvdyAmJiBoYXNOZXh0Q29sKSA/XFxuICAgICAgICAgICAgZ2V0QVZhbHVlKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueiwgZCArIDEpIDogMC4wKTtcXG5cXG4gICAgICAgIHZlYzMgZnJhY1JDID0gc291cmNlRnJhY0luZGV4UkMgLSB2ZWMzKHNvdXJjZUZsb29yUkMpO1xcblxcbiAgICAgICAgdmVjNCB0b3AgPSBtaXgodG9wTGVmdCwgdG9wUmlnaHQsIGZyYWNSQy55eXp6KTtcXG4gICAgICAgIHZlYzQgYm90dG9tID0gbWl4KGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCBmcmFjUkMueXl6eik7XFxuICAgICAgICB2ZWM0IG5ld1ZhbHVlID0gbWl4KHRvcCwgYm90dG9tLCBmcmFjUkMueCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEtzPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiZHlcIl0sdGhpcy5vdXRwdXRTaGFwZT1bXSx0aGlzLm91dHB1dFNoYXBlPWUuc2hhcGU7dmFyIHI9ZS5zaGFwZSxvPXJbMV0sYT1yWzJdLGk9dC5zaGFwZSxzPWlbMV0sdT1pWzJdLGM9W24mJnM+MT9vLTE6byxuJiZ1PjE/YS0xOmFdLGw9W24mJnM+MT9zLTE6cyxuJiZ1PjE/dS0xOnVdLGg9Y1swXS9sWzBdLGY9Y1sxXS9sWzFdLGQ9MS9oLHA9MS9mLHY9MipNYXRoLmNlaWwoZCkrMixnPTIqTWF0aC5jZWlsKHApKzI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuXFxuICAgICAgICBmbG9hdCBhY2N1bXVsYXRvciA9IDAuMDtcXG5cXG4gICAgICAgIGNvbnN0IGZsb2F0IGhlaWdodFNjYWxlID0gZmxvYXQoXCIraCtcIik7XFxuICAgICAgICBjb25zdCBmbG9hdCB3aWR0aFNjYWxlID0gZmxvYXQoXCIrZitcIik7XFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBpbnZIZWlnaHRTY2FsZSA9IGZsb2F0KFwiK2QrXCIpO1xcbiAgICAgICAgY29uc3QgZmxvYXQgaW52V2lkdGhTY2FsZSA9IGZsb2F0KFwiK3ArXCIpO1xcblxcbiAgICAgICAgY29uc3QgaW50IHdpbkhlaWdodCA9IGludChcIit2K1wiKTtcXG4gICAgICAgIGNvbnN0IGludCB3aW5XaWR0aCA9IGludChcIitnK1wiKTtcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzIGZvciB3aGVyZSBpbiBkeSB3ZSB3aWxsIGxvb2tcXG4gICAgICAgIGZsb2F0IHN0YXJ0UkxlcnAgPSBmbG9vcihmbG9hdChyKSAqIGludkhlaWdodFNjYWxlKTtcXG4gICAgICAgIGludCBzdGFydER5UiA9IGludChmbG9vcihzdGFydFJMZXJwIC0gZmxvYXQod2luSGVpZ2h0IC8gMikpKTtcXG5cXG4gICAgICAgIGZsb2F0IHN0YXJ0Q0xlcnAgPSBmbG9vcihmbG9hdChjKSAqIGludldpZHRoU2NhbGUpO1xcbiAgICAgICAgaW50IHN0YXJ0RHlDID0gaW50KGZsb29yKHN0YXJ0Q0xlcnAgLSBmbG9hdCh3aW5XaWR0aCAvIDIpKSk7XFxuXFxuICAgICAgICAvLyBMb29wIG92ZXIgZHlcXG4gICAgICAgIGZvciAoaW50IGR5Uk9mZnNldCA9IDA7IGR5Uk9mZnNldCA8IHdpbkhlaWdodDsgZHlST2Zmc2V0KyspIHtcXG4gICAgICAgICAgaW50IGR5UiA9IGR5Uk9mZnNldCArIHN0YXJ0RHlSO1xcblxcbiAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IHRoZSB3aW5kb3cgZXhjZWVkaW5nIHRoZSBib3VuZHMgb2YgZHlcXG4gICAgICAgICAgaWYgKGR5UiA8IDAgfHwgZHlSID49IFwiK3MrXCIpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGludCBkeUNPZmZzZXQgPSAwOyBkeUNPZmZzZXQgPCB3aW5XaWR0aDsgZHlDT2Zmc2V0KyspIHtcXG4gICAgICAgICAgICBpbnQgZHlDID0gZHlDT2Zmc2V0ICsgc3RhcnREeUM7XFxuXFxuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgd2luZG93IGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIGR5XFxuICAgICAgICAgICAgaWYgKGR5QyA8IDAgfHwgZHlDID49IFwiK3UrXCIpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmbG9hdCBzb3VyY2VGcmFjUm93ID1cXG4gICAgICAgICAgICAgIGZsb2F0KFwiK2NbMF0rXCIpICpcXG4gICAgICAgICAgICAgICAgKGZsb2F0KGR5UikgLyBmbG9hdChcIitsWzBdK1wiKSk7XFxuXFxuICAgICAgICAgICAgZmxvYXQgc291cmNlRnJhY0NvbCA9XFxuICAgICAgICAgICAgICAgIGZsb2F0KFwiK2NbMV0rXCIpICpcXG4gICAgICAgICAgICAgICAgICAoZmxvYXQoZHlDKSAvIGZsb2F0KFwiK2xbMV0rXCIpKTtcXG5cXG4gICAgICAgICAgICBpbnQgc291cmNlTmVhcmVzdFJvdyA9IGludChtaW4oXFxuICAgICAgICAgICAgICAgIGZsb2F0KGludChcIitvK1wiKSAtIDEpLFxcbiAgICAgICAgICAgICAgICBcIituK1wiID8gZmxvYXQocm91bmQoc291cmNlRnJhY1JvdykpIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQoZmxvb3Ioc291cmNlRnJhY1JvdykpKSk7XFxuXFxuICAgICAgICAgICAgaW50IHNvdXJjZU5lYXJlc3RDb2wgPSBpbnQobWluKFxcbiAgICAgICAgICAgICAgICBmbG9hdChpbnQoXCIrYStcIikgLSAxKSxcXG4gICAgICAgICAgICAgICAgXCIrbitcIiA/IGZsb2F0KHJvdW5kKHNvdXJjZUZyYWNDb2wpKSA6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0KGZsb29yKHNvdXJjZUZyYWNDb2wpKSkpO1xcblxcbiAgICAgICAgICAgIGlmIChyID09IHNvdXJjZU5lYXJlc3RSb3cgJiYgYyA9PSBzb3VyY2VOZWFyZXN0Q29sKSB7XFxuICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSBnZXREeShiLCBkeVIsIGR5QywgZCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAvLyBFbmQgbG9vcCBvdmVyIGR5XFxuXFxuICAgICAgICBzZXRPdXRwdXQoYWNjdW11bGF0b3IpO1xcbiAgICAgIH1cXG4gICAgXCJ9LGpzPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9W107dmFyIG89dFswXSxhPXRbMV0saT10WzJdLHM9dFszXTt0aGlzLm91dHB1dFNoYXBlPVtvLGUsbixzXTt2YXIgdT1bciYmZT4xP2EtMTphLHImJm4+MT9pLTE6aV0sYz1bciYmZT4xP2UtMTplLHImJm4+MT9uLTE6bl0sbD1yP1wiMC41XCI6XCIwLjBcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgY29uc3QgdmVjMiBlZmZlY3RpdmVJbnB1dE92ZXJPdXRwdXRSYXRpb1JDID0gdmVjMihcXG4gICAgICAgICAgXCIrdVswXS9jWzBdK1wiLFxcbiAgICAgICAgICBcIit1WzFdL2NbMV0rXCIpO1xcbiAgICAgIGNvbnN0IHZlYzIgaW5wdXRTaGFwZVJDID0gdmVjMihcIithK1wiLjAsIFwiK2krXCIuMCk7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgaXZlYzIgeVJDID0gY29vcmRzLnl6O1xcblxcbiAgICAgICAgLy8gRnJhY3Rpb25hbCBzb3VyY2UgaW5kZXguXFxuICAgICAgICB2ZWMyIHNvdXJjZUZyYWNJbmRleFJDID0gdmVjMih5UkMpICogZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQztcXG5cXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvb3JkaW5hdG9ycyBvZiBuZWFyZXN0IG5laWdoYm9yIHBvaW50LlxcbiAgICAgICAgaXZlYzIgc291cmNlTmVhcmVzdFJDID0gaXZlYzIoXFxuICAgICAgICAgIG1pbihpbnB1dFNoYXBlUkMgLSAxLjAsIGZsb29yKHNvdXJjZUZyYWNJbmRleFJDICsgXCIrbCtcIikpKTtcXG5cXG4gICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gZ2V0QShiLCBzb3VyY2VOZWFyZXN0UkMueCwgc291cmNlTmVhcmVzdFJDLnksIGQpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcXG4gICAgICB9XFxuICAgIFwifSxYcz1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdO3ZhciBuPXQubGVuZ3RoO2lmKG4+NCl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBiYWNrZW5kOiBSZXZlcnNlIG9mIHJhbmstXCIrbitcIiB0ZW5zb3IgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7aWYodGhpcy5vdXRwdXRTaGFwZT10LDEhPT1uKXt2YXIgcj10Lm1hcCgoZnVuY3Rpb24obixyKXtyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuLTEhPT1lLmluZGV4T2YobikmJjEhPT10W25dP3Rbbl0rXCIgLSBjb29yZHNbXCIrbitcIl0gLSAxXCI6XCJjb29yZHNbXCIrbitcIl1cIn0ocil9KSkuam9pbihcIixcIiksbz11aShuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrbytcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRYKFwiK3IrXCIpKTtcXG4gICAgICB9XFxuICAgIFwifWVsc2UgdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpbnQgY29vcmQgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIrdFswXStcIiAtIGNvb3JkIC0gMSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifSxZcz1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwO3ZhciBuPXQubGVuZ3RoO2lmKG4+NCl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHTCBiYWNrZW5kOiBSZXZlcnNlIG9mIHJhbmstXCIrbitcIiB0ZW5zb3IgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7dGhpcy5vdXRwdXRTaGFwZT10O3ZhciByPVhhKFwicmNcIixuKSxvPXJbbi0xXStcIiArIDEgPCBcIit0aGlzLm91dHB1dFNoYXBlW24tMV0sYT1yW24tMl0rXCIgKyAxIDwgXCIrdGhpcy5vdXRwdXRTaGFwZVtuLTJdLGk9dWkobik7ZnVuY3Rpb24gcyhuKXt2YXIgcj10Lm1hcCgoZnVuY3Rpb24ocixvKXtyZXR1cm4gZnVuY3Rpb24obixyKXtyZXR1cm4tMSE9PWUuaW5kZXhPZihuKSYmMSE9PXRbbl0/dFtuXStcIiAtIFwiK3Jbbl0rXCIgLSAxXCI6XCJcIityW25dfShvLG4pfSkpO3JldHVyblwiZ2V0Q2hhbm5lbChnZXRYKFwiK3Iuam9pbihcIixcIikrXCIpLCB2ZWMyKFwiK3Iuc2xpY2UoLTIpLmpvaW4oXCIsXCIpK1wiKSlcIn10aGlzLnVzZXJDb2RlPTE9PT1uP1wiXFxuICAgICAgICB2b2lkIG1haW4oKXtcXG4gICAgICAgICAgaW50IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICAgIHJlc3VsdC5yID0gZ2V0Q2hhbm5lbChnZXRYKFwiK3RbMF0rXCIgLSByYyAtIDEpLFxcbiAgICAgICAgICAgIFwiK3RbMF0rXCIgLSByYyAtIDEpO1xcbiAgICAgICAgICBpZihcIitvK1wiKXtcXG4gICAgICAgICAgICAgIHJlc3VsdC5nID0gZ2V0Q2hhbm5lbChnZXRYKFwiK3RbMF0rXCIgLSAocmMgICsgMSkgLSAxKSxcXG4gICAgICAgICAgICAgICAgXCIrdFswXStcIiAtIChyYyAgKyAxKSAtIDEpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiOlwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIFwiK2krXCIgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgcmVzdWx0LnIgPSBcIitmdW5jdGlvbih0KXtyZXR1cm4gcyh0KX0oci5zbGljZSgpKStcIjtcXG4gICAgICAgICAgaWYoXCIrbytcIil7XFxuICAgICAgICAgICAgcmVzdWx0LmcgPSBcIitmdW5jdGlvbih0KXtyZXR1cm4gdFtuLTFdPVwiKFwiK3Rbbi0xXStcIiArIDEpXCIscyh0KX0oci5zbGljZSgpKStcIjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZihcIithK1wiKSB7XFxuICAgICAgICAgICAgcmVzdWx0LmIgPSBcIitmdW5jdGlvbih0KXtyZXR1cm4gdFtuLTJdPVwiKFwiK3Rbbi0yXStcIiArIDEpXCIscyh0KX0oci5zbGljZSgpKStcIjtcXG4gICAgICAgICAgICBpZihcIitvK1wiKSB7XFxuICAgICAgICAgICAgICByZXN1bHQuYSA9IFwiK2Z1bmN0aW9uKHQpe3JldHVybiB0W24tMV09XCIoXCIrdFtuLTFdK1wiICsgMSlcIix0W24tMl09XCIoXCIrdFtuLTJdK1wiICsgMSlcIixzKHQpfShyLnNsaWNlKCkpK1wiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICAgIH1cXG4gICAgXCJ9LCRzPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWkmJihpPSEwKSx0aGlzLnZhcmlhYmxlTmFtZXM9W1widXBkYXRlc1wiLFwiaW5kaWNlc1wiLFwiZGVmYXVsdFZhbHVlXCJdLHRoaXMub3V0cHV0U2hhcGU9YTt2YXIgcz11aShvLmxlbmd0aCksdT11aShhLmxlbmd0aCksYz1cIlwiOzE9PT1uP2M9XCJpXCI6Mj09PW4mJihjPVwiaSwgalwiKTt2YXIgbD1cImdldEluZGljZXMoXCIrYytcIilcIixoPVwiXCI7MT09PXI/aD1cImlcIjoyPT09ciYmKGg9XCJpLCBjb29yZHNbMV1cIik7dmFyIGY9XCJnZXRVcGRhdGVzKFwiK2grXCIpXCIsZD1lPjE/XCJzdHJpZGVzW2pdXCI6XCJzdHJpZGVzXCI7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgICAgXCIrcytcIiBzdHJpZGVzID0gXCIrcytcIihcIitvK1wiKTtcXG5cXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgXCIrdStcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICAgICAgICBib29sIGZvdW5kID0gZmFsc2U7XFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIrdCtcIjsgaSsrKSB7XFxuICAgICAgICAgICAgaW50IGZsYXR0ZW5lZEluZGV4ID0gMDtcXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IFwiK2UrXCI7IGorKykge1xcbiAgICAgICAgICAgICAgaW50IGluZGV4ID0gcm91bmQoXCIrbCtcIik7XFxuICAgICAgICAgICAgICBmbGF0dGVuZWRJbmRleCArPSBpbmRleCAqIFwiK2QrXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChmbGF0dGVuZWRJbmRleCA9PSBjb29yZHNbMF0pIHtcXG4gICAgICAgICAgICAgIHN1bSArPSBcIitmK1wiO1xcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzZXRPdXRwdXQobWl4KGdldERlZmF1bHRWYWx1ZSgpLCBzdW0sIGZsb2F0KGZvdW5kKSkpO1xcbiAgICAgICAgfVxcbiAgICAgIFwifSxRcz1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJ4XCIsXCJzZWdtZW50SWRzXCJdO3ZhciBuPXQud2luZG93U2l6ZSxyPXQuYmF0Y2hTaXplLG89dC5pblNpemUsYT10Lm51bVNlZ21lbnRzLGk9YSpNYXRoLmNlaWwoby9uKTt0aGlzLm91dHB1dFNoYXBlPVtyLGldO3ZhciBzPTQqTWF0aC5mbG9vcihuLzQpLHU9biU0LGM9XCJcXG4gICAgICAgIHN1bVZhbHVlICs9IGRvdCh2YWx1ZXMsIHNlZ0ZpbHRlcik7XFxuICAgIFwiLGw9XCJcIjtvJW4+MCYmKGw9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIik7dmFyIGg9XCJcIjtvJW4+MCYmKGg9XCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIrbytcIikge1xcbiAgICAgICAgICByZXR1cm4gLTEuMDtcXG4gICAgICAgIH1cXG4gICAgICBcIiksdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIGNvbnN0IGZsb2F0IGluaXRpYWxpemF0aW9uVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoaW50IGJhdGNoLCBpbnQgaW5JZHgpIHtcXG4gICAgICAgIFwiK2wrXCJcXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCBpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIGZsb2F0IGdldFNlZ21lbnRJZEF0SW5kZXgoaW50IGluSWR4KSB7XFxuICAgICAgICBcIitoK1wiXFxuICAgICAgICByZXR1cm4gZ2V0U2VnbWVudElkcyhpbklkeCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMyIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IG91dElkeCA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBpbk9mZnNldCA9IGludChmbG9vcihmbG9hdChvdXRJZHgpIC8gZmxvYXQoXFxuICAgICAgICAgIFwiK2ErXCIpKSAqIGZsb2F0KFwiK24rXCIpKTtcXG4gICAgICAgIGludCBjdXJyZW50U2VnID0gaW50KG1vZChmbG9hdChvdXRJZHgpLCBmbG9hdChcIithK1wiKSkpO1xcblxcbiAgICAgICAgZmxvYXQgc3VtVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiK3MrXCI7IGkgKz0gNCkge1xcbiAgICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIGk7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDMpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIHZlYzQgc2VnRmlsdGVyID0gdmVjNChcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDEpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAyKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMykpID09IGN1cnJlbnRTZWcgPyAxIDogMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitjK1wiXFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnQgaW5JZHggPSBpbk9mZnNldCArIFwiK3MrXCI7XFxuICAgICAgICBpZiAoXCIrKDE9PT11KStcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBpbnQgaW5JZHhTZWcgPSBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCkpO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrYytcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMj09PXUpK1wiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICB2ZWM0IHNlZ0ZpbHRlciA9IHZlYzQoXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHgpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgaW50KGdldFNlZ21lbnRJZEF0SW5kZXgoaW5JZHggKyAxKSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgICAgMCxcXG4gICAgICAgICAgICAgIDBcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIrYytcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIisoMz09PXUpK1wiKSB7XFxuICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHgpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDEpLFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCArIDIpLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgdmVjNCBzZWdGaWx0ZXIgPSB2ZWM0KFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4KSkgPT0gY3VycmVudFNlZyA/IDEgOiAwLFxcbiAgICAgICAgICAgIGludChnZXRTZWdtZW50SWRBdEluZGV4KGluSWR4ICsgMSkpID09IGN1cnJlbnRTZWcgPyAxIDogMCxcXG4gICAgICAgICAgICBpbnQoZ2V0U2VnbWVudElkQXRJbmRleChpbklkeCArIDIpKSA9PSBjdXJyZW50U2VnID8gMSA6IDAsXFxuICAgICAgICAgICAgMFxcbiAgICAgICAgICApO1xcblxcbiAgICAgICAgICBcIitjK1wiXFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoc3VtVmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCJ9LEpzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixvO2lmKHRoaXMudmFyaWFibGVOYW1lcz1bXCJjXCIsXCJhXCIsXCJiXCJdLHRoaXMub3V0cHV0U2hhcGU9ZSxuPjQpdGhyb3cgRXJyb3IoXCJXaGVyZSBmb3IgcmFuayBcIituK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDE9PT1uKW89XCJyZXNSQ1wiLHI9XCJyZXNSQ1wiO2Vsc2V7Zm9yKHZhciBhPVtcInJlc1JDLnhcIixcInJlc1JDLnlcIixcInJlc1JDLnpcIixcInJlc1JDLndcIl0saT1bXSxzPVtdLHU9MDt1PGUubGVuZ3RoO3UrKylzLnB1c2goXCJcIithW3VdKSx1PHQmJmkucHVzaChcIlwiK2FbdV0pO3I9aS5qb2luKCksbz1zLmpvaW4oKX12YXIgYz11aShuKTt0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIrYytcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgY1ZhbCA9IGdldEMoXCIrcitcIik7XFxuICAgICAgICBpZiAoY1ZhbCA+PSAxLjApIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIrbytcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KGdldEIoXCIrbytcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCJ9LFpzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wic291cmNlXCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnJhbms9dC5sZW5ndGg7dmFyIGUsbj11aSh0aGlzLnJhbmspLHI9XCJ1bmlmb3JtIGludCBzdGFydFtcIit0aGlzLnJhbmsrXCJdO1wiLG89ZnVuY3Rpb24odCl7aWYoMT09PXQpcmV0dXJuXCJzb3VyY2VMb2NcIjtpZih0PD02KXJldHVybiB0dS5zbGljZSgwLHQpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuXCJzb3VyY2VMb2MuXCIrdH0pKS5qb2luKFwiLFwiKTt0aHJvdyBFcnJvcihcIlNsaWNpbmcgZm9yIHJhbmsgXCIrdCtcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKX0odGhpcy5yYW5rKTtlPVwiXFxuICAgICAgICBcIituK1wiIHNvdXJjZUxvYztcXG4gICAgICAgIFwiK24rXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBcIit0Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cInNvdXJjZUxvYy5cIit0dVtlXStcIiA9IHN0YXJ0W1wiK2UrXCJdICsgY29vcmRzLlwiK3R1W2VdK1wiO1wifSkpLmpvaW4oXCJcXG5cIikrXCJcXG4gICAgICBcIix0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrcitcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2UrXCJcXG4gICAgICAgIHNldE91dHB1dChnZXRTb3VyY2UoXCIrbytcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9cmV0dXJuIHQucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKHQubGVuZ3RoIT09dGhpcy5yYW5rKXRocm93IEVycm9yKFwiVGhlIHJhbmsgKFwiK3RoaXMucmFuaytcIikgb2YgdGhlIHByb2dyYW0gbXVzdCBtYXRjaCB0aGUgbGVuZ3RoIG9mIHN0YXJ0IChcIit0Lmxlbmd0aCtcIilcIik7cmV0dXJuIGZ1bmN0aW9uKG4scil7bnVsbD09ZS5zdGFydExvYyYmKGUuc3RhcnRMb2M9bi5nZXRVbmlmb3JtTG9jYXRpb25Ob1Rocm93KHIsXCJzdGFydFwiKSxudWxsPT1lLnN0YXJ0TG9jKXx8bi5nbC51bmlmb3JtMWl2KGUuc3RhcnRMb2MsdCl9fSx0fSgpLHR1PVtcInhcIixcInlcIixcInpcIixcIndcIixcInVcIixcInZcIl07dmFyIGV1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wic291cmNlXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnJhbms9dC5sZW5ndGg7dmFyIGU9dWkodGhpcy5yYW5rKSxuPVhhKFwiY29vcmRzXCIsdGhpcy5yYW5rKSxyPVhhKFwic291cmNlTG9jXCIsdGhpcy5yYW5rKSxvPTE9PT10aGlzLnJhbms/XCJzb3VyY2VMb2NcIjpcInZlYzIoXCIrci5zbGljZSgtMikuam9pbigpK1wiKVwiLGE9XCJnZXRDaGFubmVsKGdldFNvdXJjZShcIityLmpvaW4oKStcIiksIFwiK28rXCIpXCIsaT1cIlxcbiAgICAgIHJlc3VsdC54ID0gXCIrYStcIjtcXG4gICAgICBpZiAoKytcIituW3RoaXMucmFuay0xXStcIiA8IFwiK3RbdGhpcy5yYW5rLTFdK1wiKSB7XFxuICAgICAgICArK1wiK3JbdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgICAgcmVzdWx0LnkgPSBcIithK1wiO1xcbiAgICAgICAgLS1cIityW3RoaXMucmFuay0xXStcIjtcXG4gICAgICB9XFxuICAgIFwiLHM9MT09PXRoaXMucmFuaz9cIlwiOlwiXFxuICAgICAgLS1cIituW3RoaXMucmFuay0xXStcIjtcXG4gICAgICBpZiAoKytcIituW3RoaXMucmFuay0yXStcIiA8IFwiK3RbdGhpcy5yYW5rLTJdK1wiKSB7XFxuICAgICAgICArK1wiK3JbdGhpcy5yYW5rLTJdK1wiO1xcbiAgICAgICAgcmVzdWx0LnogPSBcIithK1wiO1xcbiAgICAgICAgaWYgKCsrXCIrblt0aGlzLnJhbmstMV0rXCIgPCBcIit0W3RoaXMucmFuay0xXStcIikge1xcbiAgICAgICAgICArK1wiK3JbdGhpcy5yYW5rLTFdK1wiO1xcbiAgICAgICAgICByZXN1bHQudyA9IFwiK2ErXCI7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICBcIix1PXRoaXMucmFuazw9ND9cInNvdXJjZUxvYyA9IGNvb3JkcyArXFxuICAgICAgICAgICAgXCIrZStcIihcIit0Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm5cInN0YXJ0W1wiK2UrXCJdXCJ9KSkuam9pbigpK1wiKTtcIjp0Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gcltlXStcIiA9IFwiK25bZV0rXCIgKyBzdGFydFtcIitlK1wiXTtcIn0pKS5qb2luKFwiXFxuXCIpO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB1bmlmb3JtIGludCBzdGFydFtcIit0aGlzLnJhbmsrXCJdO1xcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK2UrXCIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBcIitlK1wiIHNvdXJjZUxvYztcXG4gICAgICAgIFwiK3UrXCJcXG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNCgwLik7XFxuICAgICAgICBcIitpK1wiXFxuICAgICAgICBcIitzK1wiXFxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgICB9XFxuICAgIFwifXJldHVybiB0LnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZih0Lmxlbmd0aCE9PXRoaXMucmFuayl0aHJvdyBFcnJvcihcIlRoZSByYW5rIChcIit0aGlzLnJhbmsrXCIpIG9mIHRoZSBwcm9ncmFtIG11c3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiBzdGFydCAoXCIrdC5sZW5ndGgrXCIpXCIpO3JldHVybiBmdW5jdGlvbihuLHIpe251bGw9PWUuc3RhcnRMb2MmJihlLnN0YXJ0TG9jPW4uZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyhyLFwic3RhcnRcIiksbnVsbD09ZS5zdGFydExvYyl8fG4uZ2wudW5pZm9ybTFpdihlLnN0YXJ0TG9jLHQpfX0sdH0oKSxudT1mdW5jdGlvbih0LGUsbil7dGhpcy52YXJpYWJsZU5hbWVzPVtcInhcIl0sdGhpcy5vdXRwdXRTaGFwZT1uO3ZhciByPW4ubGVuZ3RoLG89dWkobi5sZW5ndGgpLGE9dWkobi5sZW5ndGgpLGk9XCJcIjtpZigxPT09cilpPVwiY29vcmRzICogc3RyaWRlcyArIGJlZ2luXCI7ZWxzZXt2YXIgcz0wO2k9bi5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHMrKywxPT09bi5sZW5ndGg/XCJjb29yZHMgKiBzdHJpZGVzW1wiK2UrXCJdICsgYmVnaW5bXCIrZStcIl1cIjpcImNvb3Jkc1tcIisocy0xKStcIl0gKiBzdHJpZGVzW1wiK2UrXCJdICsgYmVnaW5bXCIrZStcIl1cIn0pKS5qb2luKFwiLFwiKX10aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgXCIrbytcIiBiZWdpbiA9IFwiK28rXCIoXCIrdCtcIik7XFxuICAgICAgXCIrbytcIiBzdHJpZGVzID0gXCIrbytcIihcIitlK1wiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIithK1wiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldFgoXCIraStcIikpO1xcbiAgICAgIH1cXG4gICAgXCJ9LHJ1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmdwZ3B1PXQsdGhpcy5udW1Vc2VkVGV4dHVyZXM9MCx0aGlzLm51bUZyZWVUZXh0dXJlcz0wLHRoaXMuZnJlZVRleHR1cmVzPXt9LHRoaXMubG9nRW5hYmxlZD0hMSx0aGlzLnVzZWRUZXh0dXJlcz17fX1yZXR1cm4gdC5wcm90b3R5cGUuYWNxdWlyZVRleHR1cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG89b3UoZSxuKSxhPWF1KHQsbyxuKTtpZihhIGluIHRoaXMuZnJlZVRleHR1cmVzfHwodGhpcy5mcmVlVGV4dHVyZXNbYV09W10pLGEgaW4gdGhpcy51c2VkVGV4dHVyZXN8fCh0aGlzLnVzZWRUZXh0dXJlc1thXT1bXSksdGhpcy5mcmVlVGV4dHVyZXNbYV0ubGVuZ3RoPjApe3RoaXMubnVtRnJlZVRleHR1cmVzLS0sdGhpcy5udW1Vc2VkVGV4dHVyZXMrKyx0aGlzLmxvZygpO3ZhciBpPXRoaXMuZnJlZVRleHR1cmVzW2FdLnNoaWZ0KCk7cmV0dXJuIHRoaXMudXNlZFRleHR1cmVzW2FdLnB1c2goaSksaX1yZXR1cm4gdGhpcy5udW1Vc2VkVGV4dHVyZXMrKyx0aGlzLmxvZygpLG89PT1HdC5QQUNLRURfMlgyX0ZMT0FUMzI/cj10aGlzLmdwZ3B1LmNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmUodFswXSx0WzFdKTpvPT09R3QuUEFDS0VEXzJYMl9GTE9BVDE2P3I9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDE2UGFja2VkTWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pOm89PT1HdC5VTlBBQ0tFRF9GTE9BVDMyP3I9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pOm89PT1HdC5VTlBBQ0tFRF9GTE9BVDE2P3I9dGhpcy5ncGdwdS5jcmVhdGVGbG9hdDE2TWF0cml4VGV4dHVyZSh0WzBdLHRbMV0pOm89PT1HdC5QQUNLRURfNFgxX1VOU0lHTkVEX0JZVEUmJihyPXRoaXMuZ3BncHUuY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmUodFswXSx0WzFdKSksdGhpcy51c2VkVGV4dHVyZXNbYV0ucHVzaChyKSxyfSx0LnByb3RvdHlwZS5yZWxlYXNlVGV4dHVyZT1mdW5jdGlvbih0LGUsbixyKXtpZihudWxsIT10aGlzLmZyZWVUZXh0dXJlcyl7dmFyIG89YXUoZSxvdShuLHIpLHIpO28gaW4gdGhpcy5mcmVlVGV4dHVyZXN8fCh0aGlzLmZyZWVUZXh0dXJlc1tvXT1bXSksdGhpcy5mcmVlVGV4dHVyZXNbb10ucHVzaCh0KSx0aGlzLm51bUZyZWVUZXh0dXJlcysrLHRoaXMubnVtVXNlZFRleHR1cmVzLS07dmFyIGE9dGhpcy51c2VkVGV4dHVyZXNbb10saT1hLmluZGV4T2YodCk7aWYoaTwwKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWxlYXNlIGEgdGV4dHVyZSB0aGF0IHdhcyBuZXZlciBwcm92aWRlZCBieSB0aGlzIHRleHR1cmUgbWFuYWdlclwiKTthLnNwbGljZShpLDEpLHRoaXMubG9nKCl9fSx0LnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtpZih0aGlzLmxvZ0VuYWJsZWQpe3ZhciB0PXRoaXMubnVtRnJlZVRleHR1cmVzK3RoaXMubnVtVXNlZFRleHR1cmVzO2NvbnNvbGUubG9nKFwiRnJlZS9Vc2VkXCIsdGhpcy5udW1GcmVlVGV4dHVyZXMrXCIgLyBcIit0aGlzLm51bVVzZWRUZXh0dXJlcyxcIihcIit0K1wiKVwiKX19LHQucHJvdG90eXBlLmdldE51bVVzZWRUZXh0dXJlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm51bVVzZWRUZXh0dXJlc30sdC5wcm90b3R5cGUuZ2V0TnVtRnJlZVRleHR1cmVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubnVtRnJlZVRleHR1cmVzfSx0LnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztpZihudWxsIT10aGlzLmZyZWVUZXh0dXJlcyl7Zm9yKHZhciBlIGluIHRoaXMuZnJlZVRleHR1cmVzKXRoaXMuZnJlZVRleHR1cmVzW2VdLmZvckVhY2goKGZ1bmN0aW9uKGUpe3QuZ3BncHUuZGVsZXRlTWF0cml4VGV4dHVyZShlKX0pKTtmb3IodmFyIGUgaW4gdGhpcy51c2VkVGV4dHVyZXMpdGhpcy51c2VkVGV4dHVyZXNbZV0uZm9yRWFjaCgoZnVuY3Rpb24oZSl7dC5ncGdwdS5kZWxldGVNYXRyaXhUZXh0dXJlKGUpfSkpO3RoaXMuZnJlZVRleHR1cmVzPW51bGwsdGhpcy51c2VkVGV4dHVyZXM9bnVsbCx0aGlzLm51bVVzZWRUZXh0dXJlcz0wLHRoaXMubnVtRnJlZVRleHR1cmVzPTB9fSx0fSgpO2Z1bmN0aW9uIG91KHQsZSl7aWYodD09PXp0LlVQTE9BRClyZXR1cm4gR3QuUEFDS0VEXzJYMl9GTE9BVDMyO2lmKHQ9PT16dC5SRU5ERVJ8fG51bGw9PXQpcmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBpKCkuZ2V0Qm9vbChcIldFQkdMX1JFTkRFUl9GTE9BVDMyX0VOQUJMRURcIik/dD9HdC5QQUNLRURfMlgyX0ZMT0FUMzI6R3QuVU5QQUNLRURfRkxPQVQzMjp0P0d0LlBBQ0tFRF8yWDJfRkxPQVQxNjpHdC5VTlBBQ0tFRF9GTE9BVDE2fShlKTtpZih0PT09enQuRE9XTkxPQUR8fHQ9PT16dC5QSVhFTFMpcmV0dXJuIEd0LlBBQ0tFRF80WDFfVU5TSUdORURfQllURTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGxvZ2ljYWwgdGV4dHVyZSB0eXBlIFwiK3QpfWZ1bmN0aW9uIGF1KHQsZSxuKXtyZXR1cm4gdFswXStcIl9cIit0WzFdK1wiX1wiK2UrXCJfXCIrbn12YXIgaXU9ZnVuY3Rpb24odCxlKXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXTtmb3IodmFyIG49bmV3IEFycmF5KHQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDtyKyspbltyXT10W3JdKmVbcl07dGhpcy5vdXRwdXRTaGFwZT1uLHRoaXMucmFuaz1uLmxlbmd0aDt2YXIgbz11aSh0aGlzLnJhbmspLGE9ZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGg7aWYoZT41KXRocm93IEVycm9yKFwiVGlsZSBmb3IgcmFuayBcIitlK1wiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO2lmKDE9PT1lKXJldHVyblwiaW1vZChyZXNSQywgXCIrdFswXStcIilcIjtmb3IodmFyIG49W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiLFwicmVzUkMudVwiXSxyPVtdLG89MDtvPHQubGVuZ3RoO28rKylyLnB1c2goXCJpbW9kKFwiK25bb10rXCIsIFwiK3Rbb10rXCIpXCIpO3JldHVybiByLmpvaW4oKX0odCk7dGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiK28rXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRBKFwiK2ErXCIpKTtcXG4gICAgICB9XFxuICAgIFwifTt2YXIgc3U9MS43NTgwOTkzNDA4NDczNzY4LHV1PTEuMDUwNzAwOTg3MzU1NDgwNSxjdT1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgZmxvYXQgdW5hcnlPcGVyYXRpb24oZmxvYXQgeCkge1xcbiAgICAgICAgXCIrZStcIlxcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBmbG9hdCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICBmbG9hdCB5ID0gdW5hcnlPcGVyYXRpb24oeCk7XFxuXFxuICAgICAgICBzZXRPdXRwdXQoeSk7XFxuICAgICAgfVxcbiAgICBcIn0sbHU9XCJpZiAoaXNuYW4oeCkpIHJldHVybiB4O1wiLGh1PVwicmV0dXJuIHg7XCIsZnU9XCJyZXR1cm4gYWJzKHgpO1wiLGR1PWx1K1wiXFxuICByZXR1cm4gKHggPCAwLjApID8gMC4wIDogeDtcXG5cIixwdT1sdStcIlxcbiAgcmV0dXJuICh4IDwgMC4wKSA/IDAuMCA6IG1pbig2LjAsIHgpO1xcblwiLHZ1PVwicmV0dXJuICh4ID49IDAuMCkgPyB4IDogKGV4cCh4KSAtIDEuMCk7XCIsZ3U9XCJcXG4gIC8vIFN0YWJsZSBhbmQgQXR0cmFjdGluZyBGaXhlZCBQb2ludCAoMCwgMSkgZm9yIE5vcm1hbGl6ZWQgV2VpZ2h0cy5cXG4gIC8vIHNlZTogaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDYuMDI1MTVcXG4gIGZsb2F0IHNjYWxlQWxwaGEgPSBcIitzdStcIjtcXG4gIGZsb2F0IHNjYWxlID0gXCIrdXUrXCI7XFxuICByZXR1cm4gKHggPj0gMC4wKSA/IHNjYWxlICogeCA6IHNjYWxlQWxwaGEgKiAoZXhwKHgpIC0gMS4wKTtcXG5cIjt2YXIgbXU9XCJyZXR1cm4gLXg7XCIseXU9XCJyZXR1cm4gY2VpbCh4KTtcIix4dT1cInJldHVybiBmbG9vcih4KTtcIixidT1cInJldHVybiBleHAoeCk7XCIsd3U9XCJyZXR1cm4gZXhwKHgpIC0gMS4wO1wiLEN1PWx1K1wiXFxuICByZXR1cm4gc2luKHgpO1xcblwiLEV1PWx1K1wiXFxuICByZXR1cm4gY29zKHgpO1xcblwiLFJ1PWx1K1wiXFxuICBpZiAoYWJzKHgpID4gMS4pIHtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG4gIHJldHVybiBhc2luKHgpO1xcblwiLEl1PWx1K1wiXFxuICBpZiAoYWJzKHgpID4gMS4pIHtcXG4gICAgcmV0dXJuIE5BTjtcXG4gIH1cXG4gIHJldHVybiBhY29zKHgpO1xcblwiLGt1PWx1K1wiXFxuICByZXR1cm4gYXRhbih4KTtcXG5cIixTdT1sdStcInJldHVybiBsb2coeCArIHNxcnQoeCAqIHggKyAxLjApKTtcIixBdT1sdStcIlxcbiAgaWYgKHggPCAxLjApIHJldHVybiBOQU47XFxuICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4IC0gMS4wKSk7XCIsVHU9bHUrXCJcXG4gIGlmICgoeCA8IC0xLjApIHx8ICh4ID4gMS4wKSkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiAobG9nKDEuMCArIHgpIC0gbG9nKDEuMCAtIHgpKSAvIDIuMDtcIixEdT1cInJldHVybiB4O1wiLE51PVwicmV0dXJuIHg7XCIsRnU9XCJcXG4gIHZlYzQgcmVzdWx0ID0geCAqIHZlYzQoZ3JlYXRlclRoYW5FcXVhbCh4LCB2ZWM0KDAuMCkpKTtcXG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XFxuXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID8geC5iIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsX3U9XCJcXG4gIHZlYzQgcmVzdWx0ID0gbWluKHgsIHZlYzQoNi4pKSAqIHZlYzQoZ3JlYXRlclRoYW5FcXVhbCh4LCB2ZWM0KDAuMCkpKTtcXG4gIGJ2ZWM0IGlzTmFOID0gaXNuYW4oeCk7XFxuXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPyB4LnIgOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA/IHguZyA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID8geC5iIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPyB4LmEgOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsT3U9XCJcXG4gIHZlYzQgcmVzdWx0O1xcblxcbiAgcmVzdWx0LnIgPSAoeC5yID49IDAuMCkgPyB4LnIgOiAoZXhwKHgucikgLSAxLjApO1xcbiAgcmVzdWx0LmcgPSAoeC5nID49IDAuMCkgPyB4LmcgOiAoZXhwKHguZykgLSAxLjApO1xcbiAgcmVzdWx0LmIgPSAoeC5iID49IDAuMCkgPyB4LmIgOiAoZXhwKHguYikgLSAxLjApO1xcbiAgcmVzdWx0LmEgPSAoeC5hID49IDAuMCkgPyB4LmEgOiAoZXhwKHguYSkgLSAxLjApO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIixNdT1mdW5jdGlvbih0LGUpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdLHRoaXMucGFja2VkSW5wdXRzPSEwLHRoaXMucGFja2VkT3V0cHV0PSEwLHRoaXMub3V0cHV0U2hhcGU9dCx0aGlzLnVzZXJDb2RlPVwiXFxuICAgICAgdmVjNCB1bmFyeU9wZXJhdGlvbih2ZWM0IHgpIHtcXG4gICAgICAgIFwiK2UrXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCB4ID0gZ2V0QUF0T3V0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHkgPSB1bmFyeU9wZXJhdGlvbih4KTtcXG5cXG4gICAgICAgIHNldE91dHB1dCh5KTtcXG4gICAgICB9XFxuICAgIFwifSxCdT1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMCx0aGlzLnBhY2tlZE91dHB1dD0hMSx0aGlzLm91dHB1dFNoYXBlPXQ7dmFyIGU9dC5sZW5ndGgsbj1YYShcInJjXCIsZSkscj11aShlKSxvPWZ1bmN0aW9uKHQsZSl7aWYoMT09PXQpcmV0dXJuXCJyY1wiO2Zvcih2YXIgbj1cIlwiLHI9MDtyPHQ7cisrKW4rPWVbcl0scjx0LTEmJihuKz1cIixcIik7cmV0dXJuIG59KGUsbiksYT1uLnNsaWNlKC0yKSxpPWU8PTE/XCJyY1wiOlwidmVjMihcIithLmpvaW4oXCIsXCIpK1wiKVwiO3RoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIityK1wiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICB2ZWM0IHBhY2tlZElucHV0ID0gZ2V0QShcIitvK1wiKTtcXG5cXG4gICAgICAgIHNldE91dHB1dChnZXRDaGFubmVsKHBhY2tlZElucHV0LCBcIitpK1wiKSk7XFxuICAgICAgfVxcbiAgICBcIn0sUHU9e307ZnVuY3Rpb24gTHUodCxlKXtpZih2b2lkIDA9PT1lJiYoZT0hMSksXCJsaW5lYXJcIj09PXQpcmV0dXJuIGU/TnU6aHU7aWYoXCJyZWx1XCI9PT10KXJldHVybiBlP0Z1OmR1O2lmKFwiZWx1XCI9PT10KXJldHVybiBlP091OnZ1O2lmKFwicmVsdTZcIj09PXQpcmV0dXJuIGU/X3U6cHU7aWYoXCJwcmVsdVwiPT09dClyZXR1cm4gZT9raTpFaTt0aHJvdyBuZXcgRXJyb3IoXCJBY3RpdmF0aW9uIFwiK3QrXCIgaGFzIG5vdCBiZWVuIGltcGxlbWVudGVkIGZvciB0aGUgV2ViR0wgYmFja2VuZC5cIil9dmFyIFd1PTYwMDt2YXIgVXU9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlKXt2YXIgbixyPXQuY2FsbCh0aGlzKXx8dGhpcztpZihyLnBlbmRpbmdSZWFkPW5ldyBXZWFrTWFwLHIucGVuZGluZ0Rpc3Bvc2FsPW5ldyBXZWFrU2V0LHIuZGF0YVJlZkNvdW50PW5ldyBXZWFrTWFwLHIubnVtQnl0ZXNJbkdQVT0wLHIudXBsb2FkV2FpdE1zPTAsci5kb3dubG9hZFdhaXRNcz0wLHIud2FybmVkQWJvdXRNZW1vcnk9ITEsci5wZW5kaW5nRGVsZXRlcz0wLHIuZGlzcG9zZWQ9ITEsIWkoKS5nZXRCb29sKFwiSEFTX1dFQkdMXCIpKXRocm93IG5ldyBFcnJvcihcIldlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2VcIik7aWYobnVsbD09ZSl7dmFyIG89anQoaSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpO3IuYmluYXJ5Q2FjaGU9KG49aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikpaW4gUHU/UHVbbl06KFB1W25dPXt9LFB1W25dKSxyLmdwZ3B1PW5ldyBJcyhvKSxyLmNhbnZhcz1vLmNhbnZhcyxyLmdwZ3B1Q3JlYXRlZExvY2FsbHk9ITB9ZWxzZSByLmdwZ3B1PWUsci5iaW5hcnlDYWNoZT17fSxyLmdwZ3B1Q3JlYXRlZExvY2FsbHk9ITEsci5jYW52YXM9ZS5nbC5jYW52YXM7cmV0dXJuIHIudGV4dHVyZU1hbmFnZXI9bmV3IHJ1KHIuZ3BncHUpLHIubnVtTUJCZWZvcmVXYXJuaW5nPW51bGw9PWkoKS5nbG9iYWwuc2NyZWVuPzEwMjQ6aSgpLmdsb2JhbC5zY3JlZW4uaGVpZ2h0KmkoKS5nbG9iYWwuc2NyZWVuLndpZHRoKndpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKld1LzEwMjQvMTAyNCxyLnRleERhdGE9bmV3IGNhKHIsTHQpLHJ9cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS5udW1EYXRhSWRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4RGF0YS5udW1EYXRhSWRzKCkrKHRoaXMuY3B1QmFja2VuZD90aGlzLmNwdUJhY2tlbmQubnVtRGF0YUlkcygpOjApLXRoaXMucGVuZGluZ0RlbGV0ZXN9LG8ucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQsZSxuKXtpZihpKCkuZ2V0Qm9vbChcIkRFQlVHXCIpJiZ0aGlzLmNoZWNrTnVtZXJpY2FsUHJvYmxlbXModCksXCJjb21wbGV4NjRcIj09PW4mJm51bGwhPXQpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHdyaXRlIHRvIGEgY29tcGxleDY0IGR0eXBlLiBQbGVhc2UgdXNlIHRmLmNvbXBsZXgocmVhbCwgaW1hZykuXCIpO3ZhciByPXt9O3JldHVybiB0aGlzLnRleERhdGEuc2V0KHIse3NoYXBlOmUsZHR5cGU6bix2YWx1ZXM6dCx1c2FnZTp6dC5VUExPQUR9KSxyfSxvLnByb3RvdHlwZS5tb3ZlPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKGkoKS5nZXRCb29sKFwiREVCVUdcIikmJnRoaXMuY2hlY2tOdW1lcmljYWxQcm9ibGVtcyhlKSxcImNvbXBsZXg2NFwiPT09cil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgd3JpdGUgdG8gYSBjb21wbGV4NjQgZHR5cGUuIFBsZWFzZSB1c2UgdGYuY29tcGxleChyZWFsLCBpbWFnKS5cIik7dGhpcy50ZXhEYXRhLnNldCh0LHtzaGFwZTpuLGR0eXBlOnIsdmFsdWVzOmUsdXNhZ2U6enQuVVBMT0FEfSl9LG8ucHJvdG90eXBlLnJlYWRTeW5jPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQodCksbj1lLnZhbHVlcyxyPWUuZHR5cGUsbz1lLmNvbXBsZXhUZW5zb3JzLGE9ZS5zbGljZSxpPWUuc2hhcGUscz1lLmlzUGFja2VkO2lmKG51bGwhPWEpe3ZhciB1PXZvaWQgMDt1PXM/bmV3IE11KGksRHUpOm5ldyBjdShpLER1KTt2YXIgYz10aGlzLnJ1bldlYkdMUHJvZ3JhbSh1LFt7ZGF0YUlkOnQsc2hhcGU6aSxkdHlwZTpyfV0sciksbD10aGlzLnJlYWRTeW5jKGMuZGF0YUlkKTtyZXR1cm4gdGhpcy5kaXNwb3NlRGF0YShjLmRhdGFJZCksbH1pZihudWxsIT1uKXJldHVybiB0aGlzLmNvbnZlcnRBbmRDYWNoZU9uQ1BVKHQpO2lmKFwic3RyaW5nXCI9PT1yKXJldHVybiBuO3ZhciBoLGYsZD1udWxsIT10aGlzLmFjdGl2ZVRpbWVyczsoZCYmKGg9ZXQoKSksXCJjb21wbGV4NjRcIj09PXIpP2Y9QWEoby5yZWFsLmRhdGFTeW5jKCksby5pbWFnLmRhdGFTeW5jKCkpOmY9dGhpcy5nZXRWYWx1ZXNGcm9tVGV4dHVyZSh0KTtyZXR1cm4gZCYmKHRoaXMuZG93bmxvYWRXYWl0TXMrPWV0KCktaCksdGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0LGYpfSxvLnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG8sYSxzLHUsYyxsLGgsZixkLHAsdixnLG0seSx4LGIsdyxDLEUsUjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKHRoaXMucGVuZGluZ1JlYWQuaGFzKHQpKXJldHVybiBlPXRoaXMucGVuZGluZ1JlYWQuZ2V0KHQpLFsyLG5ldyBQcm9taXNlKChmdW5jdGlvbih0KXtyZXR1cm4gZS5wdXNoKHQpfSkpXTtpZihuPXRoaXMudGV4RGF0YS5nZXQodCksbz1uLnZhbHVlcyxhPW4uc2hhcGUscz1uLnNsaWNlLHU9bi5kdHlwZSxjPW4uY29tcGxleFRlbnNvcnMsbD1uLmlzUGFja2VkLG51bGwhPXMpcmV0dXJuIGg9dm9pZCAwLGg9bD9uZXcgTXUoYSxEdSk6bmV3IGN1KGEsRHUpLGY9dGhpcy5ydW5XZWJHTFByb2dyYW0oaCxbe2RhdGFJZDp0LHNoYXBlOmEsZHR5cGU6dX1dLHUpLGQ9dGhpcy5yZWFkKGYuZGF0YUlkKSx0aGlzLmRpc3Bvc2VEYXRhKGYuZGF0YUlkKSxbMixkXTtpZihudWxsIT1vKXJldHVyblsyLHRoaXMuY29udmVydEFuZENhY2hlT25DUFUodCldO2lmKCFpKCkuZ2V0Qm9vbChcIldFQkdMX0RPV05MT0FEX0ZMT0FUX0VOQUJMRURcIikmJjI9PT1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfVkVSU0lPTlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IuZGF0YSgpIHdpdGggV0VCR0xfRE9XTkxPQURfRkxPQVRfRU5BQkxFRD1mYWxzZSBhbmQgV0VCR0xfVkVSU0lPTj0yIG5vdCB5ZXQgc3VwcG9ydGVkLlwiKTtyZXR1cm4gcD1udWxsLFwiY29tcGxleDY0XCIhPT11JiZpKCkuZ2V0KFwiV0VCR0xfQlVGRkVSX1NVUFBPUlRFRFwiKSYmKHY9dGhpcy5kZWNvZGUodCksZz10aGlzLnRleERhdGEuZ2V0KHYuZGF0YUlkKSxwPShSPXRoaXMuZ3BncHUpLmNyZWF0ZUJ1ZmZlckZyb21UZXh0dXJlLmFwcGx5KFIsW2cudGV4dHVyZV0uY29uY2F0KFl0KGEpKSkpLHRoaXMucGVuZGluZ1JlYWQuc2V0KHQsW10pLFwiY29tcGxleDY0XCI9PT11P1szLDJdOls0LHRoaXMuZ3BncHUuY3JlYXRlQW5kV2FpdEZvckZlbmNlKCldO2Nhc2UgMTpyLnNlbnQoKSxyLmxhYmVsPTI7Y2FzZSAyOnJldHVyblwiY29tcGxleDY0XCIhPT11P1szLDRdOls0LFByb21pc2UuYWxsKFtjLnJlYWwuZGF0YSgpLGMuaW1hZy5kYXRhKCldKV07Y2FzZSAzOnJldHVybiB5PXIuc2VudCgpLHg9eVswXSxiPXlbMV0sbT1BYSh4LGIpLFszLDVdO2Nhc2UgNDpudWxsPT1wP209dGhpcy5nZXRWYWx1ZXNGcm9tVGV4dHVyZSh0KToodz1rKGEpLG09dGhpcy5ncGdwdS5kb3dubG9hZEZsb2F0MzJNYXRyaXhGcm9tQnVmZmVyKHAsdykpLHIubGFiZWw9NTtjYXNlIDU6cmV0dXJuIG51bGwhPXYmJnRoaXMuZGlzcG9zZURhdGEodi5kYXRhSWQpLEM9dGhpcy5jb252ZXJ0QW5kQ2FjaGVPbkNQVSh0LG0pLEU9dGhpcy5wZW5kaW5nUmVhZC5nZXQodCksdGhpcy5wZW5kaW5nUmVhZC5kZWxldGUodCksRS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdChDKX0pKSx0aGlzLnBlbmRpbmdEaXNwb3NhbC5oYXModCkmJih0aGlzLnBlbmRpbmdEaXNwb3NhbC5kZWxldGUodCksdGhpcy5kaXNwb3NlRGF0YSh0KSx0aGlzLnBlbmRpbmdEZWxldGVzLS0pLFsyLENdfX0pKX0pKX0sby5wcm90b3R5cGUuY2hlY2tOdW1lcmljYWxQcm9ibGVtcz1mdW5jdGlvbih0KXtpZihudWxsIT10KWZvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj10W2VdO2lmKCFlZShuKSl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9DQVBBQkxFXCIpKXRocm93IEVycm9yKFwiVGhlIHZhbHVlIFwiK24rXCIgY2Fubm90IGJlIHJlcHJlc2VudGVkIHdpdGggeW91ciBjdXJyZW50IHNldHRpbmdzLiBDb25zaWRlciBlbmFibGluZyBmbG9hdDMyIHJlbmRlcmluZzogJ3RmLmVudigpLnNldCgnV0VCR0xfUkVOREVSX0ZMT0FUMzJfRU5BQkxFRCcsIHRydWUpOydcIik7dGhyb3cgRXJyb3IoXCJUaGUgdmFsdWUgXCIrbitcIiBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgb24gdGhpcyBkZXZpY2UuXCIpfX19LG8ucHJvdG90eXBlLmdldFZhbHVlc0Zyb21UZXh0dXJlPWZ1bmN0aW9uKHQpe3ZhciBlLG49dGhpcy50ZXhEYXRhLmdldCh0KSxyPW4uc2hhcGUsbz1uLmR0eXBlLGE9bi5pc1BhY2tlZCxzPWsocik7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9ET1dOTE9BRF9GTE9BVF9FTkFCTEVEXCIpKXt2YXIgdT10aGlzLmRlY29kZSh0KSxjPXRoaXMudGV4RGF0YS5nZXQodS5kYXRhSWQpLGw9KGU9dGhpcy5ncGdwdSkuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZS5hcHBseShlLFtjLnRleHR1cmVdLmNvbmNhdChZdChyKSkpLnN1YmFycmF5KDAscyk7cmV0dXJuIHRoaXMuZGlzcG9zZURhdGEodS5kYXRhSWQpLGx9dmFyIGg9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLXCIpJiYhMD09PWEsZj1oP0RlKHIpOnIsZD1oP25ldyBKaShmKTpuZXcgUWkoZikscD10aGlzLnJ1bldlYkdMUHJvZ3JhbShkLFt7c2hhcGU6ZixkdHlwZTpvLGRhdGFJZDp0fV0sXCJmbG9hdDMyXCIpLHY9dGhpcy50ZXhEYXRhLmdldChwLmRhdGFJZCksZz10aGlzLmdwZ3B1LmRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKHYudGV4dHVyZSx2LnRleFNoYXBlWzBdLHYudGV4U2hhcGVbMV0pLnN1YmFycmF5KDAscyk7cmV0dXJuIHRoaXMuZGlzcG9zZURhdGEocC5kYXRhSWQpLGd9LG8ucHJvdG90eXBlLnRpbWU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4sbyxhLHMsdSxjO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGU9dGhpcy5hY3RpdmVUaW1lcnMsbj1bXSxvPSExLG51bGw9PXRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrPyh0aGlzLnByb2dyYW1UaW1lcnNTdGFjaz1uLG89ITApOnRoaXMuYWN0aXZlVGltZXJzLnB1c2gobiksdGhpcy5hY3RpdmVUaW1lcnM9bix0KCksYT1JKHRoaXMuYWN0aXZlVGltZXJzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQucXVlcnl9KSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPXR9KSkscz1JKHRoaXMuYWN0aXZlVGltZXJzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dH0pKSx0aGlzLmFjdGl2ZVRpbWVycz1lLG8mJih0aGlzLnByb2dyYW1UaW1lcnNTdGFjaz1udWxsKSx1PXt1cGxvYWRXYWl0TXM6dGhpcy51cGxvYWRXYWl0TXMsZG93bmxvYWRXYWl0TXM6dGhpcy5kb3dubG9hZFdhaXRNcyxrZXJuZWxNczpudWxsLHdhbGxNczpudWxsfSxpKCkuZ2V0TnVtYmVyKFwiV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFXCIpPjA/WzQsUHJvbWlzZS5hbGwoYSldOlszLDJdO2Nhc2UgMTpyZXR1cm4gYz1yLnNlbnQoKSx1Lmtlcm5lbE1zPXcoYyksdS5nZXRFeHRyYVByb2ZpbGVJbmZvPWZ1bmN0aW9uKCl7cmV0dXJuIGMubWFwKChmdW5jdGlvbih0LGUpe3JldHVybntuYW1lOnNbZV0sbXM6dH19KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lK1wiOiBcIit0Lm1zfSkpLmpvaW4oXCIsIFwiKX0sWzMsM107Y2FzZSAyOnUua2VybmVsTXM9e2Vycm9yOlwiV2ViR0wgcXVlcnkgdGltZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuXCJ9LHIubGFiZWw9MztjYXNlIDM6cmV0dXJuIHRoaXMudXBsb2FkV2FpdE1zPTAsdGhpcy5kb3dubG9hZFdhaXRNcz0wLFsyLHVdfX0pKX0pKX0sby5wcm90b3R5cGUubWVtb3J5PWZ1bmN0aW9uKCl7cmV0dXJue3VucmVsaWFibGU6ITEsbnVtQnl0ZXNJbkdQVTp0aGlzLm51bUJ5dGVzSW5HUFV9fSxvLnByb3RvdHlwZS5zdGFydFRpbWVyPWZ1bmN0aW9uKCl7cmV0dXJuIGkoKS5nZXROdW1iZXIoXCJXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fUkVMSUFCTEVcIik+MD90aGlzLmdwZ3B1LmJlZ2luUXVlcnkoKTp7c3RhcnRNczpldCgpLGVuZE1zOm51bGx9fSxvLnByb3RvdHlwZS5lbmRUaW1lcj1mdW5jdGlvbih0KXtyZXR1cm4gaSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiKT4wPyh0aGlzLmdwZ3B1LmVuZFF1ZXJ5KCksdCk6KHQuZW5kTXM9ZXQoKSx0KX0sby5wcm90b3R5cGUuZ2V0UXVlcnlUaW1lPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtyZXR1cm4gaSgpLmdldE51bWJlcihcIldFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRVwiKT4wP1syLHRoaXMuZ3BncHUud2FpdEZvclF1ZXJ5QW5kR2V0VGltZSh0KV06WzIsKGU9dCkuZW5kTXMtZS5zdGFydE1zXX0pKX0pKX0sby5wcm90b3R5cGUuZGlzcG9zZURhdGE9ZnVuY3Rpb24odCl7aWYoIXRoaXMucGVuZGluZ0Rpc3Bvc2FsLmhhcyh0KSl7aWYodGhpcy5wZW5kaW5nUmVhZC5oYXModCkpcmV0dXJuIHRoaXMucGVuZGluZ0Rpc3Bvc2FsLmFkZCh0KSx2b2lkIHRoaXMucGVuZGluZ0RlbGV0ZXMrKztpZih0aGlzLnRleERhdGEuaGFzKHQpKXt0aGlzLnJlbGVhc2VHUFVEYXRhKHQpO3ZhciBlPXRoaXMudGV4RGF0YS5nZXQodCkuY29tcGxleFRlbnNvcnM7bnVsbCE9ZSYmKGUucmVhbC5kaXNwb3NlKCksZS5pbWFnLmRpc3Bvc2UoKSksdGhpcy50ZXhEYXRhLmRlbGV0ZSh0KX19fSxvLnByb3RvdHlwZS5yZWxlYXNlR1BVRGF0YT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnRleERhdGEuZ2V0KHQpLG49ZS50ZXh0dXJlLHI9ZS5kdHlwZSxvPWUudGV4U2hhcGUsYT1lLnVzYWdlLGk9ZS5pc1BhY2tlZCxzPWUuc2xpY2UsdT1zJiZzLm9yaWdEYXRhSWR8fHQsYz10aGlzLmRhdGFSZWZDb3VudC5nZXQodSk7Yz4xP3RoaXMuZGF0YVJlZkNvdW50LnNldCh1LGMtMSk6KHRoaXMuZGF0YVJlZkNvdW50LmRlbGV0ZSh1KSxudWxsIT1uJiYodGhpcy5udW1CeXRlc0luR1BVLT10aGlzLmNvbXB1dGVCeXRlcyhvLHIpLHRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUobixvLGEsaSkpKTt2YXIgbD10aGlzLnRleERhdGEuZ2V0KHQpO2wudGV4dHVyZT1udWxsLGwudGV4U2hhcGU9bnVsbCxsLmlzUGFja2VkPSExLGwuc2xpY2U9bnVsbH0sby5wcm90b3R5cGUuZ2V0VGV4dHVyZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy51cGxvYWRUb0dQVSh0KSx0aGlzLnRleERhdGEuZ2V0KHQpLnRleHR1cmV9LG8ucHJvdG90eXBlLmdldERhdGFJbmZvPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRleERhdGEuZ2V0KHQpfSxvLnByb3RvdHlwZS5nZXRDUFVCYWNrZW5kPWZ1bmN0aW9uKCl7cmV0dXJuIGkoKS5nZXRCb29sKFwiV0VCR0xfQ1BVX0ZPUldBUkRcIik/KG51bGw9PXRoaXMuY3B1QmFja2VuZCYmKHRoaXMuY3B1QmFja2VuZD1MdC5maW5kQmFja2VuZChcImNwdVwiKSksdGhpcy5jcHVCYWNrZW5kKTpudWxsfSxvLnByb3RvdHlwZS5zaG91bGRFeGVjdXRlT25DUFU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3JldHVybiB2b2lkIDA9PT1lJiYoZT0xMjgpLG51bGwhPXRoaXMuZ2V0Q1BVQmFja2VuZCgpJiZ0LmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09bi50ZXhEYXRhLmdldCh0LmRhdGFJZCkudGV4dHVyZSYmayh0LnNoYXBlKTxlfSkpfSxvLnByb3RvdHlwZS5nZXRHUEdQVUNvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncGdwdX0sby5wcm90b3R5cGUuY29tcGxleD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubWFrZU91dHB1dCh0LnNoYXBlLFwiY29tcGxleDY0XCIpO3JldHVybiB0aGlzLnRleERhdGEuZ2V0KG4uZGF0YUlkKS5jb21wbGV4VGVuc29ycz17cmVhbDpMdC5rZWVwKHQuY2xvbmUoKSksaW1hZzpMdC5rZWVwKGUuY2xvbmUoKSl9LG59LG8ucHJvdG90eXBlLnJlYWw9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzLnJlYWwuY2xvbmUoKX0sby5wcm90b3R5cGUuaW1hZz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMuaW1hZy5jbG9uZSgpfSxvLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnNsaWNlKHQsZSxuKTtpZigwPT09ayhuKSlyZXR1cm4gRm4oW10sbix0LmR0eXBlKTt2YXIgcj10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKS5pc1BhY2tlZCxvPSRvKHQuc2hhcGUsZSxuKTtpZihyfHwhbyl7dmFyIGE9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIik/bmV3IGV1KG4pOm5ldyBacyhuKSxzPWEuZ2V0Q3VzdG9tU2V0dXBGdW5jKGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYSxbdF0sbnVsbCxzKX1yZXR1cm4gdGhpcy51cGxvYWRUb0dQVSh0LmRhdGFJZCksdGhpcy5zaGFsbG93U2xpY2UodCxlLG4pfSxvLnByb3RvdHlwZS5zaGFsbG93U2xpY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLG89dGhpcy5tYWtlT3V0cHV0KG4sdC5kdHlwZSksYT10aGlzLnRleERhdGEuZ2V0KG8uZGF0YUlkKTtPYmplY3QuYXNzaWduKGEsciksYS5zaGFwZT1uLGEuZHR5cGU9dC5kdHlwZTt2YXIgaT1RbyhlLHQuc3RyaWRlcyk7ci5zbGljZSYmKGkrPXIuc2xpY2UuZmxhdE9mZnNldCksYS5zbGljZT17ZmxhdE9mZnNldDppLG9yaWdEYXRhSWQ6ci5zbGljZSYmci5zbGljZS5vcmlnRGF0YUlkfHx0LmRhdGFJZH07dmFyIHM9dGhpcy5kYXRhUmVmQ291bnQuZ2V0KGEuc2xpY2Uub3JpZ0RhdGFJZCl8fDE7cmV0dXJuIHRoaXMuZGF0YVJlZkNvdW50LnNldChhLnNsaWNlLm9yaWdEYXRhSWQscysxKSxvfSxvLnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24odCxlLG4scil7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLnN0cmlkZWRTbGljZSh0LGUsbixyKTt2YXIgbz1qbyhlLG4scik7aWYoby5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gMD09PXR9KSkpcmV0dXJuIEZuKFtdLG8pO3ZhciBhPW5ldyBudShlLHIsbyk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhLFt0XSl9LG8ucHJvdG90eXBlLnJldmVyc2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgWXModC5zaGFwZSxlKTpuZXcgWHModC5zaGFwZSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKX0sby5wcm90b3R5cGUuY29uY2F0PWZ1bmN0aW9uKHQsZSl7aWYoXCJjb21wbGV4NjRcIj09PXRbMF0uZHR5cGUpe3ZhciBuPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gRG4odCl9KSkscj10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIE5uKHQpfSkpO3JldHVybiBUbih0aGlzLmNvbmNhdChuLGUpLHRoaXMuY29uY2F0KHIsZSkpfWlmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKHQpKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuY29uY2F0KHQsZSk7aWYoMT09PXQubGVuZ3RoKXJldHVybiB0WzBdO2lmKHQubGVuZ3RoPmkoKS5nZXROdW1iZXIoXCJXRUJHTF9NQVhfVEVYVFVSRVNfSU5fU0hBREVSXCIpKXt2YXIgbz1NYXRoLmZsb29yKHQubGVuZ3RoLzIpLGE9dGhpcy5jb25jYXQodC5zbGljZSgwLG8pLGUpLHM9dGhpcy5jb25jYXQodC5zbGljZShvKSxlKTtyZXR1cm4gdGhpcy5jb25jYXQoW2Esc10sZSl9aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0FSUkFZX09QRVJBVElPTlNcIikmJnRbMF0ucmFuaz4xKXt2YXIgdT1uZXcgRmkodC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpLGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4odSx0KX12YXIgYz1Tbih0Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSksZSksbD10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXMyRCgtMSxrKHQuc2hhcGUuc2xpY2UoZSkpKX0pKSxoPW5ldyBOaShsLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSkpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oaCxsKS5yZXNoYXBlKGMpfSxvLnByb3RvdHlwZS5uZWc9ZnVuY3Rpb24odCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm5lZyh0KTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsbXUsdC5kdHlwZSk7dmFyIGU9bmV3IGN1KHQuc2hhcGUsbXUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5iYXRjaE1hdE11bD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uP3Quc2hhcGVbMl06dC5zaGFwZVsxXSxhPXI/ZS5zaGFwZVsxXTplLnNoYXBlWzJdLGk9bj90LnNoYXBlWzFdOnQuc2hhcGVbMl0scz10LnNoYXBlWzBdO2lmKCgxPT09b3x8MT09PWEpJiZpPjFlMyl7biYmKHQ9dWEodCxbMCwyLDFdKSksciYmKGU9dWEoZSxbMCwyLDFdKSk7dmFyIHU9MT09PWE/dDp0LmFzM0QocyxpLDEpLGM9MT09PWE/MjoxLGw9MT09PWE/ZS5hczNEKHMsMSxpKTplO3JldHVybiB0aGlzLm11bHRpcGx5KHUsbCkuc3VtKGMsITApfXZhciBoPVR0KHQuZHR5cGUsZS5kdHlwZSksZj1uZXcgX3ModC5zaGFwZSxbcyxvLGFdLG4scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihmLFt0LGVdLGgpfSxvLnByb3RvdHlwZS5mdXNlZEJhdGNoTWF0TXVsPWZ1bmN0aW9uKHQpe3ZhciBlPXQuYSxuPXQuYixyPXQudHJhbnNwb3NlQSxvPXQudHJhbnNwb3NlQixhPXQuYmlhcyxpPXQuYWN0aXZhdGlvbixzPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyx1PXI/ZS5zaGFwZVsyXTplLnNoYXBlWzFdLGM9bz9uLnNoYXBlWzFdOm4uc2hhcGVbMl0sbD1lLnNoYXBlWzBdLGg9VHQoZS5kdHlwZSxuLmR0eXBlKSxmPW51bGwhPWEsZD1udWxsIT1zLHA9aT9MdShpLCEwKTpudWxsLHY9bmV3IF9zKGUuc2hhcGUsW2wsdSxjXSxyLG8sZixwLGQpLGc9W2Usbl07cmV0dXJuIGEmJmcucHVzaChhKSxzJiZnLnB1c2gocyksdGhpcy5jb21waWxlQW5kUnVuKHYsZyxoKX0sby5wcm90b3R5cGUubXVsdGlwbHk9ZnVuY3Rpb24odCxlKXtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSl7dmFyIG49dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkscj10aGlzLnRleERhdGEuZ2V0KGUuZGF0YUlkKSxvPW5ldyB5aShnaSx0LnNoYXBlLGUuc2hhcGUpLGE9bmV3IHlpKG1pLHQuc2hhcGUsZS5zaGFwZSkscz1bdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8odCxuLmNvbXBsZXhUZW5zb3JzLnJlYWwpLHRoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKHQsbi5jb21wbGV4VGVuc29ycy5pbWFnKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyhlLHIuY29tcGxleFRlbnNvcnMucmVhbCksdGhpcy5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm8oZSxyLmNvbXBsZXhUZW5zb3JzLmltYWcpXSx1PXRoaXMuY29tcGlsZUFuZFJ1bihvLHMpLGM9dGhpcy5jb21waWxlQW5kUnVuKGEscyksbD10aGlzLmNvbXBsZXgodSxjKTtyZXR1cm4gdS5kaXNwb3NlKCksYy5kaXNwb3NlKCksbH1pZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdCxlXSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5tdWx0aXBseSh0LGUpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsd2ksdC5kdHlwZSk7dmFyIGg9bmV3IFJpKHdpLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihoLFt0LGVdLHQuZHR5cGUpfSxvLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb249ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBzPVt0LGUsbl0sdT1udWxsO251bGwhPWEmJih1PWEuc2hhcGUscy5wdXNoKGEpKTt2YXIgYz1udWxsO2lmKG51bGwhPW8mJihjPW8uc2hhcGUscy5wdXNoKG8pKSxpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfTk9STUFMSVpBVElPTlwiKSl7dmFyIGw9bmV3IHZpKHQuc2hhcGUsZS5zaGFwZSxuLnNoYXBlLHUsYyxyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGwscyl9dmFyIGg9bmV3IHBpKHQuc2hhcGUsZS5zaGFwZSxuLnNoYXBlLHUsYyxyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGgscyl9LG8ucHJvdG90eXBlLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQ9ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfTk9STUFMSVpBVElPTlwiKT9uZXcgRHModC5zaGFwZSxlLG4scixvKTpuZXcgQXModC5zaGFwZSxlLG4scixvKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGEsW3RdKX0sby5wcm90b3R5cGUuTFJOR3JhZD1mdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2YXIgcz1uZXcgVHMoZS5zaGFwZSxyLG8sYSxpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHMsW2Usbix0XSl9LG8ucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24odCxlKXtpZihcInN0cmluZ1wiPT09dC5kdHlwZSl7dmFyIG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gb3QodCl9KSk7cmV0dXJuIFZhKGVyKHQuc2hhcGUsdC5kdHlwZSxuKSxlKX12YXIgcj1uZXcgaXUodC5zaGFwZSxlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdKX0sby5wcm90b3R5cGUucGFkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQVJSQVlfT1BFUkFUSU9OU1wiKT9uZXcgTHModC5zaGFwZSxlLG4pOm5ldyBQcyh0LnNoYXBlLGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSl9LG8ucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbih0LGUsbil7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuZ2F0aGVyKHQsZSxuKTt2YXIgcj1uZXcgYXModC5zaGFwZSxlLnNpemUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sby5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24odCxlLG4pe0ModC5yYW5rPD00LChmdW5jdGlvbigpe3JldHVyblwiYmF0Y2hUb1NwYWNlTkQgZm9yIHJhbmsgPiA0IHdpdGggYSBXZWJHTCBiYWNrZW5kIG5vdCBpbXBsZW1lbnRlZCB5ZXRcIn0pKTt2YXIgcj1lLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpLG89cHIodC5zaGFwZSxlLHIpLGE9dnIoby5sZW5ndGgsZS5sZW5ndGgpLGk9Z3IodC5zaGFwZSxlLHIpLHM9bXIobixlLmxlbmd0aCksdT15cihpLG4sZS5sZW5ndGgpO3JldHVybiB1YSh0LnJlc2hhcGUobyksYSkucmVzaGFwZShpKS5zbGljZShzLHUpfSxvLnByb3RvdHlwZS5zcGFjZVRvQmF0Y2hORD1mdW5jdGlvbih0LGUsbil7Qyh0LnJhbms8PTQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJzcGFjZVRvQmF0Y2hORCBmb3IgcmFuayA+IDQgd2l0aCBhIFdlYkdMIGJhY2tlbmQgbm90IGltcGxlbWVudGVkIHlldFwifSkpO3ZhciByPWUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSksbz1bWzAsMF1dO28ucHVzaC5hcHBseShvLG4pO2Zvcih2YXIgYT0xK2UubGVuZ3RoO2E8dC5zaGFwZS5sZW5ndGg7KythKW8ucHVzaChbMCwwXSk7dmFyIGk9dC5wYWQobykscz1wcihpLnNoYXBlLGUsciwhMSksdT12cihzLmxlbmd0aCxlLmxlbmd0aCwhMSksYz1ncihpLnNoYXBlLGUsciwhMSk7cmV0dXJuIHVhKGkucmVzaGFwZShzKSx1KS5yZXNoYXBlKGMpfSxvLnByb3RvdHlwZS5yZWR1Y2U9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXQuc2hhcGVbMF0sbz10LnNoYXBlWzFdLGE9VW8obyksaT1uZXcgVnMoe3dpbmRvd1NpemU6YSxpblNpemU6byxiYXRjaFNpemU6cn0sZSkscz10aGlzLmNvbXBpbGVBbmRSdW4oaSxbdF0sbik7cmV0dXJuIDE9PT1zLnNoYXBlWzFdP3M6dGhpcy5yZWR1Y2UocyxlLG4pfSxvLnByb3RvdHlwZS5hcmdSZWR1Y2U9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPW51bGwpO3ZhciByPXQuc2hhcGVbMF0sbz10LnNoYXBlWzFdO251bGwhPW4mJihyPW4uc2hhcGVbMF0sbz1uLnNoYXBlWzFdKTt2YXIgYT1VbyhvKSxpPW5ldyBLYSh7d2luZG93U2l6ZTphLGluU2l6ZTpvLGJhdGNoU2l6ZTpyfSxlLG51bGw9PW4pLHM9W3RdO251bGwhPW4mJnMucHVzaChuKTt2YXIgdT10aGlzLmNvbXBpbGVBbmRSdW4oaSxzLFwiaW50MzJcIik7cmV0dXJuIDE9PT11LnNoYXBlWzFdP3U6dGhpcy5hcmdSZWR1Y2UodCxlLHUpfSxvLnByb3RvdHlwZS5hcmdSZWR1Y2VQYWNrZWQ9ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPW51bGwpO3ZhciByPW51bGwhPW4/bi5zaGFwZTp0LnNoYXBlLG89VW8ocltyLmxlbmd0aC0xXSksYT1uZXcgaGkocixvLGUsbnVsbD09biksaT1udWxsPT1uP1t0XTpbdCxuXSxzPXRoaXMuY29tcGlsZUFuZFJ1bihhLGksXCJpbnQzMlwiKTtyZXR1cm4gcy5yYW5rPT09dC5yYW5rP3RoaXMuYXJnUmVkdWNlUGFja2VkKHQsZSxzKTpzfSxvLnByb3RvdHlwZS5zdW09ZnVuY3Rpb24odCxlKXtDbihcInN1bVwiLGUsdC5yYW5rKTt2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPWsoblsxXSksYT10LmFzMkQoLTEsbyksaT1EdCh0LmR0eXBlKTtyZXR1cm4gdGhpcy5yZWR1Y2UoYSxcInN1bVwiLGkpLnJlc2hhcGUocil9LG8ucHJvdG90eXBlLnByb2Q9ZnVuY3Rpb24odCxlKXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQucHJvZCh0LGUpO3ZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89ayhuWzFdKSxhPXQuYXMyRCgtMSxvKSxpPUR0KHQuZHR5cGUpO3JldHVybiB0aGlzLnJlZHVjZShhLFwicHJvZFwiLGkpLnJlc2hhcGUocil9LG8ucHJvdG90eXBlLnVuc29ydGVkU2VnbWVudFN1bT1mdW5jdGlvbih0LGUsbil7dmFyIHI9MCxvPUVuKFtyXSx0LnJhbmspLGE9dDtudWxsIT1vJiYoYT11YSh0LG8pLHI9SW4oMSx0LnJhbmspWzBdKTt2YXIgaT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPVtdLG89dC5sZW5ndGgsYT0wO2E8bzthKyspYSE9PWU/ci5wdXNoKHRbYV0pOnIucHVzaChuKTtyZXR1cm4gcn0oYS5zaGFwZSxyLG4pLHM9ayhbYS5zaGFwZVtyXV0pLHU9YS5hczJEKC0xLHMpLGM9RHQodC5kdHlwZSksbD10aGlzLnNlZ09wQ29tcHV0ZSh1LFwidW5zb3J0ZWRTZWdtZW50U3VtXCIsZSxjLG4pLnJlc2hhcGUoaSk7cmV0dXJuIG51bGwhPW8mJihsPXVhKGwsUm4obykpKSxsfSxvLnByb3RvdHlwZS5zZWdPcENvbXB1dGU9ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT10LnNoYXBlWzBdLGk9dC5zaGFwZVsxXSxzPWZ1bmN0aW9uKHQsZSl7dmFyIG4scj0hMTtmb3IodDw9V28/KG49dCxyPSEwKTpuPVkodCxNYXRoLmZsb29yKE1hdGguc3FydCh0KSkpOyFyOyluPmV8fG49PT10P3I9ITA6bj1ZKHQsbisxKTtyZXR1cm4gbn0oaSxvKSx1PW5ldyBRcyh7d2luZG93U2l6ZTpzLGluU2l6ZTppLGJhdGNoU2l6ZTphLG51bVNlZ21lbnRzOm99LGUpLGM9dGhpcy5jb21waWxlQW5kUnVuKHUsW3Qsbl0scik7cmV0dXJuIGMuc2hhcGVbMV09PT1vP2M6KG49S24oMCxvKS50aWxlKFtpL3NdKSx0aGlzLnNlZ09wQ29tcHV0ZShjLGUsbixyLG8pKX0sby5wcm90b3R5cGUuYXJnTWluTWF4UmVkdWNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1bZV07aWYoQ24oXCJhcmdcIituLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK24uc2xpY2UoMSkscix0LnJhbmspLCFpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfUkVEVUNFXCIpfHx0LnJhbms8PTIpe3ZhciBvPWJuKHQuc2hhcGUsciksYT1vWzBdLHM9ayhvWzFdKSx1PXQuYXMyRCgtMSxzKTtyZXR1cm4gdGhpcy5hcmdSZWR1Y2UodSxuKS5yZXNoYXBlKGEpfXJldHVybiB0aGlzLmFyZ1JlZHVjZVBhY2tlZCh0LG4pfSxvLnByb3RvdHlwZS5hcmdNaW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hcmdNaW5NYXhSZWR1Y2UodCxlLFwibWluXCIpfSxvLnByb3RvdHlwZS5hcmdNYXg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5hcmdNaW5NYXhSZWR1Y2UodCxlLFwibWF4XCIpfSxvLnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24odCxlLG4scil7aWYoZSE9PXQucmFuay0xKXRocm93IG5ldyBFcnJvcihcIldlYkdMIGN1bXN1bSBzaGFkZXIgZXhwZWN0cyBhbiBpbm5lci1tb3N0IGF4aXM9XCIrKHQucmFuay0xKStcIiBidXQgZ290IGF4aXM9XCIrZSk7dmFyIG89bmV3IHFpKHQuc2hhcGUsbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3RdKX0sby5wcm90b3R5cGUuZXF1YWw9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChlcXVhbChhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBSaShcInJldHVybiBmbG9hdChhID09IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUubm90RXF1YWw9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChub3RFcXVhbChhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBSaShcInJldHVybiBmbG9hdChhICE9IGIpO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUubGVzcz1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmxlc3ModCxlKTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChsZXNzVGhhbihhLCBiKSk7XFxuXCIsXCJib29sXCIpO3ZhciBuPW5ldyBSaShcInJldHVybiBmbG9hdChhIDwgYik7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5sZXNzRXF1YWw9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICByZXR1cm4gdmVjNChsZXNzVGhhbkVxdWFsKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IFJpKFwicmV0dXJuIGZsb2F0KGEgPD0gYik7XCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuZ3JlYXRlcih0LGUpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGdyZWF0ZXJUaGFuKGEsIGIpKTtcXG5cIixcImJvb2xcIik7dmFyIG49bmV3IFJpKFwicmV0dXJuIGZsb2F0KGEgPiBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmdyZWF0ZXJFcXVhbD1mdW5jdGlvbih0LGUpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYSwgYikpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgUmkoXCJyZXR1cm4gZmxvYXQoYSA+PSBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGN1KHQuc2hhcGUsXCJyZXR1cm4gZmxvYXQoISh4ID49IDEuMCkpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbih0LGUpe2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsXCJcXG4gIHJldHVybiB2ZWM0KFxcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYSwgdmVjNCgxLjApKSkgKlxcbiAgICB2ZWM0KGdyZWF0ZXJUaGFuRXF1YWwoYiwgdmVjNCgxLjApKSkpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgUmkoXCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgJiYgYiA+PSAxLjApO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKHQsZSl7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSxcIlxcbiAgcmV0dXJuIG1pbihcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGEsIHZlYzQoMS4wKSkpICtcXG4gICAgdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMS4wKSkpLFxcbiAgICB2ZWM0KDEuMCkpO1xcblwiLFwiYm9vbFwiKTt2YXIgbj1uZXcgUmkoXCJyZXR1cm4gZmxvYXQoYSA+PSAxLjAgfHwgYiA+PSAxLjApO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLFwiYm9vbFwiKX0sby5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgSnModC5yYW5rLGUuc2hhcGUsZS5yYW5rKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZSxuXSxUdChlLmR0eXBlLG4uZHR5cGUpKX0sby5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24odCl7ZG4oXCJ0Zi53aGVyZSgpIGluIHdlYmdsIGxvY2tzIHRoZSBVSSB0aHJlYWQuIENhbGwgdGYud2hlcmVBc3luYygpIGluc3RlYWRcIik7dmFyIGU9dC5kYXRhU3luYygpO3JldHVybiBHYSh0LnNoYXBlLGUpfSxvLnByb3RvdHlwZS50b3BrPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gemEodC5kYXRhU3luYygpLHQuc2hhcGUsdC5kdHlwZSxlKX0sby5wcm90b3R5cGUubWluPWZ1bmN0aW9uKHQsZSl7Q24oXCJtaW5cIixlLHQucmFuayk7dmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1rKG5bMV0pLGE9dC5hczJEKC0xLG8pO3JldHVybiB0aGlzLnJlZHVjZShhLFwibWluXCIsYS5kdHlwZSkucmVzaGFwZShyKX0sby5wcm90b3R5cGUubWluaW11bT1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLm1pbmltdW0odCxlKTt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IFNpKFwiXFxuICB2ZWM0IHJlc3VsdCA9IHZlYzQobWluKGEsIGIpKTtcXG4gIHZlYzQgaXNOYU4gPSBtaW4odmVjNChpc25hbihhKSkgKyB2ZWM0KGlzbmFuKGIpKSwgdmVjNCgxLjApKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgUmkoXCJcXG4gIGlmIChpc25hbihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNuYW4oYikpIHJldHVybiBiO1xcblxcbiAgcmV0dXJuIG1pbihhLCBiKTtcXG5cIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LG8ucHJvdG90eXBlLm1vZD1mdW5jdGlvbih0LGUpe3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgU2koXCJcXG4gIHZlYzQgcmVzdWx0ID0gbW9kKGEsIGIpO1xcbiAgdmVjNCBpc05hTiA9IHZlYzQoZXF1YWwoYiwgdmVjNCgwLjApKSk7XFxuICBcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA+IDAuID8gTkFOIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzTmFOLmcgPiAwLiA/IE5BTiA6IHJlc3VsdC5nO1xcbiAgcmVzdWx0LmIgPSBpc05hTi5iID4gMC4gPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA+IDAuID8gTkFOIDogcmVzdWx0LmE7XFxuXFxuICByZXR1cm4gcmVzdWx0O1xcblwiLHQuc2hhcGUsZS5zaGFwZSk6bmV3IFJpKFwiaWYgKGIgPT0gMC4wKSByZXR1cm4gTkFOO1xcbiAgcmV0dXJuIG1vZChhLCBiKTtcIix0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LG8ucHJvdG90eXBlLm1heD1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5tYXgodCxlKTtDbihcIm1heFwiLGUsdC5yYW5rKTt2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPWsoblsxXSksYT10LmFzMkQoLTEsbyk7cmV0dXJuIHRoaXMucmVkdWNlKGEsXCJtYXhcIixhLmR0eXBlKS5yZXNoYXBlKHIpfSxvLnByb3RvdHlwZS5tYXhpbXVtPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubWF4aW11bSh0LGUpO3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgU2koXCJcXG4gIHZlYzQgcmVzdWx0ID0gdmVjNChtYXgoYSwgYikpO1xcbiAgdmVjNCBpc05hTiA9IG1pbih2ZWM0KGlzbmFuKGEpKSArIHZlYzQoaXNuYW4oYikpLCB2ZWM0KDEuMCkpO1xcbiAgXFxuICByZXN1bHQuciA9IGlzTmFOLnIgPiAwLiA/IE5BTiA6IHJlc3VsdC5yO1xcbiAgcmVzdWx0LmcgPSBpc05hTi5nID4gMC4gPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA+IDAuID8gTkFOIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzTmFOLmEgPiAwLiA/IE5BTiA6IHJlc3VsdC5hO1xcblxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIix0LnNoYXBlLGUuc2hhcGUpOm5ldyBSaShcIlxcbiAgaWYgKGlzbmFuKGEpKSByZXR1cm4gYTtcXG4gIGlmIChpc25hbihiKSkgcmV0dXJuIGI7XFxuXFxuICByZXR1cm4gbWF4KGEsIGIpO1xcblwiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sby5wcm90b3R5cGUuYWxsPWZ1bmN0aW9uKHQsZSl7Q24oXCJhbGxcIixlLHQucmFuayk7dmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1rKG5bMV0pLGE9dC5hczJEKC0xLG8pO3JldHVybiB0aGlzLnJlZHVjZShhLFwiYWxsXCIsYS5kdHlwZSkucmVzaGFwZShyKX0sby5wcm90b3R5cGUuYW55PWZ1bmN0aW9uKHQsZSl7Q24oXCJhbnlcIixlLHQucmFuayk7dmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1rKG5bMV0pLGE9dC5hczJEKC0xLG8pO3JldHVybiB0aGlzLnJlZHVjZShhLFwiYW55XCIsYS5kdHlwZSkucmVzaGFwZShyKX0sby5wcm90b3R5cGUuZmxvb3JEaXY9ZnVuY3Rpb24odCxlKXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIikpcmV0dXJuIHRoaXMucGFja2VkQmluYXJ5T3AodCxlLFwiXFxuICBpdmVjNCBpYSA9IHJvdW5kKGEpO1xcbiAgaXZlYzQgaWIgPSByb3VuZChiKTtcXG4gIGJ2ZWM0IGNvbmQgPSBub3RFcXVhbChpYiwgaXZlYzQoMCkpO1xcbiAgaXZlYzQgcmVzdWx0ID0gaXZlYzQoMCk7XFxuICB2ZWM0IHMgPSBzaWduKGEpICogc2lnbihiKTtcXG5cXG4gIC8vIFdpbmRvd3MgKEQzRCkgd2FudHMgZ3VhcmFudGVlZCBub24temVybyBpbnQgZGl2aXNpb24gYXQgY29tcGlsZS10aW1lLlxcbiAgaWYgKGNvbmRbMF0pIHtcXG4gICAgcmVzdWx0WzBdID0gaWRpdihpYVswXSwgaWJbMF0sIHNbMF0pO1xcbiAgfVxcbiAgaWYgKGNvbmRbMV0pIHtcXG4gICAgcmVzdWx0WzFdID0gaWRpdihpYVsxXSwgaWJbMV0sIHNbMV0pO1xcbiAgfVxcbiAgaWYgKGNvbmRbMl0pIHtcXG4gICAgcmVzdWx0WzJdID0gaWRpdihpYVsyXSwgaWJbMl0sIHNbMl0pO1xcbiAgfVxcbiAgaWYgKGNvbmRbM10pIHtcXG4gICAgcmVzdWx0WzNdID0gaWRpdihpYVszXSwgaWJbM10sIHNbM10pO1xcbiAgfVxcbiAgcmV0dXJuIHZlYzQocmVzdWx0KTtcXG5cIixcImludDMyXCIpO3ZhciBuPW5ldyBSaShcIlxcbiAgZmxvYXQgcyA9IHNpZ24oYSkgKiBzaWduKGIpO1xcbiAgaW50IGlhID0gcm91bmQoYSk7XFxuICBpbnQgaWIgPSByb3VuZChiKTtcXG4gIGlmIChpYiAhPSAwKSB7XFxuICAgIC8vIFdpbmRvd3MgKEQzRCkgd2FudHMgZ3VhcmFudGVlZCBub24temVybyBpbnQgZGl2aXNpb24gYXQgY29tcGlsZS10aW1lLlxcbiAgICByZXR1cm4gZmxvYXQoaWRpdihpYSwgaWIsIHMpKTtcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBOQU47XFxuICB9XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0sXCJpbnQzMlwiKX0sby5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQsZSl7aWYoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUmJlwiY29tcGxleDY0XCI9PT1lLmR0eXBlKXJldHVybiB0aGlzLmNvbXBsZXhTZXBhcmFibGVCaW5hcnlPcCh0LGUseGkpO2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0LGVdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmFkZCh0LGUpO3ZhciBuPVR0KHQuZHR5cGUsZS5kdHlwZSk7aWYoaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZEJpbmFyeU9wKHQsZSx4aSxuKTt2YXIgcj1uZXcgUmkoeGksdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0sbil9LG8ucHJvdG90eXBlLnBhY2tlZFVuYXJ5T3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBNdSh0LnNoYXBlLGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0sbil9LG8ucHJvdG90eXBlLnBhY2tlZEJpbmFyeU9wPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09byYmKG89ITEpO3ZhciBhPW5ldyBTaShuLHQuc2hhcGUsZS5zaGFwZSxvKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGEsW3QsZV0scil9LG8ucHJvdG90eXBlLmNvbXBsZXhTZXBhcmFibGVCaW5hcnlPcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcyxvPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLGE9dGhpcy50ZXhEYXRhLmdldChlLmRhdGFJZCksaT1bW28uY29tcGxleFRlbnNvcnMucmVhbCxhLmNvbXBsZXhUZW5zb3JzLnJlYWxdLFtvLmNvbXBsZXhUZW5zb3JzLmltYWcsYS5jb21wbGV4VGVuc29ycy5pbWFnXV0ubWFwKChmdW5jdGlvbihvKXt2YXIgYT1vWzBdLGk9b1sxXSxzPXIubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKHQsYSksdT1yLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyhlLGkpLGM9bmV3IFJpKG4sdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gci5jb21waWxlQW5kUnVuKGMsW3MsdV0sVHQoYS5kdHlwZSxpLmR0eXBlKSl9KSkscz1pWzBdLHU9aVsxXSxjPXRoaXMuY29tcGxleChzLHUpO3JldHVybiBzLmRpc3Bvc2UoKSx1LmRpc3Bvc2UoKSxjfSxvLnByb3RvdHlwZS5tYWtlQ29tcGxleENvbXBvbmVudFRlbnNvckluZm89ZnVuY3Rpb24odCxlKXtyZXR1cm57ZGF0YUlkOmUuZGF0YUlkLGR0eXBlOmUuZHR5cGUsc2hhcGU6dC5zaGFwZX19LG8ucHJvdG90eXBlLmFkZE49ZnVuY3Rpb24odCl7aWYoMT09PXQubGVuZ3RoKXJldHVybiB0WzBdO2lmKHQubGVuZ3RoPmkoKS5nZXQoXCJXRUJHTF9NQVhfVEVYVFVSRVNfSU5fU0hBREVSXCIpKXt2YXIgZT1NYXRoLmZsb29yKHQubGVuZ3RoLzIpLG49dGhpcy5hZGROKHQuc2xpY2UoMCxlKSkscj10aGlzLmFkZE4odC5zbGljZShlKSk7cmV0dXJuIHRoaXMuYWRkTihbbixyXSl9dmFyIG89dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmR0eXBlfSkpLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gVHQodCxlKX0pKSxhPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zaGFwZX0pKSxzPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9uZXcgcWEodFswXS5zaGFwZSxhKTpuZXcgSGEodFswXS5zaGFwZSxhKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHMsdCxvKX0sby5wcm90b3R5cGUuc3VidHJhY3Q9ZnVuY3Rpb24odCxlKXtpZihcImNvbXBsZXg2NFwiPT09dC5kdHlwZSYmXCJjb21wbGV4NjRcIj09PWUuZHR5cGUpcmV0dXJuIHRoaXMuY29tcGxleFNlcGFyYWJsZUJpbmFyeU9wKHQsZSxiaSk7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3QsZV0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuc3VidHJhY3QodCxlKTt2YXIgbj1UdCh0LmR0eXBlLGUuZHR5cGUpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRCaW5hcnlPcCh0LGUsYmksdC5kdHlwZSk7dmFyIHI9bmV3IFJpKGJpLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdLG4pfSxvLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCxlKXt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IFNpKFwiXFxuICAvLyBpc01vZFJvdW5kMSBoYXMgMSBmb3IgY29tcG9uZW50cyB3aXRoIHJvdW5kKG1vZChiLCAyLjApKSA9PSAxLCAwIG90aGVyd2lzZS5cXG4gIHZlYzQgaXNNb2RSb3VuZDEgPSB2ZWM0KGVxdWFsKHJvdW5kKG1vZChiLCAyLjApKSwgaXZlYzQoMSkpKTtcXG4gIHZlYzQgbXVsdGlwbGllciA9IHNpZ24oYSkgKiBpc01vZFJvdW5kMSArICh2ZWM0KDEuMCkgLSBpc01vZFJvdW5kMSk7XFxuICB2ZWM0IHJlc3VsdCA9IG11bHRpcGxpZXIgKiBwb3coYWJzKGEpLCBiKTtcXG5cXG4gIC8vIEVuc3VyZSB0aGF0IGFeMCA9IDEsIGluY2x1ZGluZyAwXjAgPSAxIGFzIHRoaXMgY29ycmVzcG9uZCB0byBURiBhbmQgSlNcXG4gIGJ2ZWM0IGlzRXhwWmVybyA9IGVxdWFsKGIsIHZlYzQoMC4wKSk7XFxuICByZXN1bHQuciA9IGlzRXhwWmVyby5yID8gMS4wIDogcmVzdWx0LnI7XFxuICByZXN1bHQuZyA9IGlzRXhwWmVyby5nID8gMS4wIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzRXhwWmVyby5iID8gMS4wIDogcmVzdWx0LmI7XFxuICByZXN1bHQuYSA9IGlzRXhwWmVyby5hID8gMS4wIDogcmVzdWx0LmE7XFxuXFxuICB2ZWM0IGlzTmFOID0gdmVjNChsZXNzVGhhbihhLCB2ZWM0KDAuMCkpKSAqIHZlYzQobGVzc1RoYW4oZmxvb3IoYiksIGIpKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgUmkoXCJcXG5pZihhIDwgMC4wICYmIGZsb29yKGIpIDwgYil7XFxuICByZXR1cm4gTkFOO1xcbn1cXG5pZiAoYiA9PSAwLjApIHtcXG4gIHJldHVybiAxLjA7XFxufVxcbnJldHVybiAocm91bmQobW9kKGIsIDIuMCkpICE9IDEpID9cXG4gICAgcG93KGFicyhhKSwgYikgOiBzaWduKGEpICogcG93KGFicyhhKSwgYik7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKSxyPVR0KHQuZHR5cGUsZS5kdHlwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdLHIpfSxvLnByb3RvdHlwZS5jZWlsPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5jZWlsKHQpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCx5dSx0LmR0eXBlKTt2YXIgZT1uZXcgY3UodC5zaGFwZSx5dSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5mbG9vcih0KTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQseHUsdC5kdHlwZSk7dmFyIGU9bmV3IGN1KHQuc2hhcGUseHUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBjdSh0LnNoYXBlLFwiXFxuICBpZiAoaXNuYW4oeCkpIHsgcmV0dXJuIDAuMDsgfVxcbiAgcmV0dXJuIHNpZ24oeCk7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5pc05hTj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxcInJldHVybiBmbG9hdChpc25hbih4KSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5pc0luZj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxcInJldHVybiBmbG9hdChpc2luZih4KSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0sXCJib29sXCIpfSxvLnByb3RvdHlwZS5pc0Zpbml0ZT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxcInJldHVybiBmbG9hdCghaXNuYW4oeCkgJiYgIWlzaW5mKHgpKTtcIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSxcImJvb2xcIil9LG8ucHJvdG90eXBlLnJvdW5kPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBjdSh0LnNoYXBlLFwiXFxuICAvLyBPcGVuR0wgRVMgZG9lcyBub3Qgc3VwcG9ydCByb3VuZCBmdW5jdGlvbi5cXG4gIC8vIFRoZSBhbGdvcml0aG0gaXMgYmFzZWQgb24gYmFua2VyJ3Mgcm91bmRpbmcuXFxuICBmbG9hdCBiYXNlID0gZmxvb3IoeCk7XFxuICBpZiAoKHggLSBiYXNlKSA8IDAuNSkge1xcbiAgICByZXR1cm4gZmxvb3IoeCk7XFxuICB9IGVsc2UgaWYgKCh4IC0gYmFzZSkgPiAwLjUpIHtcXG4gICAgcmV0dXJuIGNlaWwoeCk7XFxuICB9IGVsc2Uge1xcbiAgICBpZiAobW9kKGJhc2UsIDIuMCkgPT0gMC4wKSB7XFxuICAgICAgcmV0dXJuIGJhc2U7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGJhc2UgKyAxLjA7XFxuICAgIH1cXG4gIH1cXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmV4cD1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQuZXhwKHQpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCxidSx0LmR0eXBlKTt2YXIgZT1uZXcgY3UodC5zaGFwZSxidSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKHQpe2lmKHRoaXMuc2hvdWxkRXhlY3V0ZU9uQ1BVKFt0XSkpcmV0dXJuIHRoaXMuY3B1QmFja2VuZC5leHBtMSh0KTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsd3UsdC5kdHlwZSk7dmFyIGU9bmV3IGN1KHQuc2hhcGUsd3UpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5zb2Z0bWF4PWZ1bmN0aW9uKHQsZSl7dmFyIG49TyhbZV0sdC5zaGFwZSkscj10aGlzLm1heCh0LG4pLG89d24oci5zaGFwZSxuKSxhPXRoaXMuc3VidHJhY3QodCxyLnJlc2hhcGUobykpLGk9dGhpcy5leHAoYSkscz10aGlzLnN1bShpLG4pLnJlc2hhcGUobyk7cmV0dXJuIEJvKGkscyl9LG8ucHJvdG90eXBlLmxvZz1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQubG9nKHQpO2lmKGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19VTkFSWV9PUEVSQVRJT05TXCIpKXJldHVybiB0aGlzLnBhY2tlZFVuYXJ5T3AodCxcIlxcbiAgdmVjNCByZXN1bHQgPSBsb2coeCk7XFxuICB2ZWM0IGlzTmFOID0gdmVjNChsZXNzVGhhbih4LCB2ZWM0KDAuMCkpKTtcXG4gIHJlc3VsdC5yID0gaXNOYU4uciA9PSAxLjAgPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA9PSAxLjAgPyBOQU4gOiByZXN1bHQuZztcXG4gIHJlc3VsdC5iID0gaXNOYU4uYiA9PSAxLjAgPyBOQU4gOiByZXN1bHQuYjtcXG4gIHJlc3VsdC5hID0gaXNOYU4uYSA9PSAxLjAgPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5kdHlwZSk7dmFyIGU9bmV3IGN1KHQuc2hhcGUsXCJpZiAoeCA8IDAuMCkgcmV0dXJuIE5BTjtcXG4gIHJldHVybiBsb2coeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5sb2cxcD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxcInJldHVybiBsb2coMS4wICsgeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5zcXJ0PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBjdSh0LnNoYXBlLFwicmV0dXJuIHNxcnQoeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbih0KXtpZih0aGlzLnNob3VsZEV4ZWN1dGVPbkNQVShbdF0pKXJldHVybiB0aGlzLmNwdUJhY2tlbmQucnNxcnQodCk7dmFyIGU9bmV3IGN1KHQuc2hhcGUsXCJyZXR1cm4gaW52ZXJzZXNxcnQoeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBjdSh0LnNoYXBlLFwicmV0dXJuIDEuMCAvIHg7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5yZWx1PWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9uZXcgTXUodC5zaGFwZSxGdSk6bmV3IGN1KHQuc2hhcGUsZHUpLHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnJlbHU2PWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiBlPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS1wiKT9uZXcgTXUodC5zaGFwZSxfdSk6bmV3IGN1KHQuc2hhcGUscHUpLHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQsZSl7dmFyIG49aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBTaShraSx0LnNoYXBlLGUuc2hhcGUpOm5ldyBSaShFaSx0LnNoYXBlLGUuc2hhcGUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdCxlXSl9LG8ucHJvdG90eXBlLmVsdT1mdW5jdGlvbih0KXtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsT3UsdC5kdHlwZSk7dmFyIGU9bmV3IGN1KHQuc2hhcGUsdnUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5lbHVEZXI9ZnVuY3Rpb24odCxlKXt2YXIgbj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfQklOQVJZX09QRVJBVElPTlNcIik/bmV3IFNpKFwiXFxuICB2ZWM0IGJHVEVaZXJvID0gdmVjNChncmVhdGVyVGhhbkVxdWFsKGIsIHZlYzQoMC4pKSk7XFxuICByZXR1cm4gKGJHVEVaZXJvICogYSkgKyAoKHZlYzQoMS4wKSAtIGJHVEVaZXJvKSAqIChhICogKGIgKyB2ZWM0KDEuMCkpKSk7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgUmkoXCJyZXR1cm4gKGIgPj0gMS4wKSA/IGEgOiBhICogKGIgKyAxLjApO1wiLHQuc2hhcGUsZS5zaGFwZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihuLFt0LGVdKX0sby5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxndSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmludD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxcInJldHVybiBmbG9hdChpbnQoeCkpO1wiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdLFwiaW50MzJcIil9LG8ucHJvdG90eXBlLmNsaXA9ZnVuY3Rpb24odCxlLG4pe3ZhciByLG89KHI9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0NMSVBcIik/bmV3IFRpKHQuc2hhcGUpOm5ldyBBaSh0LnNoYXBlKSkuZ2V0Q3VzdG9tU2V0dXBGdW5jKGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSxudWxsLG8pfSxvLnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24odCl7aWYodGhpcy5zaG91bGRFeGVjdXRlT25DUFUoW3RdKSlyZXR1cm4gdGhpcy5jcHVCYWNrZW5kLmFicyh0KTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfVU5BUllfT1BFUkFUSU9OU1wiKSlyZXR1cm4gdGhpcy5wYWNrZWRVbmFyeU9wKHQsZnUsdC5kdHlwZSk7dmFyIGU9bmV3IGN1KHQuc2hhcGUsZnUpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5jb21wbGV4QWJzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpLG49bmV3IERpKHQuc2hhcGUpLHI9W3RoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKHQsZS5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyh0LGUuY29tcGxleFRlbnNvcnMuaW1hZyldO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixyKX0sby5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxcInJldHVybiAxLjAgLyAoMS4wICsgZXhwKC0xLjAgKiB4KSk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5zb2Z0cGx1cz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxcIlxcbiAgZmxvYXQgZXBzaWxvbiA9IDEuMTkyMDkyODk1NTA3ODEyNWUtNztcXG4gIGZsb2F0IHRocmVzaG9sZCA9IGxvZyhlcHNpbG9uKSArIDIuMDtcXG5cXG4gIGJvb2wgdG9vX2xhcmdlID0geCA+IC10aHJlc2hvbGQ7XFxuICBib29sIHRvb19zbWFsbCA9IHggPCB0aHJlc2hvbGQ7XFxuXFxuICBmbG9hdCByZXN1bHQ7XFxuICBmbG9hdCBleHBfeCA9IGV4cCh4KTtcXG5cXG4gIGlmICh0b29fbGFyZ2Upe1xcbiAgICByZXN1bHQgPSB4O1xcbiAgfVxcbiAgZWxzZSBpZiAodG9vX3NtYWxsKXtcXG4gICAgcmVzdWx0ID0gZXhwX3g7XFxuICB9XFxuICBlbHNle1xcbiAgICByZXN1bHQgPSBsb2coZXhwX3ggKyAxLjApO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG5cIik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnNpbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxDdSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmNvcz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxFdSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLnRhbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxcInJldHVybiB0YW4oeCk7XCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBjdSh0LnNoYXBlLFJ1KTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuYWNvcz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxJdSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmF0YW49ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGN1KHQuc2hhcGUsa3UpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbih0LGUpe3ZhciBuPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19CSU5BUllfT1BFUkFUSU9OU1wiKT9uZXcgU2koXCJcXG4gIHZlYzQgcmVzdWx0ID0gYXRhbihhLCBiKTtcXG4gIHZlYzQgaXNOYU4gPSBtaW4odmVjNChpc25hbihhKSkgKyB2ZWM0KGlzbmFuKGIpKSwgdmVjNCgxLjApKTtcXG4gIFxcbiAgcmVzdWx0LnIgPSBpc05hTi5yID4gMC4gPyBOQU4gOiByZXN1bHQucjtcXG4gIHJlc3VsdC5nID0gaXNOYU4uZyA+IDAuID8gTkFOIDogcmVzdWx0Lmc7XFxuICByZXN1bHQuYiA9IGlzTmFOLmIgPiAwLiA/IE5BTiA6IHJlc3VsdC5iO1xcbiAgcmVzdWx0LmEgPSBpc05hTi5hID4gMC4gPyBOQU4gOiByZXN1bHQuYTtcXG5cXG4gIHJldHVybiByZXN1bHQ7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTpuZXcgUmkoXCJcXG4gIGlmIChpc25hbihhKSkgcmV0dXJuIGE7XFxuICBpZiAoaXNuYW4oYikpIHJldHVybiBiO1xcblxcbiAgcmV0dXJuIGF0YW4oYSwgYik7XFxuXCIsdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3QsZV0pfSxvLnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBjdSh0LnNoYXBlLFwiXFxuICBmbG9hdCBlMnggPSBleHAoeCk7XFxuICByZXR1cm4gKGUyeCAtIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBjdSh0LnNoYXBlLFwiXFxuICBmbG9hdCBlMnggPSBleHAoLXgpO1xcbiAgcmV0dXJuIChlMnggKyAxLjAgLyBlMngpIC8gMi4wO1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUudGFuaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKC0yLjAgKiBhYnMoeCkpO1xcbiAgcmV0dXJuIHNpZ24oeCkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xcblwiKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGN1KHQuc2hhcGUsU3UpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZSxbdF0pfSxvLnByb3RvdHlwZS5hY29zaD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3UodC5zaGFwZSxBdSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLmF0YW5oPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBjdSh0LnNoYXBlLFR1KTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBjdSh0LnNoYXBlLCdcXG4gIC8vIEVycm9yIGZ1bmN0aW9uIGlzIGNhbGN1bGF0ZWQgYXBwcm94aW1hdGVseSB3aXRoIGVsZW1lbnRhcnkgZnVuY3Rpb24uXFxuICAvLyBTZWUgXCJIYW5kYm9vayBvZiBNYXRoZW1hdGljYWwgRnVuY3Rpb25zIHdpdGggRm9ybXVsYXMsXFxuICAvLyBHcmFwaHMsIGFuZCBNYXRoZW1hdGljYWwgVGFibGVzXCIsIEFicmFtb3dpdHogYW5kIFN0ZWd1bi5cXG4gIGZsb2F0IHAgPSAwLjMyNzU5MTE7XFxuICBmbG9hdCBhMSA9IDAuMjU0ODI5NTkyO1xcbiAgZmxvYXQgYTIgPSAtMC4yODQ0OTY3MzY7XFxuICBmbG9hdCBhMyA9IDEuNDIxNDEzNzQxO1xcbiAgZmxvYXQgYTQgPSAtMS40NTMxNTIwMjc7XFxuICBmbG9hdCBhNSA9IDEuMDYxNDA1NDI5O1xcblxcbiAgZmxvYXQgc2lnbiA9IHNpZ24oeCk7XFxuICB4ID0gYWJzKHgpO1xcbiAgZmxvYXQgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XFxuICByZXR1cm4gc2lnbiAqICgxLjAgLSAoKCgoKGE1KnQgKyBhNCkqdCkgKyBhMykqdCArIGEyKSp0ICsgYTEpKnQqZXhwKC14KngpKTtcXG4nKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGUsW3RdKX0sby5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBjdSh0LnNoYXBlLGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0wKSxsdStcIlxcbiAgICByZXR1cm4geCA+IDAuMCA/IDEuMCA6IGZsb2F0KFwiK3QrXCIpO1xcbiAgXCJ9KGUpKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKX0sby5wcm90b3R5cGUuY29udjJkQnlNYXRNdWw9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBzPXQuc2hhcGUsdT10aGlzLnRleERhdGEuZ2V0KHQuZGF0YUlkKSxjPW4uaW5DaGFubmVscyxsPXNbMF0qc1sxXSpzWzJdLGg9bi5vdXRDaGFubmVscyxmPVwiY2hhbm5lbHNMYXN0XCI9PT1uLmRhdGFGb3JtYXQsZD0oMT09PWx8fDE9PT1oKSYmYz4xZTMscD1zWzJdJTIhPTAmJiEhdS5pc1BhY2tlZDtpZihkfHwhaSgpLmdldEJvb2woXCJXRUJHTF9MQVpJTFlfVU5QQUNLXCIpfHwhaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpfHwhcCl7dmFyIHY9Zj9zWzBdKnNbMV0qc1syXTpzWzBdKnNbMl0qc1szXSxnPXRoaXMucmVzaGFwZSh0LFsxLHYsbi5pbkNoYW5uZWxzXSksbT10aGlzLnJlc2hhcGUoZSxbMSxuLmluQ2hhbm5lbHMsbi5vdXRDaGFubmVsc10pO3JldHVybiB0aGlzLnJlc2hhcGUodGhpcy5mdXNlZEJhdGNoTWF0TXVsKHthOmcsYjptLHRyYW5zcG9zZUE6ITEsdHJhbnNwb3NlQjohMSxiaWFzOnIsYWN0aXZhdGlvbjpvLHByZWx1QWN0aXZhdGlvbldlaWdodHM6YX0pLG4ub3V0U2hhcGUpfXZhciB5PWY/c1swXSpzWzFdKihzWzJdKzEpOnNbMF0qc1syXSooc1szXSsxKSx4PXtkYXRhSWQ6dC5kYXRhSWQsc2hhcGU6WzEseSxuLmluQ2hhbm5lbHNdLGR0eXBlOnQuZHR5cGV9LGI9dS5zaGFwZTt1LnNoYXBlPXUuc2hhcGUuc2xpY2UoKSx1LnNoYXBlW3Uuc2hhcGUubGVuZ3RoLTJdKyssQyhfZSh1LnNoYXBlLHguc2hhcGUpLChmdW5jdGlvbigpe3JldHVyblwicGFja2VkIHJlc2hhcGUgXCIrdS5zaGFwZStcIiB0byBcIit4LnNoYXBlK1wiIGlzbid0IGZyZWVcIn0pKTt2YXIgdz10aGlzLnJlc2hhcGUoZSxbMSxuLmluQ2hhbm5lbHMsbi5vdXRDaGFubmVsc10pLEU9dGhpcy5mdXNlZEJhdGNoTWF0TXVsKHthOngsYjp3LHRyYW5zcG9zZUE6ITEsdHJhbnNwb3NlQjohMSxiaWFzOnIsYWN0aXZhdGlvbjpvLHByZWx1QWN0aXZhdGlvbldlaWdodHM6YX0pLFI9dGhpcy50ZXhEYXRhLmdldChFLmRhdGFJZCk7cmV0dXJuIEMoUi5pc1BhY2tlZCwoZnVuY3Rpb24oKXtyZXR1cm5cImJhdGNoTWF0TXVsIHJlc3VsdCBpcyBleHBlY3RlZCB0byBiZSBwYWNrZWRcIn0pKSx1LnNoYXBlPWIsUi5zaGFwZT1uLm91dFNoYXBlLEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKEUuZGF0YUlkLG4ub3V0U2hhcGUsRS5kdHlwZSl9LG8ucHJvdG90eXBlLmNvbnYyZFdpdGhJbTJSb3c9ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPW4uZmlsdGVyV2lkdGgscz1uLmZpbHRlckhlaWdodCx1PW4uaW5DaGFubmVscyxjPW4ub3V0V2lkdGgsbD1uLm91dEhlaWdodCxoPVwiY2hhbm5lbHNMYXN0XCI9PT1uLmRhdGFGb3JtYXQsZj1pKnMqdSxkPWwqYyxwPVtmLGRdLHY9dC5zcXVlZXplKFswXSksZz1lLnJlc2hhcGUoWzEsZiwtMV0pLG09bmV3IFNzKHAsdi5zaGFwZSxuKSx5PXRoaXMuY29tcGlsZUFuZFJ1bihtLFt2XSkucmVzaGFwZShbMSxwWzBdLHBbMV1dKSx4PW51bGwhPXIsYj1udWxsIT1hLHc9bz9MdShvLCEwKTpudWxsLEM9bmV3IF9zKHkuc2hhcGUsWzEsZCxuLm91dENoYW5uZWxzXSwhMCwhMSx4LHcsYiksRT1beSxnXTtyJiZFLnB1c2gociksYiYmRS5wdXNoKGEpO3ZhciBSPXRoaXMuY29tcGlsZUFuZFJ1bihDLEUpO3JldHVybiBoP1IucmVzaGFwZShbMSxsLGMsbi5vdXRDaGFubmVsc10pOlIucmVzaGFwZShbMSxuLm91dENoYW5uZWxzLGwsY10pfSxvLnByb3RvdHlwZS5mdXNlZENvbnYyZD1mdW5jdGlvbih0KXt2YXIgZT10LmlucHV0LG49dC5maWx0ZXIscj10LmNvbnZJbmZvLG89dC5iaWFzLGE9dC5hY3RpdmF0aW9uLHM9dC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzO2lmKDE9PT1yLmZpbHRlckhlaWdodCYmMT09PXIuZmlsdGVyV2lkdGgmJjE9PT1yLmRpbGF0aW9uSGVpZ2h0JiYxPT09ci5kaWxhdGlvbldpZHRoJiYxPT09ci5zdHJpZGVIZWlnaHQmJjE9PT1yLnN0cmlkZVdpZHRoJiYoXCJTQU1FXCI9PT1yLnBhZEluZm8udHlwZXx8XCJWQUxJRFwiPT09ci5wYWRJbmZvLnR5cGUpKXJldHVybiB0aGlzLmNvbnYyZEJ5TWF0TXVsKGUsbixyLG8sYSxzKTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX0NPTlZfSU0yQ09MXCIpJiYxPT09ZS5zaGFwZVswXSlyZXR1cm4gdGhpcy5jb252MmRXaXRoSW0yUm93KGUsbixyLG8sYSxzKTt2YXIgdT1udWxsIT1vLGM9bnVsbCE9cyxsPWE/THUoYSwhMSk6bnVsbCxoPW5ldyBVaShyLHUsbCxjKSxmPVtlLG5dO3JldHVybiBvJiZmLnB1c2gobykscyYmZi5wdXNoKHMpLHRoaXMuY29tcGlsZUFuZFJ1bihoLGYpfSxvLnByb3RvdHlwZS5jb252MmQ9ZnVuY3Rpb24odCxlLG4pe2lmKDE9PT1uLmZpbHRlckhlaWdodCYmMT09PW4uZmlsdGVyV2lkdGgmJjE9PT1uLmRpbGF0aW9uSGVpZ2h0JiYxPT09bi5kaWxhdGlvbldpZHRoJiYxPT09bi5zdHJpZGVIZWlnaHQmJjE9PT1uLnN0cmlkZVdpZHRoJiYoXCJTQU1FXCI9PT1uLnBhZEluZm8udHlwZXx8XCJWQUxJRFwiPT09bi5wYWRJbmZvLnR5cGUpKXJldHVybiB0aGlzLmNvbnYyZEJ5TWF0TXVsKHQsZSxuKTtpZihpKCkuZ2V0Qm9vbChcIldFQkdMX0NPTlZfSU0yQ09MXCIpJiYxPT09dC5zaGFwZVswXSlyZXR1cm4gdGhpcy5jb252MmRXaXRoSW0yUm93KHQsZSxuKTt2YXIgcj1uZXcgVWkobik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0LGVdKX0sby5wcm90b3R5cGUuY29udjJkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBNaShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5jb252MmREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBPaShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5mdXNlZERlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0KXt2YXIgZSxuPXQuaW5wdXQscj10LmZpbHRlcixvPXQuY29udkluZm8sYT10LmJpYXMscz10LmFjdGl2YXRpb24sdT10LnByZWx1QWN0aXZhdGlvbldlaWdodHMsYz1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tfREVQVEhXSVNFQ09OVlwiKSYmby5zdHJpZGVXaWR0aDw9MiYmby5vdXRDaGFubmVscy9vLmluQ2hhbm5lbHM9PTEsbD1zP0x1KHMsYyk6bnVsbCxoPVtuLHJdLGY9bnVsbCE9YSxkPW51bGwhPXU7cmV0dXJuIGYmJmgucHVzaChhKSxkJiZoLnB1c2godSksYz8oZT1uZXcgR2kobyxmLGwsZCksdGhpcy5jb21waWxlQW5kUnVuKGUsaCkpOihlPW5ldyB6aShvLGYsbCxkKSx0aGlzLmNvbXBpbGVBbmRSdW4oZSxoKSl9LG8ucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0LGUsbil7dmFyIHI7cmV0dXJuIGkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19ERVBUSFdJU0VDT05WXCIpJiZuLnN0cmlkZVdpZHRoPD0yJiZuLm91dENoYW5uZWxzL24uaW5DaGFubmVscz09MT8ocj1uZXcgR2kobiksdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pKToocj1uZXcgemkobiksdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pKX0sby5wcm90b3R5cGUuZGVwdGh3aXNlQ29udjJERGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBXaShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkREZXJGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBMaShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5jb252M2Q9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBWaShuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3QsZV0pfSxvLnByb3RvdHlwZS5jb252M2REZXJJbnB1dD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IFBpKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LG8ucHJvdG90eXBlLmNvbnYzZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IEJpKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdCxlXSl9LG8ucHJvdG90eXBlLm1heFBvb2w9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgV3MoZSxcIm1heFwiLCExKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG4sW3RdKX0sby5wcm90b3R5cGUuYXZnUG9vbD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBXcyhlLFwiYXZnXCIsITEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0sXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5tYXhQb29sQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bmV3IFdzKHIsXCJtYXhcIiwhMCksYT10aGlzLmNvbXBpbGVBbmRSdW4obyxbZV0pLGk9bmV3IE5zKHIpLHM9dGhpcy5jb21waWxlQW5kUnVuKGksW3QsYV0sZS5kdHlwZSk7cmV0dXJuIGEuZGlzcG9zZSgpLHN9LG8ucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IGZpKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0sZS5kdHlwZSl9LG8ucHJvdG90eXBlLmNhc3Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gUmEodCxlLHRoaXMpfSxvLnByb3RvdHlwZS51bnN0YWNrPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuc2hhcGVbZV0scj1uZXcgQXJyYXkodC5yYW5rLTEpLG89MCxhPTA7YTx0LnJhbms7YSsrKWEhPT1lJiYocltvKytdPXQuc2hhcGVbYV0pO3ZhciBpPW5ldyBBcnJheSh0LnJhbmspLmZpbGwoMCkscz10LnNoYXBlLnNsaWNlKCk7c1tlXT0xO3ZhciB1PW5ldyBBcnJheShuKTtmb3IoYT0wO2E8dS5sZW5ndGg7YSsrKWlbZV09YSx1W2FdPXRoaXMuc2xpY2UodCxpLHMpLnJlc2hhcGUocik7cmV0dXJuIHV9LG8ucHJvdG90eXBlLmF2Z1Bvb2wzZD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBVcyhlLFwiYXZnXCIsITEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0sXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hdmdQb29sM2RCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IGRpKG4pO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocixbdF0sZS5kdHlwZSl9LG8ucHJvdG90eXBlLm1heFBvb2wzZD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBVcyhlLFwibWF4XCIsITEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4obixbdF0sXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5tYXhQb29sM2RCYWNrcHJvcD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgVXMocixcIm1heFwiLCEwKSxhPXRoaXMuY29tcGlsZUFuZFJ1bihvLFtlXSksaT1uZXcgRnMocikscz10aGlzLmNvbXBpbGVBbmRSdW4oaSxbdCxhXSxlLmR0eXBlKTtyZXR1cm4gYS5kaXNwb3NlKCksc30sby5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMudGV4RGF0YS5nZXQodC5kYXRhSWQpO2lmKG4uaXNQYWNrZWQmJiFfZSh0LnNoYXBlLGUpJiYobnVsbD09PW4udGV4dHVyZXx8IV9lKG4uc2hhcGUsZSkpKXt2YXIgcj10aGlzLnBhY2tlZFJlc2hhcGUodCxlKTtyZXR1cm4gTHQubWFrZVRlbnNvckZyb21EYXRhSWQoci5kYXRhSWQsci5zaGFwZSxyLmR0eXBlKX1yZXR1cm4gSWEodCxlKX0sby5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0lNQUdFX09QRVJBVElPTlNcIik/bmV3IHFzKHQuc2hhcGUsZSxuLHIpOm5ldyBIcyh0LnNoYXBlLGUsbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3RdLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IEdzKHQsZSxuKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHIsW3RdKX0sby5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPW5ldyBqcyh0LnNoYXBlLGUsbixyKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW3RdKX0sby5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBLcyh0LGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihyLFt0XSl9LG8ucHJvdG90eXBlLm11bHRpbm9taWFsPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPWU/dDppYSh0KSxhPW8uc2hhcGVbMF0saT1vLnNoYXBlWzFdLHM9bmV3IE9zKGEsaSxuKSx1PXMuZ2V0Q3VzdG9tU2V0dXBGdW5jKHIpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocyxbb10sXCJpbnQzMlwiLHUpfSxvLnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89bmV3IE1zKHQuc2l6ZSxlLG4scik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihvLFt0XSl9LG8ucHJvdG90eXBlLmRpYWc9ZnVuY3Rpb24odCl7dmFyIGU9bmV3ICRpKHQuc2l6ZSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihlLFt0XSl9LG8ucHJvdG90eXBlLm5vbk1heFN1cHByZXNzaW9uPWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIGRuKFwidGYubm9uTWF4U3VwcHJlc3Npb24oKSBpbiB3ZWJnbCBsb2NrcyB0aGUgVUkgdGhyZWFkLiBDYWxsIHRmLm5vbk1heFN1cHByZXNzaW9uQXN5bmMoKSBpbnN0ZWFkXCIpLE9hKHQuZGF0YVN5bmMoKSxlLmRhdGFTeW5jKCksbixyLG8pfSxvLnByb3RvdHlwZS5jcm9wQW5kUmVzaXplPWZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2YXIgaT1uZXcgSGkodC5zaGFwZSxlLnNoYXBlLHIsbyxhKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKGksW3QsZSxuXSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUsbil7QyhlPjEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJibG9ja1NpemUgc2hvdWxkIGJlID4gMSBmb3IgZGVwdGhUb1NwYWNlLCBidXQgd2FzOiBcIitlfSkpO3ZhciByPXQuc2hhcGVbMF0sbz1cIk5IV0NcIj09PW4/dC5zaGFwZVsxXTp0LnNoYXBlWzJdLGE9XCJOSFdDXCI9PT1uP3Quc2hhcGVbMl06dC5zaGFwZVszXSxpPVwiTkhXQ1wiPT09bj90LnNoYXBlWzNdOnQuc2hhcGVbMV0scz1vKmUsdT1hKmUsYz1pLyhlKmUpLGw9bmV3IFlpKFwiTkhXQ1wiPT09bj9bcixzLHUsY106W3IsYyxzLHVdLGUsbik7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihsLFt0XSl9LG8ucHJvdG90eXBlLnNwbGl0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gVWEodCxlLG4pfSxvLnByb3RvdHlwZS5zY2F0dGVyTkQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPUdvKDAsdCxuKSxvPXIuc2xpY2VSYW5rLGE9ci5udW1VcGRhdGVzLGk9ci5zbGljZVNpemUscz1yLnN0cmlkZXMsdT1yLm91dHB1dFNpemUsYz1bdS9pLGldLGw9dC5yZXNoYXBlKFthLG9dKSxoPWUucmVzaGFwZShbYSxpXSk7aWYoMD09PXUpcmV0dXJuIElhKEZuKFtdKSxuKTt2YXIgZj1PbigwKSxkPW5ldyAkcyhhLG8sbC5yYW5rLGgucmFuayxzLGMpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oZCxbaCxsLGZdKS5yZXNoYXBlKG4pfSxvLnByb3RvdHlwZS5zcGFyc2VUb0RlbnNlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPUdvKDAsdCxuKSxhPW8uc2xpY2VSYW5rLGk9by5udW1VcGRhdGVzLHM9by5zdHJpZGVzLHU9by5vdXRwdXRTaXplLGM9bmV3ICRzKGksYSx0LnJhbmssZS5yYW5rLHMsW3UsMV0sITEpO3JldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4oYyxbZSx0LHJdKS5yZXNoYXBlKG4pfSxvLnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmZ0SW1wbCh0LCExKX0sby5wcm90b3R5cGUuaWZmdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mZnRJbXBsKHQsITApfSxvLnByb3RvdHlwZS5mZnRJbXBsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy50ZXhEYXRhLmdldCh0LmRhdGFJZCkscj1uZXcgcnMoZXMsdC5zaGFwZSxlKSxvPW5ldyBycyhucyx0LnNoYXBlLGUpLGE9W3RoaXMubWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvKHQsbi5jb21wbGV4VGVuc29ycy5yZWFsKSx0aGlzLm1ha2VDb21wbGV4Q29tcG9uZW50VGVuc29ySW5mbyh0LG4uY29tcGxleFRlbnNvcnMuaW1hZyldLGk9dGhpcy5jb21waWxlQW5kUnVuKHIsYSkscz10aGlzLmNvbXBpbGVBbmRSdW4obyxhKSx1PXRoaXMuY29tcGxleChpLHMpLmFzMkQodC5zaGFwZVswXSx0LnNoYXBlWzFdKTtyZXR1cm4gaS5kaXNwb3NlKCkscy5kaXNwb3NlKCksdX0sby5wcm90b3R5cGUuZ2F0aGVyTkQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNoYXBlLHI9bltuLmxlbmd0aC0xXSxvPVBvKHQsZSksYT1vWzBdLGk9b1sxXSxzPW9bMl0sdT1vWzNdLGM9ZS5yZXNoYXBlKFtpLHJdKSxsPXQucmVzaGFwZShbdC5zaXplL3Msc10pLGg9bmV3IGlzKHIsdSxbaSxzXSk7cmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihoLFtsLGNdKS5yZXNoYXBlKGEpfSxvLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKHQsZSxuKXtpZihcInN0cmluZ1wiPT09KG49bnx8aihlKSkpe3ZhciByPVAobixrKHQpKTtyZXR1cm4gci5maWxsKGUpLEx0Lm1ha2VUZW5zb3Iocix0LG4sdGhpcyl9dmFyIG89bmV3IG9zKHQsZSksYT1vLmdldEN1c3RvbVNldHVwRnVuYyhlKTtyZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKG8sW10sbixhKX0sby5wcm90b3R5cGUub25lc0xpa2U9ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIj09PXQuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwib25lc0xpa2UgaXMgbm90IHN1cHBvcnRlZCB1bmRlciBzdHJpbmcgZHR5cGVcIik7cmV0dXJuIHRoaXMuZmlsbCh0LnNoYXBlLDEsdC5kdHlwZSl9LG8ucHJvdG90eXBlLnplcm9zTGlrZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5maWxsKHQuc2hhcGUsXCJzdHJpbmdcIj09PXQuZHR5cGU/XCJcIjowLHQuZHR5cGUpfSxvLnByb3RvdHlwZS5saW5zcGFjZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGthKHQsZSxuKX0sby5wcm90b3R5cGUubWFrZVRlbnNvckluZm89ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLndyaXRlKG51bGwsdCxlKTtyZXR1cm4gdGhpcy50ZXhEYXRhLmdldChuKS51c2FnZT1udWxsLHtkYXRhSWQ6bixzaGFwZTp0LGR0eXBlOmV9fSxvLnByb3RvdHlwZS5tYWtlT3V0cHV0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5tYWtlVGVuc29ySW5mbyh0LGUpLmRhdGFJZDtyZXR1cm4gTHQubWFrZVRlbnNvckZyb21EYXRhSWQobix0LGUsdGhpcyl9LG8ucHJvdG90eXBlLnVucGFja1RlbnNvcj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQnUodC5zaGFwZSk7cmV0dXJuIHRoaXMucnVuV2ViR0xQcm9ncmFtKGUsW3RdLHQuZHR5cGUpfSxvLnByb3RvdHlwZS5wYWNrVGVuc29yPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBCcyh0LnNoYXBlKTtyZXR1cm4gdGhpcy5ydW5XZWJHTFByb2dyYW0oZSxbdF0sdC5kdHlwZSxudWxsLCEwKX0sby5wcm90b3R5cGUucGFja2VkUmVzaGFwZT1mdW5jdGlvbih0LGUpe3ZhciBuPVtBZSh0LnNoYXBlKV0uY29uY2F0KFRlKHQuc2hhcGUpKSxyPXtkdHlwZTp0LmR0eXBlLHNoYXBlOm4sZGF0YUlkOnQuZGF0YUlkfSxvPVtBZShlKV0uY29uY2F0KFRlKGUpKSxhPW5ldyB6cyhvLG4pLGk9dGhpcy5ydW5XZWJHTFByb2dyYW0oYSxbcl0sdC5kdHlwZSxudWxsLCEwKTtyZXR1cm57ZGF0YUlkOmkuZGF0YUlkLHNoYXBlOmUsZHR5cGU6aS5kdHlwZX19LG8ucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbih0KXt2YXIgZSxuPXRoaXMudGV4RGF0YS5nZXQodCkscj1uLmlzUGFja2VkLG89bi5zaGFwZSxhPW4uZHR5cGUsaT1EZShvKTtlPXI/bmV3IFhpKGkpOm5ldyBqaShpKTtyZXR1cm57ZHR5cGU6YSxzaGFwZTpvLGRhdGFJZDp0aGlzLnJ1bldlYkdMUHJvZ3JhbShlLFt7c2hhcGU6aSxkdHlwZTphLGRhdGFJZDp0fV0sYSxudWxsLCEwKS5kYXRhSWR9fSxvLnByb3RvdHlwZS5ydW5XZWJHTFByb2dyYW09ZnVuY3Rpb24odCxlLG4scixvKXt2YXIgYT10aGlzO3ZvaWQgMD09PW8mJihvPSExKTt2YXIgcz10aGlzLm1ha2VUZW5zb3JJbmZvKHQub3V0cHV0U2hhcGUsbiksdT10aGlzLnRleERhdGEuZ2V0KHMuZGF0YUlkKTtpZih0LnBhY2tlZE91dHB1dCYmKHUuaXNQYWNrZWQ9ITApLHQub3V0UGFja2luZ1NjaGVtZT09PVZ0LkRFTlNFKXt2YXIgYz1ZdCh0Lm91dHB1dFNoYXBlKTt1LnRleFNoYXBlPWMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gMip0fSkpfWlmKG51bGwhPXQub3V0VGV4VXNhZ2UmJih1LnVzYWdlPXQub3V0VGV4VXNhZ2UpLDA9PT1rKHMuc2hhcGUpKXJldHVybiB1LnZhbHVlcz1CKHMuZHR5cGUsMCksczt2YXIgbD1bXSxoPWUubWFwKChmdW5jdGlvbihlKXtpZihcImNvbXBsZXg2NFwiPT09ZS5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJHUEdQVVByb2dyYW0gZG9lcyBub3Qgc3VwcG9ydCBjb21wbGV4NjQgaW5wdXQuIEZvciBjb21wbGV4NjQgZHR5cGVzLCBwbGVhc2Ugc2VwYXJhdGUgdGhlIHByb2dyYW0gaW50byByZWFsIGFuZCBpbWFnaW5hcnkgcGFydHMuXCIpO3ZhciBuPWEudGV4RGF0YS5nZXQoZS5kYXRhSWQpO2lmKG51bGw9PW4udGV4dHVyZSl7aWYoIXQucGFja2VkSW5wdXRzJiZrKGUuc2hhcGUpPD1pKCkuZ2V0TnVtYmVyKFwiV0VCR0xfU0laRV9VUExPQURfVU5JRk9STVwiKSlyZXR1cm57c2hhcGU6ZS5zaGFwZSx0ZXhEYXRhOm51bGwsaXNVbmlmb3JtOiEwLHVuaWZvcm1WYWx1ZXM6bi52YWx1ZXN9O3QucGFja2VkSW5wdXRzJiYobi5pc1BhY2tlZD0hMCxuLnNoYXBlPWUuc2hhcGUpfWVsc2UgaWYoISFuLmlzUGFja2VkIT0hIXQucGFja2VkSW5wdXRzKWU9bi5pc1BhY2tlZD9hLnVucGFja1RlbnNvcihlKTphLnBhY2tUZW5zb3IoZSksbC5wdXNoKGUpLG49YS50ZXhEYXRhLmdldChlLmRhdGFJZCk7ZWxzZSBpZihuLmlzUGFja2VkJiYhX2Uobi5zaGFwZSxlLnNoYXBlKSl7dmFyIHI9ZSxvPWUuc2hhcGU7ZS5zaGFwZT1uLnNoYXBlLGU9YS5wYWNrZWRSZXNoYXBlKGUsbyksbC5wdXNoKGUpLG49YS50ZXhEYXRhLmdldChlLmRhdGFJZCksci5zaGFwZT1vfXJldHVybiBhLnVwbG9hZFRvR1BVKGUuZGF0YUlkKSx7c2hhcGU6ZS5zaGFwZSx0ZXhEYXRhOm4saXNVbmlmb3JtOiExfX0pKTt0aGlzLnVwbG9hZFRvR1BVKHMuZGF0YUlkKTt2YXIgZixkPXtzaGFwZTpzLnNoYXBlLHRleERhdGE6dSxpc1VuaWZvcm06ITF9LHA9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVwiXCI7ZS5jb25jYXQobikuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9bnVsbCE9dC50ZXhEYXRhJiZudWxsIT10LnRleERhdGEuc2xpY2UmJnQudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0PjAsbj10LmlzVW5pZm9ybT9cInVuaWZvcm1cIjp0LnRleERhdGEudGV4U2hhcGU7cis9dC5zaGFwZStcIl9cIituK1wiX1wiK2V9KSk7dmFyIG89dC51c2VyQ29kZSxhPXQuY29uc3RydWN0b3IubmFtZTtyZXR1cm4gYSs9XCJfXCIrcitcIl9cIitvfSh0LGgsZCksdj10aGlzLmdldEFuZFNhdmVCaW5hcnkocCwoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7dmFyIG89ZS51c2VyQ29kZSxhPW4ubWFwKChmdW5jdGlvbih0LG4pe3ZhciByPXtsb2dpY2FsU2hhcGU6dC5zaGFwZSx0ZXhTaGFwZTp0LmlzVW5pZm9ybT9udWxsOnQudGV4RGF0YS50ZXhTaGFwZSxpc1VuaWZvcm06dC5pc1VuaWZvcm0saXNQYWNrZWQ6IXQuaXNVbmlmb3JtJiZ0LnRleERhdGEuaXNQYWNrZWQsZmxhdE9mZnNldDpudWxsfTtyZXR1cm4gbnVsbCE9dC50ZXhEYXRhJiZudWxsIT10LnRleERhdGEuc2xpY2UmJnQudGV4RGF0YS5zbGljZS5mbGF0T2Zmc2V0PjAmJihyLmZsYXRPZmZzZXQ9dC50ZXhEYXRhLnNsaWNlLmZsYXRPZmZzZXQpLHtuYW1lOmUudmFyaWFibGVOYW1lc1tuXSxzaGFwZUluZm86cn19KSkscz1hLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGVJbmZvfSkpLHU9e2xvZ2ljYWxTaGFwZTpyLnNoYXBlLHRleFNoYXBlOnIudGV4RGF0YS50ZXhTaGFwZSxpc1VuaWZvcm06ITEsaXNQYWNrZWQ6ci50ZXhEYXRhLmlzUGFja2VkLGZsYXRPZmZzZXQ6bnVsbH0sYz1aYShhLHUsbyxlLnBhY2tlZElucHV0cyksbD10LmNyZWF0ZVByb2dyYW0oYyksaD1udWxsLGY9dC5nZXRVbmlmb3JtTG9jYXRpb24obCxcIk5BTlwiLCExKTsxPT09aSgpLmdldE51bWJlcihcIldFQkdMX1ZFUlNJT05cIikmJihoPXQuZ2V0VW5pZm9ybUxvY2F0aW9uKGwsXCJJTkZJTklUWVwiLCExKSk7Zm9yKHZhciBkPXt9LHA9MDtwPGUudmFyaWFibGVOYW1lcy5sZW5ndGg7cCsrKXt2YXIgdj1lLnZhcmlhYmxlTmFtZXNbcF07ZFt2XT10LmdldFVuaWZvcm1Mb2NhdGlvbihsLHYsITEpLGRbXCJvZmZzZXRcIit2XT10LmdldFVuaWZvcm1Mb2NhdGlvbihsLFwib2Zmc2V0XCIrdiwhMSl9cmV0dXJue3Byb2dyYW06ZSxzb3VyY2U6Yyx3ZWJHTFByb2dyYW06bCx1bmlmb3JtTG9jYXRpb25zOmQsaW5TaGFwZUluZm9zOnMsb3V0U2hhcGVJbmZvOnUsaW5mTG9jOmgsbmFuTG9jOmZ9fShhLmdwZ3B1LHQsaCxkKX0pKSxnPW51bGwhPXRoaXMuYWN0aXZlVGltZXJzO2lmKGcmJihmPXRoaXMuc3RhcnRUaW1lcigpKSxmdW5jdGlvbih0LGUsbixyLG8pe2tzKGUuaW5TaGFwZUluZm9zLG4pLGtzKFtlLm91dFNoYXBlSW5mb10sW3JdKTt2YXIgYT1yLnRleERhdGEudGV4dHVyZSxzPXIudGV4RGF0YS50ZXhTaGFwZTtyLnRleERhdGEuaXNQYWNrZWQ/dC5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlKGEsc1swXSxzWzFdKTp0LnNldE91dHB1dE1hdHJpeFRleHR1cmUoYSxzWzBdLHNbMV0pLHQuc2V0UHJvZ3JhbShlLndlYkdMUHJvZ3JhbSksMT09PWkoKS5nZXROdW1iZXIoXCJXRUJHTF9WRVJTSU9OXCIpJiZudWxsIT09ZS5pbmZMb2MmJnQuZ2wudW5pZm9ybTFmKGUuaW5mTG9jLDEvMCksbnVsbCE9PWUubmFuTG9jJiZ0LmdsLnVuaWZvcm0xZihlLm5hbkxvYyxOYU4pLG4uZm9yRWFjaCgoZnVuY3Rpb24obixyKXt2YXIgbz1lLnByb2dyYW0udmFyaWFibGVOYW1lc1tyXSxhPWUudW5pZm9ybUxvY2F0aW9uc1tvXSxpPWUudW5pZm9ybUxvY2F0aW9uc1tcIm9mZnNldFwiK29dO2lmKG51bGwhPWEpaWYobi5pc1VuaWZvcm0paWYoayhuLnNoYXBlKTwyKXQuZ2wudW5pZm9ybTFmKGEsbi51bmlmb3JtVmFsdWVzWzBdKTtlbHNle3ZhciBzPW4udW5pZm9ybVZhbHVlcztzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHwocz1uZXcgRmxvYXQzMkFycmF5KHMpKSx0LmdsLnVuaWZvcm0xZnYoYSxzKX1lbHNlIG51bGwhPW4udGV4RGF0YS5zbGljZSYmbnVsbCE9aSYmdC5nbC51bmlmb3JtMWkoaSxuLnRleERhdGEuc2xpY2UuZmxhdE9mZnNldCksdC5zZXRJbnB1dE1hdHJpeFRleHR1cmUobi50ZXhEYXRhLnRleHR1cmUsYSxyKX0pKSxudWxsIT1vJiZvKHQsZS53ZWJHTFByb2dyYW0pLHQuZXhlY3V0ZVByb2dyYW0oKX0odGhpcy5ncGdwdSx2LGgsZCxyKSxsLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBhLmRpc3Bvc2VEYXRhKHQuZGF0YUlkKX0pKSxnJiYoZj10aGlzLmVuZFRpbWVyKGYpLHRoaXMuYWN0aXZlVGltZXJzLnB1c2goe25hbWU6dC5jb25zdHJ1Y3Rvci5uYW1lLHF1ZXJ5OnRoaXMuZ2V0UXVlcnlUaW1lKGYpfSkpLCFpKCkuZ2V0Qm9vbChcIldFQkdMX0xBWklMWV9VTlBBQ0tcIikmJnUuaXNQYWNrZWQmJiExPT09byl7dmFyIG09dGhpcy51bnBhY2tUZW5zb3Iocyk7cmV0dXJuIHRoaXMuZGlzcG9zZURhdGEocy5kYXRhSWQpLG19cmV0dXJuIHN9LG8ucHJvdG90eXBlLmNvbXBpbGVBbmRSdW49ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1vJiYobz0hMSksbj1ufHxlWzBdLmR0eXBlO3ZhciBhPXRoaXMucnVuV2ViR0xQcm9ncmFtKHQsZSxuLHIsbyk7cmV0dXJuIEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKGEuZGF0YUlkLGEuc2hhcGUsYS5kdHlwZSl9LG8ucHJvdG90eXBlLmdldEFuZFNhdmVCaW5hcnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCBpbiB0aGlzLmJpbmFyeUNhY2hlfHwodGhpcy5iaW5hcnlDYWNoZVt0XT1lKCkpLHRoaXMuYmluYXJ5Q2FjaGVbdF19LG8ucHJvdG90eXBlLmdldFRleHR1cmVNYW5hZ2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGV4dHVyZU1hbmFnZXJ9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKCF0aGlzLmRpc3Bvc2VkKXtpZighaSgpLmdldEJvb2woXCJJU19URVNUXCIpKU9iamVjdC5rZXlzKHRoaXMuYmluYXJ5Q2FjaGUpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3QuZ3BncHUuZGVsZXRlUHJvZ3JhbSh0LmJpbmFyeUNhY2hlW2VdLndlYkdMUHJvZ3JhbSksZGVsZXRlIHQuYmluYXJ5Q2FjaGVbZV19KSk7dGhpcy50ZXh0dXJlTWFuYWdlci5kaXNwb3NlKCksbnVsbCE9dGhpcy5jYW52YXMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCYmdGhpcy5jYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudD90aGlzLmNhbnZhcy5yZW1vdmUoKTp0aGlzLmNhbnZhcz1udWxsLHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSYmKHRoaXMuZ3BncHUucHJvZ3JhbT1udWxsLHRoaXMuZ3BncHUuZGlzcG9zZSgpKSx0aGlzLmRpc3Bvc2VkPSEwfX0sby5wcm90b3R5cGUuZmxvYXRQcmVjaXNpb249ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBudWxsPT10aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWUmJih0aGlzLmZsb2F0UHJlY2lzaW9uVmFsdWU9WmUoKGZ1bmN0aW9uKCl7aWYoIWkoKS5nZXQoXCJXRUJHTF9SRU5ERVJfRkxPQVQzMl9FTkFCTEVEXCIpKXt2YXIgZT1pKCkuZ2V0Qm9vbChcIkRFQlVHXCIpO2koKS5zZXQoXCJERUJVR1wiLCExKTt2YXIgbj10LmFicyhPbigxZS04KSkuZGF0YVN5bmMoKVswXTtpZihpKCkuc2V0KFwiREVCVUdcIixlKSxuPjApcmV0dXJuIDMyfXJldHVybiAxNn0pKSksdGhpcy5mbG9hdFByZWNpc2lvblZhbHVlfSxvLnByb3RvdHlwZS5lcHNpbG9uPWZ1bmN0aW9uKCl7cmV0dXJuIDMyPT09dGhpcy5mbG9hdFByZWNpc2lvbigpPzFlLTc6MWUtNH0sby5wcm90b3R5cGUudXBsb2FkVG9HUFU9ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzLnRleERhdGEuZ2V0KHQpLHI9bi5zaGFwZSxvPW4uZHR5cGUsYT1uLnZhbHVlcyxpPW4udGV4dHVyZSxzPW4udXNhZ2UsdT1uLmlzUGFja2VkO2lmKG51bGw9PWkpe3ZhciBjLGw9bnVsbCE9dGhpcy5hY3RpdmVUaW1lcnM7bCYmKGM9ZXQoKSk7dmFyIGg9bi50ZXhTaGFwZTtpZihudWxsPT1oJiYoaD1OZShyLHUpLG4udGV4U2hhcGU9aCksbnVsbCE9YSl7dmFyIGY9RGUociksZD12b2lkIDAscD1oWzFdLHY9aFswXSxnPWEgaW5zdGFuY2VvZiBVaW50OEFycmF5O3U/KHA9KGU9JHQoaFswXSxoWzFdKSlbMF0sdj1lWzFdLGQ9bmV3IHRzKGYsW3YscF0sZykpOmQ9bmV3IFppKGYsW3YscF0sZyk7dmFyIG09dGhpcy5tYWtlVGVuc29ySW5mbyhbdixwXSxvKTt0aGlzLnRleERhdGEuZ2V0KG0uZGF0YUlkKS51c2FnZT1nP3p0LlBJWEVMUzp6dC5VUExPQUQsdGhpcy5ncGdwdS51cGxvYWREZW5zZU1hdHJpeFRvVGV4dHVyZSh0aGlzLmdldFRleHR1cmUobS5kYXRhSWQpLHAsdixhKTt2YXIgeT10aGlzLnJ1bldlYkdMUHJvZ3JhbShkLFttXSxvLG51bGwsITApLHg9dGhpcy50ZXhEYXRhLmdldCh5LmRhdGFJZCk7bi50ZXh0dXJlPXgudGV4dHVyZSxuLnRleFNoYXBlPXgudGV4U2hhcGUsbi5pc1BhY2tlZD14LmlzUGFja2VkLG4udXNhZ2U9eC51c2FnZSx0aGlzLmRpc3Bvc2VEYXRhKG0uZGF0YUlkKSx0aGlzLnRleERhdGEuZGVsZXRlKHkuZGF0YUlkKSxuLnZhbHVlcz1udWxsLGwmJih0aGlzLnVwbG9hZFdhaXRNcys9ZXQoKS1jKX1lbHNle3ZhciBiPXRoaXMuYWNxdWlyZVRleHR1cmUoaCxzLG8sdSk7bi50ZXh0dXJlPWJ9fX0sby5wcm90b3R5cGUuY29udmVydEFuZENhY2hlT25DUFU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnRleERhdGEuZ2V0KHQpLHI9bi5kdHlwZTtyZXR1cm4gdGhpcy5yZWxlYXNlR1BVRGF0YSh0KSxudWxsIT1lJiYobi52YWx1ZXM9ZnVuY3Rpb24odCxlKXtpZihcImZsb2F0MzJcIj09PWV8fFwiY29tcGxleDY0XCI9PT1lKXJldHVybiB0O2lmKFwiaW50MzJcIj09PWV8fFwiYm9vbFwiPT09ZSl7Zm9yKHZhciBuPVwiaW50MzJcIj09PWU/bmV3IEludDMyQXJyYXkodC5sZW5ndGgpOm5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxyPTA7cjxuLmxlbmd0aDsrK3IpbltyXT1NYXRoLnJvdW5kKHRbcl0pO3JldHVybiBufXRocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIrZSl9KGUscikpLG4udmFsdWVzfSxvLnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZT1mdW5jdGlvbih0LGUsbixyKXtpZih0aGlzLm51bUJ5dGVzSW5HUFUrPXRoaXMuY29tcHV0ZUJ5dGVzKHQsbiksIXRoaXMud2FybmVkQWJvdXRNZW1vcnkmJnRoaXMubnVtQnl0ZXNJbkdQVT4xMDI0KnRoaXMubnVtTUJCZWZvcmVXYXJuaW5nKjEwMjQpe3ZhciBvPSh0aGlzLm51bUJ5dGVzSW5HUFUvMTAyNC8xMDI0KS50b0ZpeGVkKDIpO3RoaXMud2FybmVkQWJvdXRNZW1vcnk9ITAsY29uc29sZS53YXJuKFwiSGlnaCBtZW1vcnkgdXNhZ2UgaW4gR1BVOiBcIitvK1wiIE1CLCBtb3N0IGxpa2VseSBkdWUgdG8gYSBtZW1vcnkgbGVha1wiKX1yZXR1cm4gdGhpcy50ZXh0dXJlTWFuYWdlci5hY3F1aXJlVGV4dHVyZSh0LGUscil9LG8ucHJvdG90eXBlLmNvbXB1dGVCeXRlcz1mdW5jdGlvbih0LGUpe3JldHVybiB0WzBdKnRbMV0qeihlKX0sb30obGEpO1d0KCkmJkx0LnJlZ2lzdGVyQmFja2VuZChcIndlYmdsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBVdX0pLDIpO1widW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGY7ZnVuY3Rpb24gVnUodCxlKXtyZXR1cm4gdChlPXtleHBvcnRzOnt9fSxlLmV4cG9ydHMpLGUuZXhwb3J0c312YXIgenU9VnUoKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZSxuPXRoaXMscj0oZT00MDIyODcxMTk3LGZ1bmN0aW9uKHQpe3Q9dC50b1N0cmluZygpO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj0uMDI1MTk2MDMyODI0MTY5MzgqKGUrPXQuY2hhckNvZGVBdChuKSk7ci09ZT1yPj4+MCxlPShyKj1lKT4+PjAsZSs9NDI5NDk2NzI5Niooci09ZSl9cmV0dXJuIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTAqKGU+Pj4wKX0pO24ubmV4dD1mdW5jdGlvbigpe3ZhciB0PTIwOTE2Mzkqbi5zMCsyLjMyODMwNjQzNjUzODY5NjNlLTEwKm4uYztyZXR1cm4gbi5zMD1uLnMxLG4uczE9bi5zMixuLnMyPXQtKG4uYz0wfHQpfSxuLmM9MSxuLnMwPXIoXCIgXCIpLG4uczE9cihcIiBcIiksbi5zMj1yKFwiIFwiKSxuLnMwLT1yKHQpLG4uczA8MCYmKG4uczArPTEpLG4uczEtPXIodCksbi5zMTwwJiYobi5zMSs9MSksbi5zMi09cih0KSxuLnMyPDAmJihuLnMyKz0xKSxyPW51bGx9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLmM9dC5jLGUuczA9dC5zMCxlLnMxPXQuczEsZS5zMj10LnMyLGV9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPW4ubmV4dDtyZXR1cm4gaS5pbnQzMj1mdW5jdGlvbigpe3JldHVybiA0Mjk0OTY3Mjk2Km4ubmV4dCgpfDB9LGkuZG91YmxlPWZ1bmN0aW9uKCl7cmV0dXJuIGkoKSsxMTEwMjIzMDI0NjI1MTU2NWUtMzIqKDIwOTcxNTIqaSgpfDApfSxpLnF1aWNrPWksYSYmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bigoZnVuY3Rpb24oKXtyZXR1cm4gYX0pKTp0aGlzLmFsZWE9YX0oMCx0LCExKX0pKSxHdT1WdSgoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXMsbj1cIlwiO2UueD0wLGUueT0wLGUuej0wLGUudz0wLGUubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUueF5lLng8PDExO3JldHVybiBlLng9ZS55LGUueT1lLnosZS56PWUudyxlLndePWUudz4+PjE5XnRedD4+Pjh9LHQ9PT0oMHx0KT9lLng9dDpuKz10O2Zvcih2YXIgcj0wO3I8bi5sZW5ndGgrNjQ7cisrKWUueF49MHxuLmNoYXJDb2RlQXQociksZS5uZXh0KCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLng9dC54LGUueT10LnksZS56PXQueixlLnc9dC53LGV9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuPW5ldyByKHQpLGE9ZSYmZS5zdGF0ZSxpPWZ1bmN0aW9uKCl7cmV0dXJuKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5Nn07cmV0dXJuIGkuZG91YmxlPWZ1bmN0aW9uKCl7ZG97dmFyIHQ9KChuLm5leHQoKT4+PjExKSsobi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2KS8oMTw8MjEpfXdoaWxlKDA9PT10KTtyZXR1cm4gdH0saS5pbnQzMj1uLm5leHQsaS5xdWljaz1pLGEmJihcIm9iamVjdFwiPT10eXBlb2YgYSYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSk6dGhpcy54b3IxMjg9YX0oMCx0LCExKX0pKSxIdT1WdSgoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXMsbj1cIlwiO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUueF5lLng+Pj4yO3JldHVybiBlLng9ZS55LGUueT1lLnosZS56PWUudyxlLnc9ZS52LChlLmQ9ZS5kKzM2MjQzN3wwKSsoZS52PWUudl5lLnY8PDRedF50PDwxKXwwfSxlLng9MCxlLnk9MCxlLno9MCxlLnc9MCxlLnY9MCx0PT09KDB8dCk/ZS54PXQ6bis9dDtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoKzY0O3IrKyllLnhePTB8bi5jaGFyQ29kZUF0KHIpLHI9PW4ubGVuZ3RoJiYoZS5kPWUueDw8MTBeZS54Pj4+NCksZS5uZXh0KCl9ZnVuY3Rpb24gbyh0LGUpe3JldHVybiBlLng9dC54LGUueT10LnksZS56PXQueixlLnc9dC53LGUudj10LnYsZS5kPXQuZCxlfWZ1bmN0aW9uIGEodCxlKXt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKChmdW5jdGlvbigpe3JldHVybiBhfSkpOnRoaXMueG9yd293PWF9KDAsdCwhMSl9KSkscXU9VnUoKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0LG4scj1lLngsbz1lLmk7cmV0dXJuIHQ9cltvXSxuPSh0Xj10Pj4+NyledDw8MjQsbl49KHQ9cltvKzEmN10pXnQ+Pj4xMCxuXj0odD1yW28rMyY3XSledD4+PjMsbl49KHQ9cltvKzQmN10pXnQ8PDcsdD1yW28rNyY3XSxuXj0odF49dDw8MTMpXnQ8PDkscltvXT1uLGUuaT1vKzEmNyxufSxmdW5jdGlvbih0LGUpe3ZhciBuLHI9W107aWYoZT09PSgwfGUpKXJbMF09ZTtlbHNlIGZvcihlPVwiXCIrZSxuPTA7bjxlLmxlbmd0aDsrK24pcls3Jm5dPXJbNyZuXTw8MTVeZS5jaGFyQ29kZUF0KG4pK3JbbisxJjddPDwxMztmb3IoO3IubGVuZ3RoPDg7KXIucHVzaCgwKTtmb3Iobj0wO248OCYmMD09PXJbbl07KytuKTtmb3IoOD09bj9yWzddPS0xOnJbbl0sdC54PXIsdC5pPTAsbj0yNTY7bj4wOy0tbil0Lm5leHQoKX0oZSx0KX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUueD10Lnguc2xpY2UoKSxlLmk9dC5pLGV9ZnVuY3Rpb24gYSh0LGUpe251bGw9PXQmJih0PStuZXcgRGF0ZSk7dmFyIG49bmV3IHIodCksYT1lJiZlLnN0YXRlLGk9ZnVuY3Rpb24oKXtyZXR1cm4obi5uZXh0KCk+Pj4wKS80Mjk0OTY3Mjk2fTtyZXR1cm4gaS5kb3VibGU9ZnVuY3Rpb24oKXtkb3t2YXIgdD0oKG4ubmV4dCgpPj4+MTEpKyhuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTYpLygxPDwyMSl9d2hpbGUoMD09PXQpO3JldHVybiB0fSxpLmludDMyPW4ubmV4dCxpLnF1aWNrPWksYSYmKGEueCYmbyhhLG4pLGkuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbyhuLHt9KX0pLGl9ZSYmZS5leHBvcnRzP2UuZXhwb3J0cz1hOm4mJm4uYW1kP24oKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KSk6dGhpcy54b3JzaGlmdDc9YX0oMCx0LCExKX0pKSxLdT1WdSgoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXM7ZS5uZXh0PWZ1bmN0aW9uKCl7dmFyIHQsbixyPWUudyxvPWUuWCxhPWUuaTtyZXR1cm4gZS53PXI9cisxNjQwNTMxNTI3fDAsbj1vW2ErMzQmMTI3XSx0PW9bYT1hKzEmMTI3XSxuXj1uPDwxMyx0Xj10PDwxNyxuXj1uPj4+MTUsdF49dD4+PjEyLG49b1thXT1uXnQsZS5pPWEsbisocl5yPj4+MTYpfDB9LGZ1bmN0aW9uKHQsZSl7dmFyIG4scixvLGEsaSxzPVtdLHU9MTI4O2ZvcihlPT09KDB8ZSk/KHI9ZSxlPW51bGwpOihlKz1cIlxcMFwiLHI9MCx1PU1hdGgubWF4KHUsZS5sZW5ndGgpKSxvPTAsYT0tMzI7YTx1OysrYSllJiYocl49ZS5jaGFyQ29kZUF0KChhKzMyKSVlLmxlbmd0aCkpLDA9PT1hJiYoaT1yKSxyXj1yPDwxMCxyXj1yPj4+MTUscl49cjw8NCxyXj1yPj4+MTMsYT49MCYmKGk9aSsxNjQwNTMxNTI3fDAsbz0wPT0obj1zWzEyNyZhXV49citpKT9vKzE6MCk7Zm9yKG8+PTEyOCYmKHNbMTI3JihlJiZlLmxlbmd0aHx8MCldPS0xKSxvPTEyNyxhPTUxMjthPjA7LS1hKXI9c1tvKzM0JjEyN10sbj1zW289bysxJjEyN10scl49cjw8MTMsbl49bjw8MTcscl49cj4+PjE1LG5ePW4+Pj4xMixzW29dPXJebjt0Lnc9aSx0Llg9cyx0Lmk9b30oZSx0KX1mdW5jdGlvbiBvKHQsZSl7cmV0dXJuIGUuaT10LmksZS53PXQudyxlLlg9dC5YLnNsaWNlKCksZX1mdW5jdGlvbiBhKHQsZSl7bnVsbD09dCYmKHQ9K25ldyBEYXRlKTt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoYS5YJiZvKGEsbiksaS5zdGF0ZT1mdW5jdGlvbigpe3JldHVybiBvKG4se30pfSksaX1lJiZlLmV4cG9ydHM/ZS5leHBvcnRzPWE6biYmbi5hbWQ/bigoZnVuY3Rpb24oKXtyZXR1cm4gYX0pKTp0aGlzLnhvcjQwOTY9YX0oMCx0LCExKX0pKSxqdT1WdSgoZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBlPXRoaXMsbj1cIlwiO2UubmV4dD1mdW5jdGlvbigpe3ZhciB0PWUuYixuPWUuYyxyPWUuZCxvPWUuYTtyZXR1cm4gdD10PDwyNV50Pj4+N15uLG49bi1yfDAscj1yPDwyNF5yPj4+OF5vLG89by10fDAsZS5iPXQ9dDw8MjBedD4+PjEyXm4sZS5jPW49bi1yfDAsZS5kPXI8PDE2Xm4+Pj4xNl5vLGUuYT1vLXR8MH0sZS5hPTAsZS5iPTAsZS5jPS0xNjQwNTMxNTI3LGUuZD0xMzY3MTMwNTUxLHQ9PT1NYXRoLmZsb29yKHQpPyhlLmE9dC80Mjk0OTY3Mjk2fDAsZS5iPTB8dCk6bis9dDtmb3IodmFyIHI9MDtyPG4ubGVuZ3RoKzIwO3IrKyllLmJePTB8bi5jaGFyQ29kZUF0KHIpLGUubmV4dCgpfWZ1bmN0aW9uIG8odCxlKXtyZXR1cm4gZS5hPXQuYSxlLmI9dC5iLGUuYz10LmMsZS5kPXQuZCxlfWZ1bmN0aW9uIGEodCxlKXt2YXIgbj1uZXcgcih0KSxhPWUmJmUuc3RhdGUsaT1mdW5jdGlvbigpe3JldHVybihuLm5leHQoKT4+PjApLzQyOTQ5NjcyOTZ9O3JldHVybiBpLmRvdWJsZT1mdW5jdGlvbigpe2Rve3ZhciB0PSgobi5uZXh0KCk+Pj4xMSkrKG4ubmV4dCgpPj4+MCkvNDI5NDk2NzI5NikvKDE8PDIxKX13aGlsZSgwPT09dCk7cmV0dXJuIHR9LGkuaW50MzI9bi5uZXh0LGkucXVpY2s9aSxhJiYoXCJvYmplY3RcIj09dHlwZW9mIGEmJm8oYSxuKSxpLnN0YXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG8obix7fSl9KSxpfWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9YTpuJiZuLmFtZD9uKChmdW5jdGlvbigpe3JldHVybiBhfSkpOnRoaXMudHljaGVpPWF9KDAsdCwhMSl9KSksWHU9VnUoKGZ1bmN0aW9uKHQpeyFmdW5jdGlvbihlLG4pe3ZhciByLG89dGhpcyxhPTI1NixpPTYscz1cInJhbmRvbVwiLHU9bi5wb3coYSxpKSxjPW4ucG93KDIsNTIpLGw9MipjLGg9YS0xO2Z1bmN0aW9uIGYodCxoLGYpe3ZhciBtPVtdLHk9dihmdW5jdGlvbiB0KGUsbil7dmFyIHIsbz1bXSxhPXR5cGVvZiBlO2lmKG4mJlwib2JqZWN0XCI9PWEpZm9yKHIgaW4gZSl0cnl7by5wdXNoKHQoZVtyXSxuLTEpKX1jYXRjaCh0KXt9cmV0dXJuIG8ubGVuZ3RoP286XCJzdHJpbmdcIj09YT9lOmUrXCJcXDBcIn0oKGg9MT09aD97ZW50cm9weTohMH06aHx8e30pLmVudHJvcHk/W3QsZyhlKV06bnVsbD09dD9mdW5jdGlvbigpe3RyeXt2YXIgdDtyZXR1cm4gciYmKHQ9ci5yYW5kb21CeXRlcyk/dD10KGEpOih0PW5ldyBVaW50OEFycmF5KGEpLChvLmNyeXB0b3x8by5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKHQpKSxnKHQpfWNhdGNoKHQpe3ZhciBuPW8ubmF2aWdhdG9yLGk9biYmbi5wbHVnaW5zO3JldHVyblsrbmV3IERhdGUsbyxpLG8uc2NyZWVuLGcoZSldfX0oKTp0LDMpLG0pLHg9bmV3IGQobSksYj1mdW5jdGlvbigpe2Zvcih2YXIgdD14LmcoaSksZT11LG49MDt0PGM7KXQ9KHQrbikqYSxlKj1hLG49eC5nKDEpO2Zvcig7dD49bDspdC89MixlLz0yLG4+Pj49MTtyZXR1cm4odCtuKS9lfTtyZXR1cm4gYi5pbnQzMj1mdW5jdGlvbigpe3JldHVybiAwfHguZyg0KX0sYi5xdWljaz1mdW5jdGlvbigpe3JldHVybiB4LmcoNCkvNDI5NDk2NzI5Nn0sYi5kb3VibGU9Yix2KGcoeC5TKSxlKSwoaC5wYXNzfHxmfHxmdW5jdGlvbih0LGUscixvKXtyZXR1cm4gbyYmKG8uUyYmcChvLHgpLHQuc3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gcCh4LHt9KX0pLHI/KG5bc109dCxlKTp0fSkoYix5LFwiZ2xvYmFsXCJpbiBoP2guZ2xvYmFsOnRoaXM9PW4saC5zdGF0ZSl9ZnVuY3Rpb24gZCh0KXt2YXIgZSxuPXQubGVuZ3RoLHI9dGhpcyxvPTAsaT1yLmk9ci5qPTAscz1yLlM9W107Zm9yKG58fCh0PVtuKytdKTtvPGE7KXNbb109bysrO2ZvcihvPTA7bzxhO28rKylzW29dPXNbaT1oJmkrdFtvJW5dKyhlPXNbb10pXSxzW2ldPWU7KHIuZz1mdW5jdGlvbih0KXtmb3IodmFyIGUsbj0wLG89ci5pLGk9ci5qLHM9ci5TO3QtLTspZT1zW289aCZvKzFdLG49biphK3NbaCYoc1tvXT1zW2k9aCZpK2VdKSsoc1tpXT1lKV07cmV0dXJuIHIuaT1vLHIuaj1pLG59KShhKX1mdW5jdGlvbiBwKHQsZSl7cmV0dXJuIGUuaT10LmksZS5qPXQuaixlLlM9dC5TLnNsaWNlKCksZX1mdW5jdGlvbiB2KHQsZSl7Zm9yKHZhciBuLHI9dCtcIlwiLG89MDtvPHIubGVuZ3RoOyllW2gmb109aCYobl49MTkqZVtoJm9dKStyLmNoYXJDb2RlQXQobysrKTtyZXR1cm4gZyhlKX1mdW5jdGlvbiBnKHQpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsdCl9aWYobltcInNlZWRcIitzXT1mLHYobi5yYW5kb20oKSxlKSx0LmV4cG9ydHMpe3QuZXhwb3J0cz1mO3RyeXtyPXJlcXVpcmUoXCJjcnlwdG9cIil9Y2F0Y2godCl7fX19KFtdLE1hdGgpfSkpO1h1LmFsZWE9enUsWHUueG9yMTI4PUd1LFh1Lnhvcndvdz1IdSxYdS54b3JzaGlmdDc9cXUsWHUueG9yNDA5Nj1LdSxYdS50eWNoZWk9anU7dmFyIFl1PVh1LmFsZWE7dmFyICR1PUFuKHthZGROXzpmdW5jdGlvbih0KXtDKEFycmF5LmlzQXJyYXkodCksKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgYXJndW1lbnQgcGFzc2VkIHRvIHRmLmFkZE4oKSBtdXN0IGJlIGEgbGlzdCBvZiB0ZW5zb3JzXCJ9KSksQyh0Lmxlbmd0aD49MSwoZnVuY3Rpb24oKXtyZXR1cm5cIk11c3QgcGFzcyBhdCBsZWFzdCBvbmUgdGVuc29yIHRvIHRmLmFkZE4oKSwgYnV0IGdvdCBcIit0Lmxlbmd0aH0pKTt2YXIgZT10Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gZ24odCxcInRlbnNvcnNcIitlLFwiYWRkTlwiKX0pKSxuPWVbMF07ZS5mb3JFYWNoKChmdW5jdGlvbih0KXtpZih0LmR0eXBlIT09bi5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJBbGwgdGVuc29ycyBwYXNzZWQgdG8gdGYuYWRkTigpIG11c3QgaGF2ZSB0aGUgc2FtZSBkdHlwZVwiKX0pKSxlLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKCFTKHQuc2hhcGUsbi5zaGFwZSkpdGhyb3cgbmV3IEVycm9yKFwiQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHRmLmFkZE4oKSBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGVcIil9KSk7dmFyIHI9ZTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXtyZXR1cm4gdC5hZGROKGUpfSkscixudWxsLFwiQWRkTlwiKX19KTtmdW5jdGlvbiBRdSgpe1hlKFwidGYuYmF0Y2hOb3JtYWxpemF0aW9uKCkgaXMgZ29pbmcgYXdheS4gVXNlIHRmLmJhdGNoTm9ybSgpIGluc3RlYWQsIGFuZCBub3RlIHRoZSBwb3NpdGlvbmFsIGFyZ3VtZW50IGNoYW5nZSBvZiBzY2FsZSwgb2Zmc2V0LCBhbmQgdmFyaWFuY2VFcHNpbG9uXCIpfWZ1bmN0aW9uIEp1KHQpe3JldHVybiAwPT09dC5yYW5rfHwxPT09dC5yYW5rP3QuYXM0RCgxLDEsMSx0LnNpemUpOjI9PT10LnJhbms/dC5hczREKDEsMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0pOjM9PT10LnJhbms/dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pOnR9ZnVuY3Rpb24gWnUodCxlLG4scixvLGEpe251bGw9PWEmJihhPS4wMDEpO3ZhciBpLHMsdT1nbih0LFwieFwiLFwiYmF0Y2hOb3JtXCIpLGM9Z24oZSxcIm1lYW5cIixcImJhdGNoTm9ybVwiKSxsPWduKG4sXCJ2YXJpYW5jZVwiLFwiYmF0Y2hOb3JtXCIpO251bGwhPW8mJihpPWduKG8sXCJzY2FsZVwiLFwiYmF0Y2hOb3JtXCIpKSxudWxsIT1yJiYocz1nbihyLFwib2Zmc2V0XCIsXCJiYXRjaE5vcm1cIikpLEMoYy5yYW5rPT09bC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCB2YXJpYW5jZSB0byBoYXZlIGVxdWFsIHJhbmtzLlwifSkpLEMobnVsbD09c3x8Yy5yYW5rPT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiQmF0Y2ggbm9ybWFsaXphdGlvbiBncmFkaWVudCByZXF1aXJlcyBtZWFuIGFuZCBvZmZzZXQgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIn0pKSxDKG51bGw9PWl8fGMucmFuaz09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkJhdGNoIG5vcm1hbGl6YXRpb24gZ3JhZGllbnQgcmVxdWlyZXMgbWVhbiBhbmQgc2NhbGUgdG8gaGF2ZSBlcXVhbCByYW5rcy5cIn0pKTt2YXIgaD17eDp1LHNjYWxlOmksb2Zmc2V0OnMsbWVhbjpjLHZhcmlhbmNlOmx9LGY9e3ZhcmlhbmNlRXBzaWxvbjphfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj1KdSh1KSxyPXQuYmF0Y2hOb3JtYWxpemF0aW9uKG4sdGMoYyksdGMobCksYSx0YyhpKSx0YyhzKSk7cmV0dXJuIGUoW3UsYyxsLGldKSxyfSksaCxudWxsLFwiRnVzZWRCYXRjaE5vcm1cIixmKS5yZXNoYXBlKHUuc2hhcGUpfWZ1bmN0aW9uIHRjKHQpe3JldHVybiBudWxsPT10P251bGw6MD09PXQucmFuaz90LmFzMUQoKToxPT09dC5yYW5rP3Q6Mj09PXQucmFuaz90LmFzNEQoMSwxLHQuc2hhcGVbMF0sdC5zaGFwZVsxXSk6Mz09PXQucmFuaz90LmFzNEQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSk6dH12YXIgZWM9QW4oe2JhdGNoTm9ybWFsaXphdGlvbl86ZnVuY3Rpb24odCxlLG4scixvLGEpe3JldHVybiB2b2lkIDA9PT1yJiYocj0uMDAxKSxRdSgpLFp1KHQsZSxuLGEsbyxyKX19KSxuYz1Bbih7YmF0Y2hOb3JtXzpadX0pO2Z1bmN0aW9uIHJjKHQsZSxuLHIsbyxhKXt2YXIgaSxzLHU9Z24odCxcInhcIixcImJhdGNoTm9ybVwiKSxjPWduKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksbD1nbihuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKTtyZXR1cm4gbnVsbCE9byYmKGk9Z24obyxcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpLG51bGwhPXImJihzPWduKHIsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksQygyPT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDI9PT1jLnJhbmt8fDE9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0yRDogbWVhbiBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDI9PT1sLnJhbmt8fDE9PT1sLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0yRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSksbnVsbCE9aSYmQygyPT09aS5yYW5rfHwxPT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtMkQ6IHNjYWxlIG11c3QgYmUgcmFuayAyIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwifSkpLG51bGwhPXMmJkMoMj09PXMucmFua3x8MT09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTJEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSksbmModSxjLGwscyxpLGEpfXZhciBvYz1Bbih7YmF0Y2hOb3JtYWxpemF0aW9uMmRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksUXUoKSxyYyh0LGUsbixhLG8scil9fSksYWM9QW4oe2JhdGNoTm9ybTJkXzpyY30pO2Z1bmN0aW9uIGljKHQsZSxuLHIsbyxhKXt2YXIgaSxzLHU9Z24odCxcInhcIixcImJhdGNoTm9ybVwiKSxjPWduKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksbD1nbihuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKTtyZXR1cm4gbnVsbCE9byYmKGk9Z24obyxcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpLG51bGwhPXImJihzPWduKHIsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksQygzPT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDM9PT1jLnJhbmt8fDE9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogbWVhbiBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDM9PT1sLnJhbmt8fDE9PT1sLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm0zRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSksbnVsbCE9aSYmQygzPT09aS5yYW5rfHwxPT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtM0Q6IHNjYWxlIG11c3QgYmUgcmFuayAzIG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwifSkpLG51bGwhPXMmJkMoMz09PXMucmFua3x8MT09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTNEOiBvZmZzZXQgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSksbmModSxjLGwscyxpLGEpfXZhciBzYz1Bbih7YmF0Y2hOb3JtYWxpemF0aW9uM2RfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksUXUoKSxpYyh0LGUsbixhLG8scil9fSksdWM9QW4oe2JhdGNoTm9ybTNkXzppY30pO2Z1bmN0aW9uIGNjKHQsZSxuLHIsbyxhKXt2YXIgaSxzLHU9Z24odCxcInhcIixcImJhdGNoTm9ybVwiKSxjPWduKGUsXCJtZWFuXCIsXCJiYXRjaE5vcm1cIiksbD1nbihuLFwidmFyaWFuY2VcIixcImJhdGNoTm9ybVwiKTtyZXR1cm4gbnVsbCE9byYmKGk9Z24obyxcInNjYWxlXCIsXCJiYXRjaE5vcm1cIikpLG51bGwhPXImJihzPWduKHIsXCJvZmZzZXRcIixcImJhdGNoTm9ybVwiKSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDQ9PT1jLnJhbmt8fDE9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogbWVhbiBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDQ9PT1sLnJhbmt8fDE9PT1sLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBiYXRjaE5vcm00RDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitsLnJhbmsrXCIuXCJ9KSksbnVsbCE9aSYmQyg0PT09aS5yYW5rfHwxPT09aS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYmF0Y2hOb3JtNEQ6IHNjYWxlIG11c3QgYmUgcmFuayA0IG9yIHJhbmsgMSBidXQgZ290IHJhbmsgXCIraS5yYW5rK1wiLlwifSkpLG51bGwhPXMmJkMoND09PXMucmFua3x8MT09PXMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGJhdGNoTm9ybTREOiBvZmZzZXQgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSksbmModSxjLGwscyxpLGEpfXZhciBsYz1Bbih7YmF0Y2hOb3JtYWxpemF0aW9uNGRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9LjAwMSksUXUoKSxjYyh0LGUsbixhLG8scil9fSksaGM9QW4oe2JhdGNoTm9ybTRkXzpjY30pO3ZhciBmYz1Bbih7YnJvYWRjYXN0VG9fOmZ1bmN0aW9uKHQsZSl7dmFyIG49Z24odCxcImJyb2FkY2FzdFRvXCIsXCJ4XCIpLHI9bi5zaGFwZTtpZihlLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiEodD4wKXx8dCUxIT0wfSkpKXRocm93IG5ldyBFcnJvcihcImJyb2FkY2FzdFRvKCk6IEludmFsaWQgYnJvYWRjYXN0IHNoYXBlIFtcIitlK1wiXS5cIik7aWYoZS5sZW5ndGg8bi5yYW5rKXRocm93IG5ldyBFcnJvcihcImJyb2FkY2FzdFRvKCk6IHNoYXBlLmxlbmd0aD1cIitlLmxlbmd0aCtcIiA8IGlucHV0LnJhbms9XCIrbi5yYW5rK1wiLlwiKTtpZihlLmxlbmd0aD5uLnJhbmspe2Zvcih2YXIgbz1uLnNoYXBlLnNsaWNlKCk7by5sZW5ndGg8ZS5sZW5ndGg7KW8udW5zaGlmdCgxKTtuPW4ucmVzaGFwZShvKX1mb3IodmFyIGE9bi5zaGFwZSxpPUFycmF5LmZyb20oZSkscz1lLmxlbmd0aC0xO3M+PTA7cy0tKWlmKGFbc109PT1lW3NdKWlbc109MTtlbHNlIGlmKDEhPT1uLnNoYXBlW3NdKXRocm93IG5ldyBFcnJvcihcImJyb2FkY2FzdFRvKCk6IFtcIityK1wiXSBjYW5ub3QgYmUgYnJvYWRjYXN0IHRvIFtcIitlK1wiXS5cIik7dmFyIHU9aS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+MT9lOi0xfSkpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PTB9KSk7aWYoMD09PXUubGVuZ3RoKXJldHVybiBuLmNsb25lKCk7dmFyIGM9e3g6bn0sbD17c2hhcGU6ZSxpbnB1dFNoYXBlOmF9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC50aWxlKG4saSl9KSxjLChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LnN1bSh1LCEwKX19fSksU3IsbCl9fSk7dmFyIGRjPUFuKHtjbG9uZV86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImNsb25lXCIsbnVsbCk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKCl7cmV0dXJuIEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKGUuZGF0YUlkLGUuc2hhcGUsZS5kdHlwZSl9KSx7eDplfSxudWxsLFRyKX19KTt2YXIgcGM9QW4oe2xvZ2ljYWxBbmRfOmZ1bmN0aW9uKHQsZSl7dmFyIG49Z24odCxcImFcIixcImxvZ2ljYWxBbmRcIixcImJvb2xcIikscj1nbihlLFwiYlwiLFwibG9naWNhbEFuZFwiLFwiYm9vbFwiKTtyZXR1cm4gUHIobi5zaGFwZSxyLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5sb2dpY2FsQW5kKG4scil9KSx7YTpuLGI6cn0sbnVsbCxcIkxvZ2ljYWxBbmRcIil9fSksdmM9QW4oe2xvZ2ljYWxOb3RfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJsb2dpY2FsTm90XCIsXCJib29sXCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5sb2dpY2FsTm90KGUpfSkseyR4OmV9KX19KSxnYz1Bbih7bG9naWNhbE9yXzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJhXCIsXCJsb2dpY2FsT3JcIixcImJvb2xcIikscj1nbihlLFwiYlwiLFwibG9naWNhbE9yXCIsXCJib29sXCIpO3JldHVybiBQcihuLnNoYXBlLHIuc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmxvZ2ljYWxPcihuLHIpfSkseyRhOm4sJGI6cn0pfX0pLG1jPUFuKHtsb2dpY2FsWG9yXzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJhXCIsXCJsb2dpY2FsWG9yXCIsXCJib29sXCIpLHI9Z24oZSxcImJcIixcImxvZ2ljYWxYb3JcIixcImJvb2xcIik7cmV0dXJuIFByKG4uc2hhcGUsci5zaGFwZSksZ2ModCxlKS5sb2dpY2FsQW5kKHBjKHQsZSkubG9naWNhbE5vdCgpKX19KSx5Yz1Bbih7d2hlcmVfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1nbihlLFwiYVwiLFwid2hlcmVcIiksbz1nbihuLFwiYlwiLFwid2hlcmVcIiksYT1nbih0LFwiY29uZGl0aW9uXCIsXCJ3aGVyZVwiLFwiYm9vbFwiKTtyZXR1cm4gRShyLnNoYXBlLG8uc2hhcGUsXCJFcnJvciBpbiB3aGVyZTogXCIpLDE9PT1hLnJhbms/QyhhLnNoYXBlWzBdPT09ci5zaGFwZVswXSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBmaXJzdCBkaW1lbnNpb24gb2YgYGFgIG11c3QgbWF0Y2ggdGhlIHNpemUgb2YgYGNvbmRpdGlvbmAuXCJ9KSk6RShhLnNoYXBlLG8uc2hhcGUsXCJFcnJvciBpbiB3aGVyZTogXCIpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5zZWxlY3QoYSxyLG8pO3JldHVybiBlKFthXSksbn0pLHskY29uZGl0aW9uOmEsJGE6ciwkYjpvfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskY29uZGl0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIFhuKG4pLnRvRmxvYXQoKX0sJGE6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5jYXN0KHQuZHR5cGUpKX0sJGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwobi5sb2dpY2FsTm90KCkuY2FzdCh0LmR0eXBlKSl9fX0pKX19KSx4Yz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsKGU9Z24odCxcImNvbmRpdGlvblwiLFwid2hlcmVBc3luY1wiLFwiYm9vbFwiKSkuZGF0YSgpXTtjYXNlIDE6cmV0dXJuIG49ci5zZW50KCksbz1HYShlLnNoYXBlLG4pLHQhPT1lJiZlLmRpc3Bvc2UoKSxbMixvXX19KSl9KSl9O3ZhciBiYz1Bbih7ZGl2Tm9OYW5fOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1nbih0LFwiYVwiLFwiZGl2XCIpLG89Z24oZSxcImJcIixcImRpdlwiKTtyPShuPU50KHIsbykpWzBdLG89blsxXTt2YXIgYT1CbyhyLG8pLGk9WG4oYSkscz1vLmVxdWFsKGkpO3JldHVybiB5YyhzLGksYSl9fSk7dmFyIHdjPUFuKHt0aWxlXzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJ4XCIsXCJ0aWxlXCIsbnVsbCk7QyhuLnJhbms9PT1lLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHRyYW5zcG9zZTogcmFuayBvZiBpbnB1dCBcIituLnJhbmsrXCIgbXVzdCBtYXRjaCBsZW5ndGggb2YgcmVwcyBcIitlK1wiLlwifSkpO3ZhciByPVtuXSxvPXt4Om59LGE9e3JlcHM6ZX07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQscil7dmFyIG89dC50aWxlKG4sZSk7cmV0dXJuIHIoW25dKSxvfSksbyxudWxsLERyLGEscil9fSk7dmFyIENjPUFuKHtleWVfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKSxudWxsPT1lJiYoZT10KTtmb3IodmFyIG89ZXIoW3QsZV0sciksYT10PD1lP3Q6ZSxpPTA7aTxhOysraSlvLnNldCgxLGksaSk7dmFyIHM9by50b1RlbnNvcigpLmFzMkQodCxlKTtpZihudWxsPT1uKXJldHVybiBzO2lmKDE9PT1uLmxlbmd0aClyZXR1cm4gd2Moc3IocywwKSxbblswXSwxLDFdKTtpZigyPT09bi5sZW5ndGgpcmV0dXJuIHdjKHNyKHNyKHMsMCksMCksW25bMF0sblsxXSwxLDFdKTtpZigzPT09bi5sZW5ndGgpcmV0dXJuIHdjKHNyKHNyKHNyKHMsMCksMCksMCksW25bMF0sblsxXSxuWzJdLDEsMV0pO3Rocm93IG5ldyBFcnJvcihcImV5ZSgpIGN1cnJlbnRseSBzdXBwb3J0cyBvbmx5IDFEIGFuZCAyRCBiYXRjaFNoYXBlcywgYnV0IHJlY2VpdmVkIFwiK24ubGVuZ3RoK1wiRC5cIil9fSk7dmFyIEVjPUFuKHttdWx0aW5vbWlhbF86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9ITEpO3ZhciBvPWduKHQsXCJsb2dpdHNcIixcIm11bHRpbm9taWFsXCIpLGE9by5zaXplLGk9by5yYW5rO2lmKGE8Mil0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBtdWx0aW5vbWlhbDogeW91IG5lZWQgYXQgbGVhc3QgMiBvdXRjb21lcywgYnV0IGdvdCBcIithK1wiLlwiKTtpZihpPjIpdGhyb3cgbmV3IEVycm9yKFwiUmFuayBvZiBwcm9iYWJpbGl0aWVzIG11c3QgYmUgMSBvciAyLCBidXQgaXMgXCIraSk7bj1ufHxNYXRoLnJhbmRvbSgpO3ZhciBzPTE9PT1pP28uYXMyRCgxLC0xKTpvLHU9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubXVsdGlub21pYWwocyxyLGUsbil9KSx7bG9naXRzMkQ6c30pO3JldHVybiAxPT09aT91LmFzMUQoKTp1fX0pO3ZhciBSYz1Bbih7b25lSG90XzpmdW5jdGlvbih0LGUsbixyKXtpZih2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj0wKSxlPDIpdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gb25lSG90OiBkZXB0aCBtdXN0IGJlID49MiwgYnV0IGl0IGlzIFwiK2UpO3ZhciBvPWduKHQsXCJpbmRpY2VzXCIsXCJvbmVIb3RcIixcImludDMyXCIpLGE9by5zaGFwZS5jb25jYXQoW2VdKSxpPXtpbmRpY2VzOm89by5mbGF0dGVuKCl9LHM9e2RlcHRoOmUsb25WYWx1ZTpuLG9mZlZhbHVlOnJ9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGEpe3JldHVybiBhKFtvXSksdC5vbmVIb3QobyxlLG4scil9KSxpLG51bGwsQXIscykucmVzaGFwZShhKX19KTt2YXIgSWM9QW4oe3BhZF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPTApO3ZhciByPWduKHQsXCJ4XCIsXCJwYWRcIik7aWYoMD09PXIucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJwYWQoc2NhbGFyKSBpcyBub3QgZGVmaW5lZC4gUGFzcyBub24tc2NhbGFyIHRvIHBhZFwiKTt2YXIgbz17cGFkZGluZ3M6ZSxjb25zdGFudFZhbHVlOm59LGE9e3g6cn07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbyl7cmV0dXJuIG8oW3JdKSx0LnBhZChyLGUsbil9KSxhLG51bGwsTnIsbyl9fSk7dmFyIGtjPUFuKHtwYWQxZF86ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSxDKDI9PT1lLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyLlwifSkpLEljKHQsW2VdLG4pfX0pO3ZhciBTYz1Bbih7cGFkMmRfOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksQygyPT09ZS5sZW5ndGgmJjI9PT1lWzBdLmxlbmd0aCYmMj09PWVbMV0ubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC5cIn0pKSxJYyh0LGUsbil9fSk7dmFyIEFjPUFuKHtwYWQzZF86ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1uJiYobj0wKSxDKDM9PT1lLmxlbmd0aCYmMj09PWVbMF0ubGVuZ3RoJiYyPT09ZVsxXS5sZW5ndGgmJjI9PT1lWzJdLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guXCJ9KSksSWModCxlLG4pfX0pO3ZhciBUYz1Bbih7cGFkNGRfOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MCksQyg0PT09ZS5sZW5ndGgmJjI9PT1lWzBdLmxlbmd0aCYmMj09PWVbMV0ubGVuZ3RoJiYyPT09ZVsyXS5sZW5ndGgmJjI9PT1lWzNdLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guXCJ9KSksSWModCxlLG4pfX0pO3ZhciBEYz1Bbih7cmFuZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPWsodCksbz1udWxsO2lmKG51bGw9PW58fFwiZmxvYXQzMlwiPT09bilvPW5ldyBGbG9hdDMyQXJyYXkocik7ZWxzZSBpZihcImludDMyXCI9PT1uKW89bmV3IEludDMyQXJyYXkocik7ZWxzZXtpZihcImJvb2xcIiE9PW4pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIrbik7bz1uZXcgVWludDhBcnJheShyKX1mb3IodmFyIGE9MDthPHI7YSsrKW9bYV09ZSgpO3JldHVybiBMdC5tYWtlVGVuc29yKG8sdCxuKX19KSxOYz0uMDAxLEZjPS4xO2Z1bmN0aW9uIF9jKCl7cmV0dXJuIDMyPT09THQuYmFja2VuZC5mbG9hdFByZWNpc2lvbigpP05jOkZjfWZ1bmN0aW9uIE9jKHQsZSxuKXt2YXIgcj0hMDtpZigoVih0KXx8VihlKSkmJihyPSExKSxWKHQpJiZWKGUpJiYocj0hMCkscil7dmFyIG89dC5jb25zdHJ1Y3Rvci5uYW1lLGE9ZS5jb25zdHJ1Y3Rvci5uYW1lO2lmKG8hPT1hKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBhcmUgb2YgZGlmZmVyZW50IHR5cGUuIEFjdHVhbDogXCIrbytcIi4gRXhwZWN0ZWQ6IFwiK2EpfWlmKEFycmF5LmlzQXJyYXkodCkmJkFycmF5LmlzQXJyYXkoZSkpe3ZhciBpPXBuKHQpLHM9cG4oZSk7aWYoIVMoaSxzKSl0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgaGF2ZSBkaWZmZXJlbnQgc2hhcGVzLiBBY3R1YWw6IFtcIitpK1wiXS4gRXhwZWN0ZWQ6IFtcIitzK1wiXVwiKX12YXIgdT1WKHQpP3Q6SSh0KSxjPVYoZSk/ZTpJKGUpO2lmKHUubGVuZ3RoIT09Yy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMgYWN0dWFsOiBcIit1Lmxlbmd0aCtcIiB2cyBleHBlY3RlZDogXCIrYy5sZW5ndGgrXCIuXFxuQWN0dWFsOiAgIFwiK3UrXCIuXFxuRXhwZWN0ZWQ6IFwiK2MrXCIuXCIpO2Zvcih2YXIgbD0wO2w8Yy5sZW5ndGg7KytsKXt2YXIgaD11W2xdLGY9Y1tsXTtpZighbihoLGYpKXRocm93IG5ldyBFcnJvcihcIkFycmF5cyBkaWZmZXI6IGFjdHVhbFtcIitsK1wiXSA9IFwiK2grXCIsIGV4cGVjdGVkW1wiK2wrXCJdID0gXCIrZitcIi5cXG5BY3R1YWw6ICAgXCIrdStcIi5cXG5FeHBlY3RlZDogXCIrYytcIi5cIil9fWZ1bmN0aW9uIE1jKHQsZSxuKXtyZXR1cm4haXNGaW5pdGUodCkmJiFpc0Zpbml0ZShlKXx8IShpc05hTih0KXx8aXNOYU4oZSl8fE1hdGguYWJzKHQtZSk+bil9dmFyIEJjPU9iamVjdC5mcmVlemUoe1RFU1RfRVBTSUxPTl9GTE9BVDE2OkZjLGV4cGVjdEFycmF5c0Nsb3NlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gbnVsbD09biYmKG49X2MoKSksT2ModCxlLChmdW5jdGlvbih0LGUpe3JldHVybiBNYyh0LGUsbil9KSl9LHRlc3RFcHNpbG9uOl9jLGV4cGVjdFByb21pc2VUb0ZhaWw6ZnVuY3Rpb24odCxlKXt0KCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gZS5mYWlsKCl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gZSgpfSkpfSxleHBlY3RBcnJheXNFcXVhbDpmdW5jdGlvbih0LGUpe3ZhciBuPVwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlP1tlXTplO3JldHVybiBIKHQpfHxIKHRbMF0pfHxIKGUpfHxIKGVbMF0pP09jKHQsbiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09ZX0pKTpPYyh0LGUsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1jKHQsZSwwKX0pKX0sZXhwZWN0TnVtYmVyc0Nsb3NlOmZ1bmN0aW9uKHQsZSxuKXtpZihudWxsPT1uJiYobj1fYygpKSwhTWModCxlLG4pKXRocm93IG5ldyBFcnJvcihcIk51bWJlcnMgZGlmZmVyOiBhY3R1YWwgPT09IFwiK3QrXCIsIGV4cGVjdGVkID09PSBcIitlKX0sZXhwZWN0VmFsdWVzSW5SYW5nZTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspaWYodFtyXTxlfHx0W3JdPm4pdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgb3V0IG9mIHJhbmdlOlwiK3Rbcl0rXCIgbG93OiBcIitlK1wiLCBoaWdoOiBcIituKX0sZXhwZWN0QXJyYXlCdWZmZXJzRXF1YWw6ZnVuY3Rpb24odCxlKXtleHBlY3QobmV3IEZsb2F0MzJBcnJheSh0KSkudG9FcXVhbChuZXcgRmxvYXQzMkFycmF5KGUpKX19KSxQYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4scixvKXt0aGlzLm1lYW49dCx0aGlzLnN0ZERldj1lLHRoaXMuZHR5cGU9bix0aGlzLm5leHRWYWw9TmFOLHRoaXMudHJ1bmNhdGVkPXIsdGhpcy50cnVuY2F0ZWQmJih0aGlzLnVwcGVyPXRoaXMubWVhbisyKnRoaXMuc3RkRGV2LHRoaXMubG93ZXI9dGhpcy5tZWFuLTIqdGhpcy5zdGREZXYpO3ZhciBhPW98fE1hdGgucmFuZG9tKCk7dGhpcy5yYW5kb209WXUoYS50b1N0cmluZygpKX1yZXR1cm4gdC5wcm90b3R5cGUubmV4dFZhbHVlPWZ1bmN0aW9uKCl7aWYoIWlzTmFOKHRoaXMubmV4dFZhbCkpe3ZhciB0PXRoaXMubmV4dFZhbDtyZXR1cm4gdGhpcy5uZXh0VmFsPU5hTix0fWZvcih2YXIgZSxuLHI9ITE7IXI7KXt2YXIgbz12b2lkIDAsYT12b2lkIDAsaT12b2lkIDA7ZG97aT0obz0yKnRoaXMucmFuZG9tKCktMSkqbysoYT0yKnRoaXMucmFuZG9tKCktMSkqYX13aGlsZShpPj0xfHwwPT09aSk7dmFyIHM9TWF0aC5zcXJ0KC0yKk1hdGgubG9nKGkpL2kpO2U9dGhpcy5tZWFuK3RoaXMuc3RkRGV2Km8qcyxuPXRoaXMubWVhbit0aGlzLnN0ZERldiphKnMsdGhpcy50cnVuY2F0ZWQmJiF0aGlzLmlzVmFsaWRUcnVuY2F0ZWQoZSl8fChyPSEwKX1yZXR1cm4gdGhpcy50cnVuY2F0ZWQmJiF0aGlzLmlzVmFsaWRUcnVuY2F0ZWQobil8fCh0aGlzLm5leHRWYWw9dGhpcy5jb252ZXJ0VmFsdWUobikpLHRoaXMuY29udmVydFZhbHVlKGUpfSx0LnByb3RvdHlwZS5jb252ZXJ0VmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXRoaXMuZHR5cGV8fFwiZmxvYXQzMlwiPT09dGhpcy5kdHlwZT90Ok1hdGgucm91bmQodCl9LHQucHJvdG90eXBlLmlzVmFsaWRUcnVuY2F0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQ8PXRoaXMudXBwZXImJnQ+PXRoaXMubG93ZXJ9LHR9KCksTGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxuLHIpe3RoaXMuYWxwaGE9dCx0aGlzLmJldGE9MS9lLHRoaXMuZHR5cGU9bjt2YXIgbz1yfHxNYXRoLnJhbmRvbSgpO3RoaXMucmFuZHU9WXUoby50b1N0cmluZygpKSx0aGlzLnJhbmRuPW5ldyBQYygwLDEsbiwhMSx0aGlzLnJhbmR1KCkpLHRoaXMuZD10PDE/dCsyLzM6dC0xLzMsdGhpcy5jPTEvTWF0aC5zcXJ0KDkqdGhpcy5kKX1yZXR1cm4gdC5wcm90b3R5cGUubmV4dFZhbHVlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0LGUsbixyLG8sYTs7KXtkb3tyPXRoaXMucmFuZG4ubmV4dFZhbHVlKCksYT0xK3RoaXMuYypyfXdoaWxlKGE8PTApO2lmKGEqPWEqYSxlPTEtLjMzMSoodD1yKnIpKnQsbj0uNSp0K3RoaXMuZCooMS1hK01hdGgubG9nKGEpKSwobz10aGlzLnJhbmR1KCkpPGV8fE1hdGgubG9nKG8pPG4pYnJlYWt9cmV0dXJuIGE9MS90aGlzLmJldGEqdGhpcy5kKmEsdGhpcy5hbHBoYTwxJiYoYSo9TWF0aC5wb3codGhpcy5yYW5kdSgpLDEvdGhpcy5hbHBoYSkpLHRoaXMuY29udmVydFZhbHVlKGEpfSx0LnByb3RvdHlwZS5jb252ZXJ0VmFsdWU9ZnVuY3Rpb24odCl7cmV0dXJuXCJmbG9hdDMyXCI9PT10aGlzLmR0eXBlP3Q6TWF0aC5yb3VuZCh0KX0sdH0oKSxXYz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4scil7dmFyIG89dGhpcztpZih2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1lJiYoZT0xKSx0aGlzLmNhblJldHVybkZsb2F0PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PW8uZHR5cGV8fFwiZmxvYXQzMlwiPT09by5kdHlwZX0sdGhpcy5taW49dCx0aGlzLnJhbmdlPWUtdCx0aGlzLmR0eXBlPW4sbnVsbD09ciYmKHI9TWF0aC5yYW5kb20oKSksXCJudW1iZXJcIj09dHlwZW9mIHImJihyPXIudG9TdHJpbmcoKSksIXRoaXMuY2FuUmV0dXJuRmxvYXQoKSYmdGhpcy5yYW5nZTw9MSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFwiK3QrXCIgLSBcIitlK1wiIDw9IDEgYW5kIGR0eXBlIGlzIG5vdCBmbG9hdFwiKTt0aGlzLnJhbmRvbT1ZdShyKX1yZXR1cm4gdC5wcm90b3R5cGUuY29udmVydFZhbHVlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNhblJldHVybkZsb2F0KCk/dDpNYXRoLnJvdW5kKHQpfSx0LnByb3RvdHlwZS5uZXh0VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb252ZXJ0VmFsdWUodGhpcy5taW4rdGhpcy5yYW5nZSp0aGlzLnJhbmRvbSgpKX0sdH0oKTt2YXIgVWM9QW4oe3JhbmRvbUdhbW1hXzpmdW5jdGlvbih0LGUsbixyLG8pe2lmKHZvaWQgMD09PW4mJihuPTEpLHZvaWQgMD09PXImJihyPVwiZmxvYXQzMlwiKSxudWxsPT1uJiYobj0xKSxudWxsPT1yJiYocj1cImZsb2F0MzJcIiksXCJmbG9hdDMyXCIhPT1yJiZcImludDMyXCIhPT1yKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIityKTtmb3IodmFyIGE9bmV3IExjKGUsbixyLG8pLGk9ZXIodCxyKSxzPTA7czxpLnZhbHVlcy5sZW5ndGg7cysrKWkudmFsdWVzW3NdPWEubmV4dFZhbHVlKCk7cmV0dXJuIGkudG9UZW5zb3IoKX19KTt2YXIgVmM9QW4oe3JhbmRvbU5vcm1hbF86ZnVuY3Rpb24odCxlLG4scixvKXtpZih2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1uJiYobj0xKSxudWxsIT1yJiZcImJvb2xcIj09PXIpdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiK3IpO2Zvcih2YXIgYT1uZXcgUGMoZSxuLHIsITEsbyksaT1lcih0LHIpLHM9MDtzPGkudmFsdWVzLmxlbmd0aDtzKyspaS52YWx1ZXNbc109YS5uZXh0VmFsdWUoKTtyZXR1cm4gaS50b1RlbnNvcigpfX0pO3ZhciB6Yz1Bbih7cmFuZG9tVW5pZm9ybV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj1cImZsb2F0MzJcIik7Zm9yKHZhciBhPWVyKHQsciksaT1uZXcgV2MoZSxuLG51bGwsbykscz0wO3M8YS52YWx1ZXMubGVuZ3RoO3MrKylhLnZhbHVlc1tzXT1pLm5leHRWYWx1ZSgpO3JldHVybiBhLnRvVGVuc29yKCl9fSk7dmFyIEdjPUFuKHtzcXVhcmVfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJzcXVhcmVcIiksbj1bZV07cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsbil7cmV0dXJuIG4oW2VdKSx0LnNxdWFyZShlKX0pLHt4OmV9LG51bGwsXCJTcXVhcmVcIix7fSxuLFtdKX19KTt2YXIgSGM9QW4oe3NxdWFyZWREaWZmZXJlbmNlXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9Z24odCxcImFcIixcInNxdWFyZWREaWZmZXJlbmNlXCIpLG89Z24oZSxcImJcIixcInNxdWFyZWREaWZmZXJlbmNlXCIpO249TnQocixvKSxyPW5bMF0sbz1uWzFdLFByKHIuc2hhcGUsby5zaGFwZSk7dmFyIGE9e2E6cixiOm99LGk9W3Isb107cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5zcXVhcmVkRGlmZmVyZW5jZShyLG8pO3JldHVybiBlKFtyLG9dKSxufSksYSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXSxvPU9uKDIpO3JldHVybnthOmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4uc3ViKHIpLm11bChvKSl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWwoci5zdWIobikubXVsKG8pKX19fSksRXIse30saSxbXSl9fSk7dmFyIHFjPUFuKHt0cnVuY2F0ZWROb3JtYWxfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7aWYodm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09biYmKG49MSksbnVsbCE9ciYmXCJib29sXCI9PT1yKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSAkIHsgZHR5cGUgfVwiKTtmb3IodmFyIGE9bmV3IFBjKGUsbixyLCEwLG8pLGk9ZXIodCxyKSxzPTA7czxpLnZhbHVlcy5sZW5ndGg7cysrKWkudmFsdWVzW3NdPWEubmV4dFZhbHVlKCk7cmV0dXJuIGkudG9UZW5zb3IoKX19KTt2YXIgS2M9QW4oe2VxdWFsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9Z24odCxcImFcIixcImVxdWFsXCIpLG89Z24oZSxcImJcIixcImVxdWFsXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxQcihyLnNoYXBlLG8uc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmVxdWFsKHIsbyl9KSx7JGE6ciwkYjpvfSl9fSksamM9QW4oe2VxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJhXCIsXCJlcXVhbFN0cmljdFwiKSxyPWduKGUsXCJiXCIsXCJlcXVhbFN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBlcXVhbFN0cmljdDogXCIpLG4uZXF1YWwocil9fSksWGM9QW4oe2dyZWF0ZXJfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1nbih0LFwiYVwiLFwiZ3JlYXRlclwiKSxvPWduKGUsXCJiXCIsXCJncmVhdGVyXCIpO3JldHVybiBuPU50KHIsbykscj1uWzBdLG89blsxXSxQcihyLnNoYXBlLG8uc2hhcGUpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmdyZWF0ZXIocixvKX0pLHthOnIsYjpvfSxudWxsLFwiR3JlYXRlclwiKX19KSxZYz1Bbih7Z3JlYXRlckVxdWFsXzpmdW5jdGlvbih0LGUpe3ZhciBuLHI9Z24odCxcImFcIixcImdyZWF0ZXJFcXVhbFwiKSxvPWduKGUsXCJiXCIsXCJncmVhdGVyRXF1YWxcIik7cmV0dXJuIG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFByKHIuc2hhcGUsby5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmdyZWF0ZXJFcXVhbChyLG8pO3JldHVybiBlKFtyLG9dKSxufSkse2E6cixiOm99LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdO3JldHVybnthOmZ1bmN0aW9uKCl7cmV0dXJuIFhuKG4pfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIFhuKHIpfX19KSxcIkdyZWF0ZXJFcXVhbFwiKX19KSwkYz1Bbih7Z3JlYXRlckVxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJhXCIsXCJncmVhdGVyRXF1YWxTdHJpY3RcIikscj1nbihlLFwiYlwiLFwiZ3JlYXRlckVxdWFsU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGdyZWF0ZXJFcXVhbFN0cmljdDogXCIpLG4uZ3JlYXRlckVxdWFsKHIpfX0pLFFjPUFuKHtncmVhdGVyU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJhXCIsXCJncmVhdGVyU3RyaWN0XCIpLHI9Z24oZSxcImJcIixcImdyZWF0ZXJTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gZ3JlYXRlclN0cmljdDogXCIpLG4uZ3JlYXRlcihyKX19KSxKYz1Bbih7bGVzc186ZnVuY3Rpb24odCxlKXt2YXIgbixyPWduKHQsXCJhXCIsXCJsZXNzXCIpLG89Z24oZSxcImJcIixcImxlc3NcIik7cmV0dXJuIG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFByKHIuc2hhcGUsby5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubGVzcyhyLG8pfSkse2E6cixiOm99LG51bGwsXCJMZXNzXCIpfX0pLFpjPUFuKHtsZXNzRXF1YWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1nbih0LFwiYVwiLFwibGVzc0VxdWFsXCIpLG89Z24oZSxcImJcIixcImxlc3NFcXVhbFwiKTtyZXR1cm4gbj1OdChyLG8pLHI9blswXSxvPW5bMV0sUHIoci5zaGFwZSxvLnNoYXBlKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubGVzc0VxdWFsKHIsbyk7cmV0dXJuIGUoW3Isb10pLG59KSx7YTpyLGI6b30sbnVsbCxcIkxlc3NFcXVhbFwiKX19KSx0bD1Bbih7bGVzc0VxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJhXCIsXCJsZXNzRXF1YWxTdHJpY3RcIikscj1nbihlLFwiYlwiLFwibGVzc0VxdWFsU3RyaWN0XCIpO3JldHVybiBFKG4uc2hhcGUsci5zaGFwZSxcIkVycm9yIGluIGxlc3NFcXVhbFN0cmljdDogXCIpLG4ubGVzc0VxdWFsKHIpfX0pLGVsPUFuKHtsZXNzU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJhXCIsXCJsZXNzU3RyaWN0XCIpLHI9Z24oZSxcImJcIixcImxlc3NTdHJpY3RcIik7cmV0dXJuIEUobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gbGVzc1N0cmljdDogXCIpLG4ubGVzcyhyKX19KSxubD1Bbih7bm90RXF1YWxfOmZ1bmN0aW9uKHQsZSl7dmFyIG4scj1nbih0LFwiYVwiLFwibm90RXF1YWxcIiksbz1nbihlLFwiYlwiLFwibm90RXF1YWxcIik7cmV0dXJuIG49TnQocixvKSxyPW5bMF0sbz1uWzFdLFByKHIuc2hhcGUsby5zaGFwZSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubm90RXF1YWwocixvKX0pLHthOnIsYjpvfSxudWxsLFwiTm90RXF1YWxcIil9fSkscmw9QW4oe25vdEVxdWFsU3RyaWN0XzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJhXCIsXCJub3RFcXVhbFN0cmljdFwiKSxyPWduKGUsXCJiXCIsXCJub3RFcXVhbFN0cmljdFwiKTtyZXR1cm4gRShuLnNoYXBlLHIuc2hhcGUsXCJFcnJvciBpbiBub3RFcXVhbFN0cmljdDogXCIpLG4ubm90RXF1YWwocil9fSk7ZnVuY3Rpb24gb2wodCxlKXtmb3IodmFyIG49W10scj10O3I8ZTsrK3Ipbi5wdXNoKHIpO3JldHVybiBufWZ1bmN0aW9uIGFsKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pZm9yKHZhciByPTA7cjx0W25dLmxlbmd0aDsrK3IpZS5wdXNoKHRbbl1bcl0pO3JldHVybiBlfXZhciBpbD1Bbih7Z2F0aGVyXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49MCk7dmFyIHI9Z24odCxcInhcIixcImdhdGhlclwiKSxvPWduKGUsXCJpbmRpY2VzXCIsXCJnYXRoZXJcIixcImludDMyXCIpO249TyhuLHIuc2hhcGUpWzBdO3ZhciBhPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9dC5zaGFwZVtuXSxvPVtdLGE9MSxpPTEscz0wO3M8bjtzKyspby5wdXNoKHQuc2hhcGVbc10pLGEqPXQuc2hhcGVbc107Zm9yKHM9MDtzPGUucmFuaztzKyspby5wdXNoKGUuc2hhcGVbc10pO2ZvcihzPW4rMTtzPHQucmFuaztzKyspby5wdXNoKHQuc2hhcGVbc10pLGkqPXQuc2hhcGVbc107cmV0dXJue2JhdGNoU2l6ZTphLHNsaWNlU2l6ZTppLGRpbVNpemU6cixvdXRwdXRTaGFwZTpvfX0ocixvLG4pO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBhPXQuZ2F0aGVyKHIsby5mbGF0dGVuKCksbik7cmV0dXJuIGUoW29dKSxhfSkse3g6cixpbmRpY2VzOm99LChmdW5jdGlvbih0LGUpe3ZhciBvPWVbMF07cmV0dXJue3g6ZnVuY3Rpb24oKXt2YXIgZT1yLnNoYXBlLGE9by5zaXplLGk9ZS5zbGljZSgwLG4pLHM9aS5sZW5ndGgsdT1lLnNsaWNlKG4sZS5sZW5ndGgpLnNsaWNlKDEpLGM9dS5sZW5ndGgsbD1vbCgwLHMpLGg9b2wocysxLHMrMStjKSxmPWFsKFtpLFthXSx1XSksZD10LnJlc2hhcGUoZikscD1vLnJlc2hhcGUoW2FdKSx2PWFsKFtbc10sbCxoXSksZz1kLnRyYW5zcG9zZSh2KSxtPXNsKGcscCxyLnNoYXBlW25dKSx5PVJuKHYpO3JldHVybiBtPW0udHJhbnNwb3NlKHkpfSxpbmRpY2VzOmZ1bmN0aW9uKCl7cmV0dXJuIG99fX0pLFwiR2F0aGVyXCIse2F4aXM6bn0pLnJlc2hhcGUoYS5vdXRwdXRTaGFwZSl9fSksc2w9QW4oe3Vuc29ydGVkU2VnbWVudFN1bV86ZnVuY3Rpb24odCxlLG4pe3ZhciByPWduKHQsXCJ4XCIsXCJ1bnNvcnRlZFNlZ21lbnRTdW1cIiksbz1nbihlLFwic2VnbWVudElkc1wiLFwidW5zb3J0ZWRTZWdtZW50U3VtXCIsXCJpbnQzMlwiKTtyZXR1cm4gQyhBKG4pLChmdW5jdGlvbigpe3JldHVyblwibnVtU2VnbWVudHMgbXVzdCBiZSBvZiBkdHlwZSBpbnRcIn0pKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBhPXQudW5zb3J0ZWRTZWdtZW50U3VtKHIsbyxuKTtyZXR1cm4gZShbb10pLGF9KSx7JHg6cn0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57JHg6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlKXtmb3IodmFyIG49RW8oZSxYbihlKSkscj1pbCh0LG4pLG89WWMoZSxPbigwLFwiaW50MzJcIikpLGE9ci5yYW5rLW8ucmFuayxpPTA7aTxhOysraSlvPXNyKG8saSsxKTtvPXBjKG8sem4oci5zaGFwZSxcImJvb2xcIikpO3ZhciBzPVhuKHIpO3JldHVybiB5YyhvLHIscyl9KHQsbil9fX0pKX19KTt2YXIgdWw9ZnVuY3Rpb24odCxlLG8pe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixhLGkscyx1LGMsbCxoLGYsZCxwLHYsZztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmZvcihuPWduKHQsXCJ0ZW5zb3JcIixcImJvb2xNYXNrXCIpLGE9Z24oZSxcIm1hc2tcIixcImJvb2xNYXNrXCIsXCJib29sXCIpLGk9bnVsbD09bz8wOm8scz1hLnJhbmssdT1uLnNoYXBlLEMocz4wLChmdW5jdGlvbigpe3JldHVyblwibWFzayBjYW5ub3QgYmUgc2NhbGFyXCJ9KSksRSh1LnNsaWNlKGksaStzKSxhLnNoYXBlLFwibWFzaydzIHNoYXBlIG11c3QgbWF0Y2ggdGhlIGZpcnN0IEsgZGltZW5zaW9ucyBvZiB0ZW5zb3IncyBzaGFwZSxcIiksYz0xLGw9aTtsPGkrcztsKyspYyo9dVtsXTtyZXR1cm4gaD11LnNsaWNlKDAsaSkuY29uY2F0KFtjXSx1LnNsaWNlKGkrcykpLGY9bi5yZXNoYXBlKGgpLGQ9YS5yZXNoYXBlKFstMV0pLFs0LHhjKGQpXTtjYXNlIDE6cmV0dXJuIHA9ci5zZW50KCksdj1wLnNxdWVlemUoWzFdKSxnPWlsKGYsdixpKSx0IT09biYmbi5kaXNwb3NlKCksZSE9PWEmJmEuZGlzcG9zZSgpLHYuZGlzcG9zZSgpLGYuZGlzcG9zZSgpLGQuZGlzcG9zZSgpLHAuZGlzcG9zZSgpLFsyLGddfX0pKX0pKX07ZnVuY3Rpb24gY2wodCxlLG4scixvLGEsaSl7dm9pZCAwPT09YSYmKGE9XCJOSFdDXCIpLEModC5sZW5ndGg9PT1lLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJMZW5ndGggb2YgaW5TaGFwZSAoXCIrdC5sZW5ndGgrXCIpIGFuZCByYW5rIG9mIGR5IChcIitlLnJhbmsrXCIpIG11c3QgbWF0Y2hcIn0pKTt2YXIgcz10LHU9ZSxjPSExOzM9PT1lLnJhbmsmJihjPSEwLHU9ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pLHM9WzEsdFswXSx0WzFdLHRbMl1dKSxDKDQ9PT1zLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBpblNoYXBlIG11c3QgYmUgbGVuZ3RoIDQsIGJ1dCBnb3QgbGVuZ3RoIFwiK3MubGVuZ3RoK1wiLlwifSkpLEMoND09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBkeSBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFua30pKSxDKDQ9PT1uLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrbi5yYW5rfSkpO3ZhciBsPVwiTkhXQ1wiPT09YT9zWzNdOnNbMV0saD1cIk5IV0NcIj09PWE/dS5zaGFwZVszXTp1LnNoYXBlWzFdO0MobD09PW4uc2hhcGVbMl0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2YgaW5wdXQgKFwiK2wrXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIituLnNoYXBlWzJdK1wiLlwifSkpLEMoaD09PW4uc2hhcGVbM10sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2Ygb3V0cHV0IChcIitoK1wiKSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK24uc2hhcGVbM10rXCIuXCJ9KSksbnVsbCE9aSYmQyhBKG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2krXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pKTt2YXIgZj1FYShhKSxkPXBhKHMsbi5zaGFwZSxyLDEsbyxpLCExLGYpLHA9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgcj10LmNvbnYyZERlcklucHV0KHUsbixkKTtyZXR1cm4gZShbbix1XSkscn0pLHtkeTREOnUsZmlsdGVyOm59LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scz1lWzFdO3JldHVybntkeTREOmZ1bmN0aW9uKCl7cmV0dXJuIGRsKHQsbixyLG8sYSwxLGkpfSxmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdmwodCxzLG4uc2hhcGUscixvLGEsaSl9fX0pKTtyZXR1cm4gYz9wLmFzM0QocC5zaGFwZVsxXSxwLnNoYXBlWzJdLHAuc2hhcGVbM10pOnB9ZnVuY3Rpb24gbGwodCl7dmFyIGU9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/W3QsdCx0XToyPT09dC5sZW5ndGg/W3RbMF0sdFsxXSwxXTp0fSh0KSxuPWVbMF0scj1lWzFdLG89ZVsyXTtyZXR1cm4gMT09PW4mJjE9PT1yJiYxPT09b31mdW5jdGlvbiBobCh0LGUsbixyLG8pe0ModC5sZW5ndGg9PT1lLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJMZW5ndGggb2YgaW5TaGFwZSAoXCIrdC5sZW5ndGgrXCIpIGFuZCByYW5rIG9mIGR5IChcIitlLnJhbmsrXCIpIG11c3QgbWF0Y2hcIn0pKTt2YXIgYT10LGk9ZSxzPSExOzQ9PT1lLnJhbmsmJihzPSEwLGk9ZS5hczVEKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0sZS5zaGFwZVszXSksYT1bMSx0WzBdLHRbMV0sdFsyXSx0WzNdXSk7dmFyIHU9YVs0XSxjPWkuc2hhcGVbNF07Qyg1PT09YS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogaW5TaGFwZSBtdXN0IGJlIGxlbmd0aCA1LCBidXQgZ290IGxlbmd0aCBcIithLmxlbmd0aCtcIi5cIn0pKSxDKDU9PT1pLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJJbnB1dDogZHkgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3QgcmFuayBcIitpLnJhbmt9KSksQyg1PT09bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rIFwiK24ucmFua30pKSxDKHU9PT1uLnNoYXBlWzNdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGRlcHRoIG9mIGlucHV0IChcIit1K1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrbi5zaGFwZVszXStcIi5cIn0pKSxDKGM9PT1uLnNoYXBlWzRdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVySW5wdXQ6IGRlcHRoIG9mIG91dHB1dCAoXCIrYytcIikgbXVzdCBtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciBcIituLnNoYXBlWzRdK1wiLlwifSkpO3ZhciBsPXZhKGEsbi5zaGFwZSxyLDEsbyksaD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb252M2REZXJJbnB1dChpLG4sbCl9KSx7ZHk1RDppfSk7cmV0dXJuIHM/aC5hczREKGguc2hhcGVbMV0saC5zaGFwZVsyXSxoLnNoYXBlWzNdLGguc2hhcGVbNF0pOmh9dmFyIGZsPUFuKHtjb252MWRfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PW8mJihvPVwiTldDXCIpLHZvaWQgMD09PWEmJihhPTEpO3ZhciBzPWduKHQsXCJ4XCIsXCJjb252MWRcIiksdT1nbihlLFwiZmlsdGVyXCIsXCJjb252MWRcIiksYz1zLGw9ITE7Mj09PXMucmFuayYmKGw9ITAsYz1zLmFzM0QoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0pKSxDKDM9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IGlucHV0IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIrYy5yYW5rK1wiLlwifSkpLEMoMz09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogZmlsdGVyIG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLG51bGwhPWkmJkMoQShyKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYxZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIraStcIiBidXQgZ290IHBhZCBcIityK1wiLlwifSkpLEMoYy5zaGFwZVsyXT09PXUuc2hhcGVbMV0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IGRlcHRoIG9mIGlucHV0IChcIitjLnNoYXBlWzJdK1wiKSBtdXN0IG1hdGNoIGlucHV0IGRlcHRoIGZvciBmaWx0ZXIgXCIrdS5zaGFwZVsxXStcIi5cIn0pKSxDKENhKG4sYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MUQ6IEVpdGhlciBzdHJpZGUgb3IgZGlsYXRpb24gbXVzdCBiZSAxLiBHb3Qgc3RyaWRlIFwiK24rXCIgYW5kIGRpbGF0aW9uICdcIithK1wiJ1wifSkpLEMoXCJOV0NcIj09PW8sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MWQ6IGdvdCBkYXRhRm9ybWF0IG9mIFwiK28rXCIgYnV0IG9ubHkgTldDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuXCJ9KSk7dmFyIGg9dS5hczREKDEsdS5zaGFwZVswXSx1LnNoYXBlWzFdLHUuc2hhcGVbMl0pLGY9Yy5hczREKGMuc2hhcGVbMF0sMSxjLnNoYXBlWzFdLGMuc2hhcGVbMl0pLGQ9ZGwoZixoLFsxLG5dLHIsXCJOSFdDXCIsWzEsYV0saSk7cmV0dXJuIGw/ZC5hczJEKGQuc2hhcGVbMl0sZC5zaGFwZVszXSk6ZC5hczNEKGQuc2hhcGVbMF0sZC5zaGFwZVsyXSxkLnNoYXBlWzNdKX19KSxkbD1Bbih7Y29udjJkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1vJiYobz1cIk5IV0NcIiksdm9pZCAwPT09YSYmKGE9WzEsMV0pO3ZhciBzPWduKHQsXCJ4XCIsXCJjb252MmRcIiksdT1nbihlLFwiZmlsdGVyXCIsXCJjb252MmRcIiksYz1zLGw9ITE7Mz09PXMucmFuayYmKGw9ITAsYz1zLmFzNEQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSkpLEMoND09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksbnVsbCE9aSYmQyhBKHIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK3IrXCIuXCJ9KSk7dmFyIGg9XCJOSFdDXCI9PT1vP2Muc2hhcGVbM106Yy5zaGFwZVsxXTtDKGg9PT11LnNoYXBlWzJdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBkZXB0aCBvZiBpbnB1dCAoXCIraCtcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Uuc2hhcGVbMl0rXCIuXCJ9KSksQyhDYShuLGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJEOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSk7dmFyIGY9RWEobyksZD1wYShjLnNoYXBlLHUuc2hhcGUsbixhLHIsaSwhMSxmKSxwPVt1LGNdLHY9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmNvbnYyZChjLHUsZCk7cmV0dXJuIGUoW3UsY10pLG59KSx7eDpjLGZpbHRlcjp1fSwoZnVuY3Rpb24odCxlKXt2YXIgaT1lLHM9aVswXSx1PWlbMV07cmV0dXJuIEMod2EoYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBncmFkaWVudCBvZiBjb252MkQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBncmFkaWVudHMuIEdvdCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSkse3g6ZnVuY3Rpb24oKXtyZXR1cm4gZ2wodS5zaGFwZSx0LHMsbixyLG8pfSxmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdmwodSx0LHMuc2hhcGUsbixyLG8pfX19KSxcIkNvbnYyRFwiLGQscCk7cmV0dXJuIGw/di5hczNEKHYuc2hhcGVbMV0sdi5zaGFwZVsyXSx2LnNoYXBlWzNdKTp2fX0pLHBsPUFuKHtjb252M2RfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2b2lkIDA9PT1vJiYobz1cIk5ESFdDXCIpLHZvaWQgMD09PWEmJihhPVsxLDEsMV0pO3ZhciBpPWduKHQsXCJ4XCIsXCJjb252M2RcIikscz1nbihlLFwiZmlsdGVyXCIsXCJjb252M2RcIiksdT1pLGM9ITE7ND09PWkucmFuayYmKGM9ITAsdT1pLmFzNUQoMSxpLnNoYXBlWzBdLGkuc2hhcGVbMV0saS5zaGFwZVsyXSxpLnNoYXBlWzNdKSksQyg1PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDU9PT1zLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2Q6IGZpbHRlciBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pKSxDKHUuc2hhcGVbNF09PT1zLnNoYXBlWzNdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkOiBkZXB0aCBvZiBpbnB1dCAoXCIrdS5zaGFwZVs0XStcIikgbXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiK3Muc2hhcGVbM10rXCIuXCJ9KSksQyhmdW5jdGlvbih0LGUpe3JldHVybiBsbCh0KXx8bGwoZSl9KG4sYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M0Q6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK24rXCIgYW5kIGRpbGF0aW9ucyAnXCIrYStcIidcIn0pKSxDKFwiTkRIV0NcIj09PW8sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2Q6IGdvdCBkYXRhRm9ybWF0IG9mIFwiK28rXCIgYnV0IG9ubHkgTkRIV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cIn0pKTt2YXIgbD12YSh1LnNoYXBlLHMuc2hhcGUsbixhLHIpLGg9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10LmNvbnYzZCh1LHMsbCk7cmV0dXJuIGUoW3Usc10pLG59KSx7eDp1LCRmaWx0ZXI6c30sKGZ1bmN0aW9uKHQsZSl7QyhsbChhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGdyYWRpZW50IG9mIGNvbnYzRDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnXCIrYStcIidcIn0pKTt2YXIgbz1lWzBdLGk9ZVsxXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBobChvLnNoYXBlLHQsaSxuLHIpfSwkZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGE9dDs0PT09dC5yYW5rJiYoYT10LmFzNUQoMSx0LnNoYXBlWzBdLHQuc2hhcGVbMV0sdC5zaGFwZVsyXSx0LnNoYXBlWzNdKSk7dmFyIGk9ZTs0PT09aS5yYW5rJiYoaT1lLmFzNUQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSxlLnNoYXBlWzNdKSk7Qyg1PT09YS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjNkRGVyRmlsdGVyOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSwgYnV0IGdvdCBzaGFwZSBcIithLnNoYXBlK1wiLlwifSkpLEMoNT09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZHkgbXVzdCBiZSByYW5rIDUsIGJ1dCBnb3Qgc2hhcGUgXCIraS5zaGFwZStcIi5cIn0pKSxDKDU9PT1uLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYzZERlckZpbHRlcjogZmlsdGVyU2hhcGUgbXVzdCBiZSBsZW5ndGggNSwgYnV0IGdvdCBcIituK1wiLlwifSkpLEMoYS5zaGFwZVs0XT09PW5bM10sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGRlcHRoIG9mIGlucHV0IFwiK2Euc2hhcGVbNF0rXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggaW4gZmlsdGVyIChcIituWzNdK1wiLlwifSkpLEMoaS5zaGFwZVs0XT09PW5bNF0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252M2REZXJGaWx0ZXI6IGRlcHRoIG9mIGR5IChcIitpLnNoYXBlWzRdK1wiKSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIChcIituWzRdK1wiKS5cIn0pKTt2YXIgcz12YShhLnNoYXBlLG4sciwxLG8pO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb252M2REZXJGaWx0ZXIoYSxpLHMpfSkse3g1RDphLGR5NUQ6aX0pfShvLHQsaS5zaGFwZSxuLHIpfX19KSk7cmV0dXJuIGM/aC5hczREKGguc2hhcGVbMV0saC5zaGFwZVsyXSxoLnNoYXBlWzNdLGguc2hhcGVbNF0pOmh9fSksdmw9QW4oe2NvbnYyZERlckZpbHRlcl86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09YSYmKGE9XCJOSFdDXCIpO3ZhciBzPXQ7Mz09PXQucmFuayYmKHM9dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pKTt2YXIgdT1lOzM9PT11LnJhbmsmJih1PWUuYXM0RCgxLGUuc2hhcGVbMF0sZS5zaGFwZVsxXSxlLnNoYXBlWzJdKSksQyg0PT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSBcIitzLnNoYXBlK1wiLlwifSkpLEMoND09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZHkgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3Qgc2hhcGUgXCIrdS5zaGFwZStcIi5cIn0pKSxDKDQ9PT1uLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZmlsdGVyU2hhcGUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCBcIituK1wiLlwifSkpO3ZhciBjPVwiTkhXQ1wiPT09YT9zLnNoYXBlWzNdOnMuc2hhcGVbMV0sbD1cIk5IV0NcIj09PWE/dS5zaGFwZVszXTp1LnNoYXBlWzFdO0MoYz09PW5bMl0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGlucHV0IFwiK2MrXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggaW4gZmlsdGVyIChcIituWzJdK1wiLlwifSkpLEMobD09PW5bM10sKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IGRlcHRoIG9mIGR5IChcIitsK1wiKSBtdXN0IG1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIChcIituWzNdK1wiKS5cIn0pKSxudWxsIT1pJiZDKEEobyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjb252MmREZXJGaWx0ZXI6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK2krXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pKTt2YXIgaD1FYShhKSxmPXBhKHMuc2hhcGUsbixyLDEsbyxpLCExLGgpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jb252MmREZXJGaWx0ZXIocyx1LGYpfSkse3g0RDpzLGR5NEQ6dX0pfX0pLGdsPUFuKHtjb252MmREZXJJbnB1dF86Y2x9KSxtbD1Bbih7ZGVwdGh3aXNlQ29udjJkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1vJiYobz1cIk5IV0NcIiksdm9pZCAwPT09YSYmKGE9WzEsMV0pO3ZhciBzPWduKHQsXCJ4XCIsXCJkZXB0aHdpc2VDb252MmRcIiksdT1nbihlLFwiZmlsdGVyXCIsXCJkZXB0aHdpc2VDb252MmRcIiksYz1zLGw9ITE7Mz09PXMucmFuayYmKGw9ITAsYz1zLmFzNEQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSkpLEMoND09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQyhjLnNoYXBlWzNdPT09dS5zaGFwZVsyXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGRlcHRod2lzZUNvbnYyZDogbnVtYmVyIG9mIGlucHV0IGNoYW5uZWxzIChcIitjLnNoYXBlWzNdK1wiKSBtdXN0IG1hdGNoIHRoZSBpbkNoYW5uZWxzIGRpbWVuc2lvbiBpbiBmaWx0ZXIgXCIrdS5zaGFwZVsyXStcIi5cIn0pKSxudWxsPT1hJiYoYT1bMSwxXSksQyhDYShuLGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSksbnVsbCE9aSYmQyhBKHIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZGVwdGh3aXNlQ29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK3IrXCIuXCJ9KSk7dmFyIGg9cGEoYy5zaGFwZSx1LnNoYXBlLG4sYSxyLGksITApLGY9W2MsdV0sZD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZGVwdGh3aXNlQ29udjJEKGMsdSxoKTtyZXR1cm4gZShbYyx1XSksbn0pLHt4OmMsZmlsdGVyOnV9LChmdW5jdGlvbih0LGUpe0Mod2EoYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBncmFkaWVudCBvZiBkZXB0aHdpc2VDb252MmQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZC4gR290IGRpbGF0aW9ucyAnXCIrYStcIidcIn0pKTt2YXIgbj1lWzBdLHI9ZVsxXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB5bChuLnNoYXBlLHQscixoKX0sZmlsdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHhsKG4sdCxyLnNoYXBlLGgpfX19KSxcIkRlcHRod2lzZUNvbnYyZE5hdGl2ZVwiLGgsZik7cmV0dXJuIGw/ZC5hczNEKGQuc2hhcGVbMV0sZC5zaGFwZVsyXSxkLnNoYXBlWzNdKTpkfX0pLHlsPUFuKHtkZXB0aHdpc2VDb252MmREZXJJbnB1dF86ZnVuY3Rpb24odCxlLG4scil7dmFyIG89ZSxhPSExOzM9PT1lLnJhbmsmJihhPSEwLG89ZS5hczREKDEsZS5zaGFwZVswXSxlLnNoYXBlWzFdLGUuc2hhcGVbMl0pKTt2YXIgaT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXB0aHdpc2VDb252MkREZXJJbnB1dChvLG4scil9KSx7ZHk0RDpvfSk7cmV0dXJuIGE/aS5hczNEKGkuc2hhcGVbMV0saS5zaGFwZVsyXSxpLnNoYXBlWzNdKTppfX0pLHhsPUFuKHtkZXB0aHdpc2VDb252MmREZXJGaWx0ZXJfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPXQ7Mz09PXQucmFuayYmKG89dC5hczREKDEsdC5zaGFwZVswXSx0LnNoYXBlWzFdLHQuc2hhcGVbMl0pKTt2YXIgYT1lO3JldHVybiAzPT09YS5yYW5rJiYoYT1lLmFzNEQoMSxlLnNoYXBlWzBdLGUuc2hhcGVbMV0sZS5zaGFwZVsyXSkpLEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRlcHRod2lzZUNvbnYyRERlckZpbHRlcihvLGEscil9KSx7eDREOm8sZHk0RDphfSl9fSksYmw9QW4oe3NlcGFyYWJsZUNvbnYyZF86ZnVuY3Rpb24odCxlLG4scixvLGEsaSl7dm9pZCAwPT09YSYmKGE9WzEsMV0pLHZvaWQgMD09PWkmJihpPVwiTkhXQ1wiKTt2YXIgcz1nbih0LFwieFwiLFwic2VwYXJhYmxlQ29udjJkXCIpLHU9Z24oZSxcImRlcHRod2lzZUZpbHRlclwiLFwic2VwYXJhYmxlQ29udjJkXCIpLGM9Z24obixcInBvaW50d2lzZUZpbHRlclwiLFwic2VwYXJhYmxlQ29udjJkXCIpLGw9cyxoPSExO2lmKDM9PT1zLnJhbmsmJihoPSEwLGw9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pKSxcIk5DSFdcIj09PWkpdGhyb3cgbmV3IEVycm9yKFwic2VwYXJhYmxlQ29udjJkIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IGRhdGFGb3JtYXQgTkNIVzsgb25seSBOSFdDIGlzIHN1cHBvcnRlZFwiKTtDKDQ9PT1sLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIrbC5yYW5rK1wiLlwifSkpLEMoND09PXUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogZGVwdGh3aXNlIGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKDQ9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHBvaW50d2lzZSBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQygxPT09Yy5zaGFwZVswXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIGZpcnN0IGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyICBtdXN0IGJlIDEsIGJ1dCBnb3QgXCIrYy5zaGFwZVswXStcIi5cIn0pKSxDKDE9PT1jLnNoYXBlWzFdLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgc2Vjb25kIGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgMSwgYnV0IGdvdCBcIitjLnNoYXBlWzFdK1wiLlwifSkpO3ZhciBmPXUuc2hhcGVbMl0sZD11LnNoYXBlWzNdO0MoYy5zaGFwZVsyXT09PWYqZCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIHRoaXJkIGRpbWVuc2lvbiBvZiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgXCIrZipkK1wiLCBidXQgZ290IFwiK2Muc2hhcGVbMl0rXCIuXCJ9KSk7dmFyIHA9bWwobCx1LHIsbyxpLGEpLHY9ZGwocCxjLDEsXCJ2YWxpZFwiLGkpO3JldHVybiBoP3YuYXMzRCh2LnNoYXBlWzFdLHYuc2hhcGVbMl0sdi5zaGFwZVszXSk6dn19KSx3bD1Bbih7Y29udjJkVHJhbnNwb3NlXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7cmV0dXJuIGNsKG4sZ24odCxcInhcIixcImNvbnYyZFRyYW5zcG9zZVwiKSxnbihlLFwiZmlsdGVyXCIsXCJjb252MmRUcmFuc3Bvc2VcIikscixvLFwiTkhXQ1wiLGEpfX0pLENsPUFuKHtjb252M2RUcmFuc3Bvc2VfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIGhsKG4sZ24odCxcInhcIixcImNvbnYzZFRyYW5zcG9zZVwiKSxnbihlLFwiZmlsdGVyXCIsXCJjb252M2RUcmFuc3Bvc2VcIikscixvKX19KTt2YXIgRWw9QW4oe21hdE11bF86ZnVuY3Rpb24odCxlLG4scil7dmFyIG87dm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PXImJihyPSExKTt2YXIgYT1nbih0LFwiYVwiLFwibWF0TXVsXCIpLGk9Z24oZSxcImJcIixcIm1hdE11bFwiKTtvPU50KGEsaSksYT1vWzBdLGk9b1sxXTt2YXIgcz1uP2Euc2hhcGVbYS5yYW5rLTJdOmEuc2hhcGVbYS5yYW5rLTFdLHU9cj9pLnNoYXBlW2kucmFuay0xXTppLnNoYXBlW2kucmFuay0yXSxjPW4/YS5zaGFwZVthLnJhbmstMV06YS5zaGFwZVthLnJhbmstMl0sbD1yP2kuc2hhcGVbaS5yYW5rLTJdOmkuc2hhcGVbaS5yYW5rLTFdLGg9YS5zaGFwZS5zbGljZSgwLC0yKSxmPWkuc2hhcGUuc2xpY2UoMCwtMiksZD1rKGgpLHA9ayhmKTtDKGEucmFuaz49MiYmaS5yYW5rPj0yJiZhLnJhbms9PT1pLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXRNdWw6IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBvZiBhdCBsZWFzdCAyLCBnb3QgcmFua3MgXCIrYS5yYW5rK1wiIGFuZCBcIitpLnJhbmsrXCIuXCJ9KSksQyhTKGgsZiksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXRNdWw6IG91dGVyIGRpbWVuc2lvbnMgKFwiK2grXCIpIGFuZCAoXCIrZitcIikgb2YgVGVuc29ycyB3aXRoIHNoYXBlcyBcIithLnNoYXBlK1wiIGFuZCBcIitpLnNoYXBlK1wiIG11c3QgbWF0Y2guXCJ9KSksQyhzPT09dSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1hdE11bDogaW5uZXIgc2hhcGVzIChcIitzK1wiKSBhbmQgKFwiK3UrXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIrYS5zaGFwZStcIiBhbmQgXCIraS5zaGFwZStcIiBhbmQgdHJhbnNwb3NlQT1cIituK1wiIGFuZCB0cmFuc3Bvc2VCPVwiK3IrXCIgbXVzdCBtYXRjaC5cIn0pKTt2YXIgdj1hLnNoYXBlLnNsaWNlKDAsLTIpLmNvbmNhdChbYyxsXSksZz1uP2EuYXMzRChkLHMsYyk6YS5hczNEKGQsYyxzKSxtPXI/aS5hczNEKHAsbCx1KTppLmFzM0QocCx1LGwpLHk9e3RyYW5zcG9zZUE6bix0cmFuc3Bvc2VCOnJ9O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBvPXQuYmF0Y2hNYXRNdWwoZyxtLG4scik7cmV0dXJuIGUoW2csbV0pLG99KSx7YTpnLGI6bX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG89ZSxhPW9bMF0saT1vWzFdO3JldHVybiBufHxyPyFuJiZyP3thOmZ1bmN0aW9uKCl7cmV0dXJuIHQubWF0TXVsKGksITEsITEpfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIHQubWF0TXVsKGEsITAsITEpfX06biYmIXI/e2E6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwodCwhMSwhMCl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gYS5tYXRNdWwodCwhMSwhMSl9fTp7YTpmdW5jdGlvbigpe3JldHVybiBpLm1hdE11bCh0LCEwLCEwKX0sYjpmdW5jdGlvbigpe3JldHVybiB0Lm1hdE11bChhLCEwLCEwKX19OnthOmZ1bmN0aW9uKCl7cmV0dXJuIHQubWF0TXVsKGksITEsITApfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIGEubWF0TXVsKHQsITAsITEpfX19KSxcIkJhdGNoTWF0TXVsXCIseSkucmVzaGFwZSh2KX19KSxSbD1Bbih7ZG90XzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJ0MVwiLFwiZG90XCIpLHI9Z24oZSxcInQyXCIsXCJkb3RcIik7QyghKDEhPT1uLnJhbmsmJjIhPT1uLnJhbmt8fDEhPT1yLnJhbmsmJjIhPT1yLnJhbmspLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZG90OiBpbnB1dHMgbXVzdCBhbGwgYmUgcmFuayAxIG9yIDIsIGJ1dCBnb3QgcmFua3MgXCIrbi5yYW5rK1wiIGFuZCBcIityLnJhbmsrXCIuXCJ9KSk7dmFyIG89MT09PW4ucmFuaz9uLnNpemU6bi5zaGFwZVsxXSxhPTE9PT1yLnJhbms/ci5zaXplOnIuc2hhcGVbMF07cmV0dXJuIEMobz09PWEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBkb3Q6IGlubmVyIGRpbWVuc2lvbnMgb2YgaW5wdXRzIG11c3QgbWF0Y2gsIGJ1dCBnb3QgXCIrbytcIiBhbmQgXCIrYStcIi5cIn0pKSwxPT09bi5yYW5rJiYxPT09ci5yYW5rP24uYXMyRCgxLC0xKS5tYXRNdWwoci5hczJEKC0xLDEpKS5hc1NjYWxhcigpOjE9PT1uLnJhbmsmJjI9PT1yLnJhbms/bi5hczJEKDEsLTEpLm1hdE11bChyLmFzMkQoci5zaGFwZVswXSxyLnNoYXBlWzFdKSkuYXMxRCgpOjI9PT1uLnJhbmsmJjE9PT1yLnJhbms/bi5tYXRNdWwoci5hczJEKC0xLDEpKS5hczFEKCk6bi5tYXRNdWwoci5hczJEKHIuc2hhcGVbMF0sci5zaGFwZVsxXSkpfX0pLElsPUFuKHtvdXRlclByb2R1Y3RfOmZ1bmN0aW9uKHQsZSl7dmFyIG49Z24odCxcInYxXCIsXCJvdXRlclByb2R1Y3RcIikscj1nbihlLFwidjJcIixcIm91dGVyUHJvZHVjdFwiKTtyZXR1cm4gQygxPT09bi5yYW5rJiYxPT09ci5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gb3V0ZXJQcm9kdWN0OiBpbnB1dHMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFua3MgXCIrbi5yYW5rK1wiIGFuZCBcIityLnJhbmsrXCIuXCJ9KSksbi5hczJEKC0xLDEpLm1hdE11bChyLmFzMkQoMSwtMSkpfX0pO3ZhciBrbD1Bbih7cmV2ZXJzZV86ZnVuY3Rpb24odCxlKXt2YXIgbj1nbih0LFwieFwiLFwicmV2ZXJzZVwiKTtpZigwPT09bi5yYW5rKXJldHVybiBuLmNsb25lKCk7dmFyIHI9TyhlLG4uc2hhcGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZXZlcnNlKG4scil9KSx7JHg6bn0sKGZ1bmN0aW9uKHQpe3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiB0LnJldmVyc2Uocil9fX0pKS5yZXNoYXBlQXMobil9fSksU2w9QW4oe3JldmVyc2UxZF86ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIEMoMT09PWUucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJldmVyc2UxRDogeCBtdXN0IGJlIHJhbmsgMSBidXQgZ290IHJhbmsgXCIrZS5yYW5rK1wiLlwifSkpLGtsKGUsMCl9fSksQWw9QW4oe3JldmVyc2UyZF86ZnVuY3Rpb24odCxlKXt2YXIgbj1nbih0LFwieFwiLFwicmV2ZXJzZVwiKTtyZXR1cm4gQygyPT09bi5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmV2ZXJzZTJEOiB4IG11c3QgYmUgcmFuayAyIGJ1dCBnb3QgcmFuayBcIituLnJhbmsrXCIuXCJ9KSksa2wobixlKX19KSxUbD1Bbih7cmV2ZXJzZTNkXzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKHQsXCJ4XCIsXCJyZXZlcnNlXCIpO3JldHVybiBDKDM9PT1uLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXZlcnNlM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdCByYW5rIFwiK24ucmFuaytcIi5cIn0pKSxrbChuLGUpfX0pLERsPUFuKHtyZXZlcnNlNGRfOmZ1bmN0aW9uKHQsZSl7dmFyIG49Z24odCxcInhcIixcInJldmVyc2VcIik7cmV0dXJuIEMoND09PW4ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJldmVyc2U0RDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrbi5yYW5rK1wiLlwifSkpLGtsKG4sZSl9fSk7ZnVuY3Rpb24gTmwodCxlLG4scixvLGEpe3ZhciBpPWduKHQsXCJ4XCIsXCJtYXhQb29sXCIpLHM9aSx1PSExOzM9PT1pLnJhbmsmJih1PSEwLHM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKSxudWxsPT1yJiYocj1bMSwxXSksQyg0PT09cy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK3MucmFuaytcIi5cIn0pKSxDKENhKG4sciksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK3IrXCInXCJ9KSksbnVsbCE9YSYmQyhBKG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrYStcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSkpO3ZhciBjPWZhKHMuc2hhcGUsZSxuLHIsbyxhKTtpZigxPT09Yy5maWx0ZXJXaWR0aCYmMT09PWMuZmlsdGVySGVpZ2h0JiZTKGMuaW5TaGFwZSxjLm91dFNoYXBlKSlyZXR1cm4gaS5jbG9uZSgpO3ZhciBsPVtzXSxoPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5tYXhQb29sKHMsYyk7cmV0dXJuIGUoW3Msbl0pLG59KSx7eDpzfSwoZnVuY3Rpb24odCxhKXt2YXIgaT1hWzBdLHM9YVsxXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSxpLHMpe3ZhciB1PWduKHQsXCJkeVwiLFwibWF4UG9vbEJhY2twcm9wXCIpLGM9Z24oZSxcImlucHV0XCIsXCJtYXhQb29sQmFja3Byb3BcIiksbD1nbihuLFwib3V0cHV0XCIsXCJtYXhQb29sQmFja3Byb3BcIik7QyhjLnJhbms9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJSYW5rIG9mIGlucHV0IChcIitjLnJhbmsrXCIpIGRvZXMgbm90IG1hdGNoIHJhbmsgb2YgZHkgKFwiK3UucmFuaytcIilcIn0pKSxudWxsPT1hJiYoYT1bMSwxXSk7QyhDYShvLGEpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbEJhY2tQcm9wOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIitvK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2ErXCInXCJ9KSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpLEMoND09PWMucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxudWxsIT1zJiZDKEEoaSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgZGltUm91bmRpbmdNb2RlIFwiK3MrXCIgYnV0IGdvdCBwYWQgXCIraStcIi5cIn0pKTt2YXIgaD1mYShjLnNoYXBlLHIsbyxhLGkscyk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1heFBvb2xCYWNrcHJvcCh1LGMsbCxoKX0pLHskZHk6dSwkaW5wdXQ6Y30pfSh0LGkscyxlLG4scixvKX19fSksXCJNYXhQb29sXCIsYyxsKTtyZXR1cm4gdT9oLmFzM0QoaC5zaGFwZVsxXSxoLnNoYXBlWzJdLGguc2hhcGVbM10pOmh9ZnVuY3Rpb24gRmwodCxlLG4scixvLGEpe3ZhciBpPWduKHQsXCJ4XCIsXCJhdmdQb29sXCIsXCJmbG9hdDMyXCIpO251bGw9PXImJihyPVsxLDFdKSxDKENhKG4sciksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK3IrXCInXCJ9KSk7dmFyIHM9aSx1PSExOzM9PT1pLnJhbmsmJih1PSEwLHM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKSxDKDQ9PT1zLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitzLnJhbmsrXCIuXCJ9KSksbnVsbCE9YSYmQyhBKG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrYStcIiBidXQgZ290IHBhZCBcIitvK1wiLlwifSkpO3ZhciBjPWZhKHMuc2hhcGUsZSxuLHIsbyxhKTtpZigxPT09Yy5maWx0ZXJXaWR0aCYmMT09PWMuZmlsdGVySGVpZ2h0JiZTKGMuaW5TaGFwZSxjLm91dFNoYXBlKSlyZXR1cm4gaS5jbG9uZSgpO3ZhciBsPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmF2Z1Bvb2wocyxjKX0pLHt4OnN9LChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9Z24odCxcImR5XCIsXCJhdmdQb29sQmFja3Byb3BcIikscz1nbihlLFwiaW5wdXRcIixcImF2Z1Bvb2xCYWNrcHJvcFwiKTtDKHMucmFuaz09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIlJhbmsgb2YgaW5wdXQgKFwiK3MucmFuaytcIikgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoXCIraS5yYW5rK1wiKVwifSkpLG51bGw9PW8mJihvPVsxLDFdKTtDKENhKHIsbyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IEVpdGhlciBzdHJpZGVzIG9yIGRpbGF0aW9ucyBtdXN0IGJlIDEuIEdvdCBzdHJpZGVzIFwiK3IrXCIgYW5kIGRpbGF0aW9ucyAnXCIrbytcIidcIn0pKTt2YXIgdT1zLGM9aSxsPSExOzM9PT1zLnJhbmsmJihsPSEwLHU9cy5hczREKDEscy5zaGFwZVswXSxzLnNoYXBlWzFdLHMuc2hhcGVbMl0pLGM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKTtDKDQ9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIitjLnJhbmsrXCIuXCJ9KSksQyg0PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrdS5yYW5rK1wiLlwifSkpO3ZhciBoPWZhKHUuc2hhcGUsbixyLG8sYSksZj1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hdmdQb29sQmFja3Byb3AoYyx1LGgpfSkse2R5NEQ6YyxpbnB1dDREOnV9KTtpZihsKXJldHVybiBmLmFzM0QoZi5zaGFwZVsxXSxmLnNoYXBlWzJdLGYuc2hhcGVbM10pO3JldHVybiBmfSh0LHMsZSxuLHIsbyl9fX0pLFwiQXZnUG9vbFwiLGMpO3JldHVybiBsPWwuY2FzdChpLmR0eXBlKSx1P2wuYXMzRChsLnNoYXBlWzFdLGwuc2hhcGVbMl0sbC5zaGFwZVszXSk6bH12YXIgX2w9QW4oe21heFBvb2xfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIE5sKHQsZSxuLDEscixvKX19KSxPbD1Bbih7YXZnUG9vbF86ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gRmwodCxlLG4sMSxyLG8pfX0pLE1sPUFuKHtwb29sXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7bnVsbD09byYmKG89WzEsMV0pLG51bGw9PWEmJihhPTEpLDA9PT1yJiYocj1cInZhbGlkXCIpO3ZhciBpPWduKHQsXCJ4XCIsXCJtYXhQb29sXCIpLHM9aSx1PSExOzM9PT1pLnJhbmsmJih1PSEwLHM9aS5hczREKDEsaS5zaGFwZVswXSxpLnNoYXBlWzFdLGkuc2hhcGVbMl0pKSxDKENhKGEsbyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBwb29sOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIithK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK28rXCInXCJ9KSk7dmFyIGMsbD1mYShzLnNoYXBlLGUsYSxvLHIpLGg9W2wuZGlsYXRpb25IZWlnaHQsbC5kaWxhdGlvbldpZHRoXTtjPVwic2FtZVwiPT09cj9mdW5jdGlvbih0LGUpe3ZhciBuPXQubWFwKChmdW5jdGlvbih0LG4pe3JldHVybiB0Kyh0LTEpKihlW25dLTEpfSkpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQtMX0pKSxyPW4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5mbG9vcih0LzIpfSkpLG89bi5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQtcltlXX0pKTtyZXR1cm4gbi5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuW3JbZV0sb1tlXV19KSl9KFtsLmZpbHRlckhlaWdodCxsLmZpbHRlcldpZHRoXSxoKTpbWzAsMF0sWzAsMF1dO3ZhciBmPTE9PT1oWzBdJiYxPT09aFsxXSxkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19KSksbz1uLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRbMV19KSksYT10LmNvbmNhdChyLG8pLGk9ZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQtYVtlXSV0KSV0fSkpLHM9by5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQraVtlXX0pKSx1PWUubWFwKChmdW5jdGlvbih0LGUpe3JldHVybltyW2VdLHNbZV1dfSkpLGM9ZS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuWzAsaVtlXV19KSk7cmV0dXJuW3UsY119KFtsLmluSGVpZ2h0LGwuaW5XaWR0aF0saCxjKSxwPWRbMF0sdj1kWzFdLGc9Zj9yOlwidmFsaWRcIixtPWY/czpjcihzLGgscCkseT0oXCJhdmdcIj09PW4/ZnVuY3Rpb24oKXtyZXR1cm4gRmwobSxlLGEsMSxnKX06ZnVuY3Rpb24oKXtyZXR1cm4gTmwobSxlLGEsMSxnKX0pKCkseD1mP3k6cnIoeSxoLHYpO3JldHVybiB1P3guYXMzRCh4LnNoYXBlWzFdLHguc2hhcGVbMl0seC5zaGFwZVszXSk6eH19KSxCbD1Bbih7bWF4UG9vbDNkXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2b2lkIDA9PT1hJiYoYT1cIk5ESFdDXCIpO3ZhciBzPWduKHQsXCJ4XCIsXCJtYXhQb29sM2RcIiksdT1zLGM9ITE7ND09PXMucmFuayYmKGM9ITAsdT1zLmFzNUQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSxzLnNoYXBlWzNdKSksbnVsbD09aSYmKGk9WzEsMSwxXSksQyg1PT09dS5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkOiB4IG11c3QgYmUgcmFuayA1IGJ1dCBnb3QgcmFuayBcIit1LnJhbmsrXCIuXCJ9KSksQyhcIk5ESFdDXCI9PT1hLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDNkOiBPbmx5IE5ESFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQsIGJ1dCBnb3QgZGF0YUZvcm1hdCBvZiBcIithfSkpLEMoQ2EobixpKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbitcIiBhbmQgZGlsYXRpb25zICdcIitpK1wiJ1wifSkpLG51bGwhPW8mJkMoQShyKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBkaW1Sb3VuZGluZ01vZGUgXCIrbytcIiBidXQgZ290IHBhZCBcIityK1wiLlwifSkpO3ZhciBsPWRhKHUuc2hhcGUsZSxuLGkscixvLGEpLGg9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1heFBvb2wzZCh1LGwpO3JldHVybiBlKFt1LG5dKSxufSkse3g6dX0sKGZ1bmN0aW9uKHQsYSl7dmFyIHM9YVswXSx1PWFbMV07cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixvLGEsaSxzKXt2YXIgdT1nbih0LFwiZHlcIixcIm1heFBvb2wzZEJhY2twcm9wXCIpLGM9Z24oZSxcImlucHV0XCIsXCJtYXhQb29sM2RCYWNrcHJvcFwiKSxsPWduKG4sXCJvdXRwdXRcIixcIm1heFBvb2wzZEJhY2twcm9wXCIpLGg9dSxmPWMsZD1sLHA9ITE7ND09PWMucmFuayYmKHA9ITAsaD11LmFzNUQoMSx1LnNoYXBlWzBdLHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdKSxmPWMuYXM1RCgxLGMuc2hhcGVbMF0sYy5zaGFwZVsxXSxjLnNoYXBlWzJdLGMuc2hhcGVbM10pLGQ9bC5hczVEKDEsbC5zaGFwZVswXSxsLnNoYXBlWzFdLGwuc2hhcGVbMl0sbC5zaGFwZVszXSkpO0MoNT09PWgucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgXCIraC5yYW5rK1wiLlwifSkpLEMoNT09PWYucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZEJhY2twcm9wOiBpbnB1dCBtdXN0IGJlIHJhbmsgNSBidXQgZ290IHJhbmsgXCIrZi5yYW5rK1wiLlwifSkpLEMoNT09PWQucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZEJhY2twcm9wOiBvdXRwdXQgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rIFwiK2QucmFuaytcIi5cIn0pKSxudWxsPT1hJiYoYT1bMSwxLDFdKTtDKENhKG8sYSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sM2RCYWNrcHJvcDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrbytcIiBhbmQgZGlsYXRpb25zICdcIithK1wiJ1wifSkpLG51bGwhPXMmJkMoQShpKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZEJhY2twcm9wOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitzK1wiIGJ1dCBnb3QgcGFkIFwiK2krXCIuXCJ9KSk7dmFyIHY9ZGEoZi5zaGFwZSxyLG8sYSxpLHMpLGc9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQubWF4UG9vbDNkQmFja3Byb3AoaCxmLGQsdil9KSx7ZHk1RDpoLGlucHV0NUQ6Zn0pO2lmKHApcmV0dXJuIGcuYXM0RChnLnNoYXBlWzFdLGcuc2hhcGVbMl0sZy5zaGFwZVszXSxnLnNoYXBlWzRdKTtyZXR1cm4gZ30odCxzLHUsZSxuLGkscixvKX19fSkpO3JldHVybiBjP2guYXM0RChoLnNoYXBlWzFdLGguc2hhcGVbMl0saC5zaGFwZVszXSxoLnNoYXBlWzRdKTpofX0pLFBsPUFuKHthdmdQb29sM2RfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe3ZvaWQgMD09PWEmJihhPVwiTkRIV0NcIik7dmFyIHM9Z24odCxcInhcIixcImF2Z1Bvb2wzZFwiLFwiZmxvYXQzMlwiKSx1PXMsYz0hMTs0PT09cy5yYW5rJiYoYz0hMCx1PXMuYXM1RCgxLHMuc2hhcGVbMF0scy5zaGFwZVsxXSxzLnNoYXBlWzJdLHMuc2hhcGVbM10pKSxudWxsPT1pJiYoaT1bMSwxLDFdKSxDKDU9PT11LnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2Q6IHggbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rIFwiK3UucmFuaytcIi5cIn0pKSxDKFwiTkRIV0NcIj09PWEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2Q6IE9ubHkgTkRIV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZCwgYnV0IGdvdCBkYXRhRm9ybWF0IG9mIFwiK2F9KSksQyhDYShuLGkpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDNkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIituK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK2krXCInXCJ9KSksbnVsbCE9byYmQyhBKHIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gYXZnUG9vbDNkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitvK1wiIGJ1dCBnb3QgcGFkIFwiK3IrXCIuXCJ9KSk7dmFyIGw9ZGEodS5zaGFwZSxlLG4saSxyLG8sYSksaD1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5hdmdQb29sM2QodSxsKX0pLHt4OnV9LChmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0LGUsbixyLG8sYSxpKXt2YXIgcz1nbih0LFwiZHlcIixcImF2Z1Bvb2wzZEJhY2twcm9wXCIpLHU9Z24oZSxcImlucHV0XCIsXCJhdmdQb29sM2RCYWNrcHJvcFwiKSxjPXMsbD11LGg9ITE7ND09PXUucmFuayYmKGg9ITAsYz1zLmFzNUQoMSxzLnNoYXBlWzBdLHMuc2hhcGVbMV0scy5zaGFwZVsyXSxzLnNoYXBlWzNdKSxsPXUuYXM1RCgxLHUuc2hhcGVbMF0sdS5zaGFwZVsxXSx1LnNoYXBlWzJdLHUuc2hhcGVbM10pKTtDKDU9PT1jLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2RCYWNrcHJvcDogZHkgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rIFwiK2MucmFuaytcIi5cIn0pKSxDKDU9PT1sLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2RCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDUgYnV0IGdvdCByYW5rIFwiK2wucmFuaytcIi5cIn0pKSxudWxsPT1vJiYobz1bMSwxLDFdKTtDKENhKHIsbyksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBhdmdQb29sM2RCYWNrcHJvcDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrcitcIiBhbmQgZGlsYXRpb25zICdcIitvK1wiJ1wifSkpLG51bGwhPWkmJkMoQShhKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIG1heFBvb2wzZEJhY2twcm9wOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitpK1wiIGJ1dCBnb3QgcGFkIFwiK2ErXCIuXCJ9KSk7dmFyIGY9ZGEobC5zaGFwZSxuLHIsbyxhLGkpLGQ9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuYXZnUG9vbDNkQmFja3Byb3AoYyxsLGYpfSkse2R5NUQ6YyxpbnB1dDVEOmx9KTtpZihoKXJldHVybiBkLmFzNEQoZC5zaGFwZVsxXSxkLnNoYXBlWzJdLGQuc2hhcGVbM10sZC5zaGFwZVs0XSk7cmV0dXJuIGR9KHQsdSxlLG4saSxyLG8pfX19KSk7cmV0dXJuIGg9aC5jYXN0KHUuZHR5cGUpLGM/aC5hczREKGguc2hhcGVbMV0saC5zaGFwZVsyXSxoLnNoYXBlWzNdLGguc2hhcGVbNF0pOmh9fSksTGw9QW4oe21heFBvb2xXaXRoQXJnbWF4XzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPSExKTt2YXIgYT1nbih0LFwieFwiLFwibWF4UG9vbFdpdGhBcmdtYXhcIiksaT17ZmlsdGVyU2l6ZTplLHN0cmlkZXM6bixwYWQ6cixpbmNsdWRlQmF0Y2hJbkluZGV4Om99LHM9THQucnVuS2VybmVsKFwiTWF4UG9vbFdpdGhBcmdtYXhcIix7eDphfSxpKTtyZXR1cm57cmVzdWx0OnNbMF0saW5kZXhlczpzWzFdfX19KTt2YXIgV2w9QW4oe3NsaWNlXzpmdW5jdGlvbih0LGUsbil7dmFyIHIsbyxhPWduKHQsXCJ4XCIsXCJzbGljZVwiKTtpZigwPT09YS5yYW5rKXRocm93IG5ldyBFcnJvcihcIlNsaWNpbmcgc2NhbGFyIGlzIG5vdCBwb3NzaWJsZVwiKTsocj1cIm51bWJlclwiPT10eXBlb2YgZT9bZV0uY29uY2F0KG5ldyBBcnJheShhLnJhbmstMSkuZmlsbCgwKSk6ZS5sZW5ndGg8YS5yYW5rP2UuY29uY2F0KG5ldyBBcnJheShhLnJhbmstZS5sZW5ndGgpLmZpbGwoMCkpOmUuc2xpY2UoKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7QygtMSE9PXQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZSgpIGRvZXMgbm90IHN1cHBvcnQgbmVnYXRpdmUgYmVnaW4gaW5kZXhpbmcuXCJ9KSl9KSksbz0obz1udWxsPT1uP25ldyBBcnJheShhLnJhbmspLmZpbGwoLTEpOlwibnVtYmVyXCI9PXR5cGVvZiBuP1tuXS5jb25jYXQobmV3IEFycmF5KGEucmFuay0xKS5maWxsKC0xKSk6bi5sZW5ndGg8YS5yYW5rP24uY29uY2F0KG5ldyBBcnJheShhLnJhbmstbi5sZW5ndGgpLmZpbGwoLTEpKTpuKS5tYXAoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ+PTA/dDooQygtMT09PXQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJOZWdhdGl2ZSBzaXplIHZhbHVlcyBzaG91bGQgYmUgZXhhY3RseSAtMSBidXQgZ290IFwiK3QrXCIgZm9yIHRoZSBzbGljZSgpIHNpemUgYXQgaW5kZXggXCIrZStcIi5cIn0pKSxhLnNoYXBlW2VdLXJbZV0pfSkpLHFvKGEscixvKTt2YXIgaT1hLnNoYXBlLHM9e2JlZ2luOnIsc2l6ZTpvfTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2xpY2UoYSxyLG8pfSkse3g6YX0sKGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0LnJhbms7bisrKWUucHVzaChbcltuXSxpW25dLXJbbl0tb1tuXV0pO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIEljKHQsZSl9fX0pLFwiU2xpY2VcIixzKX19KSxVbD1Bbih7c2xpY2UxZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPWduKHQsXCJ4XCIsXCJzbGljZTFkXCIpO3JldHVybiBDKDE9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZTFkIGV4cGVjdHMgYSByYW5rLTEgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIityLnJhbmsrXCIgdGVuc29yXCJ9KSksV2wocixbZV0sW25dKX19KSxWbD1Bbih7c2xpY2UyZF86ZnVuY3Rpb24odCxlLG4pe3ZhciByPWduKHQsXCJ4XCIsXCJzbGljZTJkXCIpO3JldHVybiBDKDI9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJzbGljZTJkIGV4cGVjdHMgYSByYW5rLTIgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIityLnJhbmsrXCIgdGVuc29yXCJ9KSksV2wocixlLG4pfX0pLHpsPUFuKHtzbGljZTNkXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9Z24odCxcInhcIixcInNsaWNlM2RcIik7cmV0dXJuIEMoMz09PXIucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cInNsaWNlM2QgZXhwZWN0cyBhIHJhbmstMyB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JcIn0pKSxXbChyLGUsbil9fSksR2w9QW4oe3NsaWNlNGRfOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1nbih0LFwieFwiLFwic2xpY2U0ZFwiKTtyZXR1cm4gQyg0PT09ci5yYW5rLChmdW5jdGlvbigpe3JldHVyblwic2xpY2U0ZCBleHBlY3RzIGEgcmFuay00IHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIrci5yYW5rK1wiIHRlbnNvclwifSkpLFdsKHIsZSxuKX19KTtmdW5jdGlvbiBIbCh0LGUsbixyLG8pe3JldHVybiBlLnJhbms8bi5yYW5rJiYoZT1lLnJlc2hhcGUod24oZS5zaGFwZSxyKSkpLHQucmFuazxuLnJhbmsmJih0PXQucmVzaGFwZSh3bih0LnNoYXBlLHIpKSkse3g6ZnVuY3Rpb24oKXt2YXIgcj10Lm11bChuLmVxdWFsKGUpLmNhc3QodC5kdHlwZSkpO3JldHVybiBudWxsPT1vP3I6ci50cmFuc3Bvc2Uobyl9fX12YXIgcWw9QW4oe2FsbF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1nbih0LFwieFwiLFwiYWxsXCIsXCJib29sXCIpLG89TyhlLHIuc2hhcGUpLGE9byxpPUVuKGEsci5yYW5rKTtudWxsIT1pJiYocj1yLnRyYW5zcG9zZShpKSxhPUluKGEubGVuZ3RoLHIucmFuaykpO3ZhciBzPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFsbChyLGEpfSkseyR4OnJ9KTtpZihuKXt2YXIgdT13bihzLnNoYXBlLG8pO3JldHVybiBzLnJlc2hhcGUodSl9cmV0dXJuIHN9fSksS2w9QW4oe2FueV86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1nbih0LFwieFwiLFwiYW55XCIsXCJib29sXCIpLG89TyhlLHIuc2hhcGUpLGE9byxpPUVuKGEsci5yYW5rKTtudWxsIT1pJiYocj1yLnRyYW5zcG9zZShpKSxhPUluKGEubGVuZ3RoLHIucmFuaykpO3ZhciBzPUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFueShyLGEpfSkseyR4OnJ9KTtpZihuKXt2YXIgdT13bihzLnNoYXBlLG8pO3JldHVybiBzLnJlc2hhcGUodSl9cmV0dXJuIHN9fSksamw9QW4oe2FyZ01heF86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0wKTt2YXIgbj1nbih0LFwieFwiLFwiYXJnTWF4XCIpO251bGw9PWUmJihlPTApO3ZhciByPU8oZSxuLnNoYXBlKSxvPUVuKHIsbi5yYW5rKTtudWxsIT1vJiYobj1uLnRyYW5zcG9zZShvKSxyPUluKHIubGVuZ3RoLG4ucmFuaykpO3ZhciBhPXtheGlzOnJbMF19LGk9W25dO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBvPXQuYXJnTWF4KG4sclswXSk7cmV0dXJuIGUoW25dKSxvfSkse3g6bn0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiBYbihuKX19fSksXCJBcmdNYXhcIixhLGkpfX0pLFhsPUFuKHthcmdNaW5fOmZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9MCk7dmFyIG49Z24odCxcInhcIixcImFyZ01pblwiKTtudWxsPT1lJiYoZT0wKTt2YXIgcj1PKGUsbi5zaGFwZSksbz1FbihyLG4ucmFuayk7cmV0dXJuIG51bGwhPW8mJihuPW4udHJhbnNwb3NlKG8pLHI9SW4oci5sZW5ndGgsbi5yYW5rKSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbz10LmFyZ01pbihuLHJbMF0pO3JldHVybiBlKFtuXSksb30pLHskeDpufSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBYbihuKX19fSkpfX0pLFlsPUFuKHtsb2dTdW1FeHBfOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9Z24odCxcInhcIixcImxvZ1N1bUV4cFwiKSxvPU8oZSxyLnNoYXBlKSxhPXIubWF4KG8sITApLGk9ci5zdWIoYSkuZXhwKCkuc3VtKG8pLmxvZygpLHM9YS5yZXNoYXBlKGkuc2hhcGUpLmFkZChpKTtpZihuKXt2YXIgdT13bihzLnNoYXBlLG8pO3JldHVybiBzLnJlc2hhcGUodSl9cmV0dXJuIHN9fSksJGw9QW4oe21heF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1nbih0LFwieFwiLFwibWF4XCIpLG89cixhPU8oZSxyLnNoYXBlKSxpPWEscz1FbihpLHIucmFuayk7bnVsbCE9cyYmKHI9ci50cmFuc3Bvc2UocyksaT1JbihpLmxlbmd0aCxyLnJhbmspKTt2YXIgdT1bcl0sYz1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQubWF4KHIsaSk7cmV0dXJuIGUoW28sbl0pLG59KSx7eDpyfSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gSGwodCxlWzFdLGVbMF0sYSxzKX0pLFwiTWF4XCIse2F4ZXM6aX0sdSxbITBdKTtpZihuKXt2YXIgbD13bihjLnNoYXBlLGEpO2M9Yy5yZXNoYXBlKGwpfXJldHVybiBjfX0pLFFsPUFuKHttZWFuXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPWduKHQsXCJ4XCIsXCJtZWFuXCIpLG89TyhlLHIuc2hhcGUpLGE9ayhibihyLnNoYXBlLG8pWzFdKTtyZXR1cm4gb2EoKGZ1bmN0aW9uKHQpe3ZhciByPU9uKGEpO3JldHVybnt2YWx1ZTooci5kdHlwZT09PXQuZHR5cGU/dDp0LmNhc3Qoci5kdHlwZSkpLmRpdihyKS5zdW0oZSxuKSxncmFkRnVuYzpmdW5jdGlvbihlKXt2YXIgbj10LnNoYXBlLnNsaWNlKCk7cmV0dXJuIG8uZm9yRWFjaCgoZnVuY3Rpb24odCl7blt0XT0xfSkpLGUucmVzaGFwZShuKS5tdWwoem4odC5zaGFwZSxcImZsb2F0MzJcIikpLmRpdihhKX19fSkpKHIpfX0pLEpsPUFuKHttaW5fOmZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT1udWxsKSx2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9Z24odCxcInhcIixcIm1pblwiKSxvPXIsYT1PKGUsci5zaGFwZSksaT1hLHM9RW4oaSxyLnJhbmspO251bGwhPXMmJihyPXIudHJhbnNwb3NlKHMpLGk9SW4oaS5sZW5ndGgsci5yYW5rKSk7dmFyIHU9W3JdLGM9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxlKXt2YXIgbj10Lm1pbihyLGkpO3JldHVybiBlKFtvLG5dKSxufSkse3g6cn0sKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIEhsKHQsZVsxXSxlWzBdLGEscyl9KSxcIk1pblwiLHtheGVzOml9LHUsWyEwXSk7aWYobil7dmFyIGw9d24oYy5zaGFwZSxhKTtjPWMucmVzaGFwZShsKX1yZXR1cm4gY319KSxabD1Bbih7bW9tZW50c186ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1PKGUsKHQ9Z24odCxcInhcIixcIm1vbWVudHNcIikpLnNoYXBlKSxvPXQubWVhbihyLG4pLGE9by5zaGFwZTtufHwoYT13bihvLnNoYXBlLHIpKTt2YXIgaT10LnRvRmxvYXQoKS5zdWIoby5yZXNoYXBlKGEpKS5zcXVhcmUoKTtyZXR1cm57bWVhbjpvLHZhcmlhbmNlOmkubWVhbihyLG4pfX19KSx0aD1Bbih7c3VtXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9bnVsbCksdm9pZCAwPT09biYmKG49ITEpO3ZhciByPWduKHQsXCJ4XCIsXCJzdW1cIik7XCJib29sXCI9PT1yLmR0eXBlJiYocj1yLnRvSW50KCkpO3ZhciBvPU8oZSxyLnNoYXBlKTtyZXR1cm4gb2EoKGZ1bmN0aW9uKHQpe3ZhciBlPUVuKG8sdC5yYW5rKSxyPW8sYT10O251bGwhPWUmJihhPXQudHJhbnNwb3NlKGUpLHI9SW4oci5sZW5ndGgsdC5yYW5rKSk7dmFyIGk9ZnVuY3Rpb24oZSl7dmFyIG49dC5zaGFwZS5zbGljZSgpO3JldHVybiBvLmZvckVhY2goKGZ1bmN0aW9uKHQpe25bdF09MX0pKSxlLnJlc2hhcGUobikubXVsKHpuKHQuc2hhcGUsXCJmbG9hdDMyXCIpKX0scz17YXhlczpyfSx1PUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnN1bShhLHIpfSkse3g6YX0sKGZ1bmN0aW9uKHQpe3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIGkodCl9fX0pLFwiU3VtXCIscyk7aWYobil7dmFyIGM9d24odS5zaGFwZSxvKTt1PXUucmVzaGFwZShjKX1yZXR1cm57dmFsdWU6dSxncmFkRnVuYzppfX0pKShyKX19KSxlaD1Bbih7cHJvZF86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PWUmJihlPW51bGwpLHZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1nbih0LFwieFwiLFwicHJvZFwiKTtcImJvb2xcIj09PXIuZHR5cGUmJihyPXIudG9JbnQoKSk7dmFyIG89TyhlLHIuc2hhcGUpLGE9RW4obyxyLnJhbmspLGk9byxzPXI7bnVsbCE9YSYmKHM9ci50cmFuc3Bvc2UoYSksaT1JbihpLmxlbmd0aCxyLnJhbmspKTt2YXIgdT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5wcm9kKHMsaSl9KSx7cGVybXV0ZWRYOnN9KTtpZihuKXt2YXIgYz13bih1LnNoYXBlLG8pO3U9dS5yZXNoYXBlKGMpfXJldHVybiB1fX0pO3ZhciBuaD1Bbih7ZWx1XzpmdW5jdGlvbih0KXt2YXIgZT1nbih0LFwieFwiLFwiZWx1XCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQuZWx1KGUpO3JldHVybiBuKFtyXSkscn0pLHskeDplfSwoZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnskeDpmdW5jdGlvbigpe3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbihlKXtyZXR1cm4gZS5lbHVEZXIodCxuKX0pLHtkeTp0LHk6bn0pfX19KSl9fSkscmg9QW4oe2xlYWt5UmVsdV86ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lJiYoZT0uMik7dmFyIG49Z24odCxcInhcIixcImxlYWt5UmVsdVwiKTtyZXR1cm4gRW8oT24oZSkubXVsKG4pLG4pfX0pLG9oPUFuKHtwcmVsdV86ZnVuY3Rpb24odCxlKXt2YXIgbj1nbih0LFwieFwiLFwicHJlbHVcIikscj1nbihlLFwiYWxwaGFcIixcInByZWx1XCIpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBvPXQucHJlbHUobixyKTtyZXR1cm4gZShbbixyXSksb30pLHt4Om4sYWxwaGE6cn0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sbz1uLmdyZWF0ZXIoMCk7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4geWMobyx0LHQubXVsKHIpKX0sYWxwaGE6ZnVuY3Rpb24oKXt2YXIgZT15YyhvLFhuKHQpLHQubXVsKG4pKSxhPUJyKHIuc2hhcGUsdC5zaGFwZSk7cmV0dXJuIGEubGVuZ3RoPjAmJihlPWUuc3VtKGEpKSxlLnJlc2hhcGUoci5zaGFwZSl9fX0pLFwiUHJlbHVcIil9fSksYWg9QW4oe3JlbHVfOmZ1bmN0aW9uKHQpe3ZhciBlPWduKHQsXCJ4XCIsXCJyZWx1XCIpO3JldHVyblwiYm9vbFwiPT09ZS5kdHlwZT9lLnRvSW50KCk6THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnJlbHUoZSk7cmV0dXJuIG4oW2VdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0Lm11bFN0cmljdChuLnN0ZXAoKS50b0Zsb2F0KCkpfX19KSxcIlJlbHVcIil9fSksaWg9QW4oe3JlbHU2XzpmdW5jdGlvbih0KXt2YXIgZT1nbih0LFwieFwiLFwicmVsdTZcIik7cmV0dXJuXCJib29sXCI9PT1lLmR0eXBlP2UudG9JbnQoKTpMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LG4pe3ZhciByPXQucmVsdTYoZSk7cmV0dXJuIG4oW2VdKSxyfSkse3g6ZX0sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPW4ubGVzc0VxdWFsKDYpLm11bChuLnN0ZXAoKSk7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdC5tdWxTdHJpY3Qoci50b0Zsb2F0KCkpfX19KSxcIlJlbHU2XCIpfX0pLHNoPUFuKHtzZWx1XzpmdW5jdGlvbih0KXt2YXIgZT1nbih0LFwieFwiLFwic2VsdVwiKTtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxuKXt2YXIgcj10LnNlbHUoZSk7cmV0dXJuIG4oW2VdKSxyfSkseyR4OmV9LChmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF07cmV0dXJueyR4OmZ1bmN0aW9uKCl7dmFyIGU9bi5ncmVhdGVyKE9uKDApKSxyPU9uKHN1KSxvPU9uKHV1KSxhPXQubXVsKG8pLGk9dC5tdWwocikubXVsKG4udG9GbG9hdCgpLmV4cCgpKTtyZXR1cm4geWMoZSxhLGkpfX19KSl9fSk7dmFyIHVoPUFuKHtsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbl86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1lJiYoZT01KSx2b2lkIDA9PT1uJiYobj0xKSx2b2lkIDA9PT1yJiYocj0xKSx2b2lkIDA9PT1vJiYobz0uNSk7dmFyIGE9Z24odCxcInhcIixcImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXCIpO0MoND09PWEucmFua3x8Mz09PWEucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiB4IG11c3QgYmUgcmFuayAzIG9yIDQgYnV0IGdvdFxcbiAgICAgICAgICAgICAgIHJhbmsgXCIrYS5yYW5rK1wiLlwifSkpLEMoQShlKSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiBkZXB0aFJhZGl1cyBtdXN0IGJlIGFuIGludGVnZXIgYnV0IGdvdCBkZXB0aFJhZGl1cyBcIitlK1wiLlwifSkpO3ZhciBpPWEscz0hMTszPT09YS5yYW5rJiYocz0hMCxpPWEuYXM0RCgxLGEuc2hhcGVbMF0sYS5zaGFwZVsxXSxhLnNoYXBlWzJdKSk7dmFyIHU9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCxhKXt2YXIgcz10LmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQoaSxlLG4scixvKTtyZXR1cm4gYShbaSxzXSksc30pLHt4NEQ6aX0sKGZ1bmN0aW9uKHQsYSl7dmFyIGk9YVswXSxzPWFbMV07cmV0dXJue3g0RDpmdW5jdGlvbigpe3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbihhKXtyZXR1cm4gYS5MUk5HcmFkKHQsaSxzLGUsbixyLG8pfSkse30pfX19KSk7cmV0dXJuIHM/dS5hczNEKHUuc2hhcGVbMV0sdS5zaGFwZVsyXSx1LnNoYXBlWzNdKTp1fX0pO3ZhciBjaD1Bbih7bm9ybV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ZSYmKGU9XCJldWNsaWRlYW5cIiksdm9pZCAwPT09biYmKG49bnVsbCksdm9pZCAwPT09ciYmKHI9ITEpO3ZhciBvPWZ1bmN0aW9uIHQoZSxuLHIpe3ZvaWQgMD09PXImJihyPW51bGwpO2lmKDA9PT1lLnJhbmspcmV0dXJuIGUuYWJzKCk7aWYoMSE9PWUucmFuayYmbnVsbD09PXIpcmV0dXJuIHQoZS5yZXNoYXBlKFstMV0pLG4scik7aWYoMT09PWUucmFua3x8XCJudW1iZXJcIj09dHlwZW9mIHJ8fEFycmF5LmlzQXJyYXkocikmJjE9PT1yLmxlbmd0aCl7aWYoMT09PW4pcmV0dXJuIGUuYWJzKCkuc3VtKHIpO2lmKG49PT0xLzApcmV0dXJuIGUuYWJzKCkubWF4KHIpO2lmKG49PT0tMS8wKXJldHVybiBlLmFicygpLm1pbihyKTtpZihcImV1Y2xpZGVhblwiPT09bnx8Mj09PW4pcmV0dXJuIGUuYWJzKCkucG93KE9uKDIsXCJpbnQzMlwiKSkuc3VtKHIpLnNxcnQoKTt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIG9yZCB2YWx1ZTogXCIrbil9aWYoQXJyYXkuaXNBcnJheShyKSYmMj09PXIubGVuZ3RoKXtpZigxPT09bilyZXR1cm4gZS5hYnMoKS5zdW0oclswXSkubWF4KHJbMV0tMSk7aWYobj09PTEvMClyZXR1cm4gZS5hYnMoKS5zdW0oclsxXSkubWF4KHJbMF0pO2lmKG49PT0tMS8wKXJldHVybiBlLmFicygpLnN1bShyWzFdKS5taW4oclswXSk7aWYoXCJmcm9cIj09PW58fFwiZXVjbGlkZWFuXCI9PT1uKXJldHVybiBlLnNxdWFyZSgpLnN1bShyKS5zcXJ0KCk7dGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiK24pfXRocm93IG5ldyBFcnJvcihcIkVycm9yIGluIG5vcm06IGludmFsaWQgYXhpczogXCIrcil9KHQ9Z24odCxcInhcIixcIm5vcm1cIiksZSxuKSxhPW8uc2hhcGU7aWYocil7dmFyIGk9TyhuLHQuc2hhcGUpO2E9d24oby5zaGFwZSxpKX1yZXR1cm4gby5yZXNoYXBlKGEpfX0pO3ZhciBsaD1Bbih7YmFzaWNMU1RNQ2VsbF86ZnVuY3Rpb24odCxlLG4scixvLGEpe3ZhciBpPWduKHQsXCJmb3JnZXRCaWFzXCIsXCJiYXNpY0xTVE1DZWxsXCIpLHM9Z24oZSxcImxzdG1LZXJuZWxcIixcImJhc2ljTFNUTUNlbGxcIiksdT1nbihuLFwibHN0bUJpYXNcIixcImJhc2ljTFNUTUNlbGxcIiksYz1nbihyLFwiZGF0YVwiLFwiYmFzaWNMU1RNQ2VsbFwiKSxsPWduKG8sXCJjXCIsXCJiYXNpY0xTVE1DZWxsXCIpLGg9Z24oYSxcImhcIixcImJhc2ljTFNUTUNlbGxcIiksZj1jLmNvbmNhdChoLDEpLm1hdE11bChzKS5hZGQodSksZD1mLnNoYXBlWzBdLHA9Zi5zaGFwZVsxXS80LHY9W2QscF0sZz1mLnNsaWNlKFswLDBdLHYpLG09Zi5zbGljZShbMCxwXSx2KSx5PWYuc2xpY2UoWzAsMipwXSx2KSx4PWYuc2xpY2UoWzAsMypwXSx2KSxiPWcuc2lnbW9pZCgpLm11bFN0cmljdChtLnRhbmgoKSkuYWRkU3RyaWN0KGwubXVsU3RyaWN0KGkuYWRkKHkpLnNpZ21vaWQoKSkpLHc9Yi50YW5oKCkubXVsU3RyaWN0KHguc2lnbW9pZCgpKTtyZXR1cm5bYix3XX19KSxoaD1Bbih7bXVsdGlSTk5DZWxsXzpmdW5jdGlvbih0LGUsbixyKXtmb3IodmFyIG89Z24oZSxcImRhdGFcIixcIm11bHRpUk5OQ2VsbFwiKSxhPW1uKG4sXCJjXCIsXCJtdWx0aVJOTkNlbGxcIiksaT1tbihyLFwiaFwiLFwibXVsdGlSTk5DZWxsXCIpLHM9byx1PVtdLGM9MDtjPHQubGVuZ3RoO2MrKyl7dmFyIGw9dFtjXShzLGFbY10saVtjXSk7dS5wdXNoKGxbMF0pLHUucHVzaChsWzFdKSxzPWxbMV19dmFyIGg9W10sZj1bXTtmb3IoYz0wO2M8dS5sZW5ndGg7Yys9MiloLnB1c2godVtjXSksZi5wdXNoKHVbYysxXSk7cmV0dXJuW2gsZl19fSk7dmFyIGZoPUFuKHttb3ZpbmdBdmVyYWdlXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PW8mJihvPSEwKTt2YXIgYT1nbih0LFwidlwiLFwibW92aW5nQXZlcmFnZVwiKSxpPWduKGUsXCJ4XCIsXCJtb3ZpbmdBdmVyYWdlXCIpLHM9Z24obixcImRlY2F5XCIsXCJtb3ZpbmdBdmVyYWdlXCIpO0Z0KGEsaSksQyhTKGEuc2hhcGUsaS5zaGFwZSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJTaGFwZSBtaXNtYXRjaCBpbiB2IGFuZCB4XCJ9KSk7dmFyIHU9T24oMSksYz11LnN1YihzKSxsPWkuc3ViKGEpLm11bChjKTtpZihvKXtDKG51bGwhPXIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJXaGVuIHVzaW5nIHplcm9EZWJpYXM6IHRydWUsIHN0ZXAgaXMgcmVxdWlyZWQuXCJ9KSk7dmFyIGg9Z24ocixcInN0ZXBcIixcIm1vdmluZ0F2ZXJhZ2VcIik7bD1sLmRpdih1LnN1YihObyhzLGgpKSl9cmV0dXJuIGEuYWRkKGwpfX0pO3ZhciBkaD1Bbih7c3RyaWRlZFNsaWNlXzpmdW5jdGlvbih0LGUsbixyLG8sYSxpLHMsdSl7aWYodm9pZCAwPT09byYmKG89MCksdm9pZCAwPT09YSYmKGE9MCksdm9pZCAwPT09aSYmKGk9MCksdm9pZCAwPT09cyYmKHM9MCksdm9pZCAwPT09dSYmKHU9MCksbnVsbD09ciYmKHI9bmV3IEFycmF5KGUubGVuZ3RoKSksMCE9PWkpdGhyb3cgbmV3IEVycm9yKFwiZWxsaXBzaXMgbWFzayBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTt2YXIgYz1nbih0LFwieFwiLFwic3RyaWRlZFNsaWNlXCIpLGw9S28ocyksaD1jLnNoYXBlLnNsaWNlKCk7bC5mb3JFYWNoKChmdW5jdGlvbih0KXtlW3RdPTAsblt0XT0xLGguc3BsaWNlKHQsMCwxKX0pKSxjPWMucmVzaGFwZShoKTtmb3IodmFyIGY9MDtmPGMucmFuaztmKyspZVtmXT1YbyhvLGUscixjLnNoYXBlLGYpLG5bZl09WW8oYSxuLHIsYy5zaGFwZSxmKSxyW2ZdPXJbZl18fDE7dmFyIGQ9S28odSk7ZC5mb3JFYWNoKChmdW5jdGlvbih0KXtuW3RdPWVbdF0rMSxyW3RdPTF9KSk7dmFyIHA9am8oZSxuLHIpLHY9cC5maWx0ZXIoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuLTE9PT1kLmluZGV4T2YoZSl9KSk7cmV0dXJuIHIuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiAxPT09dH0pKT9XbChjLGUscCkucmVzaGFwZSh2KTpMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zdHJpZGVkU2xpY2UoYyxlLG4scil9KSx7JHg6Y30pLnJlc2hhcGUodil9fSk7dmFyIHBoPUFuKHt0b3BrXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09ZSYmKGU9MSksdm9pZCAwPT09biYmKG49ITApO3ZhciByPWduKHQsXCJ4XCIsXCJ0b3BrXCIpO2lmKDA9PT1yLnJhbmspdGhyb3cgbmV3IEVycm9yKFwidG9waygpIGV4cGVjdHMgdGhlIGlucHV0IHRvIGJlIG9mIHJhbmsgMSBvciBoaWdoZXJcIik7dmFyIG89ci5zaGFwZVtyLnNoYXBlLmxlbmd0aC0xXTtpZihlPm8pdGhyb3cgbmV3IEVycm9yKFwiJ2snIHBhc3NlZCB0byB0b3BrKCkgbXVzdCBiZSA8PSB0aGUgbGFzdCBkaW1lbnNpb24gKFwiK28rXCIpIGJ1dCBnb3QgXCIrZSk7dmFyIGE9THQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQudG9wayhyLGUsbil9KSx7JHg6cn0pO3JldHVybnt2YWx1ZXM6YVswXSxpbmRpY2VzOmFbMV19fX0pO3ZhciB2aD1Bbih7c2NhdHRlck5EXzpmdW5jdGlvbih0LGUsbil7dmFyIHI9Z24odCxcImluZGljZXNcIixcInNjYXR0ZXJORFwiLFwiaW50MzJcIiksbz1nbihlLFwidXBkYXRlc1wiLFwic2NhdHRlck5EXCIpO3JldHVybiB6byhvLHIsbiksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2NhdHRlck5EKHIsbyxuKX0pLHtpbmRpY2VzOnIsdXBkYXRlczpvfSxudWxsLFwiU2NhdHRlck5kXCIse3NoYXBlOm59KX19KTt2YXIgZ2g9QW4oe2ZmdF86ZnVuY3Rpb24odCl7QyhcImNvbXBsZXg2NFwiPT09dC5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cIlRoZSBkdHlwZSBmb3IgdGYuc3BlY3RyYWwuZmZ0KCkgbXVzdCBiZSBjb21wbGV4NjQgYnV0IGdvdCBcIit0LmR0eXBlK1wiLlwifSkpO3ZhciBlPXQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV0sbj10LnNpemUvZSxyPXQuYXMyRChuLGUpO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5mZnQocil9KSx7aW5wdXQ6dH0pLnJlc2hhcGUodC5zaGFwZSl9fSksbWg9QW4oe2lmZnRfOmZ1bmN0aW9uKHQpe0MoXCJjb21wbGV4NjRcIj09PXQuZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHR5cGUgZm9yIHRmLnNwZWN0cmFsLmlmZnQoKSBtdXN0IGJlIGNvbXBsZXg2NCBidXQgZ290IFwiK3QuZHR5cGUrXCIuXCJ9KSk7dmFyIGU9dC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXSxuPXQuc2l6ZS9lLHI9dC5hczJEKG4sZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlmZnQocil9KSx7aW5wdXQ6dH0pLnJlc2hhcGUodC5zaGFwZSl9fSkseWg9QW4oe3JmZnRfOmZ1bmN0aW9uKHQsZSl7QyhcImZsb2F0MzJcIj09PXQuZHR5cGUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJUaGUgZHR5cGUgZm9yIHJmZnQoKSBtdXN0IGJlIHJlYWwgdmFsdWUgYnV0IGdvdCBcIit0LmR0eXBlfSkpO3ZhciBuLHI9dC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0xXSxvPXQuc2l6ZS9yO2lmKG51bGwhPWUmJmU8cil7dmFyIGE9dC5zaGFwZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiAwfSkpLGk9dC5zaGFwZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpO2lbdC5zaGFwZS5sZW5ndGgtMV09ZSxuPXQuc2xpY2UoYSxpKSxyPWV9ZWxzZSBpZihudWxsIT1lJiZlPnIpe3ZhciBzPXQuc2hhcGUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKTtzW3Quc2hhcGUubGVuZ3RoLTFdPWUtcixuPXQuY29uY2F0KEduKHMpLHQuc2hhcGUubGVuZ3RoLTEpLHI9ZX1lbHNlIG49dDt2YXIgdT1uLnplcm9zTGlrZSgpLGM9VG4obix1KS5hczJEKG8sciksbD1naChjKSxoPU1hdGguZmxvb3Ioci8yKSsxLGY9RG4obCksZD1ObihsKSxwPWYuc3BsaXQoW2gsci1oXSxmLnNoYXBlLmxlbmd0aC0xKSx2PWQuc3BsaXQoW2gsci1oXSxkLnNoYXBlLmxlbmd0aC0xKSxnPW4uc2hhcGUuc2xpY2UoKTtyZXR1cm4gZ1tuLnNoYXBlLmxlbmd0aC0xXT1oLFRuKHBbMF0sdlswXSkucmVzaGFwZShnKX19KSx4aD1Bbih7aXJmZnRfOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc2hhcGVbdC5zaGFwZS5sZW5ndGgtMV0sbj10LnNpemUvZTtpZihlPD0yKXt2YXIgcj10LmFzMkQobixlKSxvPW1oKHIpO3JldHVybiBEbihvKX12YXIgYT1bbiwyKihlLTEpXSxpPURuKHQpLmFzMkQobixlKSxzPU5uKHQpLmFzMkQobixlKSx1PWkuc2xpY2UoWzAsMV0sW24sZS0yXSkucmV2ZXJzZSgxKSxjPXMuc2xpY2UoWzAsMV0sW24sZS0yXSkucmV2ZXJzZSgxKS5tdWwoT24oLTEpKSxsPWkuY29uY2F0KHUsMSksaD1zLmNvbmNhdChjLDEpO3JldHVybiByPVRuKGwsaCkuYXMyRChhWzBdLGFbMV0pLG89bWgociksRG4obyl9fSksYmg9T2JqZWN0LmZyZWV6ZSh7ZmZ0OmdoLGlmZnQ6bWgscmZmdDp5aCxpcmZmdDp4aH0pO3ZhciB3aD1Bbih7c3BhcnNlVG9EZW5zZV86ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9MCk7dmFyIG89Z24odCxcInNwYXJzZUluZGljZXNcIixcInNwYXJzZVRvRGVuc2VcIixcImludDMyXCIpLGE9Z24oZSxcInNwYXJzZVZhbHVlc1wiLFwic3BhcnNlVG9EZW5zZVwiKSxpPWduKHIsXCJkZWZhdWx0VmFsdWVcIixcInNwYXJzZVRvRGVuc2VcIixhLmR0eXBlKTtyZXR1cm4gZnVuY3Rpb24odCxlLG4scil7aWYoXCJpbnQzMlwiIT09dC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJ0Zi5zcGFyc2VUb0RlbnNlKCkgZXhwZWN0cyB0aGUgaW5kaWNlcyB0byBiZSBpbnQzMiB0eXBlLCBidXQgdGhlIGR0eXBlIHdhcyBcIit0LmR0eXBlK1wiLlwiKTtpZih0LnJhbms+Mil0aHJvdyBuZXcgRXJyb3IoXCJzcGFyc2VJbmRpY2VzIHNob3VsZCBiZSBhIHNjYWxhciwgdmVjdG9yLCBvciBtYXRyaXgsIGJ1dCBnb3Qgc2hhcGUgXCIrdC5zaGFwZStcIi5cIik7dmFyIG89dC5yYW5rPjA/dC5zaGFwZVswXToxLGE9dC5yYW5rPjE/dC5zaGFwZVsxXToxO2lmKG4ubGVuZ3RoIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXRTaGFwZSBoYXMgaW5jb3JyZWN0IG51bWJlciBvZiBlbGVtZW50czosIFwiK24ubGVuZ3RoK1wiLCBzaG91bGQgYmU6IFwiK2ErXCIuXCIpO3ZhciBpPWUuc2l6ZTtpZigwIT09ZS5yYW5rJiYoMSE9PWUucmFua3x8aSE9PW8pKXRocm93IG5ldyBFcnJvcihcInNwYXJzZVZhbHVlcyBoYXMgaW5jb3JyZWN0IHNoYXBlIFwiK2Uuc2hhcGUrXCIsIHNob3VsZCBiZSBbXSBvciBbXCIrbytcIl1cIik7aWYoZS5kdHlwZSE9PXIuZHR5cGUpdGhyb3cgbmV3IEVycm9yKFwic3BhcnNlVmFsdWVzLmR0eXBlIG11c3QgbWF0Y2ggZGVmYXVsdFZhbHVlcy5kdHlwZVwiKX0obyxhLG4saSksTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BhcnNlVG9EZW5zZShvLGEsbixpKX0pLHskc3BhcnNlSW5kaWNlczpvLCRzcGFyc2VWYWx1ZXM6YSwkZGVmYXVsdFZhbHVlOml9KX19KTt2YXIgQ2g9QW4oe2dhdGhlck5EXzpmdW5jdGlvbih0LGUpe3ZhciBuPWduKGUsXCJpbmRpY2VzXCIsXCJnYXRoZXJORFwiLFwiaW50MzJcIikscj1nbih0LFwieFwiLFwiZ2F0aGVyTkRcIik7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmdhdGhlck5EKHIsbil9KSx7eDpyLGluZGljZXM6bn0sbnVsbCxcIkdhdGhlck5kXCIpfX0pO3ZhciBFaD1Bbih7ZGlhZ186ZnVuY3Rpb24odCl7dmFyIGU9Z24odCxcInhcIixcImRpYWdcIikuZmxhdHRlbigpLG49dC5zaGFwZS5jb25jYXQodC5zaGFwZSk7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmRpYWcoZSl9KSx7JHg6ZX0pLnJlc2hhcGUobil9fSk7dmFyIFJoPUFuKHtkcm9wb3V0XzpmdW5jdGlvbih0LGUsbixyKXt2YXIgbz1nbih0LFwieFwiLFwiZHJvcG91dFwiKTtpZihDKFwiZmxvYXQzMlwiPT09by5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cInggaGFzIHRvIGJlIGEgZmxvYXRpbmcgcG9pbnQgdGVuc29yIHNpbmNlIGl0J3MgZ29pbmcgdG8gYmUgc2NhbGVkLCBidXQgZ290IGEgXCIrby5kdHlwZStcIiB0ZW5zb3IgaW5zdGVhZC5cIn0pKSxDKGU+PTAmJmU8MSwoZnVuY3Rpb24oKXtyZXR1cm5cInJhdGUgbXVzdCBiZSBhIGZsb2F0IGluIHRoZSByYW5nZSBbMCwgMSksIGJ1dCBnb3QgXCIrZStcIi5cIn0pKSwwPT09ZSlyZXR1cm4gdCBpbnN0YW5jZW9mIHd0P28uY2xvbmUoKTpvO3ZhciBhPWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09ZSlyZXR1cm4gdC5zaGFwZS5zbGljZSgpO2lmKFModC5zaGFwZSxlKSlyZXR1cm4gZTtpZih0LnNoYXBlLmxlbmd0aD09PWUubGVuZ3RoKXtmb3IodmFyIG49W10scj0wO3I8dC5zaGFwZS5sZW5ndGg7cisrKW51bGw9PWVbcl0mJm51bGwhPXQuc2hhcGVbcl0/bi5wdXNoKHQuc2hhcGVbcl0pOm4ucHVzaChlW3JdKTtyZXR1cm4gbn1yZXR1cm4gZX0obyxuKSxpPTEtZSxzPXpjKGEsMCwxLFwiZmxvYXQzMlwiLHIpLmFkZChpKS5mbG9vcigpLmRpdihpKTtyZXR1cm4gby5tdWwocyl9fSk7ZnVuY3Rpb24gSWgodCxlLG4pe2Zvcih2YXIgcj0xLXQlMixvPW5ldyBGbG9hdDMyQXJyYXkodCksYT0wO2E8dDsrK2Epe3ZhciBpPTIqTWF0aC5QSSphLyh0K3ItMSk7b1thXT1lLW4qTWF0aC5jb3MoaSl9cmV0dXJuIE1uKG8sXCJmbG9hdDMyXCIpfXZhciBraD1Bbih7aGFubldpbmRvd186ZnVuY3Rpb24odCl7cmV0dXJuIEloKHQsLjUsLjUpfX0pLFNoPUFuKHtoYW1taW5nV2luZG93XzpmdW5jdGlvbih0KXtyZXR1cm4gSWgodCwuNTQsLjQ2KX19KSxBaD1Bbih7ZnJhbWVfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9ITEpLHZvaWQgMD09PW8mJihvPTApO2Zvcih2YXIgYT0wLGk9W107YStlPD10LnNpemU7KWkucHVzaChXbCh0LGEsZSkpLGErPW47aWYocilmb3IoO2E8dC5zaXplOyl7dmFyIHM9YStlLXQuc2l6ZSx1PVluKFtXbCh0LGEsZS1zKSxIbihbc10sbyldKTtpLnB1c2godSksYSs9bn1yZXR1cm4gMD09PWkubGVuZ3RoP0JuKFtdLFswLGVdKTpZbihpKS5hczJEKGkubGVuZ3RoLGUpfX0pLFRoPUFuKHtzdGZ0XzpmdW5jdGlvbih0LGUsbixyLG8pe3ZhciBhO3ZvaWQgMD09PW8mJihvPWtoKSxudWxsPT1yJiYoYT1lLHI9TWF0aC5mbG9vcihNYXRoLnBvdygyLE1hdGguY2VpbChNYXRoLmxvZyhhKS9NYXRoLmxvZygyKSkpKSk7Zm9yKHZhciBpPUFoKHQsZSxuKSxzPVRvKGksbyhlKSksdT1bXSxjPTA7YzxpLnNoYXBlWzBdO2MrKyl1LnB1c2goeWgocy5zbGljZShbYywwXSxbMSxlXSkscikpO3JldHVybiBZbih1KX19KSxEaD1PYmplY3QuZnJlZXplKHtoYW5uV2luZG93OmtoLGhhbW1pbmdXaW5kb3c6U2gsZnJhbWU6QWgsc3RmdDpUaH0pO3ZhciBOaCxGaD1mdW5jdGlvbih0LGUsbyl7cmV0dXJuIHZvaWQgMD09PW8mJihvPTEpLG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBuLGEsaSxzLHUsYyxsLGgsZixkLHAsdixnLG07cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj1nbih0LFwicHJlZGljdGlvbnNcIixcImluVG9wS1wiKSxhPWduKGUsXCJ0YXJnZXRzXCIsXCJpblRvcEtcIiksQyhuLnJhbms+MSwoZnVuY3Rpb24oKXtyZXR1cm5cImluVG9wSygpIGV4cGVjdHMgdGhlIHByZWRpY3Rpb25zIHRvIGJlIG9mIHJhbmsgMiBvciBoaWdoZXIsIGJ1dCBnb3QgXCIrbi5yYW5rfSkpLEMobi5yYW5rLTE9PT1hLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJwcmVkaWN0aW9ucyByYW5rIHNob3VsZCBiZSAxIGxhcmdlciB0aGFuIHRhcmdldHMgcmFuaywgYnV0IGdvdCBwcmVkaWN0aW9ucyByYW5rIFwiK24ucmFuaytcIiBhbmQgdGFyZ2V0cyByYW5rIFwiK2EucmFua30pKSxFKG4uc2hhcGUuc2xpY2UoMCxuLnNoYXBlLmxlbmd0aC0xKSxhLnNoYXBlLFwicHJlZGljdGlvbnMncyBzaGFwZSBzaG91bGQgYmUgYWxpZ24gd2l0aCB0aGUgdGFyZ2V0cycgc2hhcGUsIGV4Y2VwdCB0aGUgbGFzdCBkaW1lbnNpb24uXCIpLGk9bi5zaGFwZVtuLnNoYXBlLmxlbmd0aC0xXSxDKG8+MCYmbzw9aSwoZnVuY3Rpb24oKXtyZXR1cm5cIidrJyBwYXNzZWQgdG8gaW5Ub3BLKCkgbXVzdCBiZSA+IDAgJiYgPD0gdGhlIHByZWRpY3Rpb25zIGxhc3QgZGltZW5zaW9uIChcIitpK1wiKSwgYnV0IGdvdCBcIitvfSkpLFs0LG4uZGF0YSgpXTtjYXNlIDE6cmV0dXJuIHM9ci5zZW50KCksWzQsYS5kYXRhKCldO2Nhc2UgMjpmb3IodT1yLnNlbnQoKSxjPVtzLmxlbmd0aC9pLGldLGg9Y1sxXSxmPUIoXCJib29sXCIsbD1jWzBdKSxkPTA7ZDxsO2QrKyl7Zm9yKHA9ZCpoLHY9cy5zdWJhcnJheShwLHAraCksZz1bXSxtPTA7bTx2Lmxlbmd0aDttKyspZy5wdXNoKHt2YWx1ZTp2W21dLGluZGV4Om19KTtmb3IoZy5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiBlLnZhbHVlLXQudmFsdWV9KSksZltkXT0wLG09MDttPG87bSsrKWlmKGdbbV0uaW5kZXg9PT11W2RdKXtmW2RdPTE7YnJlYWt9fXJldHVybiB0IT09biYmbi5kaXNwb3NlKCksZSE9PWEmJmEuZGlzcG9zZSgpLFsyLEZuKGYsYS5zaGFwZSxcImJvb2xcIildfX0pKX0pKX07IWZ1bmN0aW9uKHQpe3RbdC5OT05FPTBdPVwiTk9ORVwiLHRbdC5NRUFOPTFdPVwiTUVBTlwiLHRbdC5TVU09Ml09XCJTVU1cIix0W3QuU1VNX0JZX05PTlpFUk9fV0VJR0hUUz0zXT1cIlNVTV9CWV9OT05aRVJPX1dFSUdIVFNcIn0oTmh8fChOaD17fSkpO3ZhciBfaD1Bbih7YWJzb2x1dGVEaWZmZXJlbmNlXzpmdW5jdGlvbih0LGUsbixyKXt2b2lkIDA9PT1yJiYocj1OaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgbz1nbih0LFwibGFiZWxzXCIsXCJhYnNvbHV0ZURpZmZlcmVuY2VcIiksYT1nbihlLFwicHJlZGljdGlvbnNcIixcImFic29sdXRlRGlmZmVyZW5jZVwiKSxpPW51bGw7bnVsbCE9biYmKGk9Z24obixcIndlaWdodHNcIixcImFic29sdXRlRGlmZmVyZW5jZVwiKSksRShvLnNoYXBlLGEuc2hhcGUsXCJFcnJvciBpbiBhYnNvbHV0ZURpZmZlcmVuY2U6IFwiKTt2YXIgcz1vLnN1YihhKS5hYnMoKTtyZXR1cm4gT2gocyxpLHIpfX0pLE9oPUFuKHtjb21wdXRlV2VpZ2h0ZWRMb3NzXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49TmguU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIHI9Z24odCxcImxvc3Nlc1wiLFwiY29tcHV0ZVdlaWdodGVkTG9zc1wiKSxvPW51bGw7bnVsbCE9ZSYmKG89Z24oZSxcIndlaWdodHNcIixcImNvbXB1dGVXZWlnaHRlZExvc3NcIikpO3ZhciBhPW51bGw9PW8/cjpyLm11bChvKTtpZihuPT09TmguTk9ORSlyZXR1cm4gYTtpZihuPT09TmguU1VNKXJldHVybiBhLnN1bSgpO2lmKG49PT1OaC5NRUFOKXtpZihudWxsPT1vKXJldHVybiBhLm1lYW4oKTt2YXIgaT1yLnNpemUvby5zaXplLHM9YS5zdW0oKS5kaXYoby5zdW0oKSk7cmV0dXJuIGk+MT9zLmRpdihPbihpKSk6c31pZihuPT09TmguU1VNX0JZX05PTlpFUk9fV0VJR0hUUyl7aWYobnVsbD09bylyZXR1cm4gYS5zdW0oKS5kaXYoT24oci5zaXplKSk7dmFyIHU9by5tdWwoem4oci5zaGFwZSkpLm5vdEVxdWFsKE9uKDApKS5zdW0oKS50b0Zsb2F0KCk7cmV0dXJuIGEuc3VtKCkuZGl2KHUpfXRocm93IEVycm9yKFwiVW5rbm93biByZWR1Y3Rpb246IFwiK24pfX0pLE1oPUFuKHtjb3NpbmVEaXN0YW5jZV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1vJiYobz1OaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT1nbih0LFwibGFiZWxzXCIsXCJjb3NpbmVEaXN0YW5jZVwiKSxpPWduKGUsXCJwcmVkaWN0aW9uc1wiLFwiY29zaW5lRGlzdGFuY2VcIikscz1udWxsO251bGwhPXImJihzPWduKHIsXCJ3ZWlnaHRzXCIsXCJjb3NpbmVEaXN0YW5jZVwiKSksRShhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBjb3NpbmVEaXN0YW5jZTogXCIpO3ZhciB1PU9uKDEpLnN1YihhLm11bChpKS5zdW0obiwhMCkpO3JldHVybiBPaCh1LHMsbyl9fSksQmg9QW4oe2hpbmdlTG9zc186ZnVuY3Rpb24odCxlLG4scil7dm9pZCAwPT09ciYmKHI9TmguU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIG89Z24odCxcImxhYmVsc1wiLFwiaGluZ2VMb3NzXCIpLGE9Z24oZSxcInByZWRpY3Rpb25zXCIsXCJoaW5nZUxvc3NcIiksaT1udWxsO251bGwhPW4mJihpPWduKG4sXCJ3ZWlnaHRzXCIsXCJoaW5nZUxvc3NcIikpLEUoby5zaGFwZSxhLnNoYXBlLFwiRXJyb3IgaW4gaGluZ2VMb3NzOiBcIik7dmFyIHM9T24oMSk7bz1PbigyKS5tdWwobykuc3ViKHMpO3ZhciB1PXMuc3ViKG8ubXVsKGEpKS5yZWx1KCk7cmV0dXJuIE9oKHUsaSxyKX19KSxQaD1Bbih7aHViZXJMb3NzXzpmdW5jdGlvbih0LGUsbixyLG8pe3ZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PW8mJihvPU5oLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBhPWduKHQsXCJsYWJlbHNcIixcImh1YmVyTG9zc1wiKSxpPWduKGUsXCJwcmVkaWN0aW9uc1wiLFwiaHViZXJMb3NzXCIpLHM9bnVsbDtudWxsIT1uJiYocz1nbihuLFwid2VpZ2h0c1wiLFwiaHViZXJMb3NzXCIpKSxFKGEuc2hhcGUsaS5zaGFwZSxcIkVycm9yIGluIGh1YmVyTG9zczogXCIpO3ZhciB1PU9uKHIpLGM9aS5zdWIoYSkuYWJzKCksbD1JbyhjLHUpLGg9Yy5zdWIobCksZj1PbiguNSkubXVsKGwuc3F1YXJlKCkpLmFkZCh1Lm11bChoKSk7cmV0dXJuIE9oKGYscyxvKX19KSxMaD1Bbih7bG9nTG9zc186ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0xZS03KSx2b2lkIDA9PT1vJiYobz1OaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT1nbih0LFwibGFiZWxzXCIsXCJsb2dMb3NzXCIpLGk9Z24oZSxcInByZWRpY3Rpb25zXCIsXCJsb2dMb3NzXCIpLHM9bnVsbDtudWxsIT1uJiYocz1nbihuLFwid2VpZ2h0c1wiLFwibG9nTG9zc1wiKSksRShhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBsb2dMb3NzOiBcIik7dmFyIHU9T24oMSksYz1PbihyKSxsPWEubXVsKGkuYWRkKGMpLmxvZygpKS5uZWcoKS5zdWIodS5zdWIoYSkubXVsKHUuc3ViKGkpLmFkZChjKS5sb2coKSkpO3JldHVybiBPaChsLHMsbyl9fSksV2g9QW4oe21lYW5TcXVhcmVkRXJyb3JfOmZ1bmN0aW9uKHQsZSxuLHIpe3ZvaWQgMD09PXImJihyPU5oLlNVTV9CWV9OT05aRVJPX1dFSUdIVFMpO3ZhciBvPWduKHQsXCJsYWJlbHNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIiksYT1nbihlLFwicHJlZGljdGlvbnNcIixcIm1lYW5TcXVhcmVkRXJyb3JcIiksaT1udWxsO251bGwhPW4mJihpPWduKG4sXCJ3ZWlnaHRzXCIsXCJtZWFuU3F1YXJlZEVycm9yXCIpKSxFKG8uc2hhcGUsYS5zaGFwZSxcIkVycm9yIGluIG1lYW5TcXVhcmVkRXJyb3I6IFwiKTt2YXIgcz1vLnNxdWFyZWREaWZmZXJlbmNlKGEpO3JldHVybiBPaChzLGkscil9fSksVWg9QW4oe3NpZ21vaWRDcm9zc0VudHJvcHlfOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09byYmKG89TmguU1VNX0JZX05PTlpFUk9fV0VJR0hUUyk7dmFyIGE9Z24odCxcIm11bHRpQ2xhc3NMYWJlbHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlcIiksaT1nbihlLFwibG9naXRzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5XCIpLHM9bnVsbDtpZihudWxsIT1uJiYocz1nbihuLFwid2VpZ2h0c1wiLFwic2lnbW9pZENyb3NzRW50cm9weVwiKSksRShhLnNoYXBlLGkuc2hhcGUsXCJFcnJvciBpbiBzaWdtb2lkQ3Jvc3NFbnRyb3B5OiBcIikscj4wKXt2YXIgdT1PbihyKSxjPU9uKDEpLGw9T24oLjUpO2E9YS5tdWwoYy5zdWIodSkpLmFkZChsLm11bCh1KSl9dmFyIGg9ZnVuY3Rpb24odCxlKXt2YXIgbj1nbih0LFwibGFiZWxzXCIsXCJzaWdtb2lkQ3Jvc3NFbnRyb3B5V2l0aExvZ2l0c1wiKSxyPWduKGUsXCJsb2dpdHNcIixcInNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzXCIpO0Uobi5zaGFwZSxyLnNoYXBlLFwiRXJyb3IgaW4gc2lnbW9pZENyb3NzRW50cm9weVdpdGhMb2dpdHM6IFwiKTt2YXIgbz1yLnJlbHUoKSxhPXIubXVsKG4pLGk9ci5hYnMoKS5uZWcoKS5leHAoKS5sb2cxcCgpO3JldHVybiBvLnN1YihhKS5hZGQoaSl9KGEsaSk7cmV0dXJuIE9oKGgscyxvKX19KSxWaD1Bbih7c29mdG1heENyb3NzRW50cm9weV86ZnVuY3Rpb24odCxlLG4scixvKXt2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz1OaC5TVU1fQllfTk9OWkVST19XRUlHSFRTKTt2YXIgYT1nbih0LFwib25laG90TGFiZWxzXCIsXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIpLGk9Z24oZSxcImxvZ2l0c1wiLFwic29mdG1heENyb3NzRW50cm9weVwiKSxzPW51bGw7aWYobnVsbCE9biYmKHM9Z24obixcIndlaWdodHNcIixcInNvZnRtYXhDcm9zc0VudHJvcHlcIikpLEUoYS5zaGFwZSxpLnNoYXBlLFwiRXJyb3IgaW4gc29mdG1heENyb3NzRW50cm9weTogXCIpLHI+MCl7dmFyIHU9T24ociksYz1PbigxKSxsPU9uKGEuc2hhcGVbMV0pO2E9YS5tdWwoYy5zdWIodSkpLmFkZCh1LmRpdihsKSl9dmFyIGg9ZnVuY3Rpb24odCxlLG4pe2lmKHZvaWQgMD09PW4mJihuPS0xKSwtMT09PW4mJihuPWUucmFuay0xKSxuIT09ZS5yYW5rLTEpdGhyb3cgRXJyb3IoXCJTb2Z0bWF4IGNyb3NzIGVudHJvcHkgYWxvbmcgYSBub24tbGFzdCBkaW1lbnNpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQuIExhYmVscyAvIGxvZ2l0cyB3YXMgcmFuayBcIitlLnJhbmsrXCIgYW5kIGRpbSB3YXMgXCIrbik7cmV0dXJuIG9hKChmdW5jdGlvbih0LGUscil7dmFyIG89ZS5sb2dTdW1FeHAoW25dLCEwKSxhPWUudG9GbG9hdCgpLnN1YihvKTtyKFt0LGFdKTtyZXR1cm57dmFsdWU6YS5tdWwodCkubmVnKCkuc3VtKFtuXSksZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlKXt2YXIgcj1lWzBdLG89ZVsxXSxhPXduKHQuc2hhcGUsW25dKTtyZXR1cm5bdC5yZXNoYXBlKGEpLm11bChyLnRvRmxvYXQoKS5zdWIoby5leHAoKSkpLHQucmVzaGFwZShhKS5tdWwoby5leHAoKS5zdWIoci50b0Zsb2F0KCkpKV19fX0pKSh0LGUpfShhLGkpO3JldHVybiBPaChoLHMsbyl9fSksemg9T2JqZWN0LmZyZWV6ZSh7Z2V0IFJlZHVjdGlvbigpe3JldHVybiBOaH0sYWJzb2x1dGVEaWZmZXJlbmNlOl9oLGNvbXB1dGVXZWlnaHRlZExvc3M6T2gsY29zaW5lRGlzdGFuY2U6TWgsaGluZ2VMb3NzOkJoLGh1YmVyTG9zczpQaCxsb2dMb3NzOkxoLG1lYW5TcXVhcmVkRXJyb3I6V2gsc2lnbW9pZENyb3NzRW50cm9weTpVaCxzb2Z0bWF4Q3Jvc3NFbnRyb3B5OlZofSk7ZnVuY3Rpb24gR2godCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLEx0LnRpZHkoKGZ1bmN0aW9uKCl7aWYoMiE9PXQuc2hhcGUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInFyMmQoKSByZXF1aXJlcyBhIDJEIFRlbnNvciwgYnV0IGdvdCBhIFwiK3Quc2hhcGUubGVuZ3RoK1wiRCBUZW5zb3IuXCIpO2Zvcih2YXIgbj10LnNoYXBlWzBdLHI9dC5zaGFwZVsxXSxvPUNjKG4pLGE9dC5jbG9uZSgpLGk9Qm4oW1sxXV0sWzEsMV0pLHM9aS5jbG9uZSgpLHU9bj49cj9yOm4sYz1mdW5jdGlvbih0KXt2YXIgZSx1PWEsYz1zLGw9bztlPUx0LnRpZHkoKGZ1bmN0aW9uKCl7dmFyIGU9YS5zbGljZShbdCx0XSxbbi10LDFdKSx1PWUubm9ybSgpLGM9YS5zbGljZShbdCx0XSxbMSwxXSksbD1CbihbWy0xXV0pLndoZXJlKGMuZ3JlYXRlcigwKSxCbihbWzFdXSkpLGg9Yy5zdWIobC5tdWwodSkpLGY9ZS5kaXYoaCk7cz0xPT09Zi5zaGFwZVswXT9pLmNsb25lKCk6aS5jb25jYXQoZi5zbGljZShbMSwwXSxbZi5zaGFwZVswXS0xLGYuc2hhcGVbMV1dKSwwKTt2YXIgZD1sLm1hdE11bChoKS5kaXYodSkubmVnKCkscD1hLnNsaWNlKFt0LDBdLFtuLXQscl0pLHY9ZC5tdWwocyksZz1zLnRyYW5zcG9zZSgpO2lmKDA9PT10KWE9cC5zdWIodi5tYXRNdWwoZy5tYXRNdWwocCkpKTtlbHNle3ZhciBtPXAuc3ViKHYubWF0TXVsKGcubWF0TXVsKHApKSk7YT1hLnNsaWNlKFswLDBdLFt0LHJdKS5jb25jYXQobSwwKX12YXIgeT12LnRyYW5zcG9zZSgpLHg9by5zbGljZShbMCx0XSxbbixvLnNoYXBlWzFdLXRdKTtpZigwPT09dClvPXguc3ViKHgubWF0TXVsKHMpLm1hdE11bCh5KSk7ZWxzZXt2YXIgYj14LnN1Yih4Lm1hdE11bChzKS5tYXRNdWwoeSkpO289by5zbGljZShbMCwwXSxbbix0XSkuY29uY2F0KGIsMSl9cmV0dXJuW3MsYSxvXX0pKSxzPWVbMF0sYT1lWzFdLG89ZVsyXSx0bihbdSxjLGxdKX0sbD0wO2w8dTsrK2wpYyhsKTtyZXR1cm4hZSYmbj5yJiYobz1vLnNsaWNlKFswLDBdLFtuLHJdKSxhPWEuc2xpY2UoWzAsMF0sW3Iscl0pKSxbbyxhXX0pKX12YXIgSGg9QW4oe2JhbmRQYXJ0XzpmdW5jdGlvbih0LGUsbil7aWYoZSUxIT0wKXRocm93IG5ldyBFcnJvcihcImJhbmRQYXJ0KCk6IG51bUxvd2VyIG11c3QgYmUgYW4gaW50ZWdlciwgZ290IFwiK2UrXCIuXCIpO2lmKG4lMSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJiYW5kUGFydCgpOiBudW1VcHBlciBtdXN0IGJlIGFuIGludGVnZXIsIGdvdCBcIituK1wiLlwiKTt2YXIgcj1nbih0LFwiYVwiLFwiYmFuZFBhcnRcIik7aWYoci5yYW5rPDIpdGhyb3cgbmV3IEVycm9yKFwiYmFuZFBhcnQoKTogUmFuayBtdXN0IGJlIGF0IGxlYXN0IDIsIGdvdCBcIityLnJhbmsrXCIuXCIpO3ZhciBvPXIuc2hhcGUsYT1yLnNoYXBlLnNsaWNlKC0yKSxpPWFbMF0scz1hWzFdO2lmKCEoZTw9aSkpdGhyb3cgbmV3IEVycm9yKFwiYmFuZFBhcnQoKTogbnVtTG93ZXIgKFwiK2UrXCIpIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHJvd3MgKFwiK2krXCIpLlwiKTtpZighKG48PXMpKXRocm93IG5ldyBFcnJvcihcImJhbmRQYXJ0KCk6IG51bVVwcGVyIChcIituK1wiKSBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBjb2x1bW5zIChcIitzK1wiKS5cIik7ZTwwJiYoZT1pKSxuPDAmJihuPXMpO3ZhciB1PUtuKDAsaSwxLFwiaW50MzJcIikucmVzaGFwZShbLTEsMV0pLGM9S24oMCxzLDEsXCJpbnQzMlwiKSxsPU9vKHUsYyksaD1wYyhsLmxlc3NFcXVhbChPbigrZSxcImludDMyXCIpKSxsLmdyZWF0ZXJFcXVhbChPbigtbixcImludDMyXCIpKSksZj1HbihbaSxzXSxyLmR0eXBlKTtyZXR1cm4gaHIoZnIoci5yZXNoYXBlKFstMSxpLHNdKSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4geWMoaCx0LGYpfSkpKS5yZXNoYXBlKG8pfX0pLHFoPUFuKHtncmFtU2NobWlkdF86ZnVuY3Rpb24odCl7dmFyIGU7aWYoQXJyYXkuaXNBcnJheSh0KSl7ZT0hMSxDKG51bGwhPXQmJnQubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJHcmFtLVNjaG1pZHQgcHJvY2VzczogaW5wdXQgbXVzdCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBlbXB0eVwifSkpO2Zvcih2YXIgbj10WzBdLnNoYXBlWzBdLHI9ZnVuY3Rpb24oZSl7Qyh0W2VdLnNoYXBlWzBdPT09biwoZnVuY3Rpb24oKXtyZXR1cm5cIkdyYW0tU2NobWlkdDogTm9uLXVuaXF1ZSBsZW5ndGhzIGZvdW5kIGluIHRoZSBpbnB1dCB2ZWN0b3JzOiAoXCIrdFtlXS5zaGFwZVswXStcIiB2cy4gXCIrbitcIilcIn0pKX0sbz0xO288dC5sZW5ndGg7KytvKXIobyl9ZWxzZSBlPSEwLHQ9dHIodCx0LnNoYXBlWzBdLDApLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGxyKHQsWzBdKX0pKTtDKHQubGVuZ3RoPD10WzBdLnNoYXBlWzBdLChmdW5jdGlvbigpe3JldHVyblwiR3JhbS1TY2htaWR0OiBOdW1iZXIgb2YgdmVjdG9ycyAoXCIrdC5sZW5ndGgrXCIpIGV4Y2VlZHMgbnVtYmVyIG9mIGRpbWVuc2lvbnMgKFwiK3RbMF0uc2hhcGVbMF0rXCIpLlwifSkpO3ZhciBhPVtdLGk9dCxzPWZ1bmN0aW9uKHQpe2EucHVzaChMdC50aWR5KChmdW5jdGlvbigpe3ZhciBlPWlbdF07aWYodD4wKWZvcih2YXIgbj0wO248dDsrK24pe3ZhciByPXRoKGFbbl0ubXVsU3RyaWN0KGUpKS5tdWwoYVtuXSk7ZT1lLnN1YihyKX1yZXR1cm4gZS5kaXYoY2goZSxcImV1Y2xpZGVhblwiKSl9KSkpfTtmb3Iobz0wO288dC5sZW5ndGg7KytvKXMobyk7cmV0dXJuIGU/aHIoYSwwKTphfX0pLEtoPUFuKHtxcl86ZnVuY3Rpb24odCxlKXtpZih2b2lkIDA9PT1lJiYoZT0hMSksdC5yYW5rPDIpdGhyb3cgbmV3IEVycm9yKFwicXIoKSByZXF1aXJlcyBpbnB1dCB0ZW5zb3IgdG8gaGF2ZSBhIHJhbmsgPj0gMiwgYnV0IGdvdCByYW5rIFwiK3QucmFuayk7aWYoMj09PXQucmFuaylyZXR1cm4gR2godCxlKTt2YXIgbj10LnNoYXBlLnNsaWNlKDAsdC5zaGFwZS5sZW5ndGgtMikucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSkscj1mcih0LnJlc2hhcGUoW24sdC5zaGFwZVt0LnNoYXBlLmxlbmd0aC0yXSx0LnNoYXBlW3Quc2hhcGUubGVuZ3RoLTFdXSksMCksbz1bXSxhPVtdO3JldHVybiByLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBuPUdoKHQsZSkscj1uWzBdLGk9blsxXTtvLnB1c2gociksYS5wdXNoKGkpfSkpLFtocihvLDApLnJlc2hhcGUodC5zaGFwZSksaHIoYSwwKS5yZXNoYXBlKHQuc2hhcGUpXX19KSxqaD1PYmplY3QuZnJlZXplKHtiYW5kUGFydDpIaCxncmFtU2NobWlkdDpxaCxxcjpLaH0pO2Z1bmN0aW9uIFhoKHQsZSxuLHIsbyxhKXtudWxsPT1yJiYocj0uNSksbnVsbD09byYmKG89TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSxudWxsPT1hJiYoYT0wKTt2YXIgaT10LnNoYXBlWzBdO3JldHVybiBuPU1hdGgubWluKG4saSksQygwPD1yJiZyPD0xLChmdW5jdGlvbigpe3JldHVyblwiaW91VGhyZXNob2xkIG11c3QgYmUgaW4gWzAsIDFdLCBidXQgd2FzICdcIityK1wiJ1wifSkpLEMoMj09PXQucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cImJveGVzIG11c3QgYmUgYSAyRCB0ZW5zb3IsIGJ1dCB3YXMgb2YgcmFuayAnXCIrdC5yYW5rK1wiJ1wifSkpLEMoND09PXQuc2hhcGVbMV0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJib3hlcyBtdXN0IGhhdmUgNCBjb2x1bW5zLCBidXQgMm5kIGRpbWVuc2lvbiB3YXMgXCIrdC5zaGFwZVsxXX0pKSxDKDE9PT1lLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJzY29yZXMgbXVzdCBiZSBhIDFEIHRlbnNvclwifSkpLEMoZS5zaGFwZVswXT09PWksKGZ1bmN0aW9uKCl7cmV0dXJuXCJzY29yZXMgaGFzIGluY29tcGF0aWJsZSBzaGFwZSB3aXRoIGJveGVzLiBFeHBlY3RlZCBcIitpK1wiLCBidXQgd2FzIFwiK2Uuc2hhcGVbMF19KSksQygwPD1hJiZhPD0xLChmdW5jdGlvbigpe3JldHVyblwic29mdE5tc1NpZ21hIG11c3QgYmUgaW4gWzAsIDFdLCBidXQgd2FzICdcIithK1wiJ1wifSkpLHttYXhPdXRwdXRTaXplOm4saW91VGhyZXNob2xkOnIsc2NvcmVUaHJlc2hvbGQ6byxzb2Z0Tm1zU2lnbWE6YX19dmFyIFloPUFuKHtyZXNpemVCaWxpbmVhcl86ZnVuY3Rpb24odCxlLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgcj1nbih0LFwiaW1hZ2VzXCIsXCJyZXNpemVCaWxpbmVhclwiKTtDKDM9PT1yLnJhbmt8fDQ9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjogeCBtdXN0IGJlIHJhbmsgMyBvciA0LCBidXQgZ290IHJhbmsgXCIrci5yYW5rK1wiLlwifSkpLEMoMj09PWUubGVuZ3RoLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXI6IG5ldyBzaGFwZSBtdXN0IDJELCBidXQgZ290IHNoYXBlIFwiK2UrXCIuXCJ9KSk7dmFyIG89cixhPSExOzM9PT1yLnJhbmsmJihhPSEwLG89ci5hczREKDEsci5zaGFwZVswXSxyLnNoYXBlWzFdLHIuc2hhcGVbMl0pKTt2YXIgaT1lWzBdLHM9ZVsxXSx1PUx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUoW29dKSx0LnJlc2l6ZUJpbGluZWFyKG8saSxzLG4pfSkse3g6b30sKGZ1bmN0aW9uKHQsZSl7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gTHQucnVuS2VybmVsRnVuYygoZnVuY3Rpb24ocil7cmV0dXJuIHIucmVzaXplQmlsaW5lYXJCYWNrcHJvcCh0LGVbMF0sbil9KSx7fSl9fX0pLFwiUmVzaXplQmlsaW5lYXJcIix7YWxpZ25Db3JuZXJzOm4sbmV3SGVpZ2h0OmksbmV3V2lkdGg6c30pO3JldHVybiBhP3UuYXMzRCh1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXSk6dX19KSwkaD1Bbih7cmVzaXplTmVhcmVzdE5laWdoYm9yXzpmdW5jdGlvbih0LGUsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciByPWduKHQsXCJpbWFnZXNcIixcInJlc2l6ZU5lYXJlc3ROZWlnaGJvclwiKTtDKDM9PT1yLnJhbmt8fDQ9PT1yLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiByZXNpemVOZWFyZXN0TmVpZ2hib3I6IHggbXVzdCBiZSByYW5rIDMgb3IgNCwgYnV0IGdvdCByYW5rIFwiK3IucmFuaytcIi5cIn0pKSxDKDI9PT1lLmxlbmd0aCwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIHJlc2l6ZU5lYXJlc3ROZWlnaGJvcjogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgXCIrZStcIi5cIn0pKSxDKFwiZmxvYXQzMlwiPT09ci5kdHlwZXx8XCJpbnQzMlwiPT09ci5kdHlwZSwoZnVuY3Rpb24oKXtyZXR1cm5cImBpbWFnZXNgIG11c3QgaGF2ZSBgaW50MzJgIG9yIGBmbG9hdDMyYCBhcyBkdHlwZVwifSkpO3ZhciBvPXIsYT0hMTszPT09ci5yYW5rJiYoYT0hMCxvPXIuYXM0RCgxLHIuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdKSk7dmFyIGk9ZVswXSxzPWVbMV0sdT1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3JldHVybiBlKFtvXSksdC5yZXNpemVOZWFyZXN0TmVpZ2hib3IobyxpLHMsbil9KSx7YmF0Y2hJbWFnZXM6b30sKGZ1bmN0aW9uKHQsZSl7cmV0dXJue2JhdGNoSW1hZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIEx0LnJ1bktlcm5lbEZ1bmMoKGZ1bmN0aW9uKHIpe3JldHVybiByLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wKHQsZVswXSxuKX0pLHt9KX19fSkpO3JldHVybiBhP3UuYXMzRCh1LnNoYXBlWzFdLHUuc2hhcGVbMl0sdS5zaGFwZVszXSk6dX19KSxRaD1Bbih7bm9uTWF4U3VwcHJlc3Npb25fOmZ1bmN0aW9uKHQsZSxuLHIsbyl7dm9pZCAwPT09ciYmKHI9LjUpLHZvaWQgMD09PW8mJihvPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7dmFyIGE9Z24odCxcImJveGVzXCIsXCJub25NYXhTdXBwcmVzc2lvblwiKSxpPWduKGUsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLHM9WGgoYSxpLG4scixvKTtuPXMubWF4T3V0cHV0U2l6ZSxyPXMuaW91VGhyZXNob2xkLG89cy5zY29yZVRocmVzaG9sZDt2YXIgdT17bWF4T3V0cHV0U2l6ZTpuLGlvdVRocmVzaG9sZDpyLHNjb3JlVGhyZXNob2xkOm99O3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0KXtyZXR1cm4gdC5ub25NYXhTdXBwcmVzc2lvbihhLGksbixyLG8pfSkse2JveGVzOmEsc2NvcmVzOml9LG51bGwsXCJOb25NYXhTdXBwcmVzc2lvblYzXCIsdSl9fSksSmg9ZnVuY3Rpb24odCxlLG8sYSxpKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9LjUpLHZvaWQgMD09PWkmJihpPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSksbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4scyx1LGMsbCxoLGY7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gbj1nbih0LFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIikscz1nbihlLFwic2NvcmVzXCIsXCJub25NYXhTdXBwcmVzc2lvbkFzeW5jXCIpLHU9WGgobixzLG8sYSxpKSxvPXUubWF4T3V0cHV0U2l6ZSxhPXUuaW91VGhyZXNob2xkLGk9dS5zY29yZVRocmVzaG9sZCxbNCxQcm9taXNlLmFsbChbbi5kYXRhKCkscy5kYXRhKCldKV07Y2FzZSAxOnJldHVybiBjPXIuc2VudCgpLGw9Y1swXSxoPWNbMV0sZj1PYShsLGgsbyxhLGkpLG4hPT10JiZuLmRpc3Bvc2UoKSxzIT09ZSYmcy5kaXNwb3NlKCksWzIsZl19fSkpfSkpfSxaaD1Bbih7bm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmVfOmZ1bmN0aW9uKHQsZSxuLHIsbyxhKXt2b2lkIDA9PT1yJiYocj0uNSksdm9pZCAwPT09byYmKG89TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSx2b2lkIDA9PT1hJiYoYT0wKTt2YXIgaT1nbih0LFwiYm94ZXNcIixcIm5vbk1heFN1cHByZXNzaW9uXCIpLHM9Z24oZSxcInNjb3Jlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25cIiksdT1YaChpLHMsbixyLG8sYSksYz17bWF4T3V0cHV0U2l6ZTpuPXUubWF4T3V0cHV0U2l6ZSxpb3VUaHJlc2hvbGQ6cj11LmlvdVRocmVzaG9sZCxzY29yZVRocmVzaG9sZDpvPXUuc2NvcmVUaHJlc2hvbGQsc29mdE5tc1NpZ21hOmE9dS5zb2Z0Tm1zU2lnbWF9LGw9THQucnVuS2VybmVsKFwiTm9uTWF4U3VwcHJlc3Npb25WNVwiLHtib3hlczppLHNjb3JlczpzfSxjKTtyZXR1cm57c2VsZWN0ZWRJbmRpY2VzOmxbMF0sc2VsZWN0ZWRTY29yZXM6bFsxXX19fSksdGY9ZnVuY3Rpb24odCxlLG8sYSxpLHMpe3JldHVybiB2b2lkIDA9PT1hJiYoYT0uNSksdm9pZCAwPT09aSYmKGk9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSx2b2lkIDA9PT1zJiYocz0wKSxuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbix1LGMsbCxoLGYsZDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOnJldHVybiBuPWduKHQsXCJib3hlc1wiLFwibm9uTWF4U3VwcHJlc3Npb25Bc3luY1wiKSx1PWduKGUsXCJzY29yZXNcIixcIm5vbk1heFN1cHByZXNzaW9uQXN5bmNcIiksYz1YaChuLHUsbyxhLGkscyksbz1jLm1heE91dHB1dFNpemUsYT1jLmlvdVRocmVzaG9sZCxpPWMuc2NvcmVUaHJlc2hvbGQscz1jLnNvZnRObXNTaWdtYSxbNCxQcm9taXNlLmFsbChbbi5kYXRhKCksdS5kYXRhKCldKV07Y2FzZSAxOnJldHVybiBsPXIuc2VudCgpLGg9bFswXSxmPWxbMV0sZD1NYShoLGYsbyxhLGkscyksbiE9PXQmJm4uZGlzcG9zZSgpLHUhPT1lJiZ1LmRpc3Bvc2UoKSxbMixkXX19KSl9KSl9LGVmPUFuKHtjcm9wQW5kUmVzaXplXzpmdW5jdGlvbih0LGUsbixyLG8sYSl7dmFyIGk9Z24odCxcImltYWdlXCIsXCJjcm9wQW5kUmVzaXplXCIpLHM9Z24oZSxcImJveGVzXCIsXCJjcm9wQW5kUmVzaXplXCIsXCJmbG9hdDMyXCIpLHU9Z24obixcImJveEluZFwiLFwiY3JvcEFuZFJlc2l6ZVwiLFwiaW50MzJcIik7bz1vfHxcImJpbGluZWFyXCIsYT1hfHwwO3ZhciBjPXMuc2hhcGVbMF07cmV0dXJuIEMoND09PWkucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGltYWdlIG11c3QgYmUgcmFuayA0LGJ1dCBnb3QgcmFuayBcIitpLnJhbmsrXCIuXCJ9KSksQygyPT09cy5yYW5rJiY0PT09cy5zaGFwZVsxXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNyb3BBbmRSZXNpemU6IGJveGVzIG11c3QgYmUgaGF2ZSBzaXplIFtcIitjK1wiLDRdIGJ1dCBoYWQgc2hhcGUgXCIrcy5zaGFwZStcIi5cIn0pKSxDKDE9PT11LnJhbmsmJnUuc2hhcGVbMF09PT1jLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY3JvcEFuZFJlc2l6ZTogYm94SW5kIG11c3QgYmUgaGF2ZSBzaXplIFtcIitjK1wiXSBidXQgaGFkIHNoYXBlIFwiK3Muc2hhcGUrXCIuXCJ9KSksQygyPT09ci5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBjcm9wQW5kUmVzaXplOiBjcm9wU2l6ZSBtdXN0IGJlIG9mIGxlbmd0aCAyLCBidXQgZ290IGxlbmd0aCBcIityLmxlbmd0aCtcIi5cIn0pKSxDKHJbMF0+PTEmJnJbMV0+PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJjcm9wU2l6ZSBtdXN0IGJlIGF0bGVhc3QgWzEsMV0sIGJ1dCB3YXMgXCIrcn0pKSxDKFwiYmlsaW5lYXJcIj09PW98fFwibmVhcmVzdFwiPT09bywoZnVuY3Rpb24oKXtyZXR1cm5cIm1ldGhvZCBtdXN0IGJlIGJpbGluZWFyIG9yIG5lYXJlc3QsIGJ1dCB3YXMgXCIrb30pKSxMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3JldHVybiB0LmNyb3BBbmRSZXNpemUoaSxzLHUscixvLGEpfSkse2ltYWdlczppLGJveGVzOnMsYm94SW5kOnV9LG51bGwsXCJDcm9wQW5kUmVzaXplXCIse21ldGhvZDpvLGV4dHJhcG9sYXRpb25WYWx1ZTphLGNyb3BTaXplOnJ9KX19KSxuZj1PYmplY3QuZnJlZXplKHtyZXNpemVCaWxpbmVhcjpZaCxyZXNpemVOZWFyZXN0TmVpZ2hib3I6JGgsbm9uTWF4U3VwcHJlc3Npb246UWgsbm9uTWF4U3VwcHJlc3Npb25Bc3luYzpKaCxub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZTpaaCxub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZUFzeW5jOnRmLGNyb3BBbmRSZXNpemU6ZWZ9KSxyZj1mdW5jdGlvbih0LGUpe3JldHVybiEodD4wKXx8XCJsaW5lYXJcIj09PWV9LG9mPWZ1bmN0aW9uKHQsZSxuKXtpZihudWxsPT1ufHxcImxpbmVhclwiPT09bilyZXR1cm4gdDtpZihcInJlbHVcIj09PW4pcmV0dXJuIHQubXVsKGUuc3RlcCgpKTt0aHJvdyBuZXcgRXJyb3IoXCJHcmFkaWVudCBmb3IgYWN0aXZhdGlvbiBcIituK1wiIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCB5ZXQuXCIpfSxhZj1mdW5jdGlvbih0LGUpe3ZhciBuPWUscj1Ccih0LnNoYXBlLGUuc2hhcGUpO3JldHVybiByLmxlbmd0aD4wJiYobj1uLnN1bShyKSksbi5yZXNoYXBlKHQuc2hhcGUpfSxzZj1mdW5jdGlvbih0LGUsbil7aWYoXCJsaW5lYXJcIj09PWUpcmV0dXJuIHQ7aWYoXCJyZWx1XCI9PT1lKXJldHVybiBhaCh0KTtpZihcImVsdVwiPT09ZSlyZXR1cm4gbmgodCk7aWYoXCJyZWx1NlwiPT09ZSlyZXR1cm4gaWgodCk7aWYoXCJwcmVsdVwiPT09ZSlyZXR1cm4gb2godCxuKTt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZ1c2VkIGFjdGl2YXRpb24gXCIrZStcIi5cIil9O3ZhciB1Zj1Bbih7ZnVzZWRNYXRNdWxfOmZ1bmN0aW9uKHQpe3ZhciBlLG49dC5hLHI9dC5iLG89dC50cmFuc3Bvc2VBLGE9dm9pZCAwIT09byYmbyxpPXQudHJhbnNwb3NlQixzPXZvaWQgMCE9PWkmJmksdT10LmJpYXMsYz10LmFjdGl2YXRpb24sbD12b2lkIDA9PT1jP1wibGluZWFyXCI6YyxoPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztpZighMT09PXJmKEx0LnN0YXRlLmdyYWRpZW50RGVwdGgsbCkpe3ZhciBmPUVsKG4scixhLHMpO3JldHVybiBudWxsIT11JiYoZj1PcihmLHUpKSxzZihmLGwsaCl9dmFyIGQ9Z24obixcImFcIixcImZ1c2VkIG1hdE11bFwiKSxwPWduKHIsXCJiXCIsXCJmdXNlZCBtYXRNdWxcIik7ZT1OdChkLHApLGQ9ZVswXSxwPWVbMV07dmFyIHY9YT9kLnNoYXBlW2QucmFuay0yXTpkLnNoYXBlW2QucmFuay0xXSxnPXM/cC5zaGFwZVtwLnJhbmstMV06cC5zaGFwZVtwLnJhbmstMl0sbT1hP2Quc2hhcGVbZC5yYW5rLTFdOmQuc2hhcGVbZC5yYW5rLTJdLHk9cz9wLnNoYXBlW3AucmFuay0yXTpwLnNoYXBlW3AucmFuay0xXSx4PWQuc2hhcGUuc2xpY2UoMCwtMiksYj1wLnNoYXBlLnNsaWNlKDAsLTIpLHc9ayh4KSxFPWsoYik7QyhkLnJhbms+PTImJnAucmFuaz49MiYmZC5yYW5rPT09cC5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgbWF0TXVsOiBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgb2YgYXQgbGVhc3QgMiwgZ290IHJhbmtzIFwiK2QucmFuaytcIiBhbmQgXCIrcC5yYW5rK1wiLlwifSkpLEMoUyh4LGIpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgbWF0TXVsOiBvdXRlciBkaW1lbnNpb25zIChcIit4K1wiKSBhbmQgKFwiK2IrXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIrZC5zaGFwZStcIiBhbmQgXCIrcC5zaGFwZStcIiBtdXN0IG1hdGNoLlwifSkpLEModj09PWcsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBmdXNlZCBtYXRNdWw6IGlubmVyIHNoYXBlcyAoXCIrditcIikgYW5kIChcIitnK1wiKSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzIFwiK2Quc2hhcGUrXCIgYW5kIFwiK3Auc2hhcGUrXCIgYW5kIHRyYW5zcG9zZUE9XCIrYStcIiBhbmQgdHJhbnNwb3NlQj1cIitzK1wiIG11c3QgbWF0Y2guXCJ9KSk7dmFyIFIsSSxBPWQuc2hhcGUuc2xpY2UoMCwtMikuY29uY2F0KFttLHldKSxUPWE/ZC5hczNEKHcsdixtKTpkLmFzM0QodyxtLHYpLEQ9cz9wLmFzM0QoRSx5LGcpOnAuYXMzRChFLGcseSk7bnVsbCE9dSYmUHIoQSwoUj1OdChSPWduKHUsXCJiaWFzXCIsXCJmdXNlZCBtYXRNdWxcIiksZClbMF0pLnNoYXBlKSxudWxsIT1oJiYoST1nbihoLFwicHJlbHUgd2VpZ2h0c1wiLFwiZnVzZWQgbWF0TXVsXCIpKTt2YXIgTj17YTpULGI6RH07bnVsbCE9dSYmKE4uYmlhcz1SKSxudWxsIT1oJiYoTi5wcmVsdUFjdGl2YXRpb25XZWlnaHRzPUkpO3ZhciBGPVtULERdO3JldHVybiBMdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZnVzZWRCYXRjaE1hdE11bCh7YTpULGI6RCx0cmFuc3Bvc2VBOmEsdHJhbnNwb3NlQjpzLGJpYXM6UixhY3RpdmF0aW9uOmwscHJlbHVBY3RpdmF0aW9uV2VpZ2h0czpJfSk7cmV0dXJuIGUoW1QsRCxuXSksbn0pLE4sKGZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sbz1lWzJdLGk9b2YodCxvLGwpLGM9e307cmV0dXJuIG51bGwhPXUmJihjPXtiaWFzOmZ1bmN0aW9uKCl7cmV0dXJuIGFmKFIsaSl9fSksYXx8cz8hYSYmcz9PYmplY3QuYXNzaWduKHthOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHIsITEsITEpfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKG4sITAsITEpfX0sYyk6YSYmIXM/T2JqZWN0LmFzc2lnbih7YTpmdW5jdGlvbigpe3JldHVybiByLm1hdE11bChpLCExLCEwKX0sYjpmdW5jdGlvbigpe3JldHVybiBuLm1hdE11bChpLCExLCExKX19LGMpOk9iamVjdC5hc3NpZ24oe2E6ZnVuY3Rpb24oKXtyZXR1cm4gci5tYXRNdWwoaSwhMCwhMCl9LGI6ZnVuY3Rpb24oKXtyZXR1cm4gaS5tYXRNdWwobiwhMCwhMCl9fSxjKTpPYmplY3QuYXNzaWduKHthOmZ1bmN0aW9uKCl7cmV0dXJuIGkubWF0TXVsKHIsITEsITApfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIG4ubWF0TXVsKGksITAsITEpfX0sYyl9KSxcIl9GdXNlZE1hdE11bFwiLHt0cmFuc3Bvc2VBOmEsdHJhbnNwb3NlQjpzLGFjdGl2YXRpb246bH0sRixbITBdKS5yZXNoYXBlKEEpfX0pLGNmPUFuKHtmdXNlZENvbnYyZF86ZnVuY3Rpb24odCl7dmFyIGU9dC54LG49dC5maWx0ZXIscj10LnN0cmlkZXMsbz10LnBhZCxhPXQuZGF0YUZvcm1hdCxpPXZvaWQgMD09PWE/XCJOSFdDXCI6YSxzPXQuZGlsYXRpb25zLHU9dm9pZCAwPT09cz9bMSwxXTpzLGM9dC5kaW1Sb3VuZGluZ01vZGUsbD10LmJpYXMsaD10LmFjdGl2YXRpb24sZj12b2lkIDA9PT1oP1wibGluZWFyXCI6aCxkPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cztpZihmPWZ8fFwibGluZWFyXCIsITE9PT1yZihMdC5zdGF0ZS5ncmFkaWVudERlcHRoLGYpKXt2YXIgcD1kbChlLG4scixvLGksdSxjKTtyZXR1cm4gbnVsbCE9bCYmKHA9T3IocCxsKSksc2YocCxmLGQpfXZhciB2PWduKGUsXCJ4XCIsXCJjb252MmRcIiksZz1nbihuLFwiZmlsdGVyXCIsXCJjb252MmRcIiksbT12LHk9ITE7Mz09PXYucmFuayYmKHk9ITAsbT12LmFzNEQoMSx2LnNoYXBlWzBdLHYuc2hhcGVbMV0sdi5zaGFwZVsyXSkpLEMoND09PW0ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIGNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIittLnJhbmsrXCIuXCJ9KSksQyg0PT09Zy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgY29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitnLnJhbmsrXCIuXCJ9KSksbnVsbCE9YyYmQyhBKG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgY29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIGRpbVJvdW5kaW5nTW9kZSBcIitjK1wiIGJ1dCBnb3QgcGFkIFwiK28rXCIuXCJ9KSksQyhtLnNoYXBlWzNdPT09Zy5zaGFwZVsyXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyZDogZGVwdGggb2YgaW5wdXQgKFwiK20uc2hhcGVbM10rXCIpIG11c3QgbWF0Y2ggaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIitnLnNoYXBlWzJdK1wiLlwifSkpLEMoQ2Eocix1KSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGNvbnYyRDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrcitcIiBhbmQgZGlsYXRpb25zICdcIit1K1wiJ1wifSkpLEMoXCJOSFdDXCI9PT1pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gY29udjJkOiBnb3QgZGF0YUZvcm1hdCBvZiBcIitpK1wiIGJ1dCBvbmx5IE5IV0MgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cIn0pKTt2YXIgeCxiLHc9cGEobS5zaGFwZSxnLnNoYXBlLHIsdSxvLGMpO251bGwhPWwmJih4PU50KHg9Z24obCxcImJpYXNcIixcImZ1c2VkIGNvbnYyZFwiKSx2KVswXSxQcih3Lm91dFNoYXBlLHguc2hhcGUpKSxudWxsIT1kJiYoYj1nbihkLFwicHJlbHUgd2VpZ2h0c1wiLFwiZnVzZWQgY29udjJkXCIpKTt2YXIgRT17eDptLGZpbHRlcjpnfTtudWxsIT1sJiYoRS5iaWFzPXgpLG51bGwhPWQmJihFLnByZWx1QWN0aXZhdGlvbldlaWdodHM9Yik7dmFyIFI9W2csbV0sST1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZnVzZWRDb252MmQoe2lucHV0Om0sZmlsdGVyOmcsY29udkluZm86dyxiaWFzOngsYWN0aXZhdGlvbjpmLHByZWx1QWN0aXZhdGlvbldlaWdodHM6Yn0pO3JldHVybiBlKFtnLG0sbl0pLG59KSxFLChmdW5jdGlvbih0LGUpe3ZhciBuPWUsYT1uWzBdLGk9blsxXSxzPW5bMl0sYz1vZih0LHMsZik7Qyh3YSh1KSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGdyYWRpZW50IG9mIGZ1c2VkIGNvbnYyRDogZGlsYXRpb24gcmF0ZXMgZ3JlYXRlciB0aGFuIDEgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIGluIGdyYWRpZW50cy4gR290IGRpbGF0aW9ucyAnXCIrdStcIidcIn0pKTt2YXIgaD17fTtyZXR1cm4gbnVsbCE9bCYmKGg9e2JpYXM6ZnVuY3Rpb24oKXtyZXR1cm4gYWYoeCxjKX19KSxPYmplY3QuYXNzaWduKHt4OmZ1bmN0aW9uKCl7cmV0dXJuIGdsKGkuc2hhcGUsYyxhLHIsbyl9LGZpbHRlcjpmdW5jdGlvbigpe3JldHVybiB2bChpLGMsYS5zaGFwZSxyLG8pfX0saCl9KSxcIkZ1c2VkQ29udjJEXCIse2NvbnZJbmZvOncsYWN0aXZhdGlvbjpmfSxSLFshMF0pO3JldHVybiB5P0kuYXMzRChJLnNoYXBlWzFdLEkuc2hhcGVbMl0sSS5zaGFwZVszXSk6SX19KSxsZj1Bbih7ZnVzZWREZXB0aHdpc2VDb252MmRfOmZ1bmN0aW9uKHQpe3ZhciBlPXQueCxuPXQuZmlsdGVyLHI9dC5zdHJpZGVzLG89dC5wYWQsYT10LmRhdGFGb3JtYXQsaT12b2lkIDA9PT1hP1wiTkhXQ1wiOmEscz10LmRpbGF0aW9ucyx1PXZvaWQgMD09PXM/WzEsMV06cyxjPXQuZGltUm91bmRpbmdNb2RlLGw9dC5iaWFzLGg9dC5hY3RpdmF0aW9uLGY9dm9pZCAwPT09aD9cImxpbmVhclwiOmgsZD10LnByZWx1QWN0aXZhdGlvbldlaWdodHM7aWYoITE9PT1yZihMdC5zdGF0ZS5ncmFkaWVudERlcHRoLGYpKXt2YXIgcD1tbChlLG4scixvLGksdSxjKTtyZXR1cm4gbnVsbCE9bCYmKHA9T3IocCxsKSksc2YocCxmLGQpfXZhciB2PWduKGUsXCJ4XCIsXCJkZXB0aHdpc2VDb252MmRcIiksZz1nbihuLFwiZmlsdGVyXCIsXCJkZXB0aHdpc2VDb252MmRcIiksbT12LHk9ITE7Mz09PXYucmFuayYmKHk9ITAsbT12LmFzNEQoMSx2LnNoYXBlWzBdLHYuc2hhcGVbMV0sdi5zaGFwZVsyXSkpLEMoND09PW0ucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIittLnJhbmsrXCIuXCJ9KSksQyg0PT09Zy5yYW5rLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBmaWx0ZXIgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgcmFuayBcIitnLnJhbmsrXCIuXCJ9KSksQyhtLnNoYXBlWzNdPT09Zy5zaGFwZVsyXSwoZnVuY3Rpb24oKXtyZXR1cm5cIkVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogbnVtYmVyIG9mIGlucHV0IGNoYW5uZWxzIChcIittLnNoYXBlWzNdK1wiKSBtdXN0IG1hdGNoIHRoZSBpbkNoYW5uZWxzIGRpbWVuc2lvbiBpbiBmaWx0ZXIgXCIrZy5zaGFwZVsyXStcIi5cIn0pKSxudWxsPT11JiYodT1bMSwxXSksQyhDYShyLHUpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCBiZSAxLiBHb3Qgc3RyaWRlcyBcIityK1wiIGFuZCBkaWxhdGlvbnMgJ1wiK3UrXCInXCJ9KSksbnVsbCE9YyYmQyhBKG8pLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcgZGltUm91bmRpbmdNb2RlIFwiK2MrXCIgYnV0IGdvdCBwYWQgXCIrbytcIi5cIn0pKTt2YXIgeCxiLHc9cGEobS5zaGFwZSxnLnNoYXBlLHIsdSxvLGMsITApO251bGwhPWwmJih4PU50KHg9Z24obCxcImJpYXNcIixcImZ1c2VkIGNvbnYyZFwiKSx2KVswXSxQcih3Lm91dFNoYXBlLHguc2hhcGUpKSxudWxsIT1kJiYoYj1nbihkLFwicHJlbHUgd2VpZ2h0c1wiLFwiZnVzZWQgZGVwdGh3aXNlQ29udjJkXCIpKTt2YXIgRT17eDptLGZpbHRlcjpnfTtudWxsIT1sJiYoRS5iaWFzPXgpLG51bGwhPWQmJihFLnByZWx1QWN0aXZhdGlvbldlaWdodHM9Yik7dmFyIFI9W2csbV0sST1MdC5ydW5LZXJuZWxGdW5jKChmdW5jdGlvbih0LGUpe3ZhciBuPXQuZnVzZWREZXB0aHdpc2VDb252MkQoe2lucHV0Om0sZmlsdGVyOmcsY29udkluZm86dyxiaWFzOngsYWN0aXZhdGlvbjpmLHByZWx1QWN0aXZhdGlvbldlaWdodHM6Yn0pO3JldHVybiBlKFtnLG0sbl0pLG59KSxFLChmdW5jdGlvbih0LGUpe0Mod2EodSksKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBncmFkaWVudCBvZiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZC4gR290IGRpbGF0aW9ucyAnXCIrdStcIidcIn0pKTt2YXIgbj1lWzBdLHI9ZVsxXSxvPWVbMl0sYT1vZih0LG8sZiksaT17fTtyZXR1cm4gbnVsbCE9bCYmKGk9e2JpYXM6ZnVuY3Rpb24oKXtyZXR1cm4gYWYoeCxhKX19KSxPYmplY3QuYXNzaWduKHt4OmZ1bmN0aW9uKCl7cmV0dXJuIHlsKHIuc2hhcGUsYSxuLHcpfSxmaWx0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4geGwocixhLG4uc2hhcGUsdyl9fSxpKX0pLFwiRnVzZWREZXB0aHdpc2VDb252MkRcIix7Y29udkluZm86dyxhY3RpdmF0aW9uOmZ9LFIsWyEwXSk7cmV0dXJuIHk/SS5hczNEKEkuc2hhcGVbMV0sSS5zaGFwZVsyXSxJLnNoYXBlWzNdKTpJfX0pLGhmPU9iamVjdC5mcmVlemUoe21hdE11bDp1Zixjb252MmQ6Y2YsZGVwdGh3aXNlQ29udjJkOmxmfSksZmY9T2JqZWN0LmZyZWV6ZSh7aW1hZ2U6bmYsbGluYWxnOmpoLGxvc3Nlczp6aCxzcGVjdHJhbDpiaCxmdXNlZDpoZixzaWduYWw6RGgsYWRkOk9yLGFkZE46JHUsYmF0Y2hOb3JtOm5jLGJhdGNoTm9ybWFsaXphdGlvbjplYyxiYXRjaE5vcm0yZDphYyxiYXRjaE5vcm1hbGl6YXRpb24yZDpvYyxiYXRjaE5vcm0zZDp1YyxiYXRjaE5vcm1hbGl6YXRpb24zZDpzYyxiYXRjaE5vcm00ZDpoYyxiYXRjaE5vcm1hbGl6YXRpb240ZDpsYyxicm9hZGNhc3RUbzpmYyxjbG9uZTpkYyxkaXY6Qm8sZGl2Tm9OYW46YmMsZXllOkNjLG11bHRpbm9taWFsOkVjLG9uZUhvdDpSYyxwYWQ6SWMscGFkMWQ6a2MscGFkMmQ6U2MscGFkM2Q6QWMscGFkNGQ6VGMscmFuZDpEYyxyYW5kb21HYW1tYTpVYyxyYW5kb21Ob3JtYWw6VmMscmFuZG9tVW5pZm9ybTp6YyxzcXVhcmU6R2Msc3F1YXJlZERpZmZlcmVuY2U6SGMsdGlsZTp3Yyx0cnVuY2F0ZWROb3JtYWw6cWMsY29udjFkOmZsLGNvbnYyZDpkbCxjb252M2Q6cGwsZGVwdGh3aXNlQ29udjJkOm1sLHNlcGFyYWJsZUNvbnYyZDpibCxjb252MmRUcmFuc3Bvc2U6d2wsY29udjNkVHJhbnNwb3NlOkNsLG9wOkFuLGJvb2xlYW5NYXNrQXN5bmM6dWwsY29tcGxleDpUbixyZWFsOkRuLGltYWc6Tm4sY29uY2F0OlluLGNvbmNhdDFkOiRuLGNvbmNhdDJkOlFuLGNvbmNhdDNkOkpuLGNvbmNhdDRkOlpuLHNwbGl0OnRyLG1hdE11bDpFbCxkb3Q6Umwsb3V0ZXJQcm9kdWN0OklsLHJldmVyc2U6a2wscmV2ZXJzZTFkOlNsLHJldmVyc2UyZDpBbCxyZXZlcnNlM2Q6VGwscmV2ZXJzZTRkOkRsLG1heFBvb2w6X2wsYXZnUG9vbDpPbCxwb29sOk1sLG1heFBvb2wzZDpCbCxhdmdQb29sM2Q6UGwsbWF4UG9vbFdpdGhBcmdtYXg6TGwsc2xpY2U6V2wsc2xpY2UxZDpVbCxzbGljZTJkOlZsLHNsaWNlM2Q6emwsc2xpY2U0ZDpHbCxhYnM6THIsYWNvczpXcixhY29zaDpVcixhc2luOlZyLGFzaW5oOnpyLGF0YW46R3IsYXRhbmg6SHIsY2VpbDpxcixjbGlwQnlWYWx1ZTpLcixjb3M6anIsY29zaDpYcixlcmY6WXIsZXhwOiRyLGV4cG0xOlFyLGZsb29yOkpyLGxvZzpacixsb2cxcDp0byxsb2dTaWdtb2lkOmVvLG5lZzpubyxyZWNpcHJvY2FsOnJvLHJvdW5kOm9vLHJzcXJ0OmFvLHNpZ21vaWQ6aW8sc2lnbjpzbyxpc05hTjp1byxpc0luZjpjbyxpc0Zpbml0ZTpsbyxzaW46aG8sc2luaDpmbyxzb2Z0cGx1czpwbyxzcXJ0OnZvLHN0ZXA6Z28sdGFuOm1vLHRhbmg6eW8sYWxsOnFsLGFueTpLbCxhcmdNYXg6amwsYXJnTWluOlhsLGxvZ1N1bUV4cDpZbCxtYXg6JGwsbWVhbjpRbCxtaW46SmwsbW9tZW50czpabCxzdW06dGgscHJvZDplaCxlcXVhbDpLYyxlcXVhbFN0cmljdDpqYyxncmVhdGVyOlhjLGdyZWF0ZXJFcXVhbDpZYyxncmVhdGVyRXF1YWxTdHJpY3Q6JGMsZ3JlYXRlclN0cmljdDpRYyxsZXNzOkpjLGxlc3NFcXVhbDpaYyxsZXNzRXF1YWxTdHJpY3Q6dGwsbGVzc1N0cmljdDplbCxub3RFcXVhbDpubCxub3RFcXVhbFN0cmljdDpybCxhZGRTdHJpY3Q6eG8sYXRhbjI6Ym8sZGl2U3RyaWN0OndvLGZsb29yRGl2OkNvLG1heGltdW06RW8sbWF4aW11bVN0cmljdDpSbyxtaW5pbXVtOklvLG1pbmltdW1TdHJpY3Q6a28sbW9kOlNvLG1vZFN0cmljdDpBbyxtdWw6VG8sbXVsU3RyaWN0OkRvLHBvdzpObyxwb3dTdHJpY3Q6Rm8sc3F1YXJlZERpZmZlcmVuY2VTdHJpY3Q6X28sc3ViOk9vLHN1YlN0cmljdDpNbyxlbHU6bmgsbGVha3lSZWx1OnJoLHByZWx1Om9oLHJlbHU6YWgscmVsdTY6aWgsc2VsdTpzaCxsb2dpY2FsQW5kOnBjLGxvZ2ljYWxOb3Q6dmMsbG9naWNhbE9yOmdjLGxvZ2ljYWxYb3I6bWMsd2hlcmU6eWMsd2hlcmVBc3luYzp4YyxidWZmZXI6ZXIscHJpbnQ6bnIsYmF0Y2hUb1NwYWNlTkQ6cnIsY2FzdDpvcixjdW1zdW06YXIsZGVwdGhUb1NwYWNlOmlyLGV4cGFuZERpbXM6c3IscmVzaGFwZTp1cixzcGFjZVRvQmF0Y2hORDpjcixzcXVlZXplOmxyLHN0YWNrOmhyLHVuc3RhY2s6ZnIsc2V0ZGlmZjFkQXN5bmM6ZHIsZmlsbDpIbixsaW5zcGFjZTpxbixvbmVzOnpuLHJhbmdlOktuLHNjYWxhcjpPbix0ZW5zb3I6Rm4sdGVuc29yMWQ6TW4sdGVuc29yMmQ6Qm4sdGVuc29yM2Q6UG4sdGVuc29yNGQ6TG4sdGVuc29yNWQ6V24sdGVuc29yNmQ6VW4sdmFyaWFibGU6Vm4semVyb3M6R24sb25lc0xpa2U6am4semVyb3NMaWtlOlhuLHRyYW5zcG9zZTp1YSxzb2Z0bWF4OmlhLGxvZ1NvZnRtYXg6c2EsbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb246dWgsbm9ybTpjaCxnYXRoZXI6aWwsdW5zb3J0ZWRTZWdtZW50U3VtOnNsLGJhc2ljTFNUTUNlbGw6bGgsbXVsdGlSTk5DZWxsOmhoLG1vdmluZ0F2ZXJhZ2U6Zmgsc3RyaWRlZFNsaWNlOmRoLHRvcGs6cGgsc2NhdHRlck5EOnZoLGZmdDpnaCxpZmZ0Om1oLHJmZnQ6eWgsaXJmZnQ6eGgsc3BhcnNlVG9EZW5zZTp3aCxnYXRoZXJORDpDaCxkaWFnOkVoLGRyb3BvdXQ6UmgsaGFubldpbmRvdzpraCxoYW1taW5nV2luZG93OlNoLGZyYW1lOkFoLHN0ZnQ6VGgsaW5Ub3BLQXN5bmM6Rmh9KTtmdW5jdGlvbiBkZih0LGUpe0FycmF5LmlzQXJyYXkodCl8fCh0PVt0XSksdC5mb3JFYWNoKChmdW5jdGlvbih0KXtudWxsIT10JiZDKFwiY29tcGxleDY0XCIhPT10LmR0eXBlLChmdW5jdGlvbigpe3JldHVybiBlK1wiIGRvZXMgbm90IHN1cHBvcnQgY29tcGxleDY0IHRlbnNvcnMuXCJ9KSl9KSl9ZnVuY3Rpb24gcGYodCxlLG4scixvLGEpe2Zvcih2YXIgaT1vLnN0cmlkZUhlaWdodCxzPW8uc3RyaWRlV2lkdGgsdT1vLmRpbGF0aW9uSGVpZ2h0LGM9by5kaWxhdGlvbldpZHRoLGw9by5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsaD1vLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGY9by5wYWRJbmZvLnRvcCxkPW8ucGFkSW5mby5sZWZ0LHA9XCJtYXhcIj09PWE/TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSx2PWVyKG8ub3V0U2hhcGUsbiksZz12LnZhbHVlcyxtPW8ub3V0U2hhcGVbMV0qby5vdXRTaGFwZVsyXSpvLm91dFNoYXBlWzNdLHk9by5vdXRTaGFwZVsyXSpvLm91dFNoYXBlWzNdLHg9by5vdXRTaGFwZVszXSxiPTA7YjxvLmJhdGNoU2l6ZTsrK2IpZm9yKHZhciB3PWIqbSxDPWIqclswXSxFPTA7RTxvLmluQ2hhbm5lbHM7KytFKWZvcih2YXIgUj0wO1I8by5vdXRIZWlnaHQ7KytSKWZvcih2YXIgST1SKmktZixrPU1hdGgubWF4KDAsSSksUz1NYXRoLm1pbihvLmluSGVpZ2h0LGwrSSksQT13K1IqeSxUPTA7VDxvLm91dFdpZHRoOysrVCl7Zm9yKHZhciBEPVQqcy1kLE49TWF0aC5tYXgoMCxEKSxGPU1hdGgubWluKG8uaW5XaWR0aCxoK0QpLF89cCxPPTAsTT0wLEI9aztCPFM7Qis9dSl7Zm9yKHZhciBQPUMrQipyWzFdLEw9TjtMPEY7TCs9Yyl7dmFyIFc9dFtQK0wqclsyXStFXTtcIm1heFwiPT09YSYmVz5fP189VzpcImF2Z1wiPT09YSYmKE8rPVcsTSsrKX1pZihpc05hTihfKSlicmVha31nW0ErVCp4K0VdPVwiYXZnXCI9PT1hP08vTTpffXJldHVybiB2fWZ1bmN0aW9uIHZmKHQsZSxuLHIsbyxhKXt2b2lkIDA9PT1vJiYobz0hMSksdm9pZCAwPT09YSYmKGE9ITEpO2Zvcih2YXIgaT1lcihyLm91dFNoYXBlLFwiaW50MzJcIikscz1yLnN0cmlkZUhlaWdodCx1PXIuc3RyaWRlV2lkdGgsYz1yLmRpbGF0aW9uSGVpZ2h0LGw9ci5kaWxhdGlvbldpZHRoLGg9ci5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsZj1yLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGQ9ci5wYWRJbmZvLnRvcCxwPXIucGFkSW5mby5sZWZ0LHY9ZXIoZSxuLHQpLGc9MDtnPHIuYmF0Y2hTaXplOysrZylmb3IodmFyIG09MDttPHIuaW5DaGFubmVsczsrK20pZm9yKHZhciB5PTA7eTxyLm91dEhlaWdodDsrK3kpe2Zvcih2YXIgeD15KnMtZCxiPXg7YjwwOyliKz1jO2Zvcih2YXIgdz1NYXRoLm1pbihyLmluSGVpZ2h0LGgreCksQz0wO0M8ci5vdXRXaWR0aDsrK0Mpe2Zvcih2YXIgRT1DKnUtcCxSPUU7UjwwOylSKz1sO2Zvcih2YXIgST1NYXRoLm1pbihyLmluV2lkdGgsZitFKSxrPU51bWJlci5ORUdBVElWRV9JTkZJTklUWSxTPS0xLEE9YjtBPHc7QSs9Yylmb3IodmFyIFQ9QS14LEQ9UjtEPEk7RCs9bCl7dmFyIE49RC1FLEY9di5nZXQoZyxBLEQsbSk7Rj5rJiYoaz1GLFM9bz9hPygoZypyLmluSGVpZ2h0K0EpKnIuaW5XaWR0aCtEKSpyLmluQ2hhbm5lbHMrbTooQSpyLmluV2lkdGgrRCkqci5pbkNoYW5uZWxzK206VCpmK04pfWkuc2V0KFMsZyx5LEMsbSl9fXJldHVybiBpfWZ1bmN0aW9uIGdmKHQsZSxuLHIpe2lmKFwibGluZWFyXCI9PT1uKXJldHVybiB0LmxpbmVhcihlKTtpZihcInJlbHVcIj09PW4pcmV0dXJuIHQucmVsdShlKTtpZihcImVsdVwiPT09bilyZXR1cm4gdC5lbHUoZSk7aWYoXCJyZWx1NlwiPT09bilyZXR1cm4gdC5yZWx1NihlKTtpZihcInByZWx1XCI9PT1uKXJldHVybiB0LnByZWx1KGUscik7dGhyb3cgbmV3IEVycm9yKFwiQWN0aXZhdGlvbiBcIituK1wiIGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCBmb3IgdGhlIENQVSBiYWNrZW5kLlwiKX12YXIgbWY9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbygpe3ZhciBlPXQuY2FsbCh0aGlzKXx8dGhpcztyZXR1cm4gZS5ibG9ja1NpemU9NDgsZS5maXJzdFVzZT0hMCxlLmRhdGE9bmV3IGNhKGUsTHQpLGV9cmV0dXJuIGUobyx0KSxvLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUsbil7dGhpcy5maXJzdFVzZSYmKHRoaXMuZmlyc3RVc2U9ITEsaSgpLmdldChcIklTX05PREVcIikmJmRuKFwiXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbkhpIHRoZXJlIPCfkYsuIExvb2tzIGxpa2UgeW91IGFyZSBydW5uaW5nIFRlbnNvckZsb3cuanMgaW4gTm9kZS5qcy4gVG8gc3BlZWQgdGhpbmdzIHVwIGRyYW1hdGljYWxseSwgaW5zdGFsbCBvdXIgbm9kZSBiYWNrZW5kLCB3aGljaCBiaW5kcyB0byBUZW5zb3JGbG93IEMrKywgYnkgcnVubmluZyBucG0gaSBAdGVuc29yZmxvdy90ZmpzLW5vZGUsIG9yIG5wbSBpIEB0ZW5zb3JmbG93L3RmanMtbm9kZS1ncHUgaWYgeW91IGhhdmUgQ1VEQS4gVGhlbiBjYWxsIHJlcXVpcmUoJ0B0ZW5zb3JmbG93L3RmanMtbm9kZScpOyAoLWdwdSBzdWZmaXggZm9yIENVREEpIGF0IHRoZSBzdGFydCBvZiB5b3VyIHByb2dyYW0uIFZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMtbm9kZSBmb3IgbW9yZSBkZXRhaWxzLlxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIikpO3ZhciByPXt9O3JldHVybiB0aGlzLmRhdGEuc2V0KHIse3ZhbHVlczp0LGR0eXBlOm59KSxyfSxvLnByb3RvdHlwZS5tb3ZlPWZ1bmN0aW9uKHQsZSxuLHIpe3RoaXMuZGF0YS5zZXQodCx7dmFsdWVzOmUsZHR5cGU6cn0pfSxvLnByb3RvdHlwZS5udW1EYXRhSWRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YS5udW1EYXRhSWRzKCl9LG8ucHJvdG90eXBlLnJlYWQ9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3JldHVyblsyLHRoaXMucmVhZFN5bmModCldfSkpfSkpfSxvLnByb3RvdHlwZS5yZWFkU3luYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmRhdGEuZ2V0KHQpLG49ZS5kdHlwZSxyPWUuY29tcGxleFRlbnNvcnM7cmV0dXJuXCJjb21wbGV4NjRcIj09PW4/QWEodGhpcy5yZWFkU3luYyhyLnJlYWwuZGF0YUlkKSx0aGlzLnJlYWRTeW5jKHIuaW1hZy5kYXRhSWQpKTp0aGlzLmRhdGEuZ2V0KHQpLnZhbHVlc30sby5wcm90b3R5cGUuYnVmZmVyU3luYz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPWU7aWYoXCJzdHJpbmdcIj09PXQuZHR5cGUpdHJ5e249ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBvdCh0KX0pKX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVjb2RlIGVuY29kZWQgc3RyaW5nIGJ5dGVzIGludG8gdXRmLThcIil9cmV0dXJuIGVyKHQuc2hhcGUsdC5kdHlwZSxuKX0sby5wcm90b3R5cGUubWFrZU91dHB1dD1mdW5jdGlvbih0LGUsbil7dmFyIHI9dGhpcy53cml0ZSh0LGUsbik7cmV0dXJuIEx0Lm1ha2VUZW5zb3JGcm9tRGF0YUlkKHIsZSxuLHRoaXMpfSxvLnByb3RvdHlwZS5kaXNwb3NlRGF0YT1mdW5jdGlvbih0KXtpZih0aGlzLmRhdGEuaGFzKHQpKXt2YXIgZT10aGlzLmRhdGEuZ2V0KHQpLmNvbXBsZXhUZW5zb3JzO251bGwhPWUmJihlLnJlYWwuZGlzcG9zZSgpLGUuaW1hZy5kaXNwb3NlKCkpLHRoaXMuZGF0YS5kZWxldGUodCl9fSxvLnByb3RvdHlwZS50aW1lPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtyZXR1cm4gZT1ldCgpLHQoKSxbMix7a2VybmVsTXM6ZXQoKS1lfV19KSl9KSl9LG8ucHJvdG90eXBlLm1lbW9yeT1mdW5jdGlvbigpe3JldHVybnt1bnJlbGlhYmxlOiEwLHJlYXNvbnM6W1wiVGhlIHJlcG9ydGVkIG1lbW9yeSBpcyBhbiB1cHBlciBib3VuZC4gRHVlIHRvIGF1dG9tYXRpYyBnYXJiYWdlIGNvbGxlY3Rpb24sIHRoZSB0cnVlIGFsbG9jYXRlZCBtZW1vcnkgbWF5IGJlIGxlc3MuXCJdfX0sby5wcm90b3R5cGUuY29tcGxleD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubWFrZU91dHB1dChudWxsLHQuc2hhcGUsXCJjb21wbGV4NjRcIik7cmV0dXJuIHRoaXMuZGF0YS5nZXQobi5kYXRhSWQpLmNvbXBsZXhUZW5zb3JzPXtyZWFsOkx0LmtlZXAodC5jbG9uZSgpKSxpbWFnOkx0LmtlZXAoZS5jbG9uZSgpKX0sbn0sby5wcm90b3R5cGUucmVhbD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbC5jbG9uZSgpfSxvLnByb3RvdHlwZS5pbWFnPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGEuZ2V0KHQuZGF0YUlkKS5jb21wbGV4VGVuc29ycy5pbWFnLmNsb25lKCl9LG8ucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKHQsZSxuKXtpZihkZih0LFwic2xpY2VcIiksJG8odC5zaGFwZSxlLG4pKXt2YXIgcj1RbyhlLHQuc3RyaWRlcyksbz1rKG4pO3JldHVybiBGbih0aGlzLnJlYWRTeW5jKHQuZGF0YUlkKS5zdWJhcnJheShyLHIrbyksbix0LmR0eXBlKX1mb3IodmFyIGE9ZXIobix0LmR0eXBlKSxpPXRoaXMuYnVmZmVyU3luYyh0KSxzPTA7czxhLnNpemU7KytzKXt2YXIgdT1hLmluZGV4VG9Mb2MocykubWFwKChmdW5jdGlvbih0LG4pe3JldHVybiB0K2Vbbl19KSk7YS52YWx1ZXNbc109aS5nZXQuYXBwbHkoaSx1KX1yZXR1cm4gYS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5zdHJpZGVkU2xpY2U9ZnVuY3Rpb24odCxlLG4scil7ZGYodCxcInN0cmlkZWRTbGljZVwiKTt2YXIgbz1qbyhlLG4scik7aWYoby5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gMD09PXR9KSkpcmV0dXJuIEZuKFtdLG8pO2Zvcih2YXIgYT1lcihvLHQuZHR5cGUpLGk9dGhpcy5idWZmZXJTeW5jKHQpLHM9MDtzPGEuc2l6ZTtzKyspe2Zvcih2YXIgdT1hLmluZGV4VG9Mb2MocyksYz1uZXcgQXJyYXkodS5sZW5ndGgpLGw9MDtsPGMubGVuZ3RoO2wrKyljW2xdPXVbbF0qcltsXStlW2xdO2Euc2V0LmFwcGx5KGEsW2kuZ2V0LmFwcGx5KGksYyldLmNvbmNhdCh1KSl9cmV0dXJuIGEudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuZGlhZz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1lcihbdC5zaXplLHQuc2l6ZV0sdC5kdHlwZSkscj1uLnZhbHVlcyxvPTA7bzxlLmxlbmd0aDtvKyspcltvKnQuc2l6ZStvXT1lW29dO3JldHVybiBuLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLnVuc3RhY2s9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5zaGFwZVtlXSxyPW5ldyBBcnJheSh0LnJhbmstMSksbz0wLGE9MDthPHQucmFuazthKyspYSE9PWUmJihyW28rK109dC5zaGFwZVthXSk7dmFyIGk9bmV3IEFycmF5KHQucmFuaykuZmlsbCgwKSxzPXQuc2hhcGUuc2xpY2UoKTtzW2VdPTE7dmFyIHU9bmV3IEFycmF5KG4pO2ZvcihhPTA7YTx1Lmxlbmd0aDthKyspaVtlXT1hLHVbYV09dGhpcy5zbGljZSh0LGkscykucmVzaGFwZShyKTtyZXR1cm4gdX0sby5wcm90b3R5cGUucmV2ZXJzZT1mdW5jdGlvbih0LGUpe2RmKHQsXCJyZXZlcnNlXCIpO2Zvcih2YXIgbj1lcih0LnNoYXBlLHQuZHR5cGUpLHI9dGhpcy5idWZmZXJTeW5jKHQpLG89ZnVuY3Rpb24obyl7dmFyIGE9bi5pbmRleFRvTG9jKG8pLGk9YS5zbGljZSgpO2UuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGlbZV09dC5zaGFwZVtlXS0xLWlbZV19KSksbi5zZXQuYXBwbHkobixbci5nZXQuYXBwbHkocixpKV0uY29uY2F0KGEpKX0sYT0wO2E8bi5zaXplO2ErKylvKGEpO3JldHVybiBuLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7aWYoXCJjb21wbGV4NjRcIj09PXRbMF0uZHR5cGUpe3ZhciByPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gRG4odCl9KSksbz10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIE5uKHQpfSkpO3JldHVybiBUbih0aGlzLmNvbmNhdChyLGUpLHRoaXMuY29uY2F0KG8sZSkpfXZhciBhPXQubWFwKChmdW5jdGlvbih0KXt2YXIgbj1rKHQuc2hhcGUuc2xpY2UoZSkpO3JldHVybiB0LmFzMkQoLTEsbil9KSksaT1TbihhLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hhcGV9KSksMSkscz1lcihpLHRbMF0uZHR5cGUpLnZhbHVlcztpZigxPT09YVswXS5zaGFwZVswXSl7dmFyIHU9MDthLmZvckVhY2goKGZ1bmN0aW9uKHQpe3Muc2V0KG4ucmVhZFN5bmModC5kYXRhSWQpLHUpLHUrPXQuc2l6ZX0pKX1lbHNle3ZhciBjPTA7YS5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIGU9bi5yZWFkU3luYyh0LmRhdGFJZCkscj0wLG89MDtvPHQuc2hhcGVbMF07KytvKWZvcih2YXIgYT1vKmlbMV0rYyx1PTA7dTx0LnNoYXBlWzFdOysrdSlzW2ErdV09ZVtyKytdO2MrPXQuc2hhcGVbMV19KSl9dmFyIGw9U24odC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnNoYXBlfSkpLGUpO3JldHVybiBGbihzLGwsdFswXS5kdHlwZSl9LG8ucHJvdG90eXBlLm5lZz1mdW5jdGlvbih0KXtyZXR1cm4gZGYodCxcIm5lZ1wiKSx0aGlzLm11bHRpcGx5KE9uKC0xKSx0KX0sby5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb21wbGV4NjRcIj09PXQuZHR5cGV8fFwiY29tcGxleDY0XCI9PT1lLmR0eXBlP3RoaXMuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AodC5jYXN0KFwiY29tcGxleDY0XCIpLGUuY2FzdChcImNvbXBsZXg2NFwiKSwoZnVuY3Rpb24odCxlLG4scil7cmV0dXJue3JlYWw6dCtuLGltYWc6ZStyfX0pKTp0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFR0KHQuZHR5cGUsZS5kdHlwZSksKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZX0pKX0sby5wcm90b3R5cGUuYWRkTj1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2RmKHQsXCJhZGROXCIpO2Zvcih2YXIgbj10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGUucmVhZFN5bmModC5kYXRhSWQpfSkpLHI9ZXIodFswXS5zaGFwZSx0WzBdLmR0eXBlKSxvPXIudmFsdWVzLGE9MDthPHQubGVuZ3RoO2ErKylmb3IodmFyIGk9blthXSxzPTA7czxvLmxlbmd0aDtzKyspb1tzXSs9aVtzXTtyZXR1cm4gci50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5zb2Z0bWF4PWZ1bmN0aW9uKHQsZSl7dmFyIG49TyhbZV0sdC5zaGFwZSkscj10aGlzLm1heCh0LG4pLG89d24oci5zaGFwZSxuKSxhPXRoaXMuc3VidHJhY3QodCxyLnJlc2hhcGUobykpLGk9dGhpcy5leHAoYSkscz10aGlzLnN1bShpLG4pLnJlc2hhcGUobyk7cmV0dXJuIEJvKGkscyl9LG8ucHJvdG90eXBlLnN1YnRyYWN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb21wbGV4NjRcIj09PXQuZHR5cGV8fFwiY29tcGxleDY0XCI9PT1lLmR0eXBlP3RoaXMuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AodC5jYXN0KFwiY29tcGxleDY0XCIpLGUuY2FzdChcImNvbXBsZXg2NFwiKSwoZnVuY3Rpb24odCxlLG4scil7cmV0dXJue3JlYWw6dC1uLGltYWc6ZS1yfX0pKTp0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFR0KHQuZHR5cGUsZS5kdHlwZSksKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQtZX0pKX0sby5wcm90b3R5cGUucG93PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGRmKFt0LGVdLFwicG93XCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5wb3codCxlKX0pKX0sby5wcm90b3R5cGUuYmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCxlLG4scil7ZGYoW3QsZV0sXCJtYXRNdWxcIik7Zm9yKHZhciBvPW4/dC5zaGFwZVsxXTp0LnNoYXBlWzJdLGE9bj90LnNoYXBlWzJdOnQuc2hhcGVbMV0saT1yP2Uuc2hhcGVbMV06ZS5zaGFwZVsyXSxzPXQuc2hhcGVbMF0sdT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxjPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLGw9bj9bdC5zdHJpZGVzWzBdLDEsdC5zdHJpZGVzWzFdXTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXSwxXSxoPWxbMF0sZj1sWzFdLGQ9bFsyXSxwPXI/WzEsZS5zdHJpZGVzWzFdLGUuc3RyaWRlc1swXV06W2Uuc3RyaWRlc1sxXSwxLGUuc3RyaWRlc1swXV0sdj1wWzBdLGc9cFsxXSxtPXBbMl0seT1hKmkseD1lcihbcyxhLGldLHQuZHR5cGUpLGI9eC52YWx1ZXMsdz10aGlzLmJsb2NrU2l6ZSxDPTA7QzxzO0MrKylmb3IodmFyIEU9MDtFPGE7RSs9dylmb3IodmFyIFI9MDtSPGk7Uis9dylmb3IodmFyIEk9MDtJPG87SSs9dylmb3IodmFyIGs9TWF0aC5taW4oRSt3LGEpLFM9TWF0aC5taW4oUit3LGkpLEE9TWF0aC5taW4oSSt3LG8pLFQ9RTtUPGs7VCsrKWZvcih2YXIgRD1SO0Q8UztEKyspe2Zvcih2YXIgTj0wLEY9STtGPEE7RisrKU4rPXVbQypoK1QqZitGKmRdKmNbRip2K0QqZytDKm1dO2JbQyp5KyhUKmkrRCldKz1OfXJldHVybiB4LnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmZ1c2VkQmF0Y2hNYXRNdWw9ZnVuY3Rpb24odCl7dmFyIGU9dC5hLG49dC5iLHI9dC50cmFuc3Bvc2VBLG89dC50cmFuc3Bvc2VCLGE9dC5iaWFzLGk9dC5hY3RpdmF0aW9uLHM9dC5wcmVsdUFjdGl2YXRpb25XZWlnaHRzLHU9dGhpcy5iYXRjaE1hdE11bChlLG4scixvKTtyZXR1cm4gYSYmKHU9dGhpcy5hZGQodSxhKSksaSYmKHU9Z2YodGhpcyx1LGkscykpLHV9LG8ucHJvdG90eXBlLm11bHRpcGx5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJjb21wbGV4NjRcIj09PXQuZHR5cGV8fFwiY29tcGxleDY0XCI9PT1lLmR0eXBlP3RoaXMuYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AodC5jYXN0KFwiY29tcGxleDY0XCIpLGUuY2FzdChcImNvbXBsZXg2NFwiKSwoZnVuY3Rpb24odCxlLG4scil7cmV0dXJue3JlYWw6dCpuLWUqcixpbWFnOnQqcitlKm59fSkpOnRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsVHQodC5kdHlwZSxlLmR0eXBlKSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpfSxvLnByb3RvdHlwZS5mbG9vckRpdj1mdW5jdGlvbih0LGUpe2RmKFt0LGVdLFwiZmxvb3JEaXZcIik7cmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJpbnQzMlwiLChmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLmZsb29yKHQvZSl9KSl9LG8ucHJvdG90eXBlLnN1bT1mdW5jdGlvbih0LGUpe2RmKHQsXCJzdW1cIiksQ24oXCJzdW1cIixlLHQucmFuayk7Zm9yKHZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPUduKHIsVHQodC5kdHlwZSxcImludDMyXCIpKSxpPWsobykscz10aGlzLnJlYWRTeW5jKGEuZGF0YUlkKSx1PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGM9MDtjPHMubGVuZ3RoOysrYyl7Zm9yKHZhciBsPWMqaSxoPTAsZj0wO2Y8aTsrK2YpaCs9dVtsK2ZdO3NbY109aH1yZXR1cm4gYX0sby5wcm90b3R5cGUucHJvZD1mdW5jdGlvbih0LGUpe2RmKHQsXCJzdW1cIik7Zm9yKHZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPUduKHIsVHQodC5kdHlwZSxcImludDMyXCIpKSxpPWsobykscz10aGlzLnJlYWRTeW5jKGEuZGF0YUlkKSx1PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGM9MDtjPHMubGVuZ3RoOysrYyl7Zm9yKHZhciBsPWMqaSxoPTEsZj0wO2Y8aTsrK2YpaCo9dVtsK2ZdO3NbY109aH1yZXR1cm4gYX0sby5wcm90b3R5cGUudW5zb3J0ZWRTZWdtZW50U3VtPWZ1bmN0aW9uKHQsZSxuKXtkZih0LFwidW5zb3J0ZWRTZWdtZW50U3VtXCIpO2Zvcih2YXIgcj1bXSxvPXQucmFuay1lLnJhbmssYT0wO2E8bzsrK2EpZT1lLmV4cGFuZERpbXMoYSsxKTtmb3IoYT0wO2E8bjsrK2Epe3ZhciBpPU9uKGEsXCJpbnQzMlwiKSxzPUtjKGksZSkuYXNUeXBlKFwiZmxvYXQzMlwiKS5tdWwodCkuc3VtKDApO3IucHVzaChzKX1yZXR1cm4gaHIocil9LG8ucHJvdG90eXBlLmFyZ01pbj1mdW5jdGlvbih0LGUpe2RmKHQsXCJhcmdNaW5cIik7dmFyIG49W2VdO0NuKFwiYXJnTWluXCIsbix0LnJhbmspO2Zvcih2YXIgcj1ibih0LnNoYXBlLG4pLG89clswXSxhPXJbMV0saT1HbihvLFwiaW50MzJcIikscz1rKGEpLHU9dGhpcy5yZWFkU3luYyhpLmRhdGFJZCksYz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxsPTA7bDx1Lmxlbmd0aDsrK2wpe2Zvcih2YXIgaD1sKnMsZj1jW2hdLGQ9MCxwPTA7cDxzOysrcCl7dmFyIHY9Y1toK3BdO3Y8ZiYmKGY9dixkPXApfXVbbF09ZH1yZXR1cm4gaX0sby5wcm90b3R5cGUuYXJnTWF4PWZ1bmN0aW9uKHQsZSl7ZGYodCxcImFyZ01heFwiKTt2YXIgbj1bZV07Q24oXCJhcmdNYXhcIixuLHQucmFuayk7Zm9yKHZhciByPWJuKHQuc2hhcGUsbiksbz1yWzBdLGE9clsxXSxpPUduKG8sXCJpbnQzMlwiKSxzPWsoYSksdT10aGlzLnJlYWRTeW5jKGkuZGF0YUlkKSxjPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGw9MDtsPHUubGVuZ3RoOysrbCl7Zm9yKHZhciBoPWwqcyxmPWNbaF0sZD0wLHA9MDtwPHM7KytwKXt2YXIgdj1jW2grcF07dj5mJiYoZj12LGQ9cCl9dVtsXT1kfXJldHVybiBpfSxvLnByb3RvdHlwZS5jdW1zdW09ZnVuY3Rpb24odCxlLG4scil7aWYoZGYodCxcImN1bXN1bVwiKSxlIT09dC5yYW5rLTEpdGhyb3cgbmV3IEVycm9yKFwiYmFja2VuZC5jdW1zdW0gaW4gQ1BVIGV4cGVjdHMgYW4gaW5uZXItbW9zdCBheGlzPVwiKyh0LnJhbmstMSkrXCIgYnV0IGdvdCBheGlzPVwiK2UpO2Zvcih2YXIgbz1UdCh0LmR0eXBlLFwiaW50MzJcIiksYT1Hbih0LnNoYXBlLG8pLGk9dGhpcy5yZWFkU3luYyhhLmRhdGFJZCkscz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSx1PXQuc2hhcGVbdC5yYW5rLTFdLGM9cj9mdW5jdGlvbih0LGUpe3JldHVybiB0K3UtZS0xfTpmdW5jdGlvbih0LGUpe3JldHVybiB0K2V9LGw9MDtsPHMubGVuZ3RoO2wrPXUpZm9yKHZhciBoPTA7aDx1O2grKyl7dmFyIGY9YyhsLGgpO2lmKDA9PT1oKWlbZl09bj8wOnNbZl07ZWxzZXt2YXIgZD1jKGwsaC0xKTtpW2ZdPW4/c1tkXStpW2RdOnNbZl0raVtkXX19cmV0dXJuIGF9LG8ucHJvdG90eXBlLmVxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGRmKFt0LGVdLFwiZXF1YWxcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PWU/MTowfSkpfSxvLnByb3RvdHlwZS5ub3RFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiBkZihbdCxlXSxcIm5vdEVxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQhPT1lPzE6MH0pKX0sby5wcm90b3R5cGUubGVzcz1mdW5jdGlvbih0LGUpe3JldHVybiBkZihbdCxlXSxcImxlc3NcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdDxlPzE6MH0pKX0sby5wcm90b3R5cGUubGVzc0VxdWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGRmKFt0LGVdLFwibGVzc0VxdWFsXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ8PWU/MTowfSkpfSxvLnByb3RvdHlwZS5ncmVhdGVyPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGRmKFt0LGVdLFwiZ3JlYXRlclwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLFwiYm9vbFwiLChmdW5jdGlvbih0LGUpe3JldHVybiB0PmU/MTowfSkpfSxvLnByb3RvdHlwZS5ncmVhdGVyRXF1YWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZGYoW3QsZV0sXCJncmVhdGVyRXF1YWxcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdD49ZT8xOjB9KSl9LG8ucHJvdG90eXBlLmxvZ2ljYWxOb3Q9ZnVuY3Rpb24odCl7ZGYodCxcImxvZ2ljYWxOb3RcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPWVbcl0/MDoxO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiYm9vbFwiKX0sby5wcm90b3R5cGUubG9naWNhbEFuZD1mdW5jdGlvbih0LGUpe3JldHVybiBkZihbdCxlXSxcImxvZ2ljYWxBbmRcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSxcImJvb2xcIiwoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCYmZX0pKX0sby5wcm90b3R5cGUubG9naWNhbE9yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGRmKFt0LGVdLFwibG9naWNhbE9yXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsXCJib29sXCIsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHR8fGV9KSl9LG8ucHJvdG90eXBlLnNlbGVjdD1mdW5jdGlvbih0LGUsbil7ZGYoW3QsZSxuXSxcInNlbGVjdFwiKTtmb3IodmFyIHI9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbz10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxhPXRoaXMucmVhZFN5bmMobi5kYXRhSWQpLGk9R24oZS5zaGFwZSxUdChlLmR0eXBlLG4uZHR5cGUpKSxzPXRoaXMucmVhZFN5bmMoaS5kYXRhSWQpLHU9MCxjPTA9PT10LnJhbmt8fHQucmFuaz4xfHwxPT09ZS5yYW5rPzE6ayhlLnNoYXBlLnNsaWNlKDEpKSxsPTA7bDxyLmxlbmd0aDtsKyspZm9yKHZhciBoPTA7aDxjO2grKykxPT09cltsXT9zW3UrK109b1tsXTpzW3UrK109YVtsXTtyZXR1cm4gaX0sby5wcm90b3R5cGUud2hlcmU9ZnVuY3Rpb24odCl7ZGYoW3RdLFwid2hlcmVcIik7dmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCk7cmV0dXJuIEdhKHQuc2hhcGUsZSl9LG8ucHJvdG90eXBlLnRvcGs9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBkZih0LFwidG9wa1wiKSx6YSh0aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSx0LnNoYXBlLHQuZHR5cGUsZSl9LG8ucHJvdG90eXBlLm1pbj1mdW5jdGlvbih0LGUpe2RmKHQsXCJtaW5cIiksQ24oXCJtaW5cIixlLHQucmFuayk7Zm9yKHZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPUduKHIsdC5kdHlwZSksaT1rKG8pLHM9dGhpcy5yZWFkU3luYyhhLmRhdGFJZCksdT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxjPTA7YzxzLmxlbmd0aDsrK2Mpe2Zvcih2YXIgbD1jKmksaD11W2xdLGY9MDtmPGk7KytmKXt2YXIgZD11W2wrZl07ZDxoJiYoaD1kKX1zW2NdPWh9cmV0dXJuIGF9LG8ucHJvdG90eXBlLm1pbmltdW09ZnVuY3Rpb24odCxlKXtyZXR1cm4gZGYoW3QsZV0sXCJtaW5pbXVtXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5taW4odCxlKX0pKX0sby5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGRmKFt0LGVdLFwibW9kXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSwoZnVuY3Rpb24odCxlKXt2YXIgbj10JWU7cmV0dXJuIHQ8MCYmZTwwfHx0Pj0wJiZlPj0wP246KG4rZSklZX0pKX0sby5wcm90b3R5cGUubWF4PWZ1bmN0aW9uKHQsZSl7ZGYodCxcIm1heFwiKSxDbihcIm1heFwiLGUsdC5yYW5rKTtmb3IodmFyIG49Ym4odC5zaGFwZSxlKSxyPW5bMF0sbz1uWzFdLGE9R24ocix0LmR0eXBlKSxpPWsobykscz10aGlzLnJlYWRTeW5jKGEuZGF0YUlkKSx1PXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGM9MDtjPHMubGVuZ3RoOysrYyl7Zm9yKHZhciBsPWMqaSxoPXVbbF0sZj0wO2Y8aTsrK2Ype3ZhciBkPXVbbCtmXTtkPmgmJihoPWQpfXNbY109aH1yZXR1cm4gYX0sby5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbih0LGUpe3JldHVybiBkZihbdCxlXSxcIm1heGltdW1cIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLChmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLm1heCh0LGUpfSkpfSxvLnByb3RvdHlwZS5hbGw9ZnVuY3Rpb24odCxlKXtkZih0LFwiYWxsXCIpLENuKFwiYWxsXCIsZSx0LnJhbmspO2Zvcih2YXIgbj1ibih0LnNoYXBlLGUpLHI9blswXSxvPW5bMV0sYT1HbihyLHQuZHR5cGUpLGk9ayhvKSxzPXRoaXMucmVhZFN5bmMoYS5kYXRhSWQpLHU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYz0wO2M8cy5sZW5ndGg7KytjKXtmb3IodmFyIGw9YyppLGg9dVtsXSxmPTA7ZjxpOysrZil7dmFyIGQ9dVtsK2ZdO2g9aCYmZH1zW2NdPWh9cmV0dXJuIGF9LG8ucHJvdG90eXBlLmFueT1mdW5jdGlvbih0LGUpe2RmKHQsXCJhbnlcIiksQ24oXCJhbnlcIixlLHQucmFuayk7Zm9yKHZhciBuPWJuKHQuc2hhcGUsZSkscj1uWzBdLG89blsxXSxhPUduKHIsdC5kdHlwZSksaT1rKG8pLHM9dGhpcy5yZWFkU3luYyhhLmRhdGFJZCksdT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxjPTA7YzxzLmxlbmd0aDsrK2Mpe2Zvcih2YXIgbD1jKmksaD11W2xdLGY9MDtmPGk7KytmKXt2YXIgZD11W2wrZl07aD1ofHxkfXNbY109aH1yZXR1cm4gYX0sby5wcm90b3R5cGUuc3F1YXJlZERpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZGYoW3QsZV0sXCJzcXVhcmVkRGlmZmVyZW5jZVwiKSx0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AodCxlLHQuZHR5cGUsKGZ1bmN0aW9uKHQsZSl7dmFyIG49dC1lO3JldHVybiBuKm59KSl9LG8ucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24odCl7ZGYodCxcImNlaWxcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKW5bcl09TWF0aC5jZWlsKGVbcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZmxvb3I9ZnVuY3Rpb24odCl7ZGYodCxcImZsb29yXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPU1hdGguZmxvb3IoZVtyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKHQpe2RmKHQsXCJ4XCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcillW3JdPDA/bltyXT0tMTplW3JdPjA/bltyXT0xOm5bcl09MDtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmlzTmFOPWZ1bmN0aW9uKHQpe2RmKHQsXCJ4XCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpTnVtYmVyLmlzTmFOKGVbcl0pJiYobltyXT0xKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImJvb2xcIil9LG8ucHJvdG90eXBlLmlzSW5mPWZ1bmN0aW9uKHQpe2RmKHQsXCJ4XCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3IpTWF0aC5hYnMoZVtyXSk9PT0xLzAmJihuW3JdPTEpO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiYm9vbFwiKX0sby5wcm90b3R5cGUuaXNGaW5pdGU9ZnVuY3Rpb24odCl7ZGYodCxcInhcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcilOdW1iZXIuaXNGaW5pdGUoZVtyXSkmJihuW3JdPTEpO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiYm9vbFwiKX0sby5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24odCl7ZGYodCxcInJvdW5kXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrcil7dmFyIG89TWF0aC5mbG9vcihlW3JdKTtlW3JdLW88LjU/bltyXT1NYXRoLmZsb29yKGVbcl0pOmVbcl0tbz4uNT9uW3JdPU1hdGguY2VpbChlW3JdKTpuW3JdPW8lMj09MD9vOm8rMX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmV4cD1mdW5jdGlvbih0KXtkZih0LFwiZXhwXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPU1hdGguZXhwKGVbcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZXhwbTE9ZnVuY3Rpb24odCl7ZGYodCxcImV4cG0xXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPU1hdGguZXhwbTEoZVtyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24odCl7ZGYodCxcImxvZ1wiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT1NYXRoLmxvZyhvKX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmxvZzFwPWZ1bmN0aW9uKHQpe2RmKHQsXCJsb2cxcFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT1NYXRoLmxvZzFwKG8pfXJldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuc3FydD1mdW5jdGlvbih0KXtkZih0LFwic3FydFwiKTtmb3IodmFyIGU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbj1uZXcgRmxvYXQzMkFycmF5KGUubGVuZ3RoKSxyPTA7cjxlLmxlbmd0aDsrK3Ipe3ZhciBvPWVbcl07bltyXT1NYXRoLnNxcnQobyl9cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5yc3FydD1mdW5jdGlvbih0KXtkZih0LFwicnNxcnRcIik7Zm9yKHZhciBlPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG49bmV3IEZsb2F0MzJBcnJheShlLmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKXt2YXIgbz1lW3JdO25bcl09MS9NYXRoLnNxcnQobyl9cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5yZWNpcHJvY2FsPWZ1bmN0aW9uKHQpe2RmKHQsXCJyZWNpcHJvY2FsXCIpO2Zvcih2YXIgZT10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxuPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpLHI9MDtyPGUubGVuZ3RoOysrciluW3JdPTEvZVtyXTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KG4sdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmxpbmVhcj1mdW5jdGlvbih0KXtyZXR1cm4gdH0sby5wcm90b3R5cGUucmVsdT1mdW5jdGlvbih0KXtkZih0LFwicmVsdVwiKTtmb3IodmFyIGU9R24odC5zaGFwZSx0LmR0eXBlKSxuPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHI9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbz0wO288ci5sZW5ndGg7KytvKW5bb109TWF0aC5tYXgoMCxyW29dKTtyZXR1cm4gZX0sby5wcm90b3R5cGUucmVsdTY9ZnVuY3Rpb24odCl7ZGYodCxcInJlbHVcIik7Zm9yKHZhciBlPUduKHQuc2hhcGUsdC5kdHlwZSksbj10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxyPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG89MDtvPHIubGVuZ3RoOysrbyluW29dPU1hdGgubWluKE1hdGgubWF4KDAscltvXSksNik7cmV0dXJuIGV9LG8ucHJvdG90eXBlLnByZWx1PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGRmKFt0LGVdLFwicHJlbHVcIiksdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKHQsZSx0LmR0eXBlLChmdW5jdGlvbih0LGUpe3JldHVybiB0PDA/ZSp0OnR9KSl9LG8ucHJvdG90eXBlLmVsdT1mdW5jdGlvbih0KXtkZih0LFwiZWx1XCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3Ipe3ZhciBvPW5bcl07ZVtyXT1vPj0wP286TWF0aC5leHAobyktMX1yZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSxcImZsb2F0MzJcIil9LG8ucHJvdG90eXBlLmVsdURlcj1mdW5jdGlvbih0LGUpe2RmKFt0LGVdLFwiZWx1RGVyXCIpO2Zvcih2YXIgbj1uZXcgRmxvYXQzMkFycmF5KGUuc2l6ZSkscj10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxvPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGE9MDthPHIubGVuZ3RoOysrYSl7dmFyIGk9clthXTtuW2FdPWk+PTE/b1thXTpvW2FdKihpKzEpfXJldHVybiB0aGlzLm1ha2VPdXRwdXQobixlLnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuc2VsdT1mdW5jdGlvbih0KXtkZih0LFwic2VsdVwiKTtmb3IodmFyIGU9c3Usbj11dSxyPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxvPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGE9MDthPG8ubGVuZ3RoOysrYSl7dmFyIGk9b1thXTtyW2FdPWk+PTA/bippOmUqKE1hdGguZXhwKGkpLTEpfXJldHVybiB0aGlzLm1ha2VPdXRwdXQocix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuY2xpcD1mdW5jdGlvbih0LGUsbil7ZGYodCxcImNsaXBcIik7Zm9yKHZhciByPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxvPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGE9MDthPG8ubGVuZ3RoOysrYSl7dmFyIGk9b1thXTtyW2FdPWk+bj9uOmk8ZT9lOml9cmV0dXJuIHRoaXMubWFrZU91dHB1dChyLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hYnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPU1hdGguYWJzKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuY29tcGxleEFicz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8dC5zaXplOysrcil7dmFyIG89blsyKnJdLGE9blsyKnIrMV07ZVtyXT1NYXRoLmh5cG90KG8sYSl9cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5pbnQ9ZnVuY3Rpb24odCl7ZGYodCxcImludFwiKTtmb3IodmFyIGU9bmV3IEludDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcillW3JdPW5bcl07cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJpbnQzMlwiKX0sby5wcm90b3R5cGUuc2lnbW9pZD1mdW5jdGlvbih0KXtkZih0LFwic2lnbW9pZFwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09MS8oMStNYXRoLmV4cCgtbltyXSkpO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuc29mdHBsdXM9ZnVuY3Rpb24odCl7ZGYodCxcInNvZnRwbHVzXCIpO2Zvcih2YXIgZT1NYXRoLmxvZygxLjE5MjA5Mjg5NTUwNzgxMjVlLTcpKzIsbj1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSkscj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxvPTA7bzxyLmxlbmd0aDsrK28pe3ZhciBhPXJbb10+LWUsaT1yW29dPGUscz1NYXRoLmV4cChyW29dKSx1PXZvaWQgMDt1PWk/czphP3Jbb106TWF0aC5sb2coMStzKSxuW29dPXV9cmV0dXJuIHRoaXMubWFrZU91dHB1dChuLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5zaW49ZnVuY3Rpb24odCl7ZGYodCxcInNpblwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5zaW4obltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5jb3M9ZnVuY3Rpb24odCl7ZGYodCxcImNvc1wiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC5jb3MobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS50YW49ZnVuY3Rpb24odCl7ZGYodCxcInRhblwiKTtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLG49dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkscj0wO3I8bi5sZW5ndGg7KytyKWVbcl09TWF0aC50YW4obltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hc2luPWZ1bmN0aW9uKHQpe2RmKHQsXCJhc2luXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFzaW4obltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKHQpe2RmKHQsXCJhY29zXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFjb3MobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hdGFuPWZ1bmN0aW9uKHQpe2RmKHQsXCJhdGFuXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmF0YW4obltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5hdGFuMj1mdW5jdGlvbih0LGUpe3JldHVybiBkZihbdCxlXSxcImF0YW4yXCIpLHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcCh0LGUsdC5kdHlwZSwoZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5hdGFuMih0LGUpfSkpfSxvLnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKHQpe2RmKHQsXCJzaW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLnNpbmgobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS5jb3NoPWZ1bmN0aW9uKHQpe2RmKHQsXCJjb3NoXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmNvc2gobltyXSk7cmV0dXJuIHRoaXMubWFrZU91dHB1dChlLHQuc2hhcGUsXCJmbG9hdDMyXCIpfSxvLnByb3RvdHlwZS50YW5oPWZ1bmN0aW9uKHQpe2RmKHQsXCJ0YW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1UKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24odCl7ZGYodCxcImFzaW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFzaW5oKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYWNvc2g9ZnVuY3Rpb24odCl7ZGYodCxcImFjb3NoXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmFjb3NoKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuYXRhbmg9ZnVuY3Rpb24odCl7ZGYodCxcImF0YW5oXCIpO2Zvcih2YXIgZT1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSksbj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxyPTA7cjxuLmxlbmd0aDsrK3IpZVtyXT1NYXRoLmF0YW5oKG5bcl0pO3JldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZXJmPWZ1bmN0aW9uKHQpe2RmKHQsXCJlcmZcIik7Zm9yKHZhciBlPW5ldyBGbG9hdDMyQXJyYXkodC5zaXplKSxuPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHI9MDtyPG4ubGVuZ3RoOysrcil7dmFyIG89TWF0aC5zaWduKG5bcl0pLGE9TWF0aC5hYnMobltyXSksaT0xLygxKy4zMjc1OTExKmEpO2Vbcl09byooMS0oKCgoMS4wNjE0MDU0MjkqaS0xLjQ1MzE1MjAyNykqaSsxLjQyMTQxMzc0MSkqaS0uMjg0NDk2NzM2KSppKy4yNTQ4Mjk1OTIpKmkqTWF0aC5leHAoLWEqYSkpfXJldHVybiB0aGlzLm1ha2VPdXRwdXQoZSx0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuc3RlcD1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApLGRmKHQsXCJzdGVwXCIpO2Zvcih2YXIgbj1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSkscj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxvPTA7bzxyLmxlbmd0aDsrK28pe3ZhciBhPXJbb107aXNOYU4oYSk/bltvXT1OYU46bltvXT1hPjA/MTplfXJldHVybiB0aGlzLm1ha2VPdXRwdXQobix0LnNoYXBlLFwiZmxvYXQzMlwiKX0sby5wcm90b3R5cGUuZnVzZWRDb252MmQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dCxuPXQuZmlsdGVyLHI9dC5jb252SW5mbyxvPXQuYmlhcyxhPXQuYWN0aXZhdGlvbixpPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyxzPXRoaXMuY29udjJkKGUsbixyKTtyZXR1cm4gbyYmKHM9dGhpcy5hZGQocyxvKSksYSYmKHM9Z2YodGhpcyxzLGEsaSkpLHN9LG8ucHJvdG90eXBlLmNvbnYyZD1mdW5jdGlvbih0LGUsbil7ZGYoW3QsZV0sXCJjb252MmRcIik7Zm9yKHZhciByPW4uZmlsdGVySGVpZ2h0LG89bi5maWx0ZXJXaWR0aCxhPW4uZGlsYXRpb25IZWlnaHQsaT1uLmRpbGF0aW9uV2lkdGgscz1uLnBhZEluZm8ubGVmdCx1PW4ucGFkSW5mby50b3AsYz1cImNoYW5uZWxzTGFzdFwiPT09bi5kYXRhRm9ybWF0LGw9ZXIobi5vdXRTaGFwZSx0LmR0eXBlKSxoPXQuc3RyaWRlc1swXSxmPWM/dC5zdHJpZGVzWzFdOnQuc3RyaWRlc1syXSxkPWM/dC5zdHJpZGVzWzJdOjEscD1jPzE6dC5zdHJpZGVzWzFdLHY9bC5zdHJpZGVzWzBdLGc9Yz9sLnN0cmlkZXNbMV06bC5zdHJpZGVzWzJdLG09Yz9sLnN0cmlkZXNbMl06MSx5PWM/MTpsLnN0cmlkZXNbMV0seD10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxiPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHc9bC52YWx1ZXMsQz0wO0M8bi5iYXRjaFNpemU7KytDKWZvcih2YXIgRT1DKmgsUj1DKnYsST0wO0k8bi5vdXRIZWlnaHQ7KytJKWZvcih2YXIgaz1SK0kqZyxTPUkqbi5zdHJpZGVIZWlnaHQtdSxBPTA7QTxyO0ErKyl7dmFyIFQ9UytBKmE7aWYoIShUPDB8fFQ+PW4uaW5IZWlnaHQpKWZvcih2YXIgRD1BKmUuc3RyaWRlc1swXSxOPUUrVCpmLEY9MDtGPG4ub3V0V2lkdGg7KytGKWZvcih2YXIgXz1rK0YqbSxPPUYqbi5zdHJpZGVXaWR0aC1zLE09MDtNPG87TSsrKXt2YXIgQj1PK00qaTtpZighKEI8MHx8Qj49bi5pbldpZHRoKSlmb3IodmFyIFA9TitCKmQsTD1EK00qZS5zdHJpZGVzWzFdLFc9MDtXPG4uaW5DaGFubmVsczsrK1cpe2Zvcih2YXIgVT14W1ArVypwXSxWPTA7VjxuLm91dENoYW5uZWxzOysrVil3W18rVip5XSs9VSpiW0wrVl07TCs9bi5vdXRDaGFubmVsc319fXJldHVybiBsLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmNvbnYzZD1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciByPW4uZmlsdGVyRGVwdGgsbz1uLmZpbHRlckhlaWdodCxhPW4uZmlsdGVyV2lkdGgsaT1uLmRpbGF0aW9uRGVwdGgscz1uLmRpbGF0aW9uSGVpZ2h0LHU9bi5kaWxhdGlvbldpZHRoLGM9bi5wYWRJbmZvLmZyb250LGw9bi5wYWRJbmZvLmxlZnQsaD1uLnBhZEluZm8udG9wLGY9ZXIobi5vdXRTaGFwZSx0LmR0eXBlKSxkPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHA9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksdj1mLnZhbHVlcyxnPTA7ZzxuLmJhdGNoU2l6ZTsrK2cpZm9yKHZhciBtPWcqdC5zdHJpZGVzWzBdLHk9ZypmLnN0cmlkZXNbMF0seD0wO3g8bi5vdXREZXB0aDsrK3gpZm9yKHZhciBiPXkreCpmLnN0cmlkZXNbMV0sdz14Km4uc3RyaWRlRGVwdGgtYyxDPTA7QzxyO0MrKyl7dmFyIEU9dytDKmk7aWYoIShFPDB8fEU+PW4uaW5EZXB0aCkpZm9yKHZhciBSPUMqZS5zdHJpZGVzWzBdLEk9bStFKnQuc3RyaWRlc1sxXSxrPTA7azxuLm91dEhlaWdodDsrK2spZm9yKHZhciBTPWIraypmLnN0cmlkZXNbMl0sQT1rKm4uc3RyaWRlSGVpZ2h0LWgsVD0wO1Q8bztUKyspe3ZhciBEPUErVCpzO2lmKCEoRDwwfHxEPj1uLmluSGVpZ2h0KSlmb3IodmFyIE49UitUKmUuc3RyaWRlc1sxXSxGPUkrRCp0LnN0cmlkZXNbMl0sXz0wO188bi5vdXRXaWR0aDsrK18pZm9yKHZhciBPPVMrXypuLm91dENoYW5uZWxzLE09XypuLnN0cmlkZVdpZHRoLWwsQj0wO0I8YTtCKyspe3ZhciBQPU0rQip1O2lmKCEoUDwwfHxQPj1uLmluV2lkdGgpKWZvcih2YXIgTD1OK0IqZS5zdHJpZGVzWzJdLFc9RitQKm4uaW5DaGFubmVscyxVPUwsVj0wO1Y8bi5pbkNoYW5uZWxzOysrVil7Zm9yKHZhciB6PWRbVytWXSxHPTA7RzxuLm91dENoYW5uZWxzOysrRyl2W08rR10rPXoqcFtVK0ddO1UrPW4ub3V0Q2hhbm5lbHN9fX19cmV0dXJuIGYudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuY29udjJkRGVySW5wdXQ9ZnVuY3Rpb24odCxlLG4pe2RmKFt0LGVdLFwiY29udjJkRGVySW5wdXRcIik7Zm9yKHZhciByPWVyKG4uaW5TaGFwZSxcImZsb2F0MzJcIiksbz1yLnZhbHVlcyxhPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGk9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCkscz1lLnN0cmlkZXMsdT1zWzBdLGM9c1sxXSxsPXNbMl0saD1uLmJhdGNoU2l6ZSxmPW4uZmlsdGVySGVpZ2h0LGQ9bi5maWx0ZXJXaWR0aCxwPW4uaW5DaGFubmVscyx2PW4uaW5IZWlnaHQsZz1uLmluV2lkdGgsbT1uLm91dENoYW5uZWxzLHk9bi5vdXRIZWlnaHQseD1uLm91dFdpZHRoLGI9bi5zdHJpZGVIZWlnaHQsdz1uLnN0cmlkZVdpZHRoLEM9bi5kYXRhRm9ybWF0LEU9Zi0xLW4ucGFkSW5mby50b3AsUj1kLTEtbi5wYWRJbmZvLmxlZnQsST1cImNoYW5uZWxzTGFzdFwiPT09QyxrPXIuc3RyaWRlc1swXSxTPUk/ci5zdHJpZGVzWzFdOnIuc3RyaWRlc1syXSxBPUk/ci5zdHJpZGVzWzJdOjEsVD1JPzE6ci5zdHJpZGVzWzFdLEQ9dC5zdHJpZGVzWzBdLE49ST90LnN0cmlkZXNbMV06dC5zdHJpZGVzWzJdLEY9ST90LnN0cmlkZXNbMl06MSxfPUk/MTp0LnN0cmlkZXNbMV0sTz0wO088aDsrK08pZm9yKHZhciBNPTA7TTxwOysrTSlmb3IodmFyIEI9MDtCPHY7KytCKWZvcih2YXIgUD1CLUUsTD1NYXRoLm1heCgwLE1hdGguY2VpbChQL2IpKSxXPU1hdGgubWluKHksKGYrUCkvYiksVT0wO1U8ZzsrK1Upe2Zvcih2YXIgVj1VLVIsej1NYXRoLm1heCgwLE1hdGguY2VpbChWL3cpKSxHPU1hdGgubWluKHgsKGQrVikvdyksSD0wLHE9TDtxPFc7KytxKWZvcih2YXIgSz1xKmItUCxqPXo7ajxHOysrailmb3IodmFyIFg9RCpPK04qcStGKmosWT11KihmLTEtSykrYyooZC0xLShqKnctVikpK2wqTSwkPTA7JDxtOysrJCl7SCs9YVtYK18qJF0qaVtZKyRdfW9baypPK1MqQitBKlUrVCpNXT1IfXJldHVybiByLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmNvbnYzZERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9ZXIobi5pblNoYXBlLFwiZmxvYXQzMlwiKSxvPXIudmFsdWVzLGE9ci5zdHJpZGVzLGk9YVswXSxzPWFbMV0sdT1hWzJdLGM9YVszXSxsPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGg9dC5zdHJpZGVzLGY9aFswXSxkPWhbMV0scD1oWzJdLHY9aFszXSxnPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLG09ZS5zdHJpZGVzLHk9bVswXSx4PW1bMV0sYj1tWzJdLHc9bVszXSxDPW4uYmF0Y2hTaXplLEU9bi5maWx0ZXJEZXB0aCxSPW4uZmlsdGVySGVpZ2h0LEk9bi5maWx0ZXJXaWR0aCxrPW4uaW5DaGFubmVscyxTPW4uaW5EZXB0aCxBPW4uaW5IZWlnaHQsVD1uLmluV2lkdGgsRD1uLm91dENoYW5uZWxzLE49bi5vdXREZXB0aCxGPW4ub3V0SGVpZ2h0LF89bi5vdXRXaWR0aCxPPW4uc3RyaWRlRGVwdGgsTT1uLnN0cmlkZUhlaWdodCxCPW4uc3RyaWRlV2lkdGgsUD1FLTEtbi5wYWRJbmZvLmZyb250LEw9Ui0xLW4ucGFkSW5mby50b3AsVz1JLTEtbi5wYWRJbmZvLmxlZnQsVT0wO1U8QzsrK1UpZm9yKHZhciBWPTA7VjxrOysrVilmb3IodmFyIHo9MDt6PFM7Kyt6KWZvcih2YXIgRz16LVAsSD1NYXRoLm1heCgwLE1hdGguY2VpbChHL08pKSxxPU1hdGgubWluKE4sKEUrRykvTyksSz0wO0s8QTsrK0spZm9yKHZhciBqPUstTCxYPU1hdGgubWF4KDAsTWF0aC5jZWlsKGovTSkpLFk9TWF0aC5taW4oRiwoUitqKS9NKSwkPTA7JDxUOysrJCl7Zm9yKHZhciBRPSQtVyxKPU1hdGgubWF4KDAsTWF0aC5jZWlsKFEvQikpLFo9TWF0aC5taW4oXywoSStRKS9CKSx0dD0wLGV0PUg7ZXQ8cTsrK2V0KWZvcih2YXIgbnQ9ZXQqTy1HLHJ0PVg7cnQ8WTsrK3J0KWZvcih2YXIgb3Q9cnQqTS1qLGF0PUo7YXQ8WjsrK2F0KWZvcih2YXIgaXQ9ZipVK2QqZXQrcCpydCt2KmF0LHN0PXkqKEUtMS1udCkreCooUi0xLW90KStiKihJLTEtKGF0KkItUSkpK3cqVix1dD0wO3V0PEQ7Kyt1dCl7dHQrPWxbaXQrdXRdKmdbc3QrdXRdfW9baSpVK3Mqeit1KksrYyokK1ZdPXR0fXJldHVybiByLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmNvbnYyZERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7ZGYoW3QsZV0sXCJjb252MmREZXJGaWx0ZXJcIik7Zm9yKHZhciByPW4uc3RyaWRlSGVpZ2h0LG89bi5zdHJpZGVXaWR0aCxhPW4uZmlsdGVySGVpZ2h0LGk9bi5maWx0ZXJXaWR0aCxzPVwiY2hhbm5lbHNMYXN0XCI9PT1uLmRhdGFGb3JtYXQsdT1lcihuLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSxjPW4ucGFkSW5mby5sZWZ0LGw9bi5wYWRJbmZvLnRvcCxoPXRoaXMuYnVmZmVyU3luYyh0KSxmPXRoaXMuYnVmZmVyU3luYyhlKSxkPTA7ZDxhOysrZClmb3IodmFyIHA9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKGwtZCkvcikpLHY9TWF0aC5taW4obi5vdXRIZWlnaHQsKG4uaW5IZWlnaHQrbC1kKS9yKSxnPTA7ZzxpOysrZylmb3IodmFyIG09TWF0aC5tYXgoMCxNYXRoLmNlaWwoKGMtZykvbykpLHk9TWF0aC5taW4obi5vdXRXaWR0aCwobi5pbldpZHRoK2MtZykvbykseD0wO3g8bi5pbkNoYW5uZWxzOysreClmb3IodmFyIGI9MDtiPG4ub3V0Q2hhbm5lbHM7KytiKXtmb3IodmFyIHc9MCxDPTA7QzxuLmJhdGNoU2l6ZTsrK0MpZm9yKHZhciBFPXA7RTx2OysrRSlmb3IodmFyIFI9ZCtFKnItbCxJPW07STx5OysrSSl7dmFyIGs9ZytJKm8tYzt3Kz1zP2guZ2V0KEMsUixrLHgpKmYuZ2V0KEMsRSxJLGIpOmguZ2V0KEMseCxSLGspKmYuZ2V0KEMsYixFLEkpfXUuc2V0KHcsZCxnLHgsYil9cmV0dXJuIHUudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuY29udjNkRGVyRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9bi5zdHJpZGVEZXB0aCxvPW4uc3RyaWRlSGVpZ2h0LGE9bi5zdHJpZGVXaWR0aCxpPW4uZmlsdGVyRGVwdGgscz1uLmZpbHRlckhlaWdodCx1PW4uZmlsdGVyV2lkdGgsYz1lcihuLmZpbHRlclNoYXBlLFwiZmxvYXQzMlwiKSxsPWMudmFsdWVzLGg9Yy5zdHJpZGVzLGY9aFswXSxkPWhbMV0scD1oWzJdLHY9aFszXSxnPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLG09ZS5zdHJpZGVzLHk9bVswXSx4PW1bMV0sYj1tWzJdLHc9bVszXSxDPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLEU9dC5zdHJpZGVzLFI9RVswXSxJPUVbMV0saz1FWzJdLFM9RVszXSxBPW4ucGFkSW5mby5mcm9udCxUPW4ucGFkSW5mby5sZWZ0LEQ9bi5wYWRJbmZvLnRvcCxOPTA7TjxpOysrTilmb3IodmFyIEY9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKEEtTikvcikpLF89TWF0aC5taW4obi5vdXREZXB0aCwobi5pbkRlcHRoK0EtTikvciksTz1OKmYsTT0wO008czsrK00pZm9yKHZhciBCPU1hdGgubWF4KDAsTWF0aC5jZWlsKChELU0pL28pKSxQPU1hdGgubWluKG4ub3V0SGVpZ2h0LChuLmluSGVpZ2h0K0QtTSkvbyksTD1NKmQrTyxXPTA7Vzx1OysrVylmb3IodmFyIFU9TWF0aC5tYXgoMCxNYXRoLmNlaWwoKFQtVykvYSkpLFY9TWF0aC5taW4obi5vdXRXaWR0aCwobi5pbldpZHRoK1QtVykvYSksej1XKnArTCxHPTA7RzxuLmluQ2hhbm5lbHM7KytHKWZvcih2YXIgSD1HKnYreixxPTA7cTxuLm91dENoYW5uZWxzOysrcSl7Zm9yKHZhciBLPTAsaj0wO2o8bi5iYXRjaFNpemU7KytqKWZvcih2YXIgWD1qKlIsWT1qKnksJD1GOyQ8XzsrKyQpZm9yKHZhciBRPShOKyQqci1BKSpJK1gsSj0kKngrWSxaPUI7WjxQOysrWilmb3IodmFyIHR0PShNK1oqby1EKSprK1EsZXQ9WipiK0osbnQ9VTtudDxWOysrbnQpe3ZhciBydD1udCp3K2V0O0srPUNbKFcrbnQqYS1UKSpTK3R0K0ddKmdbcnQrcV19bFtIK3FdPUt9cmV0dXJuIGMudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuZnVzZWREZXB0aHdpc2VDb252MkQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnB1dCxuPXQuZmlsdGVyLHI9dC5jb252SW5mbyxvPXQuYmlhcyxhPXQuYWN0aXZhdGlvbixpPXQucHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyxzPXRoaXMuZGVwdGh3aXNlQ29udjJEKGUsbixyKTtyZXR1cm4gbyYmKHM9dGhpcy5hZGQocyxvKSksYSYmKHM9Z2YodGhpcyxzLGEsaSkpLHN9LG8ucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRD1mdW5jdGlvbih0LGUsbil7ZGYoW3QsZV0sXCJkZXB0aHdpc2VDb252MkRcIik7Zm9yKHZhciByPW4uZmlsdGVySGVpZ2h0LG89bi5maWx0ZXJXaWR0aCxhPW4uZGlsYXRpb25IZWlnaHQsaT1uLmRpbGF0aW9uV2lkdGgscz1uLnBhZEluZm8ubGVmdCx1PW4ucGFkSW5mby50b3AsYz1uLm91dENoYW5uZWxzL24uaW5DaGFubmVscyxsPWVyKG4ub3V0U2hhcGUsdC5kdHlwZSksaD10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxmPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLGQ9bC52YWx1ZXMscD0wO3A8bi5iYXRjaFNpemU7KytwKWZvcih2YXIgdj1wKnQuc3RyaWRlc1swXSxnPXAqbC5zdHJpZGVzWzBdLG09MDttPG4ub3V0SGVpZ2h0OysrbSlmb3IodmFyIHk9ZyttKmwuc3RyaWRlc1sxXSx4PW0qbi5zdHJpZGVIZWlnaHQtcyxiPTA7YjxyOysrYil7dmFyIHc9eCtiKmE7aWYoISh3PDB8fHc+PW4uaW5IZWlnaHQpKWZvcih2YXIgQz1iKmUuc3RyaWRlc1swXSxFPXYrdyp0LnN0cmlkZXNbMV0sUj0wO1I8bi5vdXRXaWR0aDsrK1IpZm9yKHZhciBJPXkrUipsLnN0cmlkZXNbMl0saz1SKm4uc3RyaWRlV2lkdGgtdSxTPTA7UzxvOysrUyl7dmFyIEE9aytTKmk7aWYoIShBPDB8fEE+PW4uaW5XaWR0aCkpZm9yKHZhciBUPUMrUyplLnN0cmlkZXNbMV0sRD1FK0Eqbi5pbkNoYW5uZWxzLE49SSxGPVQsXz0wO188bi5pbkNoYW5uZWxzOysrXyl7Zm9yKHZhciBPPWhbRCtfXSxNPTA7TTxjOysrTSlkW04rTV0rPU8qZltGK01dO04rPWMsRis9Y319fXJldHVybiBsLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlcklucHV0PWZ1bmN0aW9uKHQsZSxuKXtkZihbdCxlXSxcImRlcHRod2lzZUNvbnYyRERlcklucHV0XCIpO2Zvcih2YXIgcj1lcihuLmluU2hhcGUsXCJmbG9hdDMyXCIpLG89ci52YWx1ZXMsYT1yLnN0cmlkZXMsaT1hWzBdLHM9YVsxXSx1PWFbMl0sYz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxsPXQuc3RyaWRlcyxoPWxbMF0sZj1sWzFdLGQ9bFsyXSxwPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpLHY9ZS5zdHJpZGVzLGc9dlswXSxtPXZbMV0seT12WzJdLHg9bi5iYXRjaFNpemUsYj1uLmZpbHRlckhlaWdodCx3PW4uZmlsdGVyV2lkdGgsQz1uLmluQ2hhbm5lbHMsRT1uLmluSGVpZ2h0LFI9bi5pbldpZHRoLEk9bi5vdXRDaGFubmVscyxrPW4ub3V0SGVpZ2h0LFM9bi5vdXRXaWR0aCxBPW4uc3RyaWRlSGVpZ2h0LFQ9bi5zdHJpZGVXaWR0aCxEPWItMS1uLnBhZEluZm8udG9wLE49dy0xLW4ucGFkSW5mby5sZWZ0LEY9SS9DLF89MDtfPHg7KytfKWZvcih2YXIgTz0wO088QzsrK08pZm9yKHZhciBNPTA7TTxFOysrTSlmb3IodmFyIEI9TS1ELFA9TWF0aC5tYXgoMCxNYXRoLmNlaWwoQi9BKSksTD1NYXRoLm1pbihrLChiK0IpL0EpLFc9MDtXPFI7KytXKXtmb3IodmFyIFU9Vy1OLFY9TWF0aC5tYXgoMCxNYXRoLmNlaWwoVS9UKSksej1NYXRoLm1pbihTLCh3K1UpL1QpLEc9MCxIPVA7SDxMOysrSClmb3IodmFyIHE9SCpBLUIsSz1WO0s8ejsrK0spZm9yKHZhciBqPWgqXytmKkgrZCpLLFg9ZyooYi0xLXEpK20qKHctMS0oSypULVUpKSt5Kk8sWT0wO1k8RjsrK1kpe0crPWNbaisoTypGK1kpXSpwW1grWV19b1tpKl8rcypNK3UqVytPXT1HfXJldHVybiByLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRERlckZpbHRlcj1mdW5jdGlvbih0LGUsbil7ZGYoW3QsZV0sXCJkZXB0aHdpc2VDb252MkREZXJGaWx0ZXJcIik7Zm9yKHZhciByPW4uc3RyaWRlSGVpZ2h0LG89bi5zdHJpZGVXaWR0aCxhPW4uZmlsdGVySGVpZ2h0LGk9bi5maWx0ZXJXaWR0aCxzPWVyKG4uZmlsdGVyU2hhcGUsXCJmbG9hdDMyXCIpLHU9bi5wYWRJbmZvLmxlZnQsYz1uLnBhZEluZm8udG9wLGw9bi5vdXRDaGFubmVscy9uLmluQ2hhbm5lbHMsaD10aGlzLmJ1ZmZlclN5bmModCksZj10aGlzLmJ1ZmZlclN5bmMoZSksZD0wO2Q8YTsrK2QpZm9yKHZhciBwPU1hdGgubWF4KDAsTWF0aC5jZWlsKChjLWQpL3IpKSx2PU1hdGgubWluKG4ub3V0SGVpZ2h0LChuLmluSGVpZ2h0K2MtZCkvciksZz0wO2c8aTsrK2cpZm9yKHZhciBtPU1hdGgubWF4KDAsTWF0aC5jZWlsKCh1LWcpL28pKSx5PU1hdGgubWluKG4ub3V0V2lkdGgsKG4uaW5XaWR0aCt1LWcpL28pLHg9MDt4PG4ub3V0Q2hhbm5lbHM7Kyt4KXtmb3IodmFyIGI9TWF0aC50cnVuYyh4L2wpLHc9eCVsLEM9MCxFPTA7RTxuLmJhdGNoU2l6ZTsrK0UpZm9yKHZhciBSPXA7Ujx2OysrUilmb3IodmFyIEk9ZCtSKnItYyxrPW07azx5Oysrayl7dmFyIFM9ZytrKm8tdTtDKz1oLmdldChFLEksUyxiKSpmLmdldChFLFIsayx4KX1zLnNldChDLGQsZyxiLHcpfXJldHVybiBzLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZGYodCxcInRpbGVcIiksVmEodGhpcy5idWZmZXJTeW5jKHQpLGUpfSxvLnByb3RvdHlwZS5wYWQ9ZnVuY3Rpb24odCxlLG4pe2RmKHQsXCJwYWRcIik7dmFyIHI9ZS5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGVbMF0rdC5zaGFwZVtuXStlWzFdfSkpLG89ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0WzBdfSkpLGE9dGhpcy5idWZmZXJTeW5jKHQpLGk9ZXIocix0LmR0eXBlKTswIT09biYmaS52YWx1ZXMuZmlsbChuKTtmb3IodmFyIHM9MDtzPHQuc2l6ZTtzKyspe3ZhciB1PWEuaW5kZXhUb0xvYyhzKSxjPXUubWFwKChmdW5jdGlvbih0LGUpe3JldHVybiB0K29bZV19KSk7aS5zZXQuYXBwbHkoaSxbYS5nZXQuYXBwbHkoYSx1KV0uY29uY2F0KGMpKX1yZXR1cm4gaS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5nYXRoZXI9ZnVuY3Rpb24odCxlLG4pe2RmKFt0LGVdLFwiZ2F0aGVyXCIpO3ZhciByPXQuc2hhcGUuc2xpY2UoKSxvPXRoaXMucmVhZFN5bmMoZS5kYXRhSWQpO3Jbbl09by5sZW5ndGg7Zm9yKHZhciBhPWVyKHIsdC5kdHlwZSksaT10aGlzLmJ1ZmZlclN5bmModCkscz0wO3M8YS5zaXplOysrcyl7dmFyIHU9YS5pbmRleFRvTG9jKHMpLGM9dS5zbGljZSgpO2Nbbl09b1t1W25dXTt2YXIgbD1pLmxvY1RvSW5kZXgoYyk7YS52YWx1ZXNbc109aS52YWx1ZXNbbF19cmV0dXJuIGEudG9UZW5zb3IoKX0sby5wcm90b3R5cGUuYmF0Y2hUb1NwYWNlTkQ9ZnVuY3Rpb24odCxlLG4pe2RmKFt0XSxcImJhdGNoVG9TcGFjZU5EXCIpO3ZhciByPWUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0KmV9KSksbz1wcih0LnNoYXBlLGUsciksYT12cihvLmxlbmd0aCxlLmxlbmd0aCksaT1ncih0LnNoYXBlLGUscikscz1tcihuLGUubGVuZ3RoKSx1PXlyKGksbixlLmxlbmd0aCk7cmV0dXJuIHVhKHQucmVzaGFwZShvKSxhKS5yZXNoYXBlKGkpLnNsaWNlKHMsdSl9LG8ucHJvdG90eXBlLnNwYWNlVG9CYXRjaE5EPWZ1bmN0aW9uKHQsZSxuKXtkZihbdF0sXCJzcGFjZVRvQmF0Y2hORFwiKTt2YXIgcj1lLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSkpLG89W1swLDBdXTtvLnB1c2guYXBwbHkobyxuKTtmb3IodmFyIGE9MStlLmxlbmd0aDthPHQuc2hhcGUubGVuZ3RoOysrYSlvLnB1c2goWzAsMF0pO3ZhciBpPXQucGFkKG8pLHM9cHIoaS5zaGFwZSxlLHIsITEpLHU9dnIocy5sZW5ndGgsZS5sZW5ndGgsITEpLGM9Z3IoaS5zaGFwZSxlLHIsITEpO3JldHVybiB1YShpLnJlc2hhcGUocyksdSkucmVzaGFwZShjKX0sby5wcm90b3R5cGUubWF4UG9vbD1mdW5jdGlvbih0LGUpe3JldHVybiBkZih0LFwibWF4UG9vbFwiKSxwZih0aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSx0LnNoYXBlLHQuZHR5cGUsdC5zdHJpZGVzLGUsXCJtYXhcIikudG9UZW5zb3IoKX0sby5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuLHIpe2RmKFtlLG5dLFwibWF4UG9vbEJhY2twcm9wXCIpO2Zvcih2YXIgbz10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxhPWVyKHIub3V0U2hhcGUsZS5kdHlwZSx2ZihvLGUuc2hhcGUsZS5kdHlwZSxyKS52YWx1ZXMpLGk9ci5zdHJpZGVIZWlnaHQscz1yLnN0cmlkZVdpZHRoLHU9ci5kaWxhdGlvbkhlaWdodCxjPXIuZGlsYXRpb25XaWR0aCxsPXIuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGg9ci5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxmPWgtMS1yLnBhZEluZm8ubGVmdCxkPWwtMS1yLnBhZEluZm8udG9wLHA9ZXIoZS5zaGFwZSxcImZsb2F0MzJcIiksdj10aGlzLmJ1ZmZlclN5bmModCksZz0wO2c8ci5iYXRjaFNpemU7KytnKWZvcih2YXIgbT0wO208ci5pbkNoYW5uZWxzOysrbSlmb3IodmFyIHk9MDt5PHIuaW5IZWlnaHQ7Kyt5KWZvcih2YXIgeD0wO3g8ci5pbldpZHRoOysreCl7Zm9yKHZhciBiPXktZCx3PXgtZixDPTAsRT0wO0U8bDtFKz11KXt2YXIgUj0oYitFKS9pO2lmKCEoUjwwfHxSPj1yLm91dEhlaWdodHx8TWF0aC5mbG9vcihSKSE9PVIpKWZvcih2YXIgST0wO0k8aDtJKz1jKXt2YXIgaz0odytJKS9zO2lmKCEoazwwfHxrPj1yLm91dFdpZHRofHxNYXRoLmZsb29yKGspIT09aykpe3ZhciBTPWwqaC0xLWEuZ2V0KGcsUixrLG0pPT09RSpoK0k/MTowO2lmKDAhPT1TKUMrPXYuZ2V0KGcsUixrLG0pKlN9fX1wLnNldChDLGcseSx4LG0pfXJldHVybiBwLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7ZGYoW3QsZV0sXCJhdmdQb29sQmFja3Byb3BcIik7Zm9yKHZhciByPW4uc3RyaWRlSGVpZ2h0LG89bi5zdHJpZGVXaWR0aCxhPW4uZmlsdGVySGVpZ2h0LGk9bi5maWx0ZXJXaWR0aCxzPW4uZGlsYXRpb25IZWlnaHQsdT1uLmRpbGF0aW9uV2lkdGgsYz1uLmVmZmVjdGl2ZUZpbHRlckhlaWdodCxsPW4uZWZmZWN0aXZlRmlsdGVyV2lkdGgsaD1sLTEtbi5wYWRJbmZvLmxlZnQsZj1jLTEtbi5wYWRJbmZvLnRvcCxkPWVyKGUuc2hhcGUsXCJmbG9hdDMyXCIpLHA9MS8oYSppKSx2PXRoaXMuYnVmZmVyU3luYyh0KSxnPTA7ZzxuLmJhdGNoU2l6ZTsrK2cpZm9yKHZhciBtPTA7bTxuLmluQ2hhbm5lbHM7KyttKWZvcih2YXIgeT0wO3k8bi5pbkhlaWdodDsrK3kpZm9yKHZhciB4PTA7eDxuLmluV2lkdGg7Kyt4KXtmb3IodmFyIGI9eS1mLHc9eC1oLEM9MCxFPTA7RTxjO0UrPXMpe3ZhciBSPShiK0UpL3I7aWYoIShSPDB8fFI+PW4ub3V0SGVpZ2h0fHxNYXRoLmZsb29yKFIpIT09UikpZm9yKHZhciBJPTA7STxsO0krPXUpe3ZhciBrPSh3K0kpL287aWYoIShrPDB8fGs+PW4ub3V0V2lkdGh8fE1hdGguZmxvb3IoaykhPT1rKSlDKz12LmdldChnLFIsayxtKX19ZC5zZXQoQypwLGcseSx4LG0pfXJldHVybiBkLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLnBvb2wzZD1mdW5jdGlvbih0LGUsbil7ZGYodCxcInBvb2wzZFwiKTtmb3IodmFyIHI9ZS5zdHJpZGVEZXB0aCxvPWUuc3RyaWRlSGVpZ2h0LGE9ZS5zdHJpZGVXaWR0aCxpPWUuZGlsYXRpb25EZXB0aCxzPWUuZGlsYXRpb25IZWlnaHQsdT1lLmRpbGF0aW9uV2lkdGgsYz1lLmVmZmVjdGl2ZUZpbHRlckRlcHRoLGw9ZS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsaD1lLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGY9ZS5wYWRJbmZvLmZyb250LGQ9ZS5wYWRJbmZvLnRvcCxwPWUucGFkSW5mby5sZWZ0LHY9XCJtYXhcIj09PW4/TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxnPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG09ZXIoZS5vdXRTaGFwZSx0LmR0eXBlKSx5PW0udmFsdWVzLHg9ZS5vdXRTaGFwZVsxXSplLm91dFNoYXBlWzJdKmUub3V0U2hhcGVbM10qZS5vdXRTaGFwZVs0XSxiPWUub3V0U2hhcGVbMl0qZS5vdXRTaGFwZVszXSplLm91dFNoYXBlWzRdLHc9ZS5vdXRTaGFwZVszXSplLm91dFNoYXBlWzRdLEM9ZS5vdXRTaGFwZVs0XSxFPTA7RTxlLmJhdGNoU2l6ZTsrK0UpZm9yKHZhciBSPUUqeCxJPUUqdC5zdHJpZGVzWzBdLGs9MDtrPGUuaW5DaGFubmVsczsrK2spZm9yKHZhciBTPTA7UzxlLm91dERlcHRoOysrUyl7Zm9yKHZhciBBPVMqci1mLFQ9QTtUPDA7KVQrPWk7Zm9yKHZhciBEPU1hdGgubWluKGUuaW5EZXB0aCxjK0EpLE49UitTKmIsRj0wO0Y8ZS5vdXRIZWlnaHQ7KytGKXtmb3IodmFyIF89RipvLWQsTz1fO088MDspTys9cztmb3IodmFyIE09TWF0aC5taW4oZS5pbkhlaWdodCxsK18pLEI9TitGKncsUD0wO1A8ZS5vdXRXaWR0aDsrK1Ape2Zvcih2YXIgTD1QKmEtcCxXPUw7VzwwOylXKz11O2Zvcih2YXIgVT1NYXRoLm1pbihlLmluV2lkdGgsaCtMKSxWPUIrUCpDLHo9dixHPTAsSD0wLHE9VDtxPEQ7cSs9aSl7Zm9yKHZhciBLPUkrcSp0LnN0cmlkZXNbMV0saj1PO2o8TTtqKz1zKXtmb3IodmFyIFg9SytqKnQuc3RyaWRlc1syXSxZPVc7WTxVO1krPXUpe3ZhciAkPWdbWCtZKnQuc3RyaWRlc1szXStrXTtpZihcIm1heFwiPT09biYmJD56P3o9JDpcImF2Z1wiPT09biYmKEcrPSQsSCsrKSxpc05hTih6KSlicmVha31pZihpc05hTih6KSlicmVha31pZihpc05hTih6KSlicmVha315W1Yra109XCJhdmdcIj09PW4/Ry9IOnp9fX1yZXR1cm4gbS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5hdmdQb29sM2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZGYodCxcImF2Z1Bvb2wzZFwiKSx0aGlzLnBvb2wzZCh0LGUsXCJhdmdcIikudG9GbG9hdCgpfSxvLnByb3RvdHlwZS5hdmdQb29sM2RCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7ZGYoW3QsZV0sXCJhdmdQb29sM2RCYWNrcHJvcFwiKTtmb3IodmFyIHI9bi5zdHJpZGVEZXB0aCxvPW4uc3RyaWRlSGVpZ2h0LGE9bi5zdHJpZGVXaWR0aCxpPW4uZmlsdGVyRGVwdGgscz1uLmZpbHRlckhlaWdodCx1PW4uZmlsdGVyV2lkdGgsYz1uLmRpbGF0aW9uRGVwdGgsbD1uLmRpbGF0aW9uSGVpZ2h0LGg9bi5kaWxhdGlvbldpZHRoLGY9bi5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxkPW4uZWZmZWN0aXZlRmlsdGVySGVpZ2h0LHA9bi5lZmZlY3RpdmVGaWx0ZXJXaWR0aCx2PWYtMS1uLnBhZEluZm8uZnJvbnQsZz1wLTEtbi5wYWRJbmZvLmxlZnQsbT1kLTEtbi5wYWRJbmZvLnRvcCx5PWVyKGUuc2hhcGUsXCJmbG9hdDMyXCIpLHg9MS8oaSpzKnUpLGI9dGhpcy5idWZmZXJTeW5jKHQpLHc9MDt3PG4uYmF0Y2hTaXplOysrdylmb3IodmFyIEM9MDtDPG4uaW5DaGFubmVsczsrK0MpZm9yKHZhciBFPTA7RTxuLmluRGVwdGg7KytFKWZvcih2YXIgUj0wO1I8bi5pbkhlaWdodDsrK1IpZm9yKHZhciBJPTA7STxuLmluV2lkdGg7KytJKXtmb3IodmFyIGs9RS12LFM9Ui1tLEE9SS1nLFQ9MCxEPTA7RDxmO0QrPWMpe3ZhciBOPShrK0QpL3I7aWYoIShOPDB8fE4+PW4ub3V0RGVwdGh8fE1hdGguZmxvb3IoTikhPT1OKSlmb3IodmFyIEY9MDtGPGQ7Ris9bCl7dmFyIF89KFMrRikvbztpZighKF88MHx8Xz49bi5vdXRIZWlnaHR8fE1hdGguZmxvb3IoXykhPT1fKSlmb3IodmFyIE89MDtPPHA7Tys9aCl7dmFyIE09KEErTykvYTtpZighKE08MHx8TT49bi5vdXRXaWR0aHx8TWF0aC5mbG9vcihNKSE9PU0pKVQrPWIuZ2V0KHcsTixfLE0sQyl9fX15LnNldChUKngsdyxFLFIsSSxDKX1yZXR1cm4geS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5tYXhQb29sM2Q9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZGYodCxcIm1heFBvb2wzZFwiKSx0aGlzLnBvb2wzZCh0LGUsXCJtYXhcIikudG9GbG9hdCgpfSxvLnByb3RvdHlwZS5tYXhQb29sM2RQb3NpdGlvbnM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZXIoZS5vdXRTaGFwZSxcImludDMyXCIpLHI9ZS5zdHJpZGVEZXB0aCxvPWUuc3RyaWRlSGVpZ2h0LGE9ZS5zdHJpZGVXaWR0aCxpPWUuZGlsYXRpb25EZXB0aCxzPWUuZGlsYXRpb25IZWlnaHQsdT1lLmRpbGF0aW9uV2lkdGgsYz1lLmVmZmVjdGl2ZUZpbHRlckRlcHRoLGw9ZS5lZmZlY3RpdmVGaWx0ZXJIZWlnaHQsaD1lLmVmZmVjdGl2ZUZpbHRlcldpZHRoLGY9ZS5wYWRJbmZvLmZyb250LGQ9ZS5wYWRJbmZvLnRvcCxwPWUucGFkSW5mby5sZWZ0LHY9dGhpcy5idWZmZXJTeW5jKHQpLGc9MDtnPGUuYmF0Y2hTaXplOysrZylmb3IodmFyIG09MDttPGUuaW5DaGFubmVsczsrK20pZm9yKHZhciB5PTA7eTxlLm91dERlcHRoOysreSl7Zm9yKHZhciB4PXkqci1mLGI9eDtiPDA7KWIrPWk7Zm9yKHZhciB3PU1hdGgubWluKGUuaW5EZXB0aCxjK3gpLEM9MDtDPGUub3V0SGVpZ2h0OysrQyl7Zm9yKHZhciBFPUMqby1kLFI9RTtSPDA7KVIrPXM7Zm9yKHZhciBJPU1hdGgubWluKGUuaW5IZWlnaHQsbCtFKSxrPTA7azxlLm91dFdpZHRoOysrayl7Zm9yKHZhciBTPWsqYS1wLEE9UztBPDA7KUErPXU7Zm9yKHZhciBUPU1hdGgubWluKGUuaW5XaWR0aCxoK1MpLEQ9TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLE49LTEsRj1iO0Y8dztGKz1pKWZvcih2YXIgXz1GLXgsTz1SO088STtPKz1zKWZvcih2YXIgTT1PLUUsQj1BO0I8VDtCKz11KXt2YXIgUD1CLVMsTD12LmdldChnLEYsTyxCLG0pO0w+PUQmJihEPUwsTj1fKmwqaCtNKmwrUCl9bi5zZXQoTixnLHksQyxrLG0pfX19cmV0dXJuIG4udG9UZW5zb3IoKX0sby5wcm90b3R5cGUubWF4UG9vbDNkQmFja3Byb3A9ZnVuY3Rpb24odCxlLG4scil7ZGYoW2Usbl0sXCJtYXhQb29sM2RCYWNrcHJvcFwiKTtmb3IodmFyIG89dGhpcy5tYXhQb29sM2RQb3NpdGlvbnMoZSxyKSxhPXIuc3RyaWRlRGVwdGgsaT1yLnN0cmlkZUhlaWdodCxzPXIuc3RyaWRlV2lkdGgsdT1yLmRpbGF0aW9uRGVwdGgsYz1yLmRpbGF0aW9uSGVpZ2h0LGw9ci5kaWxhdGlvbldpZHRoLGg9ci5lZmZlY3RpdmVGaWx0ZXJEZXB0aCxmPXIuZWZmZWN0aXZlRmlsdGVySGVpZ2h0LGQ9ci5lZmZlY3RpdmVGaWx0ZXJXaWR0aCxwPWgtMS1yLnBhZEluZm8uZnJvbnQsdj1kLTEtci5wYWRJbmZvLmxlZnQsZz1mLTEtci5wYWRJbmZvLnRvcCxtPWVyKGUuc2hhcGUsXCJmbG9hdDMyXCIpLHk9dGhpcy5idWZmZXJTeW5jKG8pLHg9dGhpcy5idWZmZXJTeW5jKHQpLGI9MDtiPHIuYmF0Y2hTaXplOysrYilmb3IodmFyIHc9MDt3PHIuaW5DaGFubmVsczsrK3cpZm9yKHZhciBDPTA7QzxyLmluRGVwdGg7KytDKWZvcih2YXIgRT0wO0U8ci5pbkhlaWdodDsrK0UpZm9yKHZhciBSPTA7UjxyLmluV2lkdGg7KytSKXtmb3IodmFyIEk9Qy1wLGs9RS1nLFM9Ui12LEE9MCxUPTA7VDxoO1QrPXUpe3ZhciBEPShJK1QpL2E7aWYoIShEPDB8fEQ+PXIub3V0RGVwdGh8fE1hdGguZmxvb3IoRCkhPT1EKSlmb3IodmFyIE49MDtOPGY7Tis9Yyl7dmFyIEY9KGsrTikvaTtpZighKEY8MHx8Rj49ci5vdXRIZWlnaHR8fE1hdGguZmxvb3IoRikhPT1GKSlmb3IodmFyIF89MDtfPGQ7Xys9bCl7dmFyIE89KFMrXykvcztpZighKE88MHx8Tz49ci5vdXRXaWR0aHx8TWF0aC5mbG9vcihPKSE9PU8pKXt2YXIgTT1oKmYqZC0xLXkuZ2V0KGIsRCxGLE8sdyk9PT1UKmYqZCtOKmQrXz8xOjA7aWYoMCE9PU0pQSs9eC5nZXQoYixELEYsTyx3KSpNfX19fW0uc2V0KEEsYixDLEUsUix3KX1yZXR1cm4gbS50b1RlbnNvcigpfSxvLnByb3RvdHlwZS5jYXN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFJhKHQsZSx0aGlzKX0sby5wcm90b3R5cGUucmVzaGFwZT1mdW5jdGlvbih0LGUpe3JldHVybiBJYSh0LGUpfSxvLnByb3RvdHlwZS5hdmdQb29sPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGRmKHQsXCJhdmdQb29sXCIpLGRmKHQsXCJtYXhQb29sXCIpLHBmKHRoaXMucmVhZFN5bmModC5kYXRhSWQpLHQuc2hhcGUsdC5kdHlwZSx0LnN0cmlkZXMsZSxcImF2Z1wiKS50b1RlbnNvcigpLnRvRmxvYXQoKX0sby5wcm90b3R5cGUucmVzaXplQmlsaW5lYXI9ZnVuY3Rpb24odCxlLG4scil7ZGYodCxcInJlc2l6ZUJpbGluZWFyXCIpO2Zvcih2YXIgbz10LnNoYXBlLGE9b1swXSxpPW9bMV0scz1vWzJdLHU9b1szXSxjPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGw9bmV3IEZsb2F0MzJBcnJheShrKFthLGUsbix1XSkpLGg9W3ImJmU+MT9pLTE6aSxyJiZuPjE/cy0xOnNdLGY9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dLGQ9MCxwPWhbMF0vZlswXSx2PWhbMV0vZlsxXSxnPTA7ZzxhO2crKylmb3IodmFyIG09MDttPGU7bSsrKWZvcih2YXIgeT1wKm0seD1NYXRoLmZsb29yKHkpLGI9eS14LHc9TWF0aC5taW4oaS0xLE1hdGguY2VpbCh5KSksQz1nKnQuc3RyaWRlc1swXSt4KnQuc3RyaWRlc1sxXSxFPWcqdC5zdHJpZGVzWzBdK3cqdC5zdHJpZGVzWzFdLFI9MDtSPG47UisrKWZvcih2YXIgST12KlIsUz1NYXRoLmZsb29yKEkpLEE9SS1TLFQ9TWF0aC5taW4ocy0xLE1hdGguY2VpbChJKSksRD1DK1MqdC5zdHJpZGVzWzJdLE49RStTKnQuc3RyaWRlc1syXSxGPUMrVCp0LnN0cmlkZXNbMl0sXz1FK1QqdC5zdHJpZGVzWzJdLE89MDtPPHU7TysrKXt2YXIgTT1jW0QrT10sQj1jW04rT10sUD1NKyhjW0YrT10tTSkqQSxMPVArKEIrKGNbXytPXS1CKSpBLVApKmI7bFtkKytdPUx9cmV0dXJuIEZuKGwsW2EsZSxuLHVdKX0sby5wcm90b3R5cGUucmVzaXplQmlsaW5lYXJCYWNrcHJvcD1mdW5jdGlvbih0LGUsbil7ZGYoW3QsZV0sXCJyZXNpemVCaWxpbmVhckJhY2twcm9wXCIpO2Zvcih2YXIgcj1lLnNoYXBlLG89clswXSxhPXJbMV0saT1yWzJdLHM9clszXSx1PXQuc2hhcGUsYz11WzFdLGw9dVsyXSxoPW5ldyBGbG9hdDMyQXJyYXkobyphKmkqcyksZj1bbiYmYz4xP2EtMTphLG4mJmw+MT9pLTE6aV0sZD1bbiYmYz4xP2MtMTpjLG4mJmw+MT9sLTE6bF0scD1mWzBdL2RbMF0sdj1mWzFdL2RbMV0sZz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxtPTAseT0wO3k8bzt5KyspZm9yKHZhciB4PXkqZS5zdHJpZGVzWzBdLGI9MDtiPGM7YisrKWZvcih2YXIgdz1iKnAsQz1NYXRoLmZsb29yKHcpLEU9TWF0aC5taW4oTWF0aC5jZWlsKHcpLGEtMSksUj14K0MqZS5zdHJpZGVzWzFdLEk9eCtFKmUuc3RyaWRlc1sxXSxrPXctQyxTPTEtayxBPTA7QTxsO0ErKylmb3IodmFyIFQ9QSp2LEQ9TWF0aC5mbG9vcihUKSxOPU1hdGgubWluKE1hdGguY2VpbChUKSxpLTEpLEY9VC1ELF89MS1GLE89UitEKmUuc3RyaWRlc1syXSxNPVIrTiplLnN0cmlkZXNbMl0sQj1JK0QqZS5zdHJpZGVzWzJdLFA9SStOKmUuc3RyaWRlc1syXSxMPVMqXyxXPVMqRixVPWsqXyxWPWsqRix6PTA7ejxzO3orKyl7dmFyIEc9Z1ttKytdO2hbTyt6XSs9RypMLGhbTSt6XSs9RypXLGhbQit6XSs9RypVLGhbUCt6XSs9RypWfXJldHVybiBMbihoLFtvLGksYSxzXSxlLmR0eXBlKX0sby5wcm90b3R5cGUucmVzaXplTmVhcmVzdE5laWdoYm9yPWZ1bmN0aW9uKHQsZSxuLHIpe2RmKHQsXCJyZXNpemVOZWFyZXN0TmVpZ2hib3JcIik7Zm9yKHZhciBvPXQuc2hhcGUsYT1vWzBdLGk9b1sxXSxzPW9bMl0sdT1vWzNdLGM9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksbD1uZXcgRmxvYXQzMkFycmF5KGEqZSpuKnUpLGg9W3ImJmU+MT9pLTE6aSxyJiZuPjE/cy0xOnNdLGY9W3ImJmU+MT9lLTE6ZSxyJiZuPjE/bi0xOm5dLGQ9aFswXS9mWzBdLHA9aFsxXS9mWzFdLHY9MCxnPTA7ZzxhO2crKylmb3IodmFyIG09Zyp0LnN0cmlkZXNbMF0seT0wO3k8ZTt5KyspZm9yKHZhciB4PWQqeSxiPW0rTWF0aC5taW4oaS0xLHI/TWF0aC5yb3VuZCh4KTpNYXRoLmZsb29yKHgpKSp0LnN0cmlkZXNbMV0sdz0wO3c8bjt3KyspZm9yKHZhciBDPXAqdyxFPWIrTWF0aC5taW4ocy0xLHI/TWF0aC5yb3VuZChDKTpNYXRoLmZsb29yKEMpKSp0LnN0cmlkZXNbMl0sUj0wO1I8dTtSKyspe3ZhciBJPWNbRStSXTtsW3YrK109SX1yZXR1cm4gRm4obCxbYSxlLG4sdV0sdC5kdHlwZSl9LG8ucHJvdG90eXBlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wPWZ1bmN0aW9uKHQsZSxuKXtkZihbdCxlXSxcInJlc2l6ZU5lYXJlc3ROZWlnaGJvckJhY2twcm9wXCIpO2Zvcih2YXIgcj1lLnNoYXBlLG89clswXSxhPXJbMV0saT1yWzJdLHM9clszXSx1PXQuc2hhcGUsYz11WzFdLGw9dVsyXSxoPW5ldyBGbG9hdDMyQXJyYXkobyphKmkqcyksZj10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxkPVtuJiZjPjE/YS0xOmEsbiYmbD4xP2ktMTppXSxwPVtuJiZjPjE/Yy0xOmMsbiYmbD4xP2wtMTpsXSx2PWRbMF0vcFswXSxnPWRbMV0vcFsxXSxtPTEvdix5PTEvZyx4PTIqTWF0aC5jZWlsKG0pKzIsYj0yKk1hdGguY2VpbCh5KSsyLHc9MDt3PG87dysrKWZvcih2YXIgQz13KmUuc3RyaWRlc1swXSxFPTA7RTxhO0UrKylmb3IodmFyIFI9QytFKmUuc3RyaWRlc1sxXSxJPU1hdGguZmxvb3IoRSptKSxrPU1hdGguZmxvb3IoSS14LzIpLFM9MDtTPGk7UysrKWZvcih2YXIgQT1SK1MqZS5zdHJpZGVzWzJdLFQ9TWF0aC5mbG9vcihTKnkpLEQ9TWF0aC5mbG9vcihULWIvMiksTj0wO048cztOKyspe2Zvcih2YXIgRj0wLF89MDtfPHg7XysrKXt2YXIgTz1fK2s7aWYoIShPPDB8fE8+PWMpKXt2YXIgTT1DK08qdC5zdHJpZGVzWzFdLEI9Typ2O2lmKEU9PT1NYXRoLm1pbihhLTEsbj9NYXRoLnJvdW5kKEIpOk1hdGguZmxvb3IoQikpKWZvcih2YXIgUD0wO1A8YjtQKyspe3ZhciBMPVArRDtpZighKEw8MHx8TD49bCkpe3ZhciBXPU0rTCp0LnN0cmlkZXNbMl0sVT1MKmc7Uz09PU1hdGgubWluKGktMSxuP01hdGgucm91bmQoVSk6TWF0aC5mbG9vcihVKSkmJihGKz1mW1crTl0pfX19fWhbQStOXT1GfXJldHVybiBMbihoLGUuc2hhcGUsZS5kdHlwZSl9LG8ucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbj1mdW5jdGlvbih0LGUsbixyLG8sYSl7ZGYoW3QsZSxuLG8sYV0sXCJiYXRjaE5vcm1cIik7Zm9yKHZhciBpPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHM9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksdT10aGlzLnJlYWRTeW5jKG4uZGF0YUlkKSxjPW8/dGhpcy5yZWFkU3luYyhvLmRhdGFJZCk6bmV3IEZsb2F0MzJBcnJheShbMV0pLGw9YT90aGlzLnJlYWRTeW5jKGEuZGF0YUlkKTpuZXcgRmxvYXQzMkFycmF5KFswXSksaD1uZXcgRmxvYXQzMkFycmF5KGkubGVuZ3RoKSxmPWwubGVuZ3RoLGQ9Yy5sZW5ndGgscD11Lmxlbmd0aCx2PXMubGVuZ3RoLGc9MCxtPTAseT0wLHg9MCxiPTA7YjxpLmxlbmd0aDsrK2IpaFtiXT1sW2crK10rKGlbYl0tc1ttKytdKSpjW3krK10vTWF0aC5zcXJ0KHVbeCsrXStyKSxnPj1mJiYoZz0wKSxtPj12JiYobT0wKSx5Pj1kJiYoeT0wKSx4Pj1wJiYoeD0wKTtyZXR1cm4gTG4oaCx0LnNoYXBlKX0sby5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RD1mdW5jdGlvbih0LGUsbixyLG8pe2RmKHQsXCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREXCIpO3ZhciBhPXQuc2hhcGVbM10saT1hLTEscz10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSx1PXQuc2l6ZSxjPW5ldyBGbG9hdDMyQXJyYXkodSk7ZnVuY3Rpb24gbCh0KXtmb3IodmFyIG49dCVhLHI9dC1uK01hdGgubWF4KDAsbi1lKSxvPXQtbitNYXRoLm1pbihuK2UsaSksdT0wO3I8PW87cisrKXt2YXIgYz1zW3JdO3UrPWMqY31yZXR1cm4gdX1mb3IodmFyIGg9MDtoPHU7aCsrKXt2YXIgZj1sKGgpLGQ9c1toXSpNYXRoLnBvdyhuK3IqZiwtbyk7Y1toXT1kfXJldHVybiBMbihjLHQuc2hhcGUpfSxvLnByb3RvdHlwZS5MUk5HcmFkPWZ1bmN0aW9uKHQsZSxuLHIsbyxhLGkpe2RmKHQsXCJMUk5HcmFkXCIpO2Zvcih2YXIgcz10LnNoYXBlWzNdLHU9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksYz10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxsPXRoaXMucmVhZFN5bmMobi5kYXRhSWQpLGg9bmV3IEZsb2F0MzJBcnJheSh0LnNpemUpLGY9dC5zaXplLGQ9MDtkPGY7ZCsrKXtmb3IodmFyIHA9ZCVzLHY9ZC1wK01hdGgubWF4KDAscC1yKSxnPWQtcCtNYXRoLm1pbihzLHArcisxKSxtPTAseT12O3k8Zzt5KyspbSs9TWF0aC5wb3coY1t5XSwyKTttPWEqbStvO2Zvcih5PXY7eTxnO3krKyl7dmFyIHg9LTIqYSppKmNbeV0qbFtkXS9tO2Q9PT15JiYoeCs9TWF0aC5wb3cobSwtaSkpLHgqPXVbZF0saFt5XSs9eH19cmV0dXJuIExuKGgsdC5zaGFwZSl9LG8ucHJvdG90eXBlLm11bHRpbm9taWFsPWZ1bmN0aW9uKHQsZSxuLHIpe2RmKHQsXCJtdWx0aW5vbWlhbFwiKTtmb3IodmFyIG89ZT90OmlhKHQpLGE9by5zaGFwZVswXSxpPW8uc2hhcGVbMV0scz1HbihbYSxuXSxcImludDMyXCIpLHU9dGhpcy5yZWFkU3luYyhzLmRhdGFJZCksYz10aGlzLnJlYWRTeW5jKG8uZGF0YUlkKSxsPTA7bDxhOysrbCl7dmFyIGg9bCppLGY9bmV3IEZsb2F0MzJBcnJheShpLTEpO2ZbMF09Y1toXTtmb3IodmFyIGQ9MTtkPGYubGVuZ3RoOysrZClmW2RdPWZbZC0xXStjW2grZF07Zm9yKHZhciBwPVl1KHIudG9TdHJpbmcoKSksdj1sKm4sZz0wO2c8bjsrK2cpe3ZhciBtPXAoKTt1W3YrZ109Zi5sZW5ndGg7Zm9yKHZhciB5PTA7eTxmLmxlbmd0aDt5KyspaWYobTxmW3ldKXt1W3YrZ109eTticmVha319fXJldHVybiBzfSxvLnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24odCxlLG4scil7ZGYodCxcIm9uZUhvdFwiKTt2YXIgbz1uZXcgRmxvYXQzMkFycmF5KHQuc2l6ZSplKTtvLmZpbGwocik7Zm9yKHZhciBhPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGk9MDtpPHQuc2l6ZTsrK2kpYVtpXT49MCYmYVtpXTxlJiYob1tpKmUrYVtpXV09bik7cmV0dXJuIEJuKG8sW3Quc2l6ZSxlXSxcImludDMyXCIpfSxvLnByb3RvdHlwZS5ub25NYXhTdXBwcmVzc2lvbj1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiBkZih0LFwibm9uTWF4U3VwcHJlc3Npb25cIiksT2EodGhpcy5yZWFkU3luYyh0LmRhdGFJZCksdGhpcy5yZWFkU3luYyhlLmRhdGFJZCksbixyLG8pfSxvLnByb3RvdHlwZS5mZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmZ0QmF0Y2godCwhMSl9LG8ucHJvdG90eXBlLmlmZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmZ0QmF0Y2godCwhMCl9LG8ucHJvdG90eXBlLmZmdEJhdGNoPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuc2hhcGVbMF0scj10LnNoYXBlWzFdLG89ZXIodC5zaGFwZSxcImZsb2F0MzJcIiksYT1lcih0LnNoYXBlLFwiZmxvYXQzMlwiKSxpPURuKHQpLmFzMkQobixyKSxzPU5uKHQpLmFzMkQobixyKSx1PTA7dTxuO3UrKylmb3IodmFyIGM9aS5zbGljZShbdSwwXSxbMSxyXSksbD1zLnNsaWNlKFt1LDBdLFsxLHJdKSxoPVRuKGMsbCksZj10aGlzLnJlYWRTeW5jKHRoaXMuZmZ0SW1wbChoLGUpLmRhdGFJZCksZD0wO2Q8cjtkKyspe3ZhciBwPVRhKGYsZCk7by52YWx1ZXNbdSpyK2RdPXAucmVhbCxhLnZhbHVlc1t1KnIrZF09cC5pbWFnfXJldHVybiBUbihvLnRvVGVuc29yKCksYS50b1RlbnNvcigpKS5hczJEKG4scil9LG8ucHJvdG90eXBlLmZmdEltcGw9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmFzMUQoKSxyPW4uc2l6ZTtpZih0aGlzLmlzRXhwb25lbnRPZjIocikpe3ZhciBvPXRoaXMuZmZ0UmFkaXgyKG4scixlKS5hczJEKHQuc2hhcGVbMF0sdC5zaGFwZVsxXSk7cmV0dXJuIGUmJihvPVRuKERuKG8pLmRpdihPbihyKSksTm4obykuZGl2KE9uKHIpKSkpLG99dmFyIGE9dGhpcy5yZWFkU3luYyh0LmRhdGFJZCksaT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEZsb2F0MzJBcnJheSh0Lmxlbmd0aC8yKSxuPW5ldyBGbG9hdDMyQXJyYXkodC5sZW5ndGgvMikscj0wO3I8dC5sZW5ndGg7cis9MillW3IvMl09dFtyXSxuW3IvMl09dFtyKzFdO3JldHVybntyZWFsOmUsaW1hZzpufX0odGhpcy5mb3VyaWVyVHJhbnNmb3JtQnlNYXRtdWwoYSxyLGUpKTtyZXR1cm4gVG4oaS5yZWFsLGkuaW1hZykuYXMyRCh0LnNoYXBlWzBdLHQuc2hhcGVbMV0pfSxvLnByb3RvdHlwZS5pc0V4cG9uZW50T2YyPWZ1bmN0aW9uKHQpe3JldHVybiAwPT0odCZ0LTEpfSxvLnByb3RvdHlwZS5mZnRSYWRpeDI9ZnVuY3Rpb24odCxlLG4pe2lmKDE9PT1lKXJldHVybiB0O3ZhciByPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLG89ZS8yLGE9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPU1hdGguY2VpbCh0Lmxlbmd0aC80KSxuPW5ldyBGbG9hdDMyQXJyYXkoZSkscj1uZXcgRmxvYXQzMkFycmF5KGUpLG89MDtvPHQubGVuZ3RoO28rPTQpbltNYXRoLmZsb29yKG8vNCldPXRbb10scltNYXRoLmZsb29yKG8vNCldPXRbbysxXTtyZXR1cm57cmVhbDpuLGltYWc6cn19KHIpLGk9VG4oYS5yZWFsLGEuaW1hZykuYXMxRCgpLHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPU1hdGguZmxvb3IodC5sZW5ndGgvNCksbj1uZXcgRmxvYXQzMkFycmF5KGUpLHI9bmV3IEZsb2F0MzJBcnJheShlKSxvPTI7bzx0Lmxlbmd0aDtvKz00KW5bTWF0aC5mbG9vcihvLzQpXT10W29dLHJbTWF0aC5mbG9vcihvLzQpXT10W28rMV07cmV0dXJue3JlYWw6bixpbWFnOnJ9fShyKSx1PVRuKHMucmVhbCxzLmltYWcpLmFzMUQoKTtpPXRoaXMuZmZ0UmFkaXgyKGksbyxuKSx1PXRoaXMuZmZ0UmFkaXgyKHUsbyxuKTt2YXIgYz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgRmxvYXQzMkFycmF5KHQvMikscj1uZXcgRmxvYXQzMkFycmF5KHQvMiksbz0wO288TWF0aC5jZWlsKHQvMik7bysrKXt2YXIgYT0oZT8yOi0yKSpNYXRoLlBJKihvL3QpO25bb109TWF0aC5jb3MoYSkscltvXT1NYXRoLnNpbihhKX1yZXR1cm57cmVhbDpuLGltYWc6cn19KGUsbiksbD1UbihjLnJlYWwsYy5pbWFnKS5tdWwodSksaD1pLmFkZChsKSxmPWkuc3ViKGwpLGQ9RG4oaCkuY29uY2F0KERuKGYpKSxwPU5uKGgpLmNvbmNhdChObihmKSk7cmV0dXJuIFRuKGQscCkuYXMxRCgpfSxvLnByb3RvdHlwZS5mb3VyaWVyVHJhbnNmb3JtQnlNYXRtdWw9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1uZXcgRmxvYXQzMkFycmF5KDIqZSksbz0wO288ZTtvKyspe2Zvcih2YXIgYT0wLGk9MCxzPTA7czxlO3MrKyl7dmFyIHU9TmEobypzLGUsbiksYz1UYSh0LHMpO2ErPWMucmVhbCp1LnJlYWwtYy5pbWFnKnUuaW1hZyxpKz1jLnJlYWwqdS5pbWFnK2MuaW1hZyp1LnJlYWx9biYmKGEvPWUsaS89ZSksRGEocixhLGksbyl9cmV0dXJuIHJ9LG8ucHJvdG90eXBlLmRlcHRoVG9TcGFjZT1mdW5jdGlvbih0LGUsbil7QyhcIk5IV0NcIj09PW4sKGZ1bmN0aW9uKCl7cmV0dXJuXCJPbmx5IE5IV0MgZGF0YUZvcm1hdCBzdXBwb3J0ZWQgb24gQ1BVIGZvciBkZXB0aFRvU3BhY2UuIEdvdCBcIitufSkpLEMoZT4xLChmdW5jdGlvbigpe3JldHVyblwiYmxvY2tTaXplIHNob3VsZCBiZSA+IDEgZm9yIGRlcHRoVG9TcGFjZSwgYnV0IHdhczogXCIrZX0pKTtmb3IodmFyIHI9dC5zaGFwZVswXSxvPXQuc2hhcGVbMV0sYT10LnNoYXBlWzJdLGk9dC5zaGFwZVszXSxzPW8qZSx1PWEqZSxjPWkvKGUqZSksbD10aGlzLnJlYWRTeW5jKHQuZGF0YUlkKSxoPW5ldyBGbG9hdDMyQXJyYXkocipzKnUqYyksZj0wLGQ9MDtkPHI7KytkKWZvcih2YXIgcD0wO3A8czsrK3ApZm9yKHZhciB2PU1hdGguZmxvb3IocC9lKSxnPXAlZSxtPTA7bTx1OysrbSlmb3IodmFyIHk9TWF0aC5mbG9vcihtL2UpLHg9KGcqZSttJWUpKmMsYj0wO2I8YzsrK2Ipe3ZhciB3PWIreCtpKih5K2EqKHYrbypkKSk7aFtmKytdPWxbd119cmV0dXJuIExuKGgsW3Iscyx1LGNdKX0sby5wcm90b3R5cGUuYnJvYWRjYXN0ZWRCaW5hcnlPcD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1Qcih0LnNoYXBlLGUuc2hhcGUpLGE9ZXIobyxuKSxpPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHM9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksdT1Ncih0LnNoYXBlLG8pLGM9TXIoZS5zaGFwZSxvKSxsPWEudmFsdWVzO2lmKHUubGVuZ3RoK2MubGVuZ3RoPT09MClmb3IodmFyIGg9MDtoPGwubGVuZ3RoOysraClsW2hdPXIoaVtoJWkubGVuZ3RoXSxzW2glcy5sZW5ndGhdKTtlbHNle3ZhciBmPXRoaXMuYnVmZmVyU3luYyh0KSxkPXRoaXMuYnVmZmVyU3luYyhlKSxwPWZ1bmN0aW9uKG4pe3ZhciBvPWEuaW5kZXhUb0xvYyhuKSxoPW8uc2xpY2UoLXQucmFuayk7dS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gaFt0XT0wfSkpO3ZhciBwPWYubG9jVG9JbmRleChoKSx2PW8uc2xpY2UoLWUucmFuayk7Yy5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdlt0XT0wfSkpO3ZhciBnPWQubG9jVG9JbmRleCh2KTtsW25dPXIoaVtwXSxzW2ddKX07Zm9yKGg9MDtoPGwubGVuZ3RoOysraClwKGgpfXJldHVybiBhLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLmJyb2FkY2FzdGVkQmluYXJ5Q29tcGxleE9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1Qcih0LnNoYXBlLGUuc2hhcGUpLG89ZXIocixcImZsb2F0MzJcIiksYT1lcihyLFwiZmxvYXQzMlwiKSxpPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLHM9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCksdT1Ncih0LnNoYXBlLHIpLGM9TXIoZS5zaGFwZSxyKSxsPW8udmFsdWVzLGg9YS52YWx1ZXM7aWYodS5sZW5ndGgrYy5sZW5ndGg9PT0wKWZvcih2YXIgZj0wO2Y8bC5sZW5ndGg7ZisrKXt2YXIgZD1mJWkubGVuZ3RoLHA9ZiVzLmxlbmd0aCx2PW4oaVsyKmRdLGlbMipkKzFdLHNbMipwXSxzWzIqcCsxXSk7bFtmXT12LnJlYWwsaFtmXT12LmltYWd9ZWxzZXt2YXIgZz10aGlzLmJ1ZmZlclN5bmModGhpcy5kYXRhLmdldCh0LmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbCksbT10aGlzLmJ1ZmZlclN5bmModGhpcy5kYXRhLmdldChlLmRhdGFJZCkuY29tcGxleFRlbnNvcnMucmVhbCkseT1mdW5jdGlvbihyKXt2YXIgYT1vLmluZGV4VG9Mb2MociksZj1hLnNsaWNlKC10LnJhbmspO3UuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGZbdF09MH0pKTt2YXIgZD1nLmxvY1RvSW5kZXgoZikscD1hLnNsaWNlKC1lLnJhbmspO2MuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHBbdF09MH0pKTt2YXIgdj1tLmxvY1RvSW5kZXgocCkseT1uKGlbMipkXSxpWzIqZCsxXSxzWzIqdl0sc1syKnYrMV0pO2xbcl09eS5yZWFsLGhbcl09eS5pbWFnfTtmb3IoZj0wO2Y8bC5sZW5ndGg7ZisrKXkoZil9cmV0dXJuIHRoaXMuY29tcGxleChvLnRvVGVuc29yKCksYS50b1RlbnNvcigpKX0sby5wcm90b3R5cGUuc3BsaXQ9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBVYSh0LGUsbil9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt9LG8ucHJvdG90eXBlLmZsb2F0UHJlY2lzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIDMyfSxvLnByb3RvdHlwZS5lcHNpbG9uPWZ1bmN0aW9uKCl7cmV0dXJuIDFlLTd9LG8ucHJvdG90eXBlLmNyb3BBbmRSZXNpemU9ZnVuY3Rpb24odCxlLG4scixvLGEpe2Zvcih2YXIgaT10LnNoYXBlLHM9aVswXSx1PWlbMV0sYz1pWzJdLGw9aVszXSxoPWUuc2hhcGVbMF0sZj1yWzBdLGQ9clsxXSxwPWVyKFtoLGYsZCxsXSxcImZsb2F0MzJcIiksdj10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxnPXRoaXMucmVhZFN5bmMobi5kYXRhSWQpLG09dGhpcy5yZWFkU3luYyh0LmRhdGFJZCkseT10LnN0cmlkZXMseD1wLnN0cmlkZXMsYj0wO2I8aDtiKyspe3ZhciB3PTQqYixDPXZbd10sRT12W3crMV0sUj12W3crMl0sST12W3crM10saz1nW2JdO2lmKCEoaz49cykpZm9yKHZhciBTPWY+MT8oUi1DKSoodS0xKS8oZi0xKTowLEE9ZD4xPyhJLUUpKihjLTEpLyhkLTEpOjAsVD0wO1Q8ZjtUKyspe3ZhciBEPWY+MT9DKih1LTEpK1QqUzouNSooQytSKSoodS0xKTtpZihEPDB8fEQ+dS0xKWZvcih2YXIgTj0wO048ZDtOKyspZm9yKHZhciBGPTA7RjxsO0YrKyl7dmFyIF89RitOKnhbMl0rVCp4WzFdK2IqeFswXTtwLnZhbHVlc1tfXT1hfWVsc2UgaWYoXCJiaWxpbmVhclwiPT09byl7dmFyIE89TWF0aC5mbG9vcihEKSxNPU1hdGguY2VpbChEKSxCPUQtTztmb3IoTj0wO048ZDtOKyspe2lmKChxPWQ+MT9FKihjLTEpK04qQTouNSooRStJKSooYy0xKSk8MHx8cT5jLTEpZm9yKEY9MDtGPGw7RisrKXtfPUYrTip4WzJdK1QqeFsxXStiKnhbMF07cC52YWx1ZXNbX109YX1lbHNle3ZhciBQPU1hdGguZmxvb3IocSksTD1NYXRoLmNlaWwocSksVz1xLVA7Zm9yKEY9MDtGPGw7RisrKXt2YXIgVT1tW189RitQKnlbMl0rTyp5WzFdK2sqeVswXV0sVj1tW189RitMKnlbMl0rTyp5WzFdK2sqeVswXV0sej1tW189RitQKnlbMl0rTSp5WzFdK2sqeVswXV0sRz1VKyhWLVUpKlcsSD16KyhtW189RitMKnlbMl0rTSp5WzFdK2sqeVswXV0teikqVztfPUYrTip4WzJdK1QqeFsxXStiKnhbMF0scC52YWx1ZXNbX109RysoSC1HKSpCfX19fWVsc2UgZm9yKE49MDtOPGQ7KytOKXt2YXIgcTtpZigocT1kPjE/RSooYy0xKStOKkE6LjUqKEUrSSkqKGMtMSkpPDB8fHE+Yy0xKWZvcihGPTA7RjxsO0YrKyl7Xz1GK04qeFsyXStUKnhbMV0rYip4WzBdO3AudmFsdWVzW19dPWF9ZWxzZXt2YXIgSz1NYXRoLnJvdW5kKHEpLGo9TWF0aC5yb3VuZChEKTtmb3IoRj0wO0Y8bDtGKyspe3ZhciBYPUYrSyp5WzJdK2oqeVsxXStrKnlbMF0sWT1GK04qeFsyXStUKnhbMV0rYip4WzBdO3AudmFsdWVzW1ldPW1bWF19fX19fXJldHVybiBwLnRvVGVuc29yKCl9LG8ucHJvdG90eXBlLnNwYXJzZVRvRGVuc2U9ZnVuY3Rpb24odCxlLG4scil7dmFyIG89R28oMCx0LG4pLGE9by5zbGljZVJhbmssaT1vLm51bVVwZGF0ZXMscz1vLnNsaWNlU2l6ZSx1PW8uc3RyaWRlcyxjPW8ub3V0cHV0U2l6ZTtyZXR1cm4gdGhpcy5zY2F0dGVyKHQsZSxuLGMscyxpLGEsdSxyLCExKX0sby5wcm90b3R5cGUuZ2F0aGVyTkQ9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNoYXBlLHI9bltuLmxlbmd0aC0xXSxvPVBvKHQsZSksYT1vWzBdLGk9b1sxXSxzPW9bMl0sdT1vWzNdO2lmKDA9PT1pKXJldHVybiBGbihbXSxhLHQuZHR5cGUpO2Zvcih2YXIgYz1uZXcgbXQoW2ksc10sdC5kdHlwZSksbD10aGlzLnJlYWRTeW5jKGUuZGF0YUlkKSxoPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGY9MDtmPGk7ZisrKXtmb3IodmFyIGQ9W10scD0wLHY9MDt2PHI7disrKXt2YXIgZz1sW2Yqcit2XTtwKz1nKnVbdl0sZC5wdXNoKGcpfWlmKHA8MHx8cD49dC5zaXplL3MpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRpY2VzOiBcIitkK1wiIGRvZXMgbm90IGluZGV4IGludG8gXCIrdC5zaGFwZSk7Zm9yKHZhciBtPTA7bTxzO20rKyljLnZhbHVlc1tmKnMrbV09aFtwKnMrbV19cmV0dXJuIGMudG9UZW5zb3IoKS5yZXNoYXBlKGEpfSxvLnByb3RvdHlwZS5zY2F0dGVyTkQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPUdvKDAsdCxuKSxvPXIuc2xpY2VSYW5rLGE9ci5udW1VcGRhdGVzLGk9ci5zbGljZVNpemUscz1yLnN0cmlkZXMsdT1yLm91dHB1dFNpemUsYz1PbigwKTtyZXR1cm4gdGhpcy5zY2F0dGVyKHQsZSxuLHUsaSxhLG8scyxjLCEwKX0sby5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbih0LGUsbil7dmFyIHI9UChuPW58fGooZSksayh0KSk7cmV0dXJuIHIuZmlsbChlKSxMdC5tYWtlVGVuc29yKHIsdCxuLHRoaXMpfSxvLnByb3RvdHlwZS5vbmVzTGlrZT1mdW5jdGlvbih0KXtpZihcInN0cmluZ1wiPT09dC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJvbmVzTGlrZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBzdHJpbmcgdGVuc29yc1wiKTtyZXR1cm4gdGhpcy5maWxsKHQuc2hhcGUsMSx0LmR0eXBlKX0sby5wcm90b3R5cGUuemVyb3NMaWtlPWZ1bmN0aW9uKHQpe3ZhciBlPVAodC5kdHlwZSxrKHQuc2hhcGUpKTtyZXR1cm4gdGhpcy5tYWtlT3V0cHV0KGUsdC5zaGFwZSx0LmR0eXBlKX0sby5wcm90b3R5cGUubGluc3BhY2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBrYSh0LGUsbil9LG8ucHJvdG90eXBlLnNjYXR0ZXI9ZnVuY3Rpb24odCxlLG4scixvLGEsaSxzLHUsYyl7dmFyIGw9W3IvbyxvXSxoPXRoaXMucmVhZFN5bmModC5kYXRhSWQpLGY9dGhpcy5yZWFkU3luYyhlLmRhdGFJZCk7aWYoMD09PXIpcmV0dXJuIEZuKFtdLG4sZS5kdHlwZSk7dmFyIGQ9bmV3IG10KGwsZS5kdHlwZSk7ZC52YWx1ZXMuZmlsbCh0aGlzLnJlYWRTeW5jKHUuZGF0YUlkKVswXSk7Zm9yKHZhciBwPTA7cDxhO3ArKyl7Zm9yKHZhciB2PVtdLGc9MCxtPTA7bTxpO20rKyl7dmFyIHk9aFtwKmkrbV07di5wdXNoKHkpLGcrPXkqc1ttXX1pZihnPDB8fGc+PXIvbyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGljZXM6IFwiK3YrXCIgZG9lcyBub3QgaW5kZXggaW50byBcIituKTtmb3IodmFyIHg9MDt4PG87eCsrKWM/ZC52YWx1ZXNbZypvK3hdKz1mW3Aqbyt4XTpkLnZhbHVlc1tnKm8reF09MD09PWUucmFuaz9mWzBdOmZbcCpvK3hdfXJldHVybiBkLnRvVGVuc29yKCkucmVzaGFwZShuKX0sb30obGEpO2Z1bmN0aW9uIHlmKHQsZSl7cmV0dXJue2tlcm5lbE5hbWU6dCxiYWNrZW5kTmFtZTpcImNwdVwiLGtlcm5lbEZ1bmM6ZnVuY3Rpb24obil7dmFyIHI9bi5pbnB1dHMsbz1uLmJhY2tlbmQsYT1yLGk9YS5hLHM9YS5iLHU9bztkZihbaSxzXSx0KTt2YXIgYz11LmRhdGEuZ2V0KGkuZGF0YUlkKS52YWx1ZXMsbD11LmRhdGEuZ2V0KHMuZGF0YUlkKS52YWx1ZXMsaD1lKGkuc2hhcGUscy5zaGFwZSxjLGwsaS5kdHlwZSksZj1oWzBdLGQ9aFsxXTtyZXR1cm57ZGF0YUlkOnUud3JpdGUoZixkLGkuZHR5cGUpLHNoYXBlOmQsZHR5cGU6aS5kdHlwZX19fX1mdW5jdGlvbiB4Zih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuLHIsbyxhKXt2YXIgaT1QcihlLG4pLHM9aS5sZW5ndGgsdT0kKGkpLGM9QihhLGsoaSkpLGw9ZS5sZW5ndGgsaD1uLmxlbmd0aCxmPSQoZSksZD0kKG4pLHA9TXIoZSxpKSx2PU1yKG4saSk7aWYocC5sZW5ndGgrdi5sZW5ndGg9PT0wKWZvcih2YXIgZz0wO2c8Yy5sZW5ndGg7KytnKWNbZ109dChyW2clci5sZW5ndGhdLG9bZyVvLmxlbmd0aF0pO2Vsc2V7dmFyIG09ZnVuY3Rpb24oZSl7dmFyIG49aXQoZSxzLHUpLGE9bi5zbGljZSgtbCk7cC5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gYVt0XT0wfSkpO3ZhciBpPWF0KGEsbCxmKSxnPW4uc2xpY2UoLWgpO3YuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuIGdbdF09MH0pKTt2YXIgbT1hdChnLGgsZCk7Y1tlXT10KHJbaV0sb1ttXSl9O2ZvcihnPTA7ZzxjLmxlbmd0aDsrK2cpbShnKX1yZXR1cm5bYyxpXX19THQucmVnaXN0ZXJCYWNrZW5kKFwiY3B1XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBtZn0pLDEpO3ZhciBiZj14ZigoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC9lfSkpLHdmPXlmKHdyLGJmKTt2YXIgQ2Y9e2tlcm5lbE5hbWU6XCJNYXhQb29sV2l0aEFyZ21heFwiLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYXR0cnMscj10LmJhY2tlbmQsbz1lLngsYT1uLGk9YS5maWx0ZXJTaXplLHM9YS5zdHJpZGVzLHU9YS5wYWQsYz1hLmluY2x1ZGVCYXRjaEluSW5kZXgsbD1yO2RmKG8sXCJNYXhQb29sV2l0aEFyZ21heFwiKTt2YXIgaD1sLmRhdGEuZ2V0KG8uZGF0YUlkKS52YWx1ZXMsZj1mYShvLnNoYXBlLGkscyxbMSwxXSx1KSxkPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dmFyIGE9cGYodCwwLG4sJChlKSxvLFwibWF4XCIpLGk9dmYodCxlLG4sbywhMCxyKTtyZXR1cm5bYS52YWx1ZXMsaS52YWx1ZXNdfShoLG8uc2hhcGUsby5kdHlwZSxjLGYpLHA9ZFswXSx2PWRbMV0sZz1sLndyaXRlKHAsZi5vdXRTaGFwZSxvLmR0eXBlKSxtPWwud3JpdGUodixmLm91dFNoYXBlLG8uZHR5cGUpO3JldHVyblt7ZGF0YUlkOmcsc2hhcGU6Zi5vdXRTaGFwZSxkdHlwZTpvLmR0eXBlfSx7ZGF0YUlkOm0sc2hhcGU6Zi5vdXRTaGFwZSxkdHlwZTpcImludDMyXCJ9XX19LEVmPXtrZXJuZWxOYW1lOlwiTm9uTWF4U3VwcHJlc3Npb25WNVwiLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPXQuYXR0cnMsbz1lLGE9by5ib3hlcyxpPW8uc2NvcmVzLHM9cix1PXMubWF4T3V0cHV0U2l6ZSxjPXMuaW91VGhyZXNob2xkLGw9cy5zY29yZVRocmVzaG9sZCxoPXMuc29mdE5tc1NpZ21hLGY9bjtkZihhLFwiTm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmVcIik7dmFyIGQ9TWEoZi5kYXRhLmdldChhLmRhdGFJZCkudmFsdWVzLGYuZGF0YS5nZXQoaS5kYXRhSWQpLnZhbHVlcyx1LGMsbCxoKTtyZXR1cm5bZC5zZWxlY3RlZEluZGljZXMsZC5zZWxlY3RlZFNjb3Jlc119fSxSZj17a2VybmVsTmFtZTpcIlNxdWFyZVwiLGJhY2tlbmROYW1lOlwiY3B1XCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPWUueCxvPW47ZGYocixcInNxdWFyZVwiKTtmb3IodmFyIGE9by5kYXRhLmdldChyLmRhdGFJZCkudmFsdWVzLGk9bmV3IEZsb2F0MzJBcnJheShhLmxlbmd0aCkscz0wO3M8YS5sZW5ndGg7KytzKXt2YXIgdT1hW3NdO2lbc109dSp1fXJldHVybntkYXRhSWQ6by53cml0ZShpLHIuc2hhcGUsci5kdHlwZSksc2hhcGU6ci5zaGFwZSxkdHlwZTpyLmR0eXBlfX19LElmPXhmKChmdW5jdGlvbih0LGUpe3ZhciBuPXQtZTtyZXR1cm4gbipufSkpO2Z1bmN0aW9uIGtmKHQsZSxuLHIsbyl7Zm9yKHZhciBhPWsoZSksaT1lLmxlbmd0aCxzPSQoZSksdT0kKG8pLGM9QihuLGsobykpLGw9MDtsPGE7KytsKXtmb3IodmFyIGg9aXQobCxpLHMpLGY9bmV3IEFycmF5KGgubGVuZ3RoKSxkPTA7ZDxmLmxlbmd0aDtkKyspZltkXT1oW3JbZF1dO2NbYXQoZixpLHUpXT10W2xdfXJldHVybiBjfWZvcih2YXIgU2Y9MCxBZj1bRWYsUmYseWYoRXIsSWYpLHdmLHtrZXJuZWxOYW1lOlwiVHJhbnNwb3NlXCIsYmFja2VuZE5hbWU6XCJjcHVcIixrZXJuZWxGdW5jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXRzLG49dC5hdHRycyxyPXQuYmFja2VuZCxvPWUueCxhPW4ucGVybSxpPXI7ZGYobyxcInRyYW5zcG9zZVwiKTtmb3IodmFyIHM9by5zaGFwZS5sZW5ndGgsdT1uZXcgQXJyYXkocyksYz0wO2M8dS5sZW5ndGg7YysrKXVbY109by5zaGFwZVthW2NdXTt2YXIgbD1rZihpLmRhdGEuZ2V0KG8uZGF0YUlkKS52YWx1ZXMsby5zaGFwZSxvLmR0eXBlLGEsdSk7cmV0dXJue2RhdGFJZDppLndyaXRlKGwsdSxvLmR0eXBlKSxzaGFwZTp1LGR0eXBlOm8uZHR5cGV9fX0sQ2ZdO1NmPEFmLmxlbmd0aDtTZisrKXtkKEFmW1NmXSl9dmFyIFRmLERmPWZ1bmN0aW9uKHQpe3RoaXMudmFyaWFibGVOYW1lcz1bXCJBXCJdO3ZhciBlPVlhKCksbj10WzBdLHI9dFsxXTt0aGlzLm91dHB1dFNoYXBlPXQsdGhpcy51c2VyQ29kZT1cIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWMzIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IHRleFIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgdGV4QyA9IGNvb3Jkc1sxXTtcXG4gICAgICAgIGludCBkZXB0aCA9IGNvb3Jkc1syXTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiK3IrXCIuMCwgXCIrbitcIi4wKTtcXG5cXG4gICAgICAgIHZlYzQgdmFsdWVzID0gXCIrZS50ZXh0dXJlMkQrXCIoQSwgdXYpO1xcbiAgICAgICAgZmxvYXQgdmFsdWU7XFxuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5yO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAxKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmc7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDIpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuYjtcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMykge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5hO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGZsb29yKHZhbHVlICogMjU1LjAgKyAwLjUpKTtcXG4gICAgICB9XFxuICAgIFwifSxOZj1mdW5jdGlvbih0KXt0aGlzLnZhcmlhYmxlTmFtZXM9W1wiQVwiXSx0aGlzLnBhY2tlZElucHV0cz0hMSx0aGlzLnBhY2tlZE91dHB1dD0hMDt2YXIgZT1ZYSgpLG49dFswXSxyPXRbMV07dGhpcy5vdXRwdXRTaGFwZT10LHRoaXMudXNlckNvZGU9XCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMyBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB0ZXhSID0gY29vcmRzWzBdO1xcbiAgICAgICAgaW50IHRleEMgPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgZGVwdGggPSBjb29yZHNbMl07XFxuXFxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xcblxcbiAgICAgICAgZm9yKGludCByb3c9MDsgcm93PD0xOyByb3crKykge1xcbiAgICAgICAgICBmb3IoaW50IGNvbD0wOyBjb2w8PTE7IGNvbCsrKSB7XFxuICAgICAgICAgICAgdGV4QyA9IGNvb3Jkc1sxXSArIHJvdztcXG4gICAgICAgICAgICBkZXB0aCA9IGNvb3Jkc1syXSArIGNvbDtcXG5cXG4gICAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC9cXG4gICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIrcitcIi4wLCBcIituK1wiLjApO1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gXCIrZS50ZXh0dXJlMkQrXCIoQSwgdXYpO1xcbiAgICAgICAgICAgIGZsb2F0IHZhbHVlO1xcbiAgICAgICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XFxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5yO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMSkge1xcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuZztcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDIpIHtcXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmI7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAzKSB7XFxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5hO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXN1bHRbcm93ICogMiArIGNvbF0gPSBmbG9vcih2YWx1ZSAqIDI1NS4wICsgMC41KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgXCIrZS5vdXRwdXQrXCIgPSByZXN1bHQ7XFxuICAgICAgfVxcbiAgICBcIn07dmFyIEZmPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl07Zm9yKHZhciBuPW5ldyBBcnJheSh0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dFtlW3JdXTt0aGlzLm91dHB1dFNoYXBlPW4sdGhpcy5yYW5rPW4ubGVuZ3RoO3ZhciBvPXVpKHRoaXMucmFuayksYT1mdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZihlPjYpdGhyb3cgRXJyb3IoXCJUcmFuc3Bvc2UgZm9yIHJhbmsgXCIrZStcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtmb3IodmFyIG49W1wicmVzUkMueFwiLFwicmVzUkMueVwiLFwicmVzUkMuelwiLFwicmVzUkMud1wiLFwicmVzUkMudVwiLFwicmVzUkMudlwiXSxyPW5ldyBBcnJheShlKSxvPTA7bzx0Lmxlbmd0aDtvKyspclt0W29dXT1uW29dO3JldHVybiByLmpvaW4oKX0oZSk7dGhpcy51c2VyQ29kZT1cIlxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgXCIrbytcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHNldE91dHB1dChnZXRBKFwiK2ErXCIpKTtcXG4gICAgfVxcbiAgICBcIn07dmFyIF9mPWZ1bmN0aW9uKHQsZSl7dGhpcy52YXJpYWJsZU5hbWVzPVtcIkFcIl0sdGhpcy5wYWNrZWRJbnB1dHM9ITAsdGhpcy5wYWNrZWRPdXRwdXQ9ITA7Zm9yKHZhciBuPW5ldyBBcnJheSh0Lmxlbmd0aCkscj0wO3I8bi5sZW5ndGg7cisrKW5bcl09dFtlW3JdXTtpZih0aGlzLm91dHB1dFNoYXBlPW4sdGhpcy5yYW5rPW4ubGVuZ3RoLHRoaXMucmFuaz42KXRocm93IEVycm9yKFwiUGFja2VkIHRyYW5zcG9zZSBmb3IgcmFuayBcIit0aGlzLnJhbmsrXCIgaXMgbm90IHlldCBzdXBwb3J0ZWQuXCIpO3ZhciBvPXVpKHRoaXMucmFuayksYT1qYShcInJjXCIsdGhpcy5yYW5rKSxpPW5ldyBBcnJheSh0aGlzLnJhbmspO2ZvcihyPTA7cjxlLmxlbmd0aDtyKyspaVtlW3JdXT1hW3JdO3ZhciBzPVwidmVjMihcIitpLnNsaWNlKC0yKS5qb2luKCkrXCIpXCIsdT1cIisrXCIrYVt0aGlzLnJhbmstMV0rXCIgPCBcIituW3RoaXMucmFuay0xXSxjPVwiZ2V0Q2hhbm5lbChnZXRBKFwiK2kuam9pbigpK1wiKSwgXCIrcytcIilcIjt0aGlzLnVzZXJDb2RlPVwiXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBcIitvK1wiIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuKTtcXG4gICAgICByZXN1bHRbMF0gPSBcIitjK1wiO1xcbiAgICAgIGlmKFwiK3UrXCIpIHtcXG4gICAgICAgIHJlc3VsdFsxXSA9IFwiK2MrXCI7XFxuICAgICAgfVxcbiAgICAgIC0tXCIrYVt0aGlzLnJhbmstMV0rXCI7XFxuICAgICAgaWYoKytcIithW3RoaXMucmFuay0yXStcIiA8IFwiK25bdGhpcy5yYW5rLTJdK1wiKSB7XFxuICAgICAgICByZXN1bHRbMl0gPSBcIitjK1wiO1xcbiAgICAgICAgaWYoXCIrdStcIikge1xcbiAgICAgICAgICByZXN1bHRbM10gPSBcIitjK1wiO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBzZXRPdXRwdXQocmVzdWx0KTtcXG4gICAgfVxcbiAgICBcIn07Zm9yKHZhciBPZj0wLE1mPVt7a2VybmVsTmFtZTpcIkZyb21QaXhlbHNcIixiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPXQuYXR0cnMsbz1lLnBpeGVscyxhPXIubnVtQ2hhbm5lbHMscz1cInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTFZpZGVvRWxlbWVudCYmbyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQsdT1cInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTEltYWdlRWxlbWVudCYmbyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQsYz1zP1tvLnZpZGVvV2lkdGgsby52aWRlb0hlaWdodF06W28ud2lkdGgsby5oZWlnaHRdLGw9Y1swXSxoPWNbMV0sZj1baCxsXSxkPVtoLGwsYV07KHV8fHMpJiYobnVsbD09VGYmJihUZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKSksVGYuY2FudmFzLndpZHRoPWwsVGYuY2FudmFzLmhlaWdodD1oLFRmLmRyYXdJbWFnZShvLDAsMCxsLGgpLG89VGYuY2FudmFzKTt2YXIgcD1uLm1ha2VUZW5zb3JJbmZvKGYsXCJpbnQzMlwiKTtuLnRleERhdGEuZ2V0KHAuZGF0YUlkKS51c2FnZT16dC5QSVhFTFMsbi5ncGdwdS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUobi5nZXRUZXh0dXJlKHAuZGF0YUlkKSxvKTt2YXIgdj1pKCkuZ2V0Qm9vbChcIldFQkdMX1BBQ0tcIik/bmV3IE5mKGQpOm5ldyBEZihkKSxnPW4ucnVuV2ViR0xQcm9ncmFtKHYsW3BdLFwiaW50MzJcIik7cmV0dXJuIG4uZGlzcG9zZURhdGEocC5kYXRhSWQpLGd9fSx7a2VybmVsTmFtZTp3cixiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPWU7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uZXcgUmkoQ2ksdC5zaGFwZSxlLnNoYXBlKTtyZXR1cm4gaSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpJiYocj1uZXcgU2koSWksdC5zaGFwZSxlLnNoYXBlLCEwKSksbi5ydW5XZWJHTFByb2dyYW0ocixbdCxlXSxcImZsb2F0MzJcIil9KHIuYSxyLmIsbil9fSx7a2VybmVsTmFtZTpcIk5vbk1heFN1cHByZXNzaW9uVjVcIixiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPXQuYXR0cnM7ZG4oXCJ0Zi5ub25NYXhTdXBwcmVzc2lvbigpIGluIHdlYmdsIGxvY2tzIHRoZSBVSSB0aHJlYWQuIENhbGwgdGYubm9uTWF4U3VwcHJlc3Npb25Bc3luYygpIGluc3RlYWRcIik7dmFyIG89ZSxhPW8uYm94ZXMsaT1vLnNjb3JlcyxzPXIsdT1zLm1heE91dHB1dFNpemUsYz1zLmlvdVRocmVzaG9sZCxsPXMuc2NvcmVUaHJlc2hvbGQsaD1zLnNvZnRObXNTaWdtYSxmPW4sZD1NYShmLnJlYWRTeW5jKGEuZGF0YUlkKSxmLnJlYWRTeW5jKGkuZGF0YUlkKSx1LGMsbCxoKTtyZXR1cm5bZC5zZWxlY3RlZEluZGljZXMsZC5zZWxlY3RlZFNjb3Jlc119fSx7a2VybmVsTmFtZTpcIlNxdWFyZVwiLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXRzLG49dC5iYWNrZW5kLHI9ZS54LG89bixhPW5ldyBjdShyLnNoYXBlLFwicmV0dXJuIHggKiB4O1wiKTtyZXR1cm4gby5ydW5XZWJHTFByb2dyYW0oYSxbcl0sci5kdHlwZSl9fSx7a2VybmVsTmFtZTpFcixiYWNrZW5kTmFtZTpcIndlYmdsXCIsa2VybmVsRnVuYzpmdW5jdGlvbih0KXt2YXIgZT10LmlucHV0cyxuPXQuYmFja2VuZCxyPWUsbz1yLmEsYT1yLmIscz1uLHU9aSgpLmdldEJvb2woXCJXRUJHTF9QQUNLX0JJTkFSWV9PUEVSQVRJT05TXCIpP25ldyBTaShcInJldHVybiAoYSAtIGIpICogKGEgLSBiKTtcIixvLnNoYXBlLGEuc2hhcGUpOm5ldyBSaShcInJldHVybiAoYSAtIGIpICogKGEgLSBiKTtcIixvLnNoYXBlLGEuc2hhcGUpO3JldHVybiBzLmNvbXBpbGVBbmRSdW4odSxbbyxhXSl9fSx7a2VybmVsTmFtZTpcIlRyYW5zcG9zZVwiLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxuPXQuaW5wdXRzLHI9dC5hdHRycyxvPXQuYmFja2VuZCxhPW4ueCxzPXIucGVybSx1PW8sYz1hLnNoYXBlLmxlbmd0aCxsPW5ldyBBcnJheShjKSxoPTA7aDxsLmxlbmd0aDtoKyspbFtoXT1hLnNoYXBlW3NbaF1dO2lmKHUuc2hvdWxkRXhlY3V0ZU9uQ1BVKFthXSkpe3ZhciBmPWtmKHUudGV4RGF0YS5nZXQoYS5kYXRhSWQpLnZhbHVlcyxhLnNoYXBlLGEuZHR5cGUscyxsKTtlPXUubWFrZVRlbnNvckluZm8obCxhLmR0eXBlKSx1LnRleERhdGEuZ2V0KGUuZGF0YUlkKS52YWx1ZXM9Zn1lbHNlIGU9ZnVuY3Rpb24odCxlLG4pe3ZhciByPWkoKS5nZXRCb29sKFwiV0VCR0xfUEFDS19BUlJBWV9PUEVSQVRJT05TXCIpP25ldyBfZih0LnNoYXBlLGUpOm5ldyBGZih0LnNoYXBlLGUpO3JldHVybiBuLnJ1bldlYkdMUHJvZ3JhbShyLFt0XSx0LmR0eXBlKX0oYSxzLHUpO3JldHVybiBlfX0se2tlcm5lbE5hbWU6XCJNYXhQb29sV2l0aEFyZ21heFwiLGJhY2tlbmROYW1lOlwid2ViZ2xcIixrZXJuZWxGdW5jOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW5wdXRzLG49dC5hdHRycyxyPXQuYmFja2VuZCxvPWUueCxhPW4saT1hLmZpbHRlclNpemUscz1hLnN0cmlkZXMsdT1hLnBhZCxjPWEuaW5jbHVkZUJhdGNoSW5JbmRleCxsPXI7Qyg0PT09by5zaGFwZS5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJFcnJvciBpbiBtYXhQb29sOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIrby5zaGFwZS5sZW5ndGgrXCIuXCJ9KSk7dmFyIGg9WzEsMV07QyhDYShzLGgpLChmdW5jdGlvbigpe3JldHVyblwiRXJyb3IgaW4gbWF4UG9vbDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gR290IHN0cmlkZXMgXCIrcytcIiBhbmQgZGlsYXRpb25zICdcIitoK1wiJ1wifSkpO3ZhciBmPWZhKG8uc2hhcGUsaSxzLGgsdSksZD1mdW5jdGlvbih0LGUsbixyKXt2YXIgbz1uZXcgV3MobixcIm1heFwiLCExKSxhPXIucnVuV2ViR0xQcm9ncmFtKG8sW3RdLFwiZmxvYXQzMlwiKTtyZXR1cm4gbz1uZXcgV3MobixcIm1heFwiLCEwLCEwLGUpLFthLHIucnVuV2ViR0xQcm9ncmFtKG8sW3RdLFwiZmxvYXQzMlwiKV19KG8sYyxmLGwpO3JldHVybltkWzBdLGRbMV1dfX1dO09mPE1mLmxlbmd0aDtPZisrKXtkKE1mW09mXSl9Zm9yKHZhciBCZj0wLFBmPVt7a2VybmVsTmFtZTp4cixpbnB1dHNUb1NhdmU6W1wiYVwiLFwiYlwiXSxncmFkRnVuYzpmdW5jdGlvbih0LGUpe3ZhciBuPWVbMF0scj1lWzFdLG89UHIobi5zaGFwZSxyLnNoYXBlKTtyZXR1cm57YTpmdW5jdGlvbigpe3ZhciBlPXQscj1CcihuLnNoYXBlLG8pO3JldHVybiByLmxlbmd0aD4wJiYoZT1lLnN1bShyKSksZS5yZXNoYXBlKG4uc2hhcGUpfSxiOmZ1bmN0aW9uKCl7dmFyIGU9dCxuPUJyKHIuc2hhcGUsbyk7cmV0dXJuIG4ubGVuZ3RoPjAmJihlPWUuc3VtKG4pKSxlLnJlc2hhcGUoci5zaGFwZSl9fX19LHtrZXJuZWxOYW1lOlwiQWRkTlwiLHNhdmVBbGxJbnB1dHM6ITAsZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlKXt2YXIgbj17fTtyZXR1cm4gZS5mb3JFYWNoKChmdW5jdGlvbihlLHIpe25bcl09ZnVuY3Rpb24oKXtyZXR1cm4gdC5jbG9uZSgpfX0pKSxufX0se2tlcm5lbE5hbWU6U3IsZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj1uLG89ci5pbnB1dFNoYXBlLGE9ci5zaGFwZSxpPUFycmF5LmZyb20oYSkscz1vLmxlbmd0aC0xO3M+PTA7cy0tKWlmKG9bc109PT1hW3NdKWlbc109MTtlbHNlIGlmKDEhPT1vW3NdKXRocm93IG5ldyBFcnJvcihcImJyb2FkY2FzdFRvKCk6IFtcIitvK1wiXSBjYW5ub3QgYmUgYnJvYWRjYXN0IHRvIFtcIithK1wiXS5cIik7dmFyIHU9W107Zm9yKHM9MDtzPGkubGVuZ3RoO3MrKylpW3NdPjEmJnUucHVzaChzKTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LnN1bSh1LCEwKX19fX0se2tlcm5lbE5hbWU6d3IsaW5wdXRzVG9TYXZlOltcImFcIixcImJcIl0sZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdLHI9ZVsxXSxvPVByKG4uc2hhcGUsci5zaGFwZSk7cmV0dXJue2E6ZnVuY3Rpb24oKXt2YXIgZT1Cbyh0LHIudG9GbG9hdCgpKSxhPUJyKG4uc2hhcGUsbyk7cmV0dXJuIGEubGVuZ3RoPjA/dGgoZSxhKS5yZXNoYXBlKG4uc2hhcGUpOmV9LGI6ZnVuY3Rpb24oKXt2YXIgZT10Lm11bChuLnRvRmxvYXQoKSksYT1CcihyLnNoYXBlLG8pO2EubGVuZ3RoPjAmJihlPXRoKGUsYSkucmVzaGFwZShyLnNoYXBlKSk7dmFyIGk9R2Mocik7cmV0dXJuIG5vKEJvKGUsaS50b0Zsb2F0KCkpKX19fX0se2tlcm5lbE5hbWU6XCJGdXNlZEJhdGNoTm9ybVwiLGlucHV0c1RvU2F2ZTpbXCJ4XCIsXCJtZWFuXCIsXCJ2YXJpYW5jZVwiLFwic2NhbGVcIl0sZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlLG4pe3ZhciByPW4udmFyaWFuY2VFcHNpbG9uLG89ZVswXSxhPWVbMV0saT1lWzJdLHM9ZVszXSx1PUp1KG8pLGM9bnVsbD09cz9PbigxKTpzLGw9QnIoYS5zaGFwZSx1LnNoYXBlKSxoPVtdO2lmKDE9PT1hLnJhbmspe2Zvcih2YXIgZj0wO2Y8dS5zaGFwZS5sZW5ndGgtMTsrK2YpaC5wdXNoKHUuc2hhcGVbZl0pO2gucHVzaCgxKX12YXIgZD1PbyhvLGEpLHA9VG8odCxjKSx2PWFvKE9yKGksT24ocikpKSxnPVRvKFRvKFRvKHYsdiksdiksT24oLS41KSk7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gMT09PWEucmFuaz91cihUbyhUbyh0LHdjKHYuYXM0RCgxLDEsMSxhLnNoYXBlWzBdKSxoKSksYyksby5zaGFwZSk6dXIoVG8oVG8odCx2KSxjKSxvLnNoYXBlKX0sbWVhbjpmdW5jdGlvbigpe3ZhciB0PVRvKFRvKHYsT24oLTEpKSxwKTtyZXR1cm4gMT09PWEucmFuayYmKHQ9dGgodCxsKSksdXIodCxhLnNoYXBlKX0sdmFyaWFuY2U6ZnVuY3Rpb24oKXt2YXIgdD1UbyhUbyhnLGQpLHApO3JldHVybiAxPT09YS5yYW5rJiYodD10aCh0LGwpKSx1cih0LGEuc2hhcGUpfSxzY2FsZTpmdW5jdGlvbigpe3ZhciBlPVRvKGQsdiksbj1Ubyh0LGUpO3JldHVybiAxPT09YS5yYW5rJiYobj10aChuLGwpKSx1cihuLGEuc2hhcGUpfSxvZmZzZXQ6ZnVuY3Rpb24oKXt2YXIgZT10O3JldHVybiAxPT09YS5yYW5rJiYoZT10aChlLGwpKSx1cihlLGEuc2hhcGUpfX19fSx7a2VybmVsTmFtZTpUcixncmFkRnVuYzpmdW5jdGlvbih0KXtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LnRvRmxvYXQoKX19fX0se2tlcm5lbE5hbWU6QXIsaW5wdXRzVG9TYXZlOltcImluZGljZXNcIl0sZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybntpbmRpY2VzOmZ1bmN0aW9uKCl7cmV0dXJuIEduKG4uc2hhcGUsXCJmbG9hdDMyXCIpfX19fSx7a2VybmVsTmFtZTpOcixpbnB1dHNUb1NhdmU6W1wieFwiXSxncmFkRnVuYzpmdW5jdGlvbih0LGUsbil7dmFyIHI9ZVswXSxvPW4ucGFkZGluZ3MubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFswXX0pKTtyZXR1cm57eDpmdW5jdGlvbigpe3JldHVybiB0LnNsaWNlKG8sci5zaGFwZSl9fX19LHtrZXJuZWxOYW1lOlwiU3F1YXJlXCIsaW5wdXRzVG9TYXZlOltcInhcIl0sZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlKXt2YXIgbj1lWzBdO3JldHVybnt4OmZ1bmN0aW9uKCl7cmV0dXJuIHQubXVsKG4udG9GbG9hdCgpLm11bCgyKSl9fX19LHtrZXJuZWxOYW1lOkVyLGlucHV0c1RvU2F2ZTpbXCJhXCIsXCJiXCJdLGdyYWRGdW5jOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZVswXSxyPWVbMV0sbz1PbigyKTtyZXR1cm57YTpmdW5jdGlvbigpe3JldHVybiBUbyh0LFRvKG8sT28obixyKSkpfSxiOmZ1bmN0aW9uKCl7cmV0dXJuIFRvKHQsVG8obyxPbyhyLG4pKSl9fX19LHtrZXJuZWxOYW1lOkRyLGlucHV0c1RvU2F2ZTpbXCJ4XCJdLGdyYWRGdW5jOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1lWzBdLG89bi5yZXBzO3JldHVybnt4OmZ1bmN0aW9uKCl7dmFyIGU9WG4ocik7aWYoMT09PXIucmFuaylmb3IodmFyIG49MDtuPG9bMF07KytuKWU9ZS5hZGQodC5zbGljZShbbipyLnNoYXBlWzBdXSxbci5zaGFwZVswXV0pKTtlbHNlIGlmKDI9PT1yLnJhbmspZm9yKG49MDtuPG9bMF07KytuKWZvcih2YXIgYT0wO2E8b1sxXTsrK2EpZT1lLmFkZCh0LnNsaWNlKFtuKnIuc2hhcGVbMF0sYSpyLnNoYXBlWzFdXSxbci5zaGFwZVswXSxyLnNoYXBlWzFdXSkpO2Vsc2UgaWYoMz09PXIucmFuaylmb3Iobj0wO248b1swXTsrK24pZm9yKGE9MDthPG9bMV07KythKWZvcih2YXIgaT0wO2k8b1syXTsrK2kpZT1lLmFkZCh0LnNsaWNlKFtuKnIuc2hhcGVbMF0sYSpyLnNoYXBlWzFdLGkqci5zaGFwZVsyXV0sW3Iuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdXSkpO2Vsc2V7aWYoNCE9PXIucmFuayl0aHJvdyBuZXcgRXJyb3IoXCJHcmFkaWVudCBmb3IgdGlsZSBvcGVyYXRpb24gaXMgbm90IGltcGxlbWVudGVkIGZvciByYW5rLVwiK3IucmFuaytcIiB0ZW5zb3JzIHlldC5cIik7Zm9yKG49MDtuPG9bMF07KytuKWZvcihhPTA7YTxvWzFdOysrYSlmb3IoaT0wO2k8b1syXTsrK2kpZm9yKHZhciBzPTA7czxvWzNdOysrcyllPWUuYWRkKHQuc2xpY2UoW24qci5zaGFwZVswXSxhKnIuc2hhcGVbMV0saSpyLnNoYXBlWzJdLHMqci5zaGFwZVszXV0sW3Iuc2hhcGVbMF0sci5zaGFwZVsxXSxyLnNoYXBlWzJdLHIuc2hhcGVbM11dKSl9cmV0dXJuIGV9fX19LHtrZXJuZWxOYW1lOlwiVHJhbnNwb3NlXCIsZ3JhZEZ1bmM6ZnVuY3Rpb24odCxlLG4pe3ZhciByPVJuKG4ucGVybSk7cmV0dXJue3g6ZnVuY3Rpb24oKXtyZXR1cm4gdWEodCxyKX19fX1dO0JmPFBmLmxlbmd0aDtCZisrKXtwKFBmW0JmXSl9dmFyIExmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gdC5wcm90b3R5cGUuZmV0Y2g9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZmV0Y2godCxlKX0sdC5wcm90b3R5cGUubm93PWZ1bmN0aW9uKCl7cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpfSx0LnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihcInV0Zi04XCIhPT1lJiZcInV0ZjhcIiE9PWUpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIGVuY29kZXIgb25seSBzdXBwb3J0cyB1dGYtOCwgYnV0IGdvdCBcIitlKTtyZXR1cm4gbnVsbD09dGhpcy50ZXh0RW5jb2RlciYmKHRoaXMudGV4dEVuY29kZXI9bmV3IFRleHRFbmNvZGVyKSx0aGlzLnRleHRFbmNvZGVyLmVuY29kZSh0KX0sdC5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBUZXh0RGVjb2RlcihlKS5kZWNvZGUodCl9LHR9KCk7aSgpLmdldChcIklTX0JST1dTRVJcIikmJmkoKS5zZXRQbGF0Zm9ybShcImJyb3dzZXJcIixuZXcgTGYpO3ZhciBXZixVZj1mdW5jdGlvbigpe3JldHVybiByZXF1aXJlKFwibm9kZS1mZXRjaFwiKX0sVmY9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy51dGlsPXJlcXVpcmUoXCJ1dGlsXCIpLHRoaXMudGV4dEVuY29kZXI9bmV3IHRoaXMudXRpbC5UZXh0RW5jb2Rlcn1yZXR1cm4gdC5wcm90b3R5cGUuZmV0Y2g9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9aSgpLmdsb2JhbC5mZXRjaD9pKCkuZ2xvYmFsLmZldGNoKHQsZSk6KG51bGw9PVdmJiYoV2Y9VWYoKSksV2YodCxlKSl9LHQucHJvdG90eXBlLm5vdz1mdW5jdGlvbigpe3ZhciB0PXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJuIDFlMyp0WzBdK3RbMV0vMWU2fSx0LnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24odCxlKXtpZihcInV0Zi04XCIhPT1lJiZcInV0ZjhcIiE9PWUpdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBidWlsdC1pbiBlbmNvZGVyIG9ubHkgc3VwcG9ydHMgdXRmLTgsIGJ1dCBnb3QgXCIrZSk7cmV0dXJuIHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHQpfSx0LnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMD09PXQubGVuZ3RoP1wiXCI6bmV3IHRoaXMudXRpbC5UZXh0RGVjb2RlcihlKS5kZWNvZGUodCl9LHR9KCk7aSgpLmdldChcIklTX05PREVcIikmJmkoKS5zZXRQbGF0Zm9ybShcIm5vZGVcIixuZXcgVmYpO3ZhciB6Zj17ZmxvYXQzMjo0LGludDMyOjQsdWludDE2OjIsdWludDg6MSxib29sOjF9LEdmPTQ7ZnVuY3Rpb24gSGYodCxlKXtmb3IodmFyIG49e30scj0wLG89ZnVuY3Rpb24oZSl7dmFyIG89ZS5uYW1lLGE9ZS5kdHlwZSxpPWUuc2hhcGUscz1rKGkpLHU9dm9pZCAwO2lmKFwicXVhbnRpemF0aW9uXCJpbiBlKXt2YXIgYz1lLnF1YW50aXphdGlvbjtpZihcInVpbnQ4XCIhPT1jLmR0eXBlJiZcInVpbnQxNlwiIT09Yy5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJXZWlnaHQgXCIrZS5uYW1lK1wiIGhhcyB1bmtub3duIHF1YW50aXphdGlvbiBkdHlwZSBcIitjLmR0eXBlK1wiLiBTdXBwb3J0ZWQgcXVhbnRpemF0aW9uIGR0eXBlcyBhcmU6ICd1aW50OCcgYW5kICd1aW50MTYnLlwiKTt2YXIgbD16ZltjLmR0eXBlXSxoPXQuc2xpY2UocixyK3MqbCksZj1cInVpbnQ4XCI9PT1jLmR0eXBlP25ldyBVaW50OEFycmF5KGgpOm5ldyBVaW50MTZBcnJheShoKTtpZihcImZsb2F0MzJcIj09PWEpdT1GbG9hdDMyQXJyYXkuZnJvbShmLChmdW5jdGlvbih0KXtyZXR1cm4gdCpjLnNjYWxlK2MubWlufSkpO2Vsc2V7aWYoXCJpbnQzMlwiIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJ1wiK28rXCInOiBcIithKTt1PUludDMyQXJyYXkuZnJvbShmLChmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5yb3VuZCh0KmMuc2NhbGUrYy5taW4pfSkpfXIrPXMqbH1lbHNlIGlmKFwic3RyaW5nXCI9PT1hKXt2YXIgZD1rKGUuc2hhcGUpO3U9W107Zm9yKHZhciBwPTA7cDxkO3ArKyl7dmFyIHY9bmV3IFVpbnQzMkFycmF5KHQuc2xpY2UocixyK0dmKSlbMF07cis9R2Y7dmFyIGc9bmV3IFVpbnQ4QXJyYXkodC5zbGljZShyLHIrdikpO3UucHVzaChnKSxyKz12fX1lbHNle3ZhciBtPXpmW2FdO2g9dC5zbGljZShyLHIrcyptKTtpZihcImZsb2F0MzJcIj09PWEpdT1uZXcgRmxvYXQzMkFycmF5KGgpO2Vsc2UgaWYoXCJpbnQzMlwiPT09YSl1PW5ldyBJbnQzMkFycmF5KGgpO2Vsc2V7aWYoXCJib29sXCIhPT1hKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnXCIrbytcIic6IFwiK2EpO3U9bmV3IFVpbnQ4QXJyYXkoaCl9cis9cyptfW5bb109Rm4odSxpLGEpfSxhPTAsaT1lO2E8aS5sZW5ndGg7YSsrKXtvKGlbYV0pfXJldHVybiBufWZ1bmN0aW9uIHFmKHQpe2lmKG51bGw9PT10KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdmFsdWU6IFwiK0pTT04uc3RyaW5naWZ5KHQpKTt2YXIgZT0wLG49W107dC5mb3JFYWNoKChmdW5jdGlvbih0KXtpZihlKz10LmJ5dGVMZW5ndGgsbi5wdXNoKHQuYnl0ZUxlbmd0aD09PXQuYnVmZmVyLmJ5dGVMZW5ndGg/dDpuZXcgdC5jb25zdHJ1Y3Rvcih0KSksISh0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFR5cGVkQXJyYXkgc3VidHlwZTogXCIrdC5jb25zdHJ1Y3Rvci5uYW1lKX0pKTt2YXIgcj1uZXcgVWludDhBcnJheShlKSxvPTA7cmV0dXJuIG4uZm9yRWFjaCgoZnVuY3Rpb24odCl7ci5zZXQobmV3IFVpbnQ4QXJyYXkodC5idWZmZXIpLG8pLG8rPXQuYnl0ZUxlbmd0aH0pKSxyLmJ1ZmZlcn12YXIgS2Y9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJ1ZmZlciYmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBCbG9ifHxcInVuZGVmaW5lZFwiPT10eXBlb2YgYXRvYnx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIGJ0b2EpO2Z1bmN0aW9uIGpmKHQpe3JldHVybiBLZj9CdWZmZXIuYnl0ZUxlbmd0aCh0KTpuZXcgQmxvYihbdF0pLnNpemV9ZnVuY3Rpb24gWGYodCl7dmFyIGU9MDt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe2UrPXQuYnl0ZUxlbmd0aH0pKTt2YXIgbj1uZXcgVWludDhBcnJheShlKSxyPTA7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7bi5zZXQobmV3IFVpbnQ4QXJyYXkodCkscikscis9dC5ieXRlTGVuZ3RofSkpLG4uYnVmZmVyfWZ1bmN0aW9uIFlmKHQpe2Zvcih0PXQudHJpbSgpO3QuZW5kc1dpdGgoXCIvXCIpOyl0PXQuc2xpY2UoMCx0Lmxlbmd0aC0xKTt2YXIgZT10LnNwbGl0KFwiL1wiKTtyZXR1cm4gZVtlLmxlbmd0aC0xXX1mdW5jdGlvbiAkZih0KXtpZih0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBKU09OIG1vZGVsIHRvcG9sb2d5LCByZWNlaXZlZCBBcnJheUJ1ZmZlci5cIik7cmV0dXJue2RhdGVTYXZlZDpuZXcgRGF0ZSxtb2RlbFRvcG9sb2d5VHlwZTpcIkpTT05cIixtb2RlbFRvcG9sb2d5Qnl0ZXM6bnVsbD09dC5tb2RlbFRvcG9sb2d5PzA6amYoSlNPTi5zdHJpbmdpZnkodC5tb2RlbFRvcG9sb2d5KSksd2VpZ2h0U3BlY3NCeXRlczpudWxsPT10LndlaWdodFNwZWNzPzA6amYoSlNPTi5zdHJpbmdpZnkodC53ZWlnaHRTcGVjcykpLHdlaWdodERhdGFCeXRlczpudWxsPT10LndlaWdodERhdGE/MDp0LndlaWdodERhdGEuYnl0ZUxlbmd0aH19dmFyIFFmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuc2F2ZVJvdXRlcnM9W10sdGhpcy5sb2FkUm91dGVycz1bXX1yZXR1cm4gdC5nZXRJbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiBudWxsPT10Lmluc3RhbmNlJiYodC5pbnN0YW5jZT1uZXcgdCksdC5pbnN0YW5jZX0sdC5yZWdpc3RlclNhdmVSb3V0ZXI9ZnVuY3Rpb24oZSl7dC5nZXRJbnN0YW5jZSgpLnNhdmVSb3V0ZXJzLnB1c2goZSl9LHQucmVnaXN0ZXJMb2FkUm91dGVyPWZ1bmN0aW9uKGUpe3QuZ2V0SW5zdGFuY2UoKS5sb2FkUm91dGVycy5wdXNoKGUpfSx0LmdldFNhdmVIYW5kbGVycz1mdW5jdGlvbihlKXtyZXR1cm4gdC5nZXRIYW5kbGVycyhlLFwic2F2ZVwiKX0sdC5nZXRMb2FkSGFuZGxlcnM9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5nZXRIYW5kbGVycyhlLFwibG9hZFwiLG4pfSx0LmdldEhhbmRsZXJzPWZ1bmN0aW9uKGUsbixyKXt2YXIgbz1bXTtyZXR1cm4oXCJsb2FkXCI9PT1uP3QuZ2V0SW5zdGFuY2UoKS5sb2FkUm91dGVyczp0LmdldEluc3RhbmNlKCkuc2F2ZVJvdXRlcnMpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBuPXQoZSxyKTtudWxsIT09biYmby5wdXNoKG4pfSkpLG99LHR9KCksSmY9XCI6Ly9cIixaZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLm1hbmFnZXJzPXt9fXJldHVybiB0LmdldEluc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PXQuaW5zdGFuY2UmJih0Lmluc3RhbmNlPW5ldyB0KSx0Lmluc3RhbmNlfSx0LnJlZ2lzdGVyTWFuYWdlcj1mdW5jdGlvbihlLG4pe0MobnVsbCE9ZSwoZnVuY3Rpb24oKXtyZXR1cm5cInNjaGVtZSBtdXN0IG5vdCBiZSB1bmRlZmluZWQgb3IgbnVsbC5cIn0pKSxlLmVuZHNXaXRoKEpmKSYmKGU9ZS5zbGljZSgwLGUuaW5kZXhPZihKZikpKSxDKGUubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJzY2hlbWUgbXVzdCBub3QgYmUgYW4gZW1wdHkgc3RyaW5nLlwifSkpO3ZhciByPXQuZ2V0SW5zdGFuY2UoKTtDKG51bGw9PXIubWFuYWdlcnNbZV0sKGZ1bmN0aW9uKCl7cmV0dXJuXCJBIG1vZGVsIHN0b3JlIG1hbmFnZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBzY2hlbWUgJ1wiK2UrXCInLlwifSkpLHIubWFuYWdlcnNbZV09bn0sdC5nZXRNYW5hZ2VyPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0SW5zdGFuY2UoKS5tYW5hZ2Vyc1t0XTtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIG1hbmFnZXIgZm9yIHNjaGVtZSAnXCIrdCtcIidcIik7cmV0dXJuIGV9LHQuZ2V0U2NoZW1lcz1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEluc3RhbmNlKCkubWFuYWdlcnMpfSx0fSgpO2Z1bmN0aW9uIHRkKHQpe2lmKC0xPT09dC5pbmRleE9mKEpmKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdXJsIHN0cmluZyBwcm92aWRlZCBkb2VzIG5vdCBjb250YWluIGEgc2NoZW1lLiBTdXBwb3J0ZWQgc2NoZW1lcyBhcmU6IFwiK1pmLmdldFNjaGVtZXMoKS5qb2luKFwiLFwiKSk7cmV0dXJue3NjaGVtZTp0LnNwbGl0KEpmKVswXSxwYXRoOnQuc3BsaXQoSmYpWzFdfX1mdW5jdGlvbiBlZCh0LGUsbyl7cmV0dXJuIHZvaWQgMD09PW8mJihvPSExKSxuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbixhLGkscyx1LGMsbCxoLGY7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm4gQyh0IT09ZSwoZnVuY3Rpb24oKXtyZXR1cm5cIk9sZCBwYXRoIGFuZCBuZXcgcGF0aCBhcmUgdGhlIHNhbWU6ICdcIit0K1wiJ1wifSkpLEMoKG49UWYuZ2V0TG9hZEhhbmRsZXJzKHQpKS5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cIkNvcHlpbmcgZmFpbGVkIGJlY2F1c2Ugbm8gbG9hZCBoYW5kbGVyIGlzIGZvdW5kIGZvciBzb3VyY2UgVVJMIFwiK3QrXCIuXCJ9KSksQyhuLmxlbmd0aDwyLChmdW5jdGlvbigpe3JldHVyblwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBtb3JlIHRoYW4gb25lIChcIituLmxlbmd0aCtcIikgbG9hZCBoYW5kbGVycyBmb3Igc291cmNlIFVSTCBcIit0K1wiLlwifSkpLGE9blswXSxDKChpPVFmLmdldFNhdmVIYW5kbGVycyhlKSkubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJDb3B5aW5nIGZhaWxlZCBiZWNhdXNlIG5vIHNhdmUgaGFuZGxlciBpcyBmb3VuZCBmb3IgZGVzdGluYXRpb24gVVJMIFwiK2UrXCIuXCJ9KSksQyhpLmxlbmd0aDwyLChmdW5jdGlvbigpe3JldHVyblwiQ29weWluZyBmYWlsZWQgYmVjYXVzZSBtb3JlIHRoYW4gb25lIChcIituLmxlbmd0aCtcIikgc2F2ZSBoYW5kbGVycyBmb3IgZGVzdGluYXRpb24gVVJMIFwiK2UrXCIuXCJ9KSkscz1pWzBdLHU9dGQodCkuc2NoZW1lLGM9dGQodCkucGF0aCxsPXU9PT10ZCh0KS5zY2hlbWUsWzQsYS5sb2FkKCldO2Nhc2UgMTpyZXR1cm4gaD1yLnNlbnQoKSxvJiZsP1s0LFpmLmdldE1hbmFnZXIodSkucmVtb3ZlTW9kZWwoYyldOlszLDNdO2Nhc2UgMjpyLnNlbnQoKSxyLmxhYmVsPTM7Y2FzZSAzOnJldHVybls0LHMuc2F2ZShoKV07Y2FzZSA0OnJldHVybiBmPXIuc2VudCgpLCFvfHxsP1szLDZdOls0LFpmLmdldE1hbmFnZXIodSkucmVtb3ZlTW9kZWwoYyldO2Nhc2UgNTpyLnNlbnQoKSxyLmxhYmVsPTY7Y2FzZSA2OnJldHVyblsyLGYubW9kZWxBcnRpZmFjdHNJbmZvXX19KSl9KSl9dmFyIG5kPVwibW9kZWxzX3N0b3JlXCIscmQ9XCJtb2RlbF9pbmZvX3N0b3JlXCI7ZnVuY3Rpb24gb2QoKXtpZighaSgpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBvYnRhaW4gSW5kZXhlZERCIGZhY3RvcnkgYmVjYXVzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudGlzIG5vdCBhIHdlYiBicm93c2VyLlwiKTt2YXIgdD13aW5kb3d8fHNlbGYsZT10LmluZGV4ZWREQnx8dC5tb3pJbmRleGVkREJ8fHQud2Via2l0SW5kZXhlZERCfHx0Lm1zSW5kZXhlZERCfHx0LnNoaW1JbmRleGVkREI7aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY3VycmVudCBicm93c2VyIGRvZXMgbm90IGFwcGVhciB0byBzdXBwb3J0IEluZGV4ZWREQi5cIik7cmV0dXJuIGV9ZnVuY3Rpb24gYWQodCl7dmFyIGU9dC5yZXN1bHQ7ZS5jcmVhdGVPYmplY3RTdG9yZShuZCx7a2V5UGF0aDpcIm1vZGVsUGF0aFwifSksZS5jcmVhdGVPYmplY3RTdG9yZShyZCx7a2V5UGF0aDpcIm1vZGVsUGF0aFwifSl9dmFyIGlkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZih0aGlzLmluZGV4ZWREQj1vZCgpLG51bGw9PXR8fCF0KXRocm93IG5ldyBFcnJvcihcIkZvciBJbmRleGVkREIsIG1vZGVsUGF0aCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCIpO3RoaXMubW9kZWxQYXRoPXR9cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe2lmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2Uuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7cmV0dXJuWzIsdGhpcy5kYXRhYmFzZUFjdGlvbih0aGlzLm1vZGVsUGF0aCx0KV19KSl9KSl9LHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7cmV0dXJuWzIsdGhpcy5kYXRhYmFzZUFjdGlvbih0aGlzLm1vZGVsUGF0aCldfSkpfSkpfSx0LnByb3RvdHlwZS5kYXRhYmFzZUFjdGlvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbih0LHIpe3ZhciBvPW4uaW5kZXhlZERCLm9wZW4oXCJ0ZW5zb3JmbG93anNcIiwxKTtvLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbigpe3JldHVybiBhZChvKX0sby5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgYT1vLnJlc3VsdDtpZihudWxsPT1lKXt2YXIgaT1hLnRyYW5zYWN0aW9uKG5kLFwicmVhZG9ubHlcIikscz1pLm9iamVjdFN0b3JlKG5kKS5nZXQobi5tb2RlbFBhdGgpO3Mub25zdWNjZXNzPWZ1bmN0aW9uKCl7aWYobnVsbD09cy5yZXN1bHQpcmV0dXJuIGEuY2xvc2UoKSxyKG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIHdpdGggcGF0aCAnXCIrbi5tb2RlbFBhdGgrXCInIGluIEluZGV4ZWREQi5cIikpO3Qocy5yZXN1bHQubW9kZWxBcnRpZmFjdHMpfSxzLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGEuY2xvc2UoKSxyKHMuZXJyb3IpfSxpLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpfX1lbHNle3ZhciB1LGM9JGYoZSksbD1hLnRyYW5zYWN0aW9uKHJkLFwicmVhZHdyaXRlXCIpLGg9bC5vYmplY3RTdG9yZShyZCksZj1oLnB1dCh7bW9kZWxQYXRoOm4ubW9kZWxQYXRoLG1vZGVsQXJ0aWZhY3RzSW5mbzpjfSk7Zi5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgbz0odT1hLnRyYW5zYWN0aW9uKG5kLFwicmVhZHdyaXRlXCIpKS5vYmplY3RTdG9yZShuZCkucHV0KHttb2RlbFBhdGg6bi5tb2RlbFBhdGgsbW9kZWxBcnRpZmFjdHM6ZSxtb2RlbEFydGlmYWN0c0luZm86Y30pO28ub25zdWNjZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIHQoe21vZGVsQXJ0aWZhY3RzSW5mbzpjfSl9LG8ub25lcnJvcj1mdW5jdGlvbih0KXt2YXIgZT0oaD1sLm9iamVjdFN0b3JlKHJkKSkuZGVsZXRlKG4ubW9kZWxQYXRoKTtlLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3JldHVybiBhLmNsb3NlKCkscihvLmVycm9yKX0sZS5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBhLmNsb3NlKCkscihvLmVycm9yKX19fSxmLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIGEuY2xvc2UoKSxyKGYuZXJyb3IpfSxsLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtudWxsPT11P2EuY2xvc2UoKTp1Lm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gYS5jbG9zZSgpfX19fSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHIoby5lcnJvcil9fSkpfSx0LlVSTF9TQ0hFTUU9XCJpbmRleGVkZGI6Ly9cIix0fSgpLHNkPWZ1bmN0aW9uKHQpe3JldHVybiBpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikmJiFBcnJheS5pc0FycmF5KHQpJiZ0LnN0YXJ0c1dpdGgoaWQuVVJMX1NDSEVNRSk/KGU9dC5zbGljZShpZC5VUkxfU0NIRU1FLmxlbmd0aCksbmV3IGlkKGUpKTpudWxsO3ZhciBlfTtRZi5yZWdpc3RlclNhdmVSb3V0ZXIoc2QpLFFmLnJlZ2lzdGVyTG9hZFJvdXRlcihzZCk7dmFyIHVkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuaW5kZXhlZERCPW9kKCl9cmV0dXJuIHQucHJvdG90eXBlLmxpc3RNb2RlbHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtyZXR1cm5bMixuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSxuKXt2YXIgcj10LmluZGV4ZWREQi5vcGVuKFwidGVuc29yZmxvd2pzXCIsMSk7ci5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gYWQocil9LHIub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIHQ9ci5yZXN1bHQsbz10LnRyYW5zYWN0aW9uKHJkLFwicmVhZG9ubHlcIiksYT1vLm9iamVjdFN0b3JlKHJkKS5nZXRBbGwoKTthLm9uc3VjY2Vzcz1mdW5jdGlvbigpe2Zvcih2YXIgdD17fSxuPTAscj1hLnJlc3VsdDtuPHIubGVuZ3RoO24rKyl7dmFyIG89cltuXTt0W28ubW9kZWxQYXRoXT1vLm1vZGVsQXJ0aWZhY3RzSW5mb31lKHQpfSxhLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuY2xvc2UoKSxuKGEuZXJyb3IpfSxvLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtyZXR1cm4gdC5jbG9zZSgpfX0sci5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBuKHIuZXJyb3IpfX0pKV19KSl9KSl9LHQucHJvdG90eXBlLnJlbW92ZU1vZGVsPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiB0PShyPXQpLnN0YXJ0c1dpdGgoaWQuVVJMX1NDSEVNRSk/ci5zbGljZShpZC5VUkxfU0NIRU1FLmxlbmd0aCk6cixbMixuZXcgUHJvbWlzZSgoZnVuY3Rpb24obixyKXt2YXIgbz1lLmluZGV4ZWREQi5vcGVuKFwidGVuc29yZmxvd2pzXCIsMSk7by5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gYWQobyl9LG8ub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIGUsYT1vLnJlc3VsdCxpPWEudHJhbnNhY3Rpb24ocmQsXCJyZWFkd3JpdGVcIikscz1pLm9iamVjdFN0b3JlKHJkKSx1PXMuZ2V0KHQpO3Uub25zdWNjZXNzPWZ1bmN0aW9uKCl7aWYobnVsbD09dS5yZXN1bHQpcmV0dXJuIGEuY2xvc2UoKSxyKG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIHdpdGggcGF0aCAnXCIrdCtcIicgaW4gSW5kZXhlZERCLlwiKSk7dmFyIG89cy5kZWxldGUodCksaT1mdW5jdGlvbigpe3ZhciBvPShlPWEudHJhbnNhY3Rpb24obmQsXCJyZWFkd3JpdGVcIikpLm9iamVjdFN0b3JlKG5kKS5kZWxldGUodCk7by5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtyZXR1cm4gbih1LnJlc3VsdC5tb2RlbEFydGlmYWN0c0luZm8pfSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHIodS5lcnJvcil9fTtvLm9uc3VjY2Vzcz1pLG8ub25lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gaSgpLGEuY2xvc2UoKSxyKHUuZXJyb3IpfX0sdS5vbmVycm9yPWZ1bmN0aW9uKHQpe3JldHVybiBhLmNsb3NlKCkscih1LmVycm9yKX0saS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7bnVsbD09ZT9hLmNsb3NlKCk6ZS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuIGEuY2xvc2UoKX19fSxvLm9uZXJyb3I9ZnVuY3Rpb24odCl7cmV0dXJuIHIoby5lcnJvcil9fSkpXX0pKX0pKX0sdH0oKTtpZihpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdHJ5e1pmLnJlZ2lzdGVyTWFuYWdlcihpZC5VUkxfU0NIRU1FLG5ldyB1ZCl9Y2F0Y2godCl7fXZhciBjZD1cIi9cIixsZD1cInRlbnNvcmZsb3dqc19tb2RlbHNcIixoZD1cImluZm9cIixmZD1cIm1vZGVsX3RvcG9sb2d5XCIsZGQ9XCJ3ZWlnaHRfc3BlY3NcIixwZD1cIndlaWdodF9kYXRhXCIsdmQ9XCJtb2RlbF9tZXRhZGF0YVwiO2Z1bmN0aW9uIGdkKHQpe3JldHVybntpbmZvOltsZCx0LGhkXS5qb2luKGNkKSx0b3BvbG9neTpbbGQsdCxmZF0uam9pbihjZCksd2VpZ2h0U3BlY3M6W2xkLHQsZGRdLmpvaW4oY2QpLHdlaWdodERhdGE6W2xkLHQscGRdLmpvaW4oY2QpLG1vZGVsTWV0YWRhdGE6W2xkLHQsdmRdLmpvaW4oY2QpfX1mdW5jdGlvbiBtZCh0KXt2YXIgZT10LnNwbGl0KGNkKTtpZihlLmxlbmd0aDwzKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5IGZvcm1hdDogXCIrdCk7cmV0dXJuIGUuc2xpY2UoMSxlLmxlbmd0aC0xKS5qb2luKGNkKX12YXIgeWQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2lmKCFpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIil8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3d8fHZvaWQgMD09PXdpbmRvdy5sb2NhbFN0b3JhZ2UpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBsb2NhbCBzdG9yYWdlLlwiKTtpZih0aGlzLkxTPXdpbmRvdy5sb2NhbFN0b3JhZ2UsbnVsbD09dHx8IXQpdGhyb3cgbmV3IEVycm9yKFwiRm9yIGxvY2FsIHN0b3JhZ2UsIG1vZGVsUGF0aCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCIpO3RoaXMubW9kZWxQYXRoPXQsdGhpcy5rZXlzPWdkKHRoaXMubW9kZWxQYXRoKX1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe2lmKHQubW9kZWxUb3BvbG9neSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXJMb2NhbFN0b3JhZ2Uuc2F2ZSgpIGRvZXMgbm90IHN1cHBvcnQgc2F2aW5nIG1vZGVsIHRvcG9sb2d5IGluIGJpbmFyeSBmb3JtYXRzIHlldC5cIik7ZT1KU09OLnN0cmluZ2lmeSh0Lm1vZGVsVG9wb2xvZ3kpLG49SlNPTi5zdHJpbmdpZnkodC53ZWlnaHRTcGVjcyksbz0kZih0KTt0cnl7cmV0dXJuIHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMuaW5mbyxKU09OLnN0cmluZ2lmeShvKSksdGhpcy5MUy5zZXRJdGVtKHRoaXMua2V5cy50b3BvbG9neSxlKSx0aGlzLkxTLnNldEl0ZW0odGhpcy5rZXlzLndlaWdodFNwZWNzLG4pLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSxmdW5jdGlvbih0KXtpZihLZilyZXR1cm4gQnVmZmVyLmZyb20odCkudG9TdHJpbmcoXCJiYXNlNjRcIik7Zm9yKHZhciBlPW5ldyBVaW50OEFycmF5KHQpLG49XCJcIixyPTAsbz1lLmxlbmd0aDtyPG87cisrKW4rPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtyXSk7cmV0dXJuIGJ0b2Eobil9KHQud2VpZ2h0RGF0YSkpLHRoaXMuTFMuc2V0SXRlbSh0aGlzLmtleXMubW9kZWxNZXRhZGF0YSxKU09OLnN0cmluZ2lmeSh7Zm9ybWF0OnQuZm9ybWF0LGdlbmVyYXRlZEJ5OnQuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6dC5jb252ZXJ0ZWRCeSx1c2VyRGVmaW5lZE1ldGFkYXRhOnQudXNlckRlZmluZWRNZXRhZGF0YX0pKSxbMix7bW9kZWxBcnRpZmFjdHNJbmZvOm99XX1jYXRjaCh0KXt0aHJvdyB0aGlzLkxTLnJlbW92ZUl0ZW0odGhpcy5rZXlzLmluZm8pLHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMudG9wb2xvZ3kpLHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMud2VpZ2h0U3BlY3MpLHRoaXMuTFMucmVtb3ZlSXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSksdGhpcy5MUy5yZW1vdmVJdGVtKHRoaXMua2V5cy5tb2RlbE1ldGFkYXRhKSxuZXcgRXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIHRvIGxvY2FsIHN0b3JhZ2U6IHNpemUgcXVvdGEgYmVpbmcgZXhjZWVkZWQgaXMgYSBwb3NzaWJsZSBjYXVzZSBvZiB0aGlzIGZhaWx1cmU6IG1vZGVsVG9wb2xvZ3lCeXRlcz1cIitvLm1vZGVsVG9wb2xvZ3lCeXRlcytcIiwgd2VpZ2h0U3BlY3NCeXRlcz1cIitvLndlaWdodFNwZWNzQnl0ZXMrXCIsIHdlaWdodERhdGFCeXRlcz1cIitvLndlaWdodERhdGFCeXRlcytcIi5cIil9cmV0dXJuWzJdfSkpfSkpfSx0LnByb3RvdHlwZS5sb2FkPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0LGUsbixvLGEsaSxzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe2lmKG51bGw9PSh0PUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy5pbmZvKSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZXJlIGlzIG5vIG1vZGVsIHdpdGggbmFtZSAnXCIrdGhpcy5tb2RlbFBhdGgrXCInXCIpO2lmKFwiSlNPTlwiIT09dC5tb2RlbFRvcG9sb2d5VHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyTG9jYWxTdG9yYWdlIGRvZXMgbm90IHN1cHBvcnQgbG9hZGluZyBub24tSlNPTiBtb2RlbCB0b3BvbG9neSB5ZXQuXCIpO2lmKGU9e30sbnVsbD09KG49SlNPTi5wYXJzZSh0aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLnRvcG9sb2d5KSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSB0b3BvbG9neSBvZiBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIGlzIG1pc3NpbmcuXCIpO2lmKGUubW9kZWxUb3BvbG9neT1uLG51bGw9PShvPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKHRoaXMua2V5cy53ZWlnaHRTcGVjcykpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbiBsb2NhbCBzdG9yYWdlLCB0aGUgd2VpZ2h0IHNwZWNzIG9mIG1vZGVsICdcIit0aGlzLm1vZGVsUGF0aCtcIicgYXJlIG1pc3NpbmcuXCIpO2lmKGUud2VpZ2h0U3BlY3M9byxudWxsIT0oYT10aGlzLkxTLmdldEl0ZW0odGhpcy5rZXlzLm1vZGVsTWV0YWRhdGEpKSYmKGk9SlNPTi5wYXJzZShhKSxlLmZvcm1hdD1pLmZvcm1hdCxlLmdlbmVyYXRlZEJ5PWkuZ2VuZXJhdGVkQnksZS5jb252ZXJ0ZWRCeT1pLmNvbnZlcnRlZEJ5LGUudXNlckRlZmluZWRNZXRhZGF0YT1pLnVzZXJEZWZpbmVkTWV0YWRhdGEpLG51bGw9PShzPXRoaXMuTFMuZ2V0SXRlbSh0aGlzLmtleXMud2VpZ2h0RGF0YSkpKXRocm93IG5ldyBFcnJvcihcIkluIGxvY2FsIHN0b3JhZ2UsIHRoZSBiaW5hcnkgd2VpZ2h0IHZhbHVlcyBvZiBtb2RlbCAnXCIrdGhpcy5tb2RlbFBhdGgrXCInIGFyZSBtaXNzaW5nLlwiKTtyZXR1cm4gZS53ZWlnaHREYXRhPWZ1bmN0aW9uKHQpe2lmKEtmKXt2YXIgZT1CdWZmZXIuZnJvbSh0LFwiYmFzZTY0XCIpO3JldHVybiBlLmJ1ZmZlci5zbGljZShlLmJ5dGVPZmZzZXQsZS5ieXRlT2Zmc2V0K2UuYnl0ZUxlbmd0aCl9Zm9yKHZhciBuPWF0b2IodCkscj1uZXcgVWludDhBcnJheShuLmxlbmd0aCksbz0wO288bi5sZW5ndGg7KytvKXIuc2V0KFtuLmNoYXJDb2RlQXQobyldLG8pO3JldHVybiByLmJ1ZmZlcn0ocyksWzIsZV19KSl9KSl9LHQuVVJMX1NDSEVNRT1cImxvY2Fsc3RvcmFnZTovL1wiLHR9KCkseGQ9ZnVuY3Rpb24odCl7cmV0dXJuIGkoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkodCkmJnQuc3RhcnRzV2l0aCh5ZC5VUkxfU0NIRU1FKT8oZT10LnNsaWNlKHlkLlVSTF9TQ0hFTUUubGVuZ3RoKSxuZXcgeWQoZSkpOm51bGw7dmFyIGV9O1FmLnJlZ2lzdGVyU2F2ZVJvdXRlcih4ZCksUWYucmVnaXN0ZXJMb2FkUm91dGVyKHhkKTt2YXIgYmQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7QyhpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIiksKGZ1bmN0aW9uKCl7cmV0dXJuXCJDdXJyZW50IGVudmlyb25tZW50IGlzIG5vdCBhIHdlYiBicm93c2VyXCJ9KSksQyhcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93fHx2b2lkIDAhPT13aW5kb3cubG9jYWxTdG9yYWdlLChmdW5jdGlvbigpe3JldHVyblwiQ3VycmVudCBicm93c2VyIGRvZXMgbm90IGFwcGVhciB0byBzdXBwb3J0IGxvY2FsU3RvcmFnZVwifSkpLHRoaXMuTFM9d2luZG93LmxvY2FsU3RvcmFnZX1yZXR1cm4gdC5wcm90b3R5cGUubGlzdE1vZGVscz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlLG4sbyxhLGk7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7Zm9yKHQ9e30sZT1sZCtjZCxuPWNkK2hkLG89MDtvPHRoaXMuTFMubGVuZ3RoOysrbykoYT10aGlzLkxTLmtleShvKSkuc3RhcnRzV2l0aChlKSYmYS5lbmRzV2l0aChuKSYmKGk9bWQoYSksdFtpXT1KU09OLnBhcnNlKHRoaXMuTFMuZ2V0SXRlbShhKSkpO3JldHVyblsyLHRdfSkpfSkpfSx0LnByb3RvdHlwZS5yZW1vdmVNb2RlbD1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbjtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXt2YXIgbztpZih0PShvPXQpLnN0YXJ0c1dpdGgoeWQuVVJMX1NDSEVNRSk/by5zbGljZSh5ZC5VUkxfU0NIRU1FLmxlbmd0aCk6byxlPWdkKHQpLG51bGw9PXRoaXMuTFMuZ2V0SXRlbShlLmluZm8pKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZGVsIGF0IHBhdGggJ1wiK3QrXCInXCIpO3JldHVybiBuPUpTT04ucGFyc2UodGhpcy5MUy5nZXRJdGVtKGUuaW5mbykpLHRoaXMuTFMucmVtb3ZlSXRlbShlLmluZm8pLHRoaXMuTFMucmVtb3ZlSXRlbShlLnRvcG9sb2d5KSx0aGlzLkxTLnJlbW92ZUl0ZW0oZS53ZWlnaHRTcGVjcyksdGhpcy5MUy5yZW1vdmVJdGVtKGUud2VpZ2h0RGF0YSksWzIsbl19KSl9KSl9LHR9KCk7aWYoaSgpLmdldEJvb2woXCJJU19CUk9XU0VSXCIpKXRyeXtaZi5yZWdpc3Rlck1hbmFnZXIoeWQuVVJMX1NDSEVNRSxuZXcgYmQpfWNhdGNoKHQpe312YXIgd2Q9XCJtb2RlbFwiLENkPVwiLmpzb25cIixFZD1cIi53ZWlnaHRzLmJpblwiO2Z1bmN0aW9uIFJkKHQpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7cmV0dXJuIHNldFRpbWVvdXQodCl9KSkudGhlbih0KX12YXIgSWQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe2lmKCFpKCkuZ2V0Qm9vbChcIklTX0JST1dTRVJcIikpdGhyb3cgbmV3IEVycm9yKFwiYnJvd3NlckRvd25sb2FkcygpIGNhbm5vdCBwcm9jZWVkIGJlY2F1c2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgbm90IGEgYnJvd3Nlci5cIik7ZS5zdGFydHNXaXRoKHQuVVJMX1NDSEVNRSkmJihlPWUuc2xpY2UodC5VUkxfU0NIRU1FLmxlbmd0aCkpLG51bGwhPWUmJjAhPT1lLmxlbmd0aHx8KGU9d2QpLHRoaXMubW9kZWxUb3BvbG9neUZpbGVOYW1lPWUrQ2QsdGhpcy53ZWlnaHREYXRhRmlsZU5hbWU9ZStFZH1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvLGEsaSxzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGRvY3VtZW50KXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIgZG93bmxvYWRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgc2luY2UgYGRvY3VtZW50YCBpcyBub3QgcHJlc2VudFwiKTtpZihlPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt0LndlaWdodERhdGFdLHt0eXBlOlwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9KSksISh0Lm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpcmV0dXJuWzMsMV07dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckRvd25sb2Fkcy5zYXZlKCkgZG9lcyBub3Qgc3VwcG9ydCBzYXZpbmcgbW9kZWwgdG9wb2xvZ3kgaW4gYmluYXJ5IGZvcm1hdHMgeWV0LlwiKTtjYXNlIDE6cmV0dXJuIG49W3twYXRoczpbXCIuL1wiK3RoaXMud2VpZ2h0RGF0YUZpbGVOYW1lXSx3ZWlnaHRzOnQud2VpZ2h0U3BlY3N9XSxvPXttb2RlbFRvcG9sb2d5OnQubW9kZWxUb3BvbG9neSxmb3JtYXQ6dC5mb3JtYXQsZ2VuZXJhdGVkQnk6dC5nZW5lcmF0ZWRCeSxjb252ZXJ0ZWRCeTp0LmNvbnZlcnRlZEJ5LHdlaWdodHNNYW5pZmVzdDpufSxhPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShvKV0se3R5cGU6XCJhcHBsaWNhdGlvbi9qc29uXCJ9KSksKGk9bnVsbD09dGhpcy5qc29uQW5jaG9yP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpOnRoaXMuanNvbkFuY2hvcikuZG93bmxvYWQ9dGhpcy5tb2RlbFRvcG9sb2d5RmlsZU5hbWUsaS5ocmVmPWEsWzQsUmQoKGZ1bmN0aW9uKCl7cmV0dXJuIGkuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChcImNsaWNrXCIpKX0pKV07Y2FzZSAyOnJldHVybiByLnNlbnQoKSxudWxsPT10LndlaWdodERhdGE/WzMsNF06KChzPW51bGw9PXRoaXMud2VpZ2h0RGF0YUFuY2hvcj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTp0aGlzLndlaWdodERhdGFBbmNob3IpLmRvd25sb2FkPXRoaXMud2VpZ2h0RGF0YUZpbGVOYW1lLHMuaHJlZj1lLFs0LFJkKChmdW5jdGlvbigpe3JldHVybiBzLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoXCJjbGlja1wiKSl9KSldKTtjYXNlIDM6ci5zZW50KCksci5sYWJlbD00O2Nhc2UgNDpyZXR1cm5bMix7bW9kZWxBcnRpZmFjdHNJbmZvOiRmKHQpfV19fSkpfSkpfSx0LlVSTF9TQ0hFTUU9XCJkb3dubG9hZHM6Ly9cIix0fSgpLGtkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtpZihudWxsPT10fHx0Lmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIldoZW4gY2FsbGluZyBicm93c2VyRmlsZXMsIGF0IGxlYXN0IDEgZmlsZSBpcyByZXF1aXJlZCwgYnV0IHJlY2VpdmVkIFwiK3QpO3RoaXMuZmlsZXM9dH1yZXR1cm4gdC5wcm90b3R5cGUubG9hZD1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlLG49dGhpcztyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtyZXR1cm4gdD10aGlzLmZpbGVzWzBdLGU9dGhpcy5maWxlcy5zbGljZSgxKSxbMixuZXcgUHJvbWlzZSgoZnVuY3Rpb24ocixvKXt2YXIgYT1uZXcgRmlsZVJlYWRlcjthLm9ubG9hZD1mdW5jdGlvbihhKXt2YXIgaT1KU09OLnBhcnNlKGEudGFyZ2V0LnJlc3VsdCkscz1pLm1vZGVsVG9wb2xvZ3k7aWYobnVsbCE9cyl7MD09PWUubGVuZ3RoJiZyKHttb2RlbFRvcG9sb2d5OnN9KTt2YXIgdT1pLndlaWdodHNNYW5pZmVzdDtpZihudWxsIT11KXt2YXIgYzt0cnl7Yz1uLmNoZWNrTWFuaWZlc3RBbmRXZWlnaHRGaWxlcyh1LGUpfWNhdGNoKHQpe3JldHVybiB2b2lkIG8odCl9dmFyIGw9W10saD1bXSxmPVtdO3UuZm9yRWFjaCgoZnVuY3Rpb24odCl7dC5wYXRocy5mb3JFYWNoKChmdW5jdGlvbih0KXtoLnB1c2godCksZi5wdXNoKG51bGwpfSkpLGwucHVzaC5hcHBseShsLHQud2VpZ2h0cyl9KSksdS5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnBhdGhzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBGaWxlUmVhZGVyO2Uub25sb2FkPWZ1bmN0aW9uKGUpe3ZhciBuPWUudGFyZ2V0LnJlc3VsdCxvPWguaW5kZXhPZih0KTtmW29dPW4sLTE9PT1mLmluZGV4T2YobnVsbCkmJnIoe21vZGVsVG9wb2xvZ3k6cyx3ZWlnaHRTcGVjczpsLHdlaWdodERhdGE6WGYoZiksZm9ybWF0OmkuZm9ybWF0LGdlbmVyYXRlZEJ5OmkuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6aS5jb252ZXJ0ZWRCeSx1c2VyRGVmaW5lZE1ldGFkYXRhOmkudXNlckRlZmluZWRNZXRhZGF0YX0pfSxlLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIG8oXCJGYWlsZWQgdG8gd2VpZ2h0cyBkYXRhIGZyb20gZmlsZSBvZiBwYXRoICdcIit0K1wiJy5cIil9LGUucmVhZEFzQXJyYXlCdWZmZXIoY1t0XSl9KSl9KSl9ZWxzZSBvKG5ldyBFcnJvcihcIndlaWdodE1hbmlmZXN0IGZpZWxkIGlzIG1pc3NpbmcgZnJvbSBmaWxlIFwiK3QubmFtZSkpfWVsc2UgbyhuZXcgRXJyb3IoXCJtb2RlbFRvcG9sb2d5IGZpZWxkIGlzIG1pc3NpbmcgZnJvbSBmaWxlIFwiK3QubmFtZSkpfSxhLm9uZXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJuIG8oXCJGYWlsZWQgdG8gcmVhZCBtb2RlbCB0b3BvbG9neSBhbmQgd2VpZ2h0cyBtYW5pZmVzdCBKU09OIGZyb20gZmlsZSAnXCIrdC5uYW1lK1wiJy4gQnJvd3NlckZpbGVzIHN1cHBvcnRzIGxvYWRpbmcgS2VyYXMtc3R5bGUgdGYuTW9kZWwgYXJ0aWZhY3RzIG9ubHkuXCIpfSxhLnJlYWRBc1RleHQodCl9KSldfSkpfSkpfSx0LnByb3RvdHlwZS5jaGVja01hbmlmZXN0QW5kV2VpZ2h0RmlsZXM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49W10scj1lLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIFlmKHQubmFtZSl9KSksbz17fSxhPTAsaT10O2E8aS5sZW5ndGg7YSsrKXtpW2FdLnBhdGhzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBhPVlmKHQpO2lmKC0xIT09bi5pbmRleE9mKGEpKXRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBmaWxlIGJhc2VuYW1lIGZvdW5kIGluIHdlaWdodHMgbWFuaWZlc3Q6ICdcIithK1wiJ1wiKTtpZihuLnB1c2goYSksLTE9PT1yLmluZGV4T2YoYSkpdGhyb3cgbmV3IEVycm9yKFwiV2VpZ2h0IGZpbGUgd2l0aCBiYXNlbmFtZSAnXCIrYStcIicgaXMgbm90IHByb3ZpZGVkLlwiKTtvW3RdPWVbci5pbmRleE9mKGEpXX0pKX1pZihuLmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgZmlsZXMgaW4gd2VpZ2h0cyBtYW5pZmVzdCAoXCIrbi5sZW5ndGgrXCIpIGFuZCB0aGUgbnVtYmVyIG9mIHdlaWdodCBmaWxlcyBwcm92aWRlZCAoXCIrZS5sZW5ndGgrXCIpLlwiKTtyZXR1cm4gb30sdH0oKTtmdW5jdGlvbiBTZCh0LGUsbixyKXshZnVuY3Rpb24odCl7QyhudWxsIT10JiZBcnJheS5pc0FycmF5KHQpJiZ0Lmxlbmd0aD4wLChmdW5jdGlvbigpe3JldHVyblwicHJvbWlzZXMgbXVzdCBiZSBhIG5vbmUgZW1wdHkgYXJyYXlcIn0pKX0odCksZnVuY3Rpb24odCxlKXtDKHQ+PTAmJnQ8PTEsKGZ1bmN0aW9uKCl7cmV0dXJuXCJQcm9ncmVzcyBmcmFjdGlvbiBtdXN0IGJlIGluIHJhbmdlIFswLCAxXSwgYnV0IGdvdCBzdGFydEZyYWN0aW9uIFwiK3R9KSksQyhlPj0wJiZlPD0xLChmdW5jdGlvbigpe3JldHVyblwiUHJvZ3Jlc3MgZnJhY3Rpb24gbXVzdCBiZSBpbiByYW5nZSBbMCwgMV0sIGJ1dCBnb3QgZW5kRnJhY3Rpb24gXCIrZX0pKSxDKGU+PXQsKGZ1bmN0aW9uKCl7cmV0dXJuXCJzdGFydEZyYWN0aW9uIG11c3QgYmUgbm8gbW9yZSB0aGFuIGVuZEZyYWN0aW9uLCBidXQgZ290IHN0YXJ0RnJhY3Rpb24gXCIrdCtcIiBhbmQgZW5kRnJhY3Rpb24gXCIrZX0pKX0obj1udWxsPT1uPzA6bixyPW51bGw9PXI/MTpyKTt2YXIgbz0wO3JldHVybiBQcm9taXNlLmFsbCh0Lm1hcCgoZnVuY3Rpb24oYSl7cmV0dXJuIGEudGhlbigoZnVuY3Rpb24oYSl7dmFyIGk9bisgKytvL3QubGVuZ3RoKihyLW4pO3JldHVybiBlKGkpLGF9KSksYX0pKSl9ZnVuY3Rpb24gQWQodCxlKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sbyxhLHMsdSxjLGwsaCxmO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuIG51bGw9PWUmJihlPXt9KSxuPW51bGw9PWUuZmV0Y2hGdW5jP2koKS5wbGF0Zm9ybS5mZXRjaDplLmZldGNoRnVuYyxvPXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gbih0LGUucmVxdWVzdEluaXQse2lzQmluYXJ5OiEwfSl9KSksYT0wLHM9LjUsbnVsbCE9ZS5vblByb2dyZXNzP1szLDJdOls0LFByb21pc2UuYWxsKG8pXTtjYXNlIDE6cmV0dXJuIHU9ci5zZW50KCksWzMsNF07Y2FzZSAyOnJldHVybls0LFNkKG8sZS5vblByb2dyZXNzLGEscyldO2Nhc2UgMzp1PXIuc2VudCgpLHIubGFiZWw9NDtjYXNlIDQ6cmV0dXJuIGM9dS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmFycmF5QnVmZmVyKCl9KSksbD0uNSxoPTEsbnVsbCE9ZS5vblByb2dyZXNzP1szLDZdOls0LFByb21pc2UuYWxsKGMpXTtjYXNlIDU6cmV0dXJuIGY9ci5zZW50KCksWzMsOF07Y2FzZSA2OnJldHVybls0LFNkKGMsZS5vblByb2dyZXNzLGwsaCldO2Nhc2UgNzpmPXIuc2VudCgpLHIubGFiZWw9ODtjYXNlIDg6cmV0dXJuWzIsZl19fSkpfSkpfWZ1bmN0aW9uIFRkKHQpe3ZhciBlPXRoaXM7cmV0dXJuIGZ1bmN0aW9uKG8sYSxpKXtyZXR1cm4gdm9pZCAwPT09YSYmKGE9XCJcIiksbihlLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixzLHUsYyxsLGgsZixkLHA7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDppZihlPW8ubWFwKChmdW5jdGlvbigpe3JldHVybiExfSkpLG49e30scz1udWxsIT1pP2kubWFwKChmdW5jdGlvbigpe3JldHVybiExfSkpOltdLHU9W10sby5mb3JFYWNoKChmdW5jdGlvbih0LHIpe3ZhciBvPTA7dC53ZWlnaHRzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBhPVwicXVhbnRpemF0aW9uXCJpbiB0P3QucXVhbnRpemF0aW9uLmR0eXBlOnQuZHR5cGUsYz16ZlthXSprKHQuc2hhcGUpLGw9ZnVuY3Rpb24oKXtlW3JdPSEwLG51bGw9PW5bcl0mJihuW3JdPVtdKSxuW3JdLnB1c2goe21hbmlmZXN0RW50cnk6dCxncm91cE9mZnNldDpvLHNpemVCeXRlczpjfSl9O251bGwhPWk/aS5mb3JFYWNoKChmdW5jdGlvbihlLG4pe2U9PT10Lm5hbWUmJihsKCksc1tuXT0hMCl9KSk6bCgpLHUucHVzaCh0Lm5hbWUpLG8rPWN9KSl9KSksIXMuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiB0fSkpKXRocm93IGM9aS5maWx0ZXIoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIXNbZV19KSksbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgd2VpZ2h0cyBpbiBtYW5pZmVzdCB3aXRoIG5hbWVzOiBcIitjLmpvaW4oXCIsIFwiKStcIi4gXFxuTWFuaWZlc3QgSlNPTiBoYXMgd2VpZ2h0cyB3aXRoIG5hbWVzOiBcIit1LmpvaW4oXCIsIFwiKStcIi5cIik7cmV0dXJuIGw9ZS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gZSYmdC5wdXNoKG4pLHR9KSxbXSksaD1bXSxsLmZvckVhY2goKGZ1bmN0aW9uKHQpe29bdF0ucGF0aHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9YSsoYS5lbmRzV2l0aChcIi9cIik/XCJcIjpcIi9cIikrdDtoLnB1c2goZSl9KSl9KSksWzQsdChoKV07Y2FzZSAxOnJldHVybiBmPXIuc2VudCgpLGQ9e30scD0wLGwuZm9yRWFjaCgoZnVuY3Rpb24odCl7Zm9yKHZhciBlPW9bdF0ucGF0aHMubGVuZ3RoLHI9MCxhPTA7YTxlO2ErKylyKz1mW3ArYV0uYnl0ZUxlbmd0aDtmb3IodmFyIGk9bmV3IEFycmF5QnVmZmVyKHIpLHM9bmV3IFVpbnQ4QXJyYXkoaSksdT0wLGM9MDtjPGU7YysrKXt2YXIgbD1uZXcgVWludDhBcnJheShmW3ArY10pO3Muc2V0KGwsdSksdSs9bC5ieXRlTGVuZ3RofW5bdF0uZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGU9SGYoaS5zbGljZSh0Lmdyb3VwT2Zmc2V0LHQuZ3JvdXBPZmZzZXQrdC5zaXplQnl0ZXMpLFt0Lm1hbmlmZXN0RW50cnldKTtmb3IodmFyIG4gaW4gZSlkW25dPWVbbl19KSkscCs9ZX0pKSxbMixkXX19KSl9KSl9fVFmLnJlZ2lzdGVyU2F2ZVJvdXRlcigoZnVuY3Rpb24odCl7cmV0dXJuIGkoKS5nZXRCb29sKFwiSVNfQlJPV1NFUlwiKSYmIUFycmF5LmlzQXJyYXkodCkmJnQuc3RhcnRzV2l0aChJZC5VUkxfU0NIRU1FKT9mdW5jdGlvbih0KXt2b2lkIDA9PT10JiYodD1cIm1vZGVsXCIpO3JldHVybiBuZXcgSWQodCl9KHQuc2xpY2UoSWQuVVJMX1NDSEVNRS5sZW5ndGgpKTpudWxsfSkpO3ZhciBEZD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXtpZih0aGlzLkRFRkFVTFRfTUVUSE9EPVwiUE9TVFwiLG51bGw9PWUmJihlPXt9KSx0aGlzLndlaWdodFBhdGhQcmVmaXg9ZS53ZWlnaHRQYXRoUHJlZml4LHRoaXMub25Qcm9ncmVzcz1lLm9uUHJvZ3Jlc3MsbnVsbCE9ZS5mZXRjaEZ1bmM/KEMoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5mZXRjaEZ1bmMsKGZ1bmN0aW9uKCl7cmV0dXJuXCJNdXN0IHBhc3MgYSBmdW5jdGlvbiB0aGF0IG1hdGNoZXMgdGhlIHNpZ25hdHVyZSBvZiBgZmV0Y2hgIChzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSSlcIn0pKSx0aGlzLmZldGNoPWUuZmV0Y2hGdW5jKTp0aGlzLmZldGNoPWkoKS5wbGF0Zm9ybS5mZXRjaCxDKG51bGwhPXQmJnQubGVuZ3RoPjAsKGZ1bmN0aW9uKCl7cmV0dXJuXCJVUkwgcGF0aCBmb3IgaHR0cCBtdXN0IG5vdCBiZSBudWxsLCB1bmRlZmluZWQgb3IgZW1wdHkuXCJ9KSksQXJyYXkuaXNBcnJheSh0KSYmQygyPT09dC5sZW5ndGgsKGZ1bmN0aW9uKCl7cmV0dXJuXCJVUkwgcGF0aHMgZm9yIGh0dHAgbXVzdCBoYXZlIGEgbGVuZ3RoIG9mIDIsIChhY3R1YWwgbGVuZ3RoIGlzIFwiK3QubGVuZ3RoK1wiKS5cIn0pKSx0aGlzLnBhdGg9dCxudWxsIT1lLnJlcXVlc3RJbml0JiZudWxsIT1lLnJlcXVlc3RJbml0LmJvZHkpdGhyb3cgbmV3IEVycm9yKFwicmVxdWVzdEluaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBubyBwcmUtZXhpc3RpbmcgYm9keSwgYnV0IGhhcyBvbmUuXCIpO3RoaXMucmVxdWVzdEluaXQ9ZS5yZXF1ZXN0SW5pdHx8e319cmV0dXJuIHQucHJvdG90eXBlLnNhdmU9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlLG4sbyxhO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6aWYodC5tb2RlbFRvcG9sb2d5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpdGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckhUVFBSZXF1ZXN0LnNhdmUoKSBkb2VzIG5vdCBzdXBwb3J0IHNhdmluZyBtb2RlbCB0b3BvbG9neSBpbiBiaW5hcnkgZm9ybWF0cyB5ZXQuXCIpO3JldHVybihlPU9iamVjdC5hc3NpZ24oe21ldGhvZDp0aGlzLkRFRkFVTFRfTUVUSE9EfSx0aGlzLnJlcXVlc3RJbml0KSkuYm9keT1uZXcgRm9ybURhdGEsbj1be3BhdGhzOltcIi4vbW9kZWwud2VpZ2h0cy5iaW5cIl0sd2VpZ2h0czp0LndlaWdodFNwZWNzfV0sbz17bW9kZWxUb3BvbG9neTp0Lm1vZGVsVG9wb2xvZ3ksZm9ybWF0OnQuZm9ybWF0LGdlbmVyYXRlZEJ5OnQuZ2VuZXJhdGVkQnksY29udmVydGVkQnk6dC5jb252ZXJ0ZWRCeSx1c2VyRGVmaW5lZE1ldGFkYXRhOnQudXNlckRlZmluZWRNZXRhZGF0YSx3ZWlnaHRzTWFuaWZlc3Q6bn0sZS5ib2R5LmFwcGVuZChcIm1vZGVsLmpzb25cIixuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkobyldLHt0eXBlOlwiYXBwbGljYXRpb24vanNvblwifSksXCJtb2RlbC5qc29uXCIpLG51bGwhPXQud2VpZ2h0RGF0YSYmZS5ib2R5LmFwcGVuZChcIm1vZGVsLndlaWdodHMuYmluXCIsbmV3IEJsb2IoW3Qud2VpZ2h0RGF0YV0se3R5cGU6XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn0pLFwibW9kZWwud2VpZ2h0cy5iaW5cIiksWzQsdGhpcy5mZXRjaCh0aGlzLnBhdGgsZSldO2Nhc2UgMTppZigoYT1yLnNlbnQoKSkub2spcmV0dXJuWzIse21vZGVsQXJ0aWZhY3RzSW5mbzokZih0KSxyZXNwb25zZXM6W2FdfV07dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlckhUVFBSZXF1ZXN0LnNhdmUoKSBmYWlsZWQgZHVlIHRvIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIFwiK2Euc3RhdHVzK1wiLlwiKX19KSl9KSl9LHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsZSxuLG8sYSxpLHMsdSxjLGwsaCxmO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5mZXRjaCh0aGlzLnBhdGgsdGhpcy5yZXF1ZXN0SW5pdCldO2Nhc2UgMTppZighKHQ9ci5zZW50KCkpLm9rKXRocm93IG5ldyBFcnJvcihcIlJlcXVlc3QgdG8gXCIrdGhpcy5wYXRoK1wiIGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlIFwiK3Quc3RhdHVzK1wiLiBQbGVhc2UgdmVyaWZ5IHRoaXMgVVJMIHBvaW50cyB0byB0aGUgbW9kZWwgSlNPTiBvZiB0aGUgbW9kZWwgdG8gbG9hZC5cIik7ci5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gci50cnlzLnB1c2goWzIsNCwsNV0pLFs0LHQuanNvbigpXTtjYXNlIDM6cmV0dXJuIGU9ci5zZW50KCksWzMsNV07Y2FzZSA0OnRocm93IHIuc2VudCgpLG49XCJGYWlsZWQgdG8gcGFyc2UgbW9kZWwgSlNPTiBvZiByZXNwb25zZSBmcm9tIFwiK3RoaXMucGF0aCtcIi5cIix0aGlzLnBhdGguZW5kc1dpdGgoXCIucGJcIik/bis9XCIgWW91ciBwYXRoIGNvbnRhaW5zIGEgLnBiIGZpbGUgZXh0ZW5zaW9uLiBTdXBwb3J0IGZvciAucGIgbW9kZWxzIGhhdmUgYmVlbiByZW1vdmVkIGluIFRlbnNvckZsb3cuanMgMS4wIGluIGZhdm9yIG9mIC5qc29uIG1vZGVscy4gWW91IGNhbiByZS1jb252ZXJ0IHlvdXIgUHl0aG9uIFRlbnNvckZsb3cgbW9kZWwgdXNpbmcgdGhlIFRlbnNvckZsb3cuanMgMS4wIGNvbnZlcnNpb24gc2NyaXB0cyBvciB5b3UgY2FuIGNvbnZlcnQgeW91ci5wYiBtb2RlbHMgd2l0aCB0aGUgJ3BiMmpzb24nTlBNIHNjcmlwdCBpbiB0aGUgdGVuc29yZmxvdy90ZmpzLWNvbnZlcnRlciByZXBvc2l0b3J5LlwiOm4rPVwiIFBsZWFzZSBtYWtlIHN1cmUgdGhlIHNlcnZlciBpcyBzZXJ2aW5nIHZhbGlkIEpTT04gZm9yIHRoaXMgcmVxdWVzdC5cIixuZXcgRXJyb3Iobik7Y2FzZSA1OmlmKG89ZS5tb2RlbFRvcG9sb2d5LGE9ZS53ZWlnaHRzTWFuaWZlc3QsaT1lLmdlbmVyYXRlZEJ5LHM9ZS5jb252ZXJ0ZWRCeSx1PWUuZm9ybWF0LGM9ZS51c2VyRGVmaW5lZE1ldGFkYXRhLG51bGw9PW8mJm51bGw9PWEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIEpTT04gZnJvbSBIVFRQIHBhdGggXCIrdGhpcy5wYXRoK1wiIGNvbnRhaW5zIG5laXRoZXIgbW9kZWwgdG9wb2xvZ3kgb3IgbWFuaWZlc3QgZm9yIHdlaWdodHMuXCIpO3JldHVybiBudWxsPT1hP1szLDddOls0LHRoaXMubG9hZFdlaWdodHMoYSldO2Nhc2UgNjpmPXIuc2VudCgpLGw9ZlswXSxoPWZbMV0sci5sYWJlbD03O2Nhc2UgNzpyZXR1cm5bMix7bW9kZWxUb3BvbG9neTpvLHdlaWdodFNwZWNzOmwsd2VpZ2h0RGF0YTpoLHVzZXJEZWZpbmVkTWV0YWRhdGE6YyxnZW5lcmF0ZWRCeTppLGNvbnZlcnRlZEJ5OnMsZm9ybWF0OnV9XX19KSl9KSl9LHQucHJvdG90eXBlLmxvYWRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgZSxuLG8sYSxpLHMsdSxjLGwsaCxmO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6Zm9yKGU9QXJyYXkuaXNBcnJheSh0aGlzLnBhdGgpP3RoaXMucGF0aFsxXTp0aGlzLnBhdGgsbj1mdW5jdGlvbih0KXt2YXIgZT10Lmxhc3RJbmRleE9mKFwiL1wiKSxuPXQubGFzdEluZGV4T2YoXCI/XCIpLHI9dC5zdWJzdHJpbmcoMCxlKSxvPW4+ZT90LnN1YnN0cmluZyhuKTpcIlwiO3JldHVybltyK1wiL1wiLG9dfShlKSxvPW5bMF0sYT1uWzFdLGk9dGhpcy53ZWlnaHRQYXRoUHJlZml4fHxvLHM9W10sdT0wLGM9dDt1PGMubGVuZ3RoO3UrKylsPWNbdV0scy5wdXNoLmFwcGx5KHMsbC53ZWlnaHRzKTtyZXR1cm4gaD1bXSx0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3QucGF0aHMuZm9yRWFjaCgoZnVuY3Rpb24odCl7aC5wdXNoKGkrdCthKX0pKX0pKSxbNCxBZChoLHtyZXF1ZXN0SW5pdDp0aGlzLnJlcXVlc3RJbml0LGZldGNoRnVuYzp0aGlzLmZldGNoLG9uUHJvZ3Jlc3M6dGhpcy5vblByb2dyZXNzfSldO2Nhc2UgMTpyZXR1cm4gZj1yLnNlbnQoKSxbMixbcyxYZihmKV1dfX0pKX0pKX0sdC5VUkxfU0NIRU1FX1JFR0VYPS9eaHR0cHM/OlxcL1xcLy8sdH0oKTtmdW5jdGlvbiBOZCh0KXtyZXR1cm4gbnVsbCE9dC5tYXRjaChEZC5VUkxfU0NIRU1FX1JFR0VYKX12YXIgRmQ9ZnVuY3Rpb24odCxlKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgZmV0Y2gpcmV0dXJuIG51bGw7cmV0dXJuKEFycmF5LmlzQXJyYXkodCk/dC5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIE5kKHQpfSkpOk5kKHQpKT9fZCh0LHtvblByb2dyZXNzOmV9KTpudWxsfTtmdW5jdGlvbiBfZCh0LGUpe3JldHVybiBuZXcgRGQodCxlKX1RZi5yZWdpc3RlclNhdmVSb3V0ZXIoRmQpLFFmLnJlZ2lzdGVyTG9hZFJvdXRlcihGZCk7dmFyIE9kPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLm1vZGVsQXJ0aWZhY3RzPXR9cmV0dXJuIHQucHJvdG90eXBlLmxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7cmV0dXJuWzIsdGhpcy5tb2RlbEFydGlmYWN0c119KSl9KSl9LHR9KCksTWQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuc2F2ZUhhbmRsZXI9dH1yZXR1cm4gdC5wcm90b3R5cGUuc2F2ZT1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24oZSl7cmV0dXJuWzIsdGhpcy5zYXZlSGFuZGxlcih0KV19KSl9KSl9LHR9KCk7dmFyIEJkPU9iamVjdC5mcmVlemUoe2Jyb3dzZXJGaWxlczpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGtkKHQpfSxicm93c2VySFRUUFJlcXVlc3Q6ZnVuY3Rpb24odCxlKXtyZXR1cm4gX2QodCxlKX0sY29uY2F0ZW5hdGVBcnJheUJ1ZmZlcnM6WGYsZGVjb2RlV2VpZ2h0czpIZixlbmNvZGVXZWlnaHRzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBvLGEsaSxzLHUsYz10aGlzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGwpe3N3aXRjaChsLmxhYmVsKXtjYXNlIDA6Zm9yKG89W10sYT1bXSxpPUFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCkscz1mdW5jdGlvbihzKXt2YXIgdT1pW3NdLGw9QXJyYXkuaXNBcnJheSh0KT90W3NdLnRlbnNvcjp0W3VdO2lmKFwiZmxvYXQzMlwiIT09bC5kdHlwZSYmXCJpbnQzMlwiIT09bC5kdHlwZSYmXCJib29sXCIhPT1sLmR0eXBlJiZcInN0cmluZ1wiIT09bC5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJ1wiK3UrXCInOiBcIitsLmR0eXBlKTt2YXIgaD17bmFtZTp1LHNoYXBlOmwuc2hhcGUsZHR5cGU6bC5kdHlwZX07aWYoXCJzdHJpbmdcIj09PWwuZHR5cGUpe3ZhciBmPW5ldyBQcm9taXNlKChmdW5jdGlvbih0KXtyZXR1cm4gbihjLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbixvLGEsaSxzLHU7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCxsLmJ5dGVzKCldO2Nhc2UgMTpmb3IoZT1yLnNlbnQoKSxuPWUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0K2UubGVuZ3RofSksMCkrR2YqZS5sZW5ndGgsbz1uZXcgVWludDhBcnJheShuKSxhPTAsaT0wO2k8ZS5sZW5ndGg7aSsrKXM9ZVtpXSx1PW5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbcy5sZW5ndGhdKS5idWZmZXIpLG8uc2V0KHUsYSksYSs9R2Ysby5zZXQocyxhKSxhKz1zLmxlbmd0aDtyZXR1cm4gdChvKSxbMl19fSkpfSkpfSkpO2EucHVzaChmKX1lbHNlIGEucHVzaChsLmRhdGEoKSk7bnVsbCE9ZSYmKGguZ3JvdXA9ZSksby5wdXNoKGgpfSx1PTA7dTxpLmxlbmd0aDsrK3Upcyh1KTtyZXR1cm5bNCxQcm9taXNlLmFsbChhKV07Y2FzZSAxOnJldHVyblsyLHtkYXRhOnFmKGwuc2VudCgpKSxzcGVjczpvfV19fSkpfSkpfSxmcm9tTWVtb3J5OmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiAxPT09YXJndW1lbnRzLmxlbmd0aD9udWxsIT10Lm1vZGVsVG9wb2xvZ3l8fG51bGwhPXQud2VpZ2h0U3BlY3M/bmV3IE9kKHQpOihjb25zb2xlLndhcm4oXCJQbGVhc2UgY2FsbCB0Zi5pby5mcm9tTWVtb3J5KCkgd2l0aCBvbmx5IG9uZSBhcmd1bWVudC4gVGhlIGFyZ3VtZW50IHNob3VsZCBiZSBvZiB0eXBlIE1vZGVsQXJ0aWZhY3RzLiBUaGUgbXVsdGktYXJndW1lbnQgc2lnbmF0dXJlIG9mIHRmLmlvLmZyb21NZW1vcnkoKSBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIiksbmV3IE9kKHttb2RlbFRvcG9sb2d5OnR9KSk6KGNvbnNvbGUud2FybihcIlBsZWFzZSBjYWxsIHRmLmlvLmZyb21NZW1vcnkoKSB3aXRoIG9ubHkgb25lIGFyZ3VtZW50LiBUaGUgYXJndW1lbnQgc2hvdWxkIGJlIG9mIHR5cGUgTW9kZWxBcnRpZmFjdHMuIFRoZSBtdWx0aS1hcmd1bWVudCBzaWduYXR1cmUgb2YgdGYuaW8uZnJvbU1lbW9yeSgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiKSxuZXcgT2Qoe21vZGVsVG9wb2xvZ3k6dCx3ZWlnaHRTcGVjczplLHdlaWdodERhdGE6bix0cmFpbmluZ0NvbmZpZzpyfSkpfSxnZXRMb2FkSGFuZGxlcnM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gUWYuZ2V0TG9hZEhhbmRsZXJzKHQsZSl9LGdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT046JGYsZ2V0U2F2ZUhhbmRsZXJzOmZ1bmN0aW9uKHQpe3JldHVybiBRZi5nZXRTYXZlSGFuZGxlcnModCl9LGh0dHA6X2QsaXNIVFRQU2NoZW1lOk5kLGxvYWRXZWlnaHRzOmZ1bmN0aW9uKHQsZSxvLGEpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cIlwiKSxuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtyZXR1cm5bMixUZCgoZnVuY3Rpb24odCl7cmV0dXJuIEFkKHQse3JlcXVlc3RJbml0OmF9KX0pKSh0LGUsbyldfSkpfSkpfSxyZWdpc3RlckxvYWRSb3V0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIFFmLnJlZ2lzdGVyTG9hZFJvdXRlcih0KX0scmVnaXN0ZXJTYXZlUm91dGVyOmZ1bmN0aW9uKHQpe3JldHVybiBRZi5yZWdpc3RlclNhdmVSb3V0ZXIodCl9LHdlaWdodHNMb2FkZXJGYWN0b3J5OlRkLHdpdGhTYXZlSGFuZGxlcjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IE1kKHQpfSxjb3B5TW9kZWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7cmV0dXJuITEsWzIsZWQodCxlLCExKV19KSl9KSl9LGxpc3RNb2RlbHM6ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIHQsZSxuLG8sYSxpLHM7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDp0PVpmLmdldFNjaGVtZXMoKSxlPXt9LG49MCxvPXQsci5sYWJlbD0xO2Nhc2UgMTpyZXR1cm4gbjxvLmxlbmd0aD8oYT1vW25dLFs0LFpmLmdldE1hbmFnZXIoYSkubGlzdE1vZGVscygpXSk6WzMsNF07Y2FzZSAyOmZvcihzIGluIGk9ci5zZW50KCkpZVthK0pmK3NdPWlbc107ci5sYWJlbD0zO2Nhc2UgMzpyZXR1cm4gbisrLFszLDFdO2Nhc2UgNDpyZXR1cm5bMixlXX19KSl9KSl9LG1vdmVNb2RlbDpmdW5jdGlvbih0LGUpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihuKXtyZXR1cm4hMCxbMixlZCh0LGUsITApXX0pKX0pKX0scmVtb3ZlTW9kZWw6ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3JldHVybiBlPXRkKHQpLFsyLFpmLmdldE1hbmFnZXIoZS5zY2hlbWUpLnJlbW92ZU1vZGVsKGUucGF0aCldfSkpfSkpfX0pO3ZhciBQZCxMZD1Bbih7Y29uZnVzaW9uTWF0cml4XzpmdW5jdGlvbih0LGUsbil7dmFyIHI9Z24odCxcImxhYmVsc1wiLFwiY29uZnVzaW9uTWF0cml4XCIpLG89Z24oZSxcInByZWRpY3Rpb25zXCIsXCJjb25mdXNpb25NYXRyaXhcIik7QyhudWxsPT1ufHxuPjAmJk51bWJlci5pc0ludGVnZXIobiksKGZ1bmN0aW9uKCl7cmV0dXJuXCJJZiBwcm92aWRlZCwgbnVtQ2xhc3NlcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIitufSkpLEMoMT09PXIucmFuaywoZnVuY3Rpb24oKXtyZXR1cm5cIkV4cGVjdGVkIHRoZSByYW5rIG9mIGxhYmVscyB0byBiZSAxLCBidXQgZ290IFwiK3IucmFua30pKSxDKDE9PT1vLnJhbmssKGZ1bmN0aW9uKCl7cmV0dXJuXCJFeHBlY3RlZCB0aGUgcmFuayBvZiBwcmVkaWN0aW9ucyB0byBiZSAxLCBidXQgZ290IFwiK28ucmFua30pKSxDKHIuc2hhcGVbMF09PT1vLnNoYXBlWzBdLChmdW5jdGlvbigpe3JldHVyblwiTWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBleGFtcGxlczogXCIrci5zaGFwZVswXStcIiB2cy4gXCIrby5zaGFwZVswXStcIi4gTGFiZWxzIGFuZCBwcmVkaWN0aW9ucyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuXCJ9KSksQyhuPjAmJk51bWJlci5pc0ludGVnZXIobiksKGZ1bmN0aW9uKCl7cmV0dXJuXCJudW1DbGFzc2VzIGlzIHJlcXVpcmVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCBcIitufSkpO3ZhciBhPVJjKHIuYXNUeXBlKFwiaW50MzJcIiksbiksaT1SYyhvLmFzVHlwZShcImludDMyXCIpLG4pO3JldHVybiBhLnRyYW5zcG9zZSgpLm1hdE11bChpKS5hc1R5cGUoXCJpbnQzMlwiKX19KSxXZD1PYmplY3QuZnJlZXplKHtjb25mdXNpb25NYXRyaXg6TGR9KTt2YXIgVWQ9QW4oe2Zyb21QaXhlbHNfOmZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09ZSYmKGU9MyksZT40KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgVGVuc29yIHdpdGggbW9yZSB0aGFuIDQgY2hhbm5lbHMgZnJvbSBwaXhlbHMuXCIpO2lmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwicGl4ZWxzIHBhc3NlZCB0byB0Zi5icm93c2VyLmZyb21QaXhlbHMoKSBjYW4gbm90IGJlIG51bGxcIik7dmFyIG49ITEscj0hMSxvPSExLGE9ITEsaT0hMTtpZih0LmRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KW49ITA7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgSW1hZ2VEYXRhJiZ0IGluc3RhbmNlb2YgSW1hZ2VEYXRhKXI9ITA7ZWxzZSBpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgSFRNTFZpZGVvRWxlbWVudCYmdCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpbz0hMDtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50JiZ0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudClhPSEwO2Vsc2V7aWYobnVsbD09dC5nZXRDb250ZXh0KXRocm93IG5ldyBFcnJvcihcInBpeGVscyBwYXNzZWQgdG8gdGYuYnJvd3Nlci5mcm9tUGl4ZWxzKCkgbXVzdCBiZSBlaXRoZXIgYW4gSFRNTFZpZGVvRWxlbWVudCwgSFRNTEltYWdlRWxlbWVudCwgSFRNTENhbnZhc0VsZW1lbnQsIEltYWdlRGF0YSBpbiBicm93c2VyLCBvciBPZmZzY3JlZW5DYW52YXMsIEltYWdlRGF0YSBpbiB3ZWJ3b3JrZXIgb3Ige2RhdGE6IFVpbnQzMkFycmF5LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0sIGJ1dCB3YXMgXCIrdC5jb25zdHJ1Y3Rvci5uYW1lKTtpPSEwfWlmKG8pe2lmKG8mJnQucmVhZHlTdGF0ZTwyKXRocm93IG5ldyBFcnJvcihcIlRoZSB2aWRlbyBlbGVtZW50IGhhcyBub3QgbG9hZGVkIGRhdGEgeWV0LiBQbGVhc2Ugd2FpdCBmb3IgYGxvYWRlZGRhdGFgIGV2ZW50IG9uIHRoZSA8dmlkZW8+IGVsZW1lbnQuXCIpfWlmKG51bGwhPWwoXCJGcm9tUGl4ZWxzXCIsTHQuYmFja2VuZE5hbWUpKXJldHVybiBMdC5ydW5LZXJuZWwoXCJGcm9tUGl4ZWxzXCIse3BpeGVsczp0fSx7bnVtQ2hhbm5lbHM6ZX0pO3ZhciBzLHUsYz1vP1t0LnZpZGVvV2lkdGgsdC52aWRlb0hlaWdodF06W3Qud2lkdGgsdC5oZWlnaHRdLGg9Y1swXSxmPWNbMV07aWYoaT9zPXQuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YSgwLDAsaCxmKS5kYXRhOnJ8fG4/cz10LmRhdGE6KGF8fG8pJiYobnVsbD09UGQmJihQZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKSksUGQuY2FudmFzLndpZHRoPWgsUGQuY2FudmFzLmhlaWdodD1mLFBkLmRyYXdJbWFnZSh0LDAsMCxoLGYpLHM9UGQuZ2V0SW1hZ2VEYXRhKDAsMCxoLGYpLmRhdGEpLDQ9PT1lKXU9bmV3IEludDMyQXJyYXkocyk7ZWxzZXt2YXIgZD1oKmY7dT1uZXcgSW50MzJBcnJheShkKmUpO2Zvcih2YXIgcD0wO3A8ZDtwKyspZm9yKHZhciB2PTA7djxlOysrdil1W3AqZSt2XT1zWzQqcCt2XX1yZXR1cm4gUG4odSxbZixoLGVdLFwiaW50MzJcIil9fSksVmQ9T2JqZWN0LmZyZWV6ZSh7dG9QaXhlbHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIG4sbyxhLGkscyx1LGMsbCxoLGYsZCxwLHYsZyxtLHkseCxiLHcsQyxFLFIsSTtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihyKXtzd2l0Y2goci5sYWJlbCl7Y2FzZSAwOmlmKG49Z24odCxcImltZ1wiLFwidG9QaXhlbHNcIiksdCBpbnN0YW5jZW9mIHd0fHwobj1uLnRvSW50KCkpLDIhPT1uLnJhbmsmJjMhPT1uLnJhbmspdGhyb3cgbmV3IEVycm9yKFwidG9QaXhlbHMgb25seSBzdXBwb3J0cyByYW5rIDIgb3IgMyB0ZW5zb3JzLCBnb3QgcmFuayBcIituLnJhbmsrXCIuXCIpO2lmKG89bi5zaGFwZS5zbGljZSgwLDIpLGE9b1swXSxpPW9bMV0sKHM9Mj09PW4ucmFuaz8xOm4uc2hhcGVbMl0pPjR8fDI9PT1zKXRocm93IG5ldyBFcnJvcihcInRvUGl4ZWxzIG9ubHkgc3VwcG9ydHMgZGVwdGggb2Ygc2l6ZSAxLCAzIG9yIDQgYnV0IGdvdCBcIitzKTtyZXR1cm5bNCxuLmRhdGEoKV07Y2FzZSAxOnJldHVybiB1PXIuc2VudCgpLGM9bi5taW4oKSxsPW4ubWF4KCksWzQsUHJvbWlzZS5hbGwoW2MuZGF0YSgpLGwuZGF0YSgpXSldO2Nhc2UgMjppZihoPXIuc2VudCgpLGY9aFswXSxkPWhbMV0scD1mWzBdLHY9ZFswXSxjLmRpc3Bvc2UoKSxsLmRpc3Bvc2UoKSxcImZsb2F0MzJcIj09PW4uZHR5cGUpe2lmKHA8MHx8dj4xKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciB2YWx1ZXMgZm9yIGEgZmxvYXQzMiBUZW5zb3IgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAxXSBidXQgZ290IHJhbmdlIFtcIitwK1wiIC0gXCIrditcIl0uXCIpfWVsc2V7aWYoXCJpbnQzMlwiIT09bi5kdHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlIGZvciB0b1BpeGVsczogXCIrbi5kdHlwZStcIi4gUGxlYXNlIHVzZSBmbG9hdDMyIG9yIGludDMyIHRlbnNvcnMuXCIpO2lmKHA8MHx8dj4yNTUpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIHZhbHVlcyBmb3IgYSBpbnQzMiBUZW5zb3IgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAgLSAyNTVdIGJ1dCBnb3QgcmFuZ2UgW1wiK3ArXCIgLSBcIit2K1wiXS5cIil9Zm9yKGc9XCJmbG9hdDMyXCI9PT1uLmR0eXBlPzI1NToxLG09bmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGkqYSo0KSx5PTA7eTxhKmk7Kyt5KXg9dm9pZCAwLGI9dm9pZCAwLHc9dm9pZCAwLEM9dm9pZCAwLDE9PT1zPyh4PXVbeV0qZyxiPXVbeV0qZyx3PXVbeV0qZyxDPTI1NSk6Mz09PXM/KHg9dVszKnldKmcsYj11WzMqeSsxXSpnLHc9dVszKnkrMl0qZyxDPTI1NSk6ND09PXMmJih4PXVbNCp5XSpnLGI9dVs0KnkrMV0qZyx3PXVbNCp5KzJdKmcsQz11WzQqeSszXSpnKSxtWyhFPTQqeSkrMF09TWF0aC5yb3VuZCh4KSxtW0UrMV09TWF0aC5yb3VuZChiKSxtW0UrMl09TWF0aC5yb3VuZCh3KSxtW0UrM109TWF0aC5yb3VuZChDKTtyZXR1cm4gbnVsbCE9ZSYmKGUud2lkdGg9aSxlLmhlaWdodD1hLFI9ZS5nZXRDb250ZXh0KFwiMmRcIiksST1uZXcgSW1hZ2VEYXRhKG0saSxhKSxSLnB1dEltYWdlRGF0YShJLDAsMCkpLG4hPT10JiZuLmRpc3Bvc2UoKSxbMixtXX19KSl9KSl9LGZyb21QaXhlbHM6VWR9KSx6ZD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQucHJvdG90eXBlLmdldENsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLmNsYXNzTmFtZX0sdC5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUpfSx0fSgpLEdkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuY2xhc3NOYW1lTWFwPXt9fXJldHVybiB0LmdldE1hcD1mdW5jdGlvbigpe3JldHVybiBudWxsPT10Lmluc3RhbmNlJiYodC5pbnN0YW5jZT1uZXcgdCksdC5pbnN0YW5jZX0sdC5yZWdpc3Rlcj1mdW5jdGlvbihlKXt0LmdldE1hcCgpLmNsYXNzTmFtZU1hcFtlLmNsYXNzTmFtZV09W2UsZS5mcm9tQ29uZmlnXX0sdH0oKTtmdW5jdGlvbiBIZCh0KXtDKG51bGwhPXQuY2xhc3NOYW1lLChmdW5jdGlvbigpe3JldHVyblwiQ2xhc3MgYmVpbmcgcmVnaXN0ZXJlZCBkb2VzIG5vdCBoYXZlIHRoZSBzdGF0aWMgY2xhc3NOYW1lIHByb3BlcnR5IGRlZmluZWQuXCJ9KSksQyhcInN0cmluZ1wiPT10eXBlb2YgdC5jbGFzc05hbWUsKGZ1bmN0aW9uKCl7cmV0dXJuXCJjbGFzc05hbWUgaXMgcmVxdWlyZWQgdG8gYmUgYSBzdHJpbmcsIGJ1dCBnb3QgdHlwZSBcIit0eXBlb2YgdC5jbGFzc05hbWV9KSksQyh0LmNsYXNzTmFtZS5sZW5ndGg+MCwoZnVuY3Rpb24oKXtyZXR1cm5cIkNsYXNzIGJlaW5nIHJlZ2lzdGVyZWQgaGFzIGFuIGVtcHR5LXN0cmluZyBhcyBpdHMgY2xhc3NOYW1lLCB3aGljaCBpcyBkaXNhbGxvd2VkLlwifSkpLEdkLnJlZ2lzdGVyKHQpfXZhciBxZD1PYmplY3QuZnJlZXplKHtTZXJpYWxpemFibGU6emQsU2VyaWFsaXphdGlvbk1hcDpHZCxyZWdpc3RlckNsYXNzOkhkfSksS2Q9XCIxLjcuNFwiO3ZhciBqZD1PYmplY3QuZnJlZXplKHtncGdwdV91dGlsOlJzLHdlYmdsX3V0aWw6R2UsZm9yY2VIYWxmRmxvYXQ6ZnVuY3Rpb24oKXtpKCkuc2V0KFwiV0VCR0xfRk9SQ0VfRjE2X1RFWFRVUkVTXCIsITApfSxNYXRoQmFja2VuZFdlYkdMOlV1LHNldFdlYkdMQ29udGV4dDpLdCxHUEdQVUNvbnRleHQ6SXN9KSxYZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLm1pbmltaXplPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1lJiYoZT0hMSk7dmFyIHI9dGhpcy5jb21wdXRlR3JhZGllbnRzKHQsbiksbz1yLnZhbHVlLGE9ci5ncmFkcztpZihudWxsIT1uKXt2YXIgaT1uLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue25hbWU6dC5uYW1lLHRlbnNvcjphW3QubmFtZV19fSkpO3RoaXMuYXBwbHlHcmFkaWVudHMoaSl9ZWxzZSB0aGlzLmFwcGx5R3JhZGllbnRzKGEpO3JldHVybiB0bihhKSxlP286KG8uZGlzcG9zZSgpLG51bGwpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoby5wcm90b3R5cGUsXCJpdGVyYXRpb25zXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBudWxsPT10aGlzLml0ZXJhdGlvbnNfJiYodGhpcy5pdGVyYXRpb25zXz0wKSx0aGlzLml0ZXJhdGlvbnNffSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLG8ucHJvdG90eXBlLmluY3JlbWVudEl0ZXJhdGlvbnM9ZnVuY3Rpb24oKXt0aGlzLml0ZXJhdGlvbnNfPXRoaXMuaXRlcmF0aW9ucysxfSxvLnByb3RvdHlwZS5jb21wdXRlR3JhZGllbnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHJhKHQsZSl9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXtudWxsIT10aGlzLml0ZXJhdGlvbnNfJiZ0bih0aGlzLml0ZXJhdGlvbnNfKX0sby5wcm90b3R5cGUuc2F2ZUl0ZXJhdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXRoaXMuaXRlcmF0aW9uc18mJih0aGlzLml0ZXJhdGlvbnNfPTApLFsyLHtuYW1lOlwiaXRlclwiLHRlbnNvcjpPbih0aGlzLml0ZXJhdGlvbnNfLFwiaW50MzJcIil9XX0pKX0pKX0sby5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJnZXRXZWlnaHRzKCkgaXMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIG9wdGltaXplciB5ZXQuXCIpfSkpfSkpfSxvLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbih0KXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRXZWlnaHRzKCkgaXMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIG9wdGltaXplciBjbGFzcyBcIit0aGlzLmdldENsYXNzTmFtZSgpKX0pKX0pKX0sby5wcm90b3R5cGUuZXh0cmFjdEl0ZXJhdGlvbnM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciBlO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKG4pe3N3aXRjaChuLmxhYmVsKXtjYXNlIDA6cmV0dXJuIGU9dGhpcyxbNCx0WzBdLnRlbnNvci5kYXRhKCldO2Nhc2UgMTpyZXR1cm4gZS5pdGVyYXRpb25zXz1uLnNlbnQoKVswXSxbMix0LnNsaWNlKDEpXX19KSl9KSl9LG99KHpkKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoWGQsU3ltYm9sLmhhc0luc3RhbmNlLHt2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9dC5taW5pbWl6ZSYmbnVsbCE9dC5jb21wdXRlR3JhZGllbnRzJiZudWxsIT10LmFwcGx5R3JhZGllbnRzfX0pO3ZhciBZZD1mdW5jdGlvbih0KXtmdW5jdGlvbiBvKGUsbixyKXt2b2lkIDA9PT1yJiYocj1udWxsKTt2YXIgbz10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG8ubGVhcm5pbmdSYXRlPWUsby5yaG89bixvLmVwc2lsb249cixvLmFjY3VtdWxhdGVkR3JhZHM9W10sby5hY2N1bXVsYXRlZFVwZGF0ZXM9W10sbnVsbD09ciYmKG8uZXBzaWxvbj1MdC5iYWNrZW5kLmVwc2lsb24oKSksb31yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7KEFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCkpLmZvckVhY2goKGZ1bmN0aW9uKG4scil7dmFyIG89THQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtudWxsPT1lLmFjY3VtdWxhdGVkR3JhZHNbcl0mJihlLmFjY3VtdWxhdGVkR3JhZHNbcl09e29yaWdpbmFsTmFtZTpuK1wiL2FjY3VtX2dyYWRcIix2YXJpYWJsZTpaZSgoZnVuY3Rpb24oKXtyZXR1cm4gWG4obykudmFyaWFibGUoITEpfSkpfSksbnVsbD09ZS5hY2N1bXVsYXRlZFVwZGF0ZXNbcl0mJihlLmFjY3VtdWxhdGVkVXBkYXRlc1tyXT17b3JpZ2luYWxOYW1lOm4rXCIvYWNjdW1fdmFyXCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIFhuKG8pLnZhcmlhYmxlKCExKX0pKX0pO3ZhciBhPUFycmF5LmlzQXJyYXkodCk/dFtyXS50ZW5zb3I6dFtuXTtpZihudWxsIT1hKXt2YXIgaT1lLmFjY3VtdWxhdGVkR3JhZHNbcl0udmFyaWFibGUscz1lLmFjY3VtdWxhdGVkVXBkYXRlc1tyXS52YXJpYWJsZTtaZSgoZnVuY3Rpb24oKXt2YXIgdD1pLm11bChlLnJobykuYWRkKGEuc3F1YXJlKCkubXVsKDEtZS5yaG8pKSxuPXMuYWRkKGUuZXBzaWxvbikuc3FydCgpLmRpdihpLmFkZChlLmVwc2lsb24pLnNxcnQoKSkubXVsKGEpLHI9cy5tdWwoZS5yaG8pLmFkZChuLnNxdWFyZSgpLm11bCgxLWUucmhvKSk7aS5hc3NpZ24odCkscy5hc3NpZ24ocik7dmFyIHU9bi5tdWwoLWUubGVhcm5pbmdSYXRlKS5hZGQobyk7by5hc3NpZ24odSl9KSl9fSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMmJih0bih0aGlzLmFjY3VtdWxhdGVkR3JhZHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSksdG4odGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSkpfSxvLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9dGhpcy5hY2N1bXVsYXRlZEdyYWRzLmNvbmNhdCh0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcyksWzQsdGhpcy5zYXZlSXRlcmF0aW9ucygpXTtjYXNlIDE6cmV0dXJuWzIsW2Uuc2VudCgpXS5jb25jYXQodC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntuYW1lOnQub3JpZ2luYWxOYW1lLHRlbnNvcjp0LnZhcmlhYmxlfX0pKSldfX0pKX0pKX0sby5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmV4dHJhY3RJdGVyYXRpb25zKHQpXTtjYXNlIDE6cmV0dXJuIHQ9bi5zZW50KCksZT10Lmxlbmd0aC8yLCExLHRoaXMuYWNjdW11bGF0ZWRHcmFkcz10LnNsaWNlKDAsZSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm57b3JpZ2luYWxOYW1lOnQubmFtZSx2YXJpYWJsZTp0LnRlbnNvci52YXJpYWJsZSghMSl9fSkpLHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzPXQuc2xpY2UoZSwyKmUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSxbMl19fSkpfSkpfSxvLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLHJobzp0aGlzLnJobyxlcHNpbG9uOnRoaXMuZXBzaWxvbn19LG8uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLnJobyxlLmVwc2lsb24pfSxvLmNsYXNzTmFtZT1cIkFkYWRlbHRhXCIsb30oWGQpO0hkKFlkKTt2YXIgJGQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlLG4pe3ZvaWQgMD09PW4mJihuPS4xKTt2YXIgcj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIHIubGVhcm5pbmdSYXRlPWUsci5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZT1uLHIuYWNjdW11bGF0ZWRHcmFkcz1bXSxyfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczsoQXJyYXkuaXNBcnJheSh0KT90Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKTpPYmplY3Qua2V5cyh0KSkuZm9yRWFjaCgoZnVuY3Rpb24obixyKXt2YXIgbz1MdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO2lmKG51bGw9PWUuYWNjdW11bGF0ZWRHcmFkc1tyXSl7ZS5hY2N1bXVsYXRlZEdyYWRzW3JdPXtvcmlnaW5hbE5hbWU6bitcIi9hY2N1bXVsYXRvclwiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBIbihvLnNoYXBlLGUuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUpLnZhcmlhYmxlKCExKX0pKX19dmFyIGE9QXJyYXkuaXNBcnJheSh0KT90W3JdLnRlbnNvcjp0W25dO2lmKG51bGwhPWEpe3ZhciBpPWUuYWNjdW11bGF0ZWRHcmFkc1tyXS52YXJpYWJsZTtaZSgoZnVuY3Rpb24oKXt2YXIgdD1pLmFkZChhLnNxdWFyZSgpKTtpLmFzc2lnbih0KTt2YXIgbj1hLmRpdih0LmFkZChMdC5iYWNrZW5kLmVwc2lsb24oKSkuc3FydCgpKS5tdWwoLWUubGVhcm5pbmdSYXRlKS5hZGQobyk7by5hc3NpZ24obil9KSl9fSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7bnVsbCE9dGhpcy5hY2N1bXVsYXRlZEdyYWRzJiZ0bih0aGlzLmFjY3VtdWxhdGVkR3JhZHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSl9LG8ucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLnNhdmVJdGVyYXRpb25zKCldO2Nhc2UgMTpyZXR1cm5bMixbdC5zZW50KCldLmNvbmNhdCh0aGlzLmFjY3VtdWxhdGVkR3JhZHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm57bmFtZTp0Lm9yaWdpbmFsTmFtZSx0ZW5zb3I6dC52YXJpYWJsZX19KSkpXX19KSl9KSl9LG8ucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5leHRyYWN0SXRlcmF0aW9ucyh0KV07Y2FzZSAxOnJldHVybiB0PWUuc2VudCgpLCExLHRoaXMuYWNjdW11bGF0ZWRHcmFkcz10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSxbMl19fSkpfSkpfSxvLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGluaXRpYWxBY2N1bXVsYXRvclZhbHVlOnRoaXMuaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWV9fSxvLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSl9LG8uY2xhc3NOYW1lPVwiQWRhZ3JhZFwiLG99KFhkKTtIZCgkZCk7dmFyIFFkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuLHIsbyl7dm9pZCAwPT09byYmKG89bnVsbCk7dmFyIGE9dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBhLmxlYXJuaW5nUmF0ZT1lLGEuYmV0YTE9bixhLmJldGEyPXIsYS5lcHNpbG9uPW8sYS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PVtdLGEuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnQ9W10sWmUoKGZ1bmN0aW9uKCl7YS5hY2NCZXRhMT1PbihuKS52YXJpYWJsZSgpLGEuYWNjQmV0YTI9T24ocikudmFyaWFibGUoKX0pKSxudWxsPT1vJiYoYS5lcHNpbG9uPUx0LmJhY2tlbmQuZXBzaWxvbigpKSxhfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPUFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCk7WmUoKGZ1bmN0aW9uKCl7dmFyIHI9T28oMSxlLmFjY0JldGExKSxvPU9vKDEsZS5hY2NCZXRhMik7bi5mb3JFYWNoKChmdW5jdGlvbihuLGEpe3ZhciBpPUx0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07bnVsbD09ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2FdJiYoZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2FdPXtvcmlnaW5hbE5hbWU6bitcIi9tXCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIFhuKGkpLnZhcmlhYmxlKCExKX0pKX0pLG51bGw9PWUuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbYV0mJihlLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W2FdPXtvcmlnaW5hbE5hbWU6bitcIi92XCIsdmFyaWFibGU6WmUoKGZ1bmN0aW9uKCl7cmV0dXJuIFhuKGkpLnZhcmlhYmxlKCExKX0pKX0pO3ZhciBzPUFycmF5LmlzQXJyYXkodCk/dFthXS50ZW5zb3I6dFtuXTtpZihudWxsIT1zKXt2YXIgdT1lLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbYV0udmFyaWFibGUsYz1lLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50W2FdLnZhcmlhYmxlLGw9dS5tdWwoZS5iZXRhMSkuYWRkKHMubXVsKDEtZS5iZXRhMSkpLGg9Yy5tdWwoZS5iZXRhMikuYWRkKHMuc3F1YXJlKCkubXVsKDEtZS5iZXRhMikpLGY9bC5kaXYociksZD1oLmRpdihvKTt1LmFzc2lnbihsKSxjLmFzc2lnbihoKTt2YXIgcD1mLmRpdihkLnNxcnQoKS5hZGQoZS5lcHNpbG9uKSkubXVsKC1lLmxlYXJuaW5nUmF0ZSkuYWRkKGkpO2kuYXNzaWduKHApfX0pKSxlLmFjY0JldGExLmFzc2lnbihlLmFjY0JldGExLm11bChlLmJldGExKSksZS5hY2NCZXRhMi5hc3NpZ24oZS5hY2NCZXRhMi5tdWwoZS5iZXRhMikpfSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5hY2NCZXRhMS5kaXNwb3NlKCksdGhpcy5hY2NCZXRhMi5kaXNwb3NlKCksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50JiZ0bih0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCYmdG4odGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhcmlhYmxlfSkpKX0sby5wcm90b3R5cGUuZ2V0V2VpZ2h0cz1mdW5jdGlvbigpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybiB0PXRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudC5jb25jYXQodGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCksWzQsdGhpcy5zYXZlSXRlcmF0aW9ucygpXTtjYXNlIDE6cmV0dXJuWzIsW2Uuc2VudCgpXS5jb25jYXQodC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntuYW1lOnQub3JpZ2luYWxOYW1lLHRlbnNvcjp0LnZhcmlhYmxlfX0pKSldfX0pKX0pKX0sby5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGUsbj10aGlzO3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHIpe3N3aXRjaChyLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5leHRyYWN0SXRlcmF0aW9ucyh0KV07Y2FzZSAxOnJldHVybiB0PXIuc2VudCgpLFplKChmdW5jdGlvbigpe24uYWNjQmV0YTEuYXNzaWduKE5vKG4uYmV0YTEsbi5pdGVyYXRpb25zXysxKSksbi5hY2NCZXRhMi5hc3NpZ24oTm8obi5iZXRhMixuLml0ZXJhdGlvbnNfKzEpKX0pKSxlPXQubGVuZ3RoLzIsITEsdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PXQuc2xpY2UoMCxlKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSksdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudD10LnNsaWNlKGUsMiplKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSksWzJdfX0pKX0pKX0sby5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZSxiZXRhMTp0aGlzLmJldGExLGJldGEyOnRoaXMuYmV0YTIsZXBzaWxvbjp0aGlzLmVwc2lsb259fSxvLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5iZXRhMSxlLmJldGEyLGUuZXBzaWxvbil9LG8uY2xhc3NOYW1lPVwiQWRhbVwiLG99KFhkKTtIZChRZCk7dmFyIEpkPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG8oZSxuLHIsbyxhKXt2b2lkIDA9PT1vJiYobz1udWxsKSx2b2lkIDA9PT1hJiYoYT0wKTt2YXIgaT10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIGkubGVhcm5pbmdSYXRlPWUsaS5iZXRhMT1uLGkuYmV0YTI9cixpLmVwc2lsb249byxpLmRlY2F5PWEsaS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50PVtdLGkuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm09W10sWmUoKGZ1bmN0aW9uKCl7aS5pdGVyYXRpb249T24oMCkudmFyaWFibGUoKSxpLmFjY0JldGExPU9uKG4pLnZhcmlhYmxlKCl9KSksbnVsbD09byYmKGkuZXBzaWxvbj1MdC5iYWNrZW5kLmVwc2lsb24oKSksaX1yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1BcnJheS5pc0FycmF5KHQpP3QubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5uYW1lfSkpOk9iamVjdC5rZXlzKHQpO1plKChmdW5jdGlvbigpe3ZhciByPU9vKDEsZS5hY2NCZXRhMSksbz1CbygtZS5sZWFybmluZ1JhdGUsZS5pdGVyYXRpb24ubXVsKGUuZGVjYXkpLmFkZCgxKSk7bi5mb3JFYWNoKChmdW5jdGlvbihuLGEpe3ZhciBpPUx0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07bnVsbD09ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2FdJiYoZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2FdPXtvcmlnaW5hbE5hbWU6bitcIi9tXCIsdmFyaWFibGU6WG4oaSkudmFyaWFibGUoITEpfSksbnVsbD09ZS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVthXSYmKGUuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bYV09e29yaWdpbmFsTmFtZTpuK1wiL3ZcIix2YXJpYWJsZTpYbihpKS52YXJpYWJsZSghMSl9KTt2YXIgcz1BcnJheS5pc0FycmF5KHQpP3RbYV0udGVuc29yOnRbbl07aWYobnVsbCE9cyl7dmFyIHU9ZS5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W2FdLnZhcmlhYmxlLGM9ZS5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVthXS52YXJpYWJsZSxsPXUubXVsKGUuYmV0YTEpLmFkZChzLm11bCgxLWUuYmV0YTEpKSxoPWMubXVsKGUuYmV0YTIpLGY9cy5hYnMoKSxkPWgubWF4aW11bShmKTt1LmFzc2lnbihsKSxjLmFzc2lnbihkKTt2YXIgcD1vLmRpdihyKS5tdWwobC5kaXYoZC5hZGQoZS5lcHNpbG9uKSkpLmFkZChpKTtpLmFzc2lnbihwKX19KSksZS5pdGVyYXRpb24uYXNzaWduKGUuaXRlcmF0aW9uLmFkZCgxKSksZS5hY2NCZXRhMS5hc3NpZ24oZS5hY2NCZXRhMS5tdWwoZS5iZXRhMSkpfSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dGhpcy5hY2NCZXRhMS5kaXNwb3NlKCksdGhpcy5pdGVyYXRpb24uZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCYmdG4odGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0mJnRuKHRoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSl9LG8ucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwiZ2V0V2VpZ2h0cygpIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgQWRhbWF4IHlldC5cIil9KSl9KSl9LG8ucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcInNldFdlaWdodHMoKSBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIEFkYW1heCB5ZXQuXCIpfSkpfSkpfSxvLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLGJldGExOnRoaXMuYmV0YTEsYmV0YTI6dGhpcy5iZXRhMixlcHNpbG9uOnRoaXMuZXBzaWxvbixkZWNheTp0aGlzLmRlY2F5fX0sby5mcm9tQ29uZmlnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyB0KGUubGVhcm5pbmdSYXRlLGUuYmV0YTEsZS5iZXRhMixlLmVwc2lsb24sZS5kZWNheSl9LG8uY2xhc3NOYW1lPVwiQWRhbWF4XCIsb30oWGQpO0hkKEpkKTt2YXIgWmQ9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlKXt2YXIgbj10LmNhbGwodGhpcyl8fHRoaXM7cmV0dXJuIG4ubGVhcm5pbmdSYXRlPWUsbi5zZXRMZWFybmluZ1JhdGUoZSksbn1yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7KEFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCkpLmZvckVhY2goKGZ1bmN0aW9uKG4scil7dmFyIG89QXJyYXkuaXNBcnJheSh0KT90W3JdLnRlbnNvcjp0W25dO2lmKG51bGwhPW8pe3ZhciBhPUx0LnJlZ2lzdGVyZWRWYXJpYWJsZXNbbl07WmUoKGZ1bmN0aW9uKCl7dmFyIHQ9ZS5jLm11bChvKS5hZGQoYSk7YS5hc3NpZ24odCl9KSl9fSkpLHRoaXMuaW5jcmVtZW50SXRlcmF0aW9ucygpfSxvLnByb3RvdHlwZS5zZXRMZWFybmluZ1JhdGU9ZnVuY3Rpb24odCl7dGhpcy5sZWFybmluZ1JhdGU9dCxudWxsIT10aGlzLmMmJnRoaXMuYy5kaXNwb3NlKCksdGhpcy5jPWVuKE9uKC10KSl9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLmMuZGlzcG9zZSgpfSxvLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5zYXZlSXRlcmF0aW9ucygpXTtjYXNlIDE6cmV0dXJuWzIsW3Quc2VudCgpXV19fSkpfSkpfSxvLnByb3RvdHlwZS5zZXRXZWlnaHRzPWZ1bmN0aW9uKHQpe3JldHVybiBuKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXtyZXR1cm4gcih0aGlzLChmdW5jdGlvbihlKXtzd2l0Y2goZS5sYWJlbCl7Y2FzZSAwOnJldHVybls0LHRoaXMuZXh0cmFjdEl0ZXJhdGlvbnModCldO2Nhc2UgMTppZigwIT09KHQ9ZS5zZW50KCkpLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJTR0Qgb3B0aW1pemVyIGRvZXMgbm90IGhhdmUgc2V0dGFibGUgd2VpZ2h0cy5cIik7cmV0dXJuWzJdfX0pKX0pKX0sby5wcm90b3R5cGUuZ2V0Q29uZmlnPWZ1bmN0aW9uKCl7cmV0dXJue2xlYXJuaW5nUmF0ZTp0aGlzLmxlYXJuaW5nUmF0ZX19LG8uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSl9LG8uY2xhc3NOYW1lPVwiU0dEXCIsb30oWGQpO0hkKFpkKTt2YXIgdHA9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlLG4scil7dm9pZCAwPT09ciYmKHI9ITEpO3ZhciBvPXQuY2FsbCh0aGlzLGUpfHx0aGlzO3JldHVybiBvLmxlYXJuaW5nUmF0ZT1lLG8ubW9tZW50dW09bixvLnVzZU5lc3Rlcm92PXIsby5hY2N1bXVsYXRpb25zPVtdLG8ubT1PbihvLm1vbWVudHVtKSxvfXJldHVybiBlKG8sdCksby5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczsoQXJyYXkuaXNBcnJheSh0KT90Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKTpPYmplY3Qua2V5cyh0KSkuZm9yRWFjaCgoZnVuY3Rpb24obixyKXt2YXIgbz1MdC5yZWdpc3RlcmVkVmFyaWFibGVzW25dO2lmKG51bGw9PWUuYWNjdW11bGF0aW9uc1tyXSl7ZS5hY2N1bXVsYXRpb25zW3JdPXtvcmlnaW5hbE5hbWU6bitcIi9tb21lbnR1bVwiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBYbihvKS52YXJpYWJsZSghMSl9KSl9fXZhciBhPWUuYWNjdW11bGF0aW9uc1tyXS52YXJpYWJsZSxpPUFycmF5LmlzQXJyYXkodCk/dFtyXS50ZW5zb3I6dFtuXTtudWxsIT1pJiZaZSgoZnVuY3Rpb24oKXt2YXIgdCxuPWUubS5tdWwoYSkuYWRkKGkpO3Q9ZS51c2VOZXN0ZXJvdj9lLmMubXVsKGkuYWRkKG4ubXVsKGUubSkpKS5hZGQobyk6ZS5jLm11bChuKS5hZGQobyksYS5hc3NpZ24obiksby5hc3NpZ24odCl9KSl9KSksdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCl9LG8ucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0aGlzLm0uZGlzcG9zZSgpLG51bGwhPXRoaXMuYWNjdW11bGF0aW9ucyYmdG4odGhpcy5hY2N1bXVsYXRpb25zLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpfSxvLnByb3RvdHlwZS5zZXRNb21lbnR1bT1mdW5jdGlvbih0KXt0aGlzLm1vbWVudHVtPXR9LG8ucHJvdG90eXBlLmdldFdlaWdodHM9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24odCl7c3dpdGNoKHQubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLnNhdmVJdGVyYXRpb25zKCldO2Nhc2UgMTpyZXR1cm5bMixbdC5zZW50KCldLmNvbmNhdCh0aGlzLmFjY3VtdWxhdGlvbnMubWFwKChmdW5jdGlvbih0KXtyZXR1cm57bmFtZTp0Lm9yaWdpbmFsTmFtZSx0ZW5zb3I6dC52YXJpYWJsZX19KSkpXX19KSl9KSl9LG8ucHJvdG90eXBlLnNldFdlaWdodHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuWzQsdGhpcy5leHRyYWN0SXRlcmF0aW9ucyh0KV07Y2FzZSAxOnJldHVybiB0PWUuc2VudCgpLCExLHRoaXMuYWNjdW11bGF0aW9ucz10Lm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSxbMl19fSkpfSkpfSxvLnByb3RvdHlwZS5nZXRDb25maWc9ZnVuY3Rpb24oKXtyZXR1cm57bGVhcm5pbmdSYXRlOnRoaXMubGVhcm5pbmdSYXRlLG1vbWVudHVtOnRoaXMubW9tZW50dW0sdXNlTmVzdGVyb3Y6dGhpcy51c2VOZXN0ZXJvdn19LG8uZnJvbUNvbmZpZz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgdChlLmxlYXJuaW5nUmF0ZSxlLm1vbWVudHVtLGUudXNlTmVzdGVyb3YpfSxvLmNsYXNzTmFtZT1cIk1vbWVudHVtXCIsb30oWmQpO0hkKHRwKTt2YXIgZXA9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gbyhlLG4scixvLGEpe3ZvaWQgMD09PW4mJihuPS45KSx2b2lkIDA9PT1yJiYocj0wKSx2b2lkIDA9PT1vJiYobz1udWxsKSx2b2lkIDA9PT1hJiYoYT0hMSk7dmFyIGk9dC5jYWxsKHRoaXMpfHx0aGlzO2lmKGkubGVhcm5pbmdSYXRlPWUsaS5kZWNheT1uLGkubW9tZW50dW09cixpLmVwc2lsb249byxpLmFjY3VtdWxhdGVkTWVhblNxdWFyZXM9W10saS5hY2N1bXVsYXRlZE1vbWVudHM9W10saS5hY2N1bXVsYXRlZE1lYW5HcmFkcz1bXSxpLmNlbnRlcmVkPWEsbnVsbD09byYmKGkuZXBzaWxvbj1MdC5iYWNrZW5kLmVwc2lsb24oKSksbnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJsZWFybmluZ1JhdGUgZm9yIFJNU1Byb3BPcHRpbWl6ZXIgbXVzdCBiZSBkZWZpbmVkLlwiKTtyZXR1cm4gaX1yZXR1cm4gZShvLHQpLG8ucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7KEFycmF5LmlzQXJyYXkodCk/dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm5hbWV9KSk6T2JqZWN0LmtleXModCkpLmZvckVhY2goKGZ1bmN0aW9uKG4scil7dmFyIG89THQucmVnaXN0ZXJlZFZhcmlhYmxlc1tuXTtudWxsPT1lLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbcl0mJihlLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbcl09e29yaWdpbmFsTmFtZTpuK1wiL3Jtc1wiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBYbihvKS52YXJpYWJsZSghMSl9KSl9KSxudWxsPT1lLmFjY3VtdWxhdGVkTW9tZW50c1tyXSYmKGUuYWNjdW11bGF0ZWRNb21lbnRzW3JdPXtvcmlnaW5hbE5hbWU6bitcIi9tb21lbnR1bVwiLHZhcmlhYmxlOlplKChmdW5jdGlvbigpe3JldHVybiBYbihvKS52YXJpYWJsZSghMSl9KSl9KSxudWxsPT1lLmFjY3VtdWxhdGVkTWVhbkdyYWRzW3JdJiZlLmNlbnRlcmVkJiYoZS5hY2N1bXVsYXRlZE1lYW5HcmFkc1tyXT17b3JpZ2luYWxOYW1lOm4rXCIvbWdcIix2YXJpYWJsZTpaZSgoZnVuY3Rpb24oKXtyZXR1cm4gWG4obykudmFyaWFibGUoITEpfSkpfSk7dmFyIGE9QXJyYXkuaXNBcnJheSh0KT90W3JdLnRlbnNvcjp0W25dO2lmKG51bGwhPWEpe3ZhciBpPWUuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tyXS52YXJpYWJsZSxzPWUuYWNjdW11bGF0ZWRNb21lbnRzW3JdLnZhcmlhYmxlO1plKChmdW5jdGlvbigpe3ZhciB0PWkubXVsKGUuZGVjYXkpLmFkZChhLnNxdWFyZSgpLm11bCgxLWUuZGVjYXkpKTtpZihlLmNlbnRlcmVkKXt2YXIgbj1lLmFjY3VtdWxhdGVkTWVhbkdyYWRzW3JdLnZhcmlhYmxlLHU9bi5tdWwoZS5kZWNheSkuYWRkKGEubXVsKDEtZS5kZWNheSkpLGM9cy5tdWwoZS5tb21lbnR1bSkuYWRkKGEubXVsKGUubGVhcm5pbmdSYXRlKS5kaXYodC5zdWIodS5zcXVhcmUoKS5hZGQoZS5lcHNpbG9uKSkuc3FydCgpKSk7aS5hc3NpZ24odCksbi5hc3NpZ24odSkscy5hc3NpZ24oYyk7dmFyIGw9by5zdWIoYyk7by5hc3NpZ24obCl9ZWxzZXt2YXIgaD1pLm11bChlLmRlY2F5KS5hZGQoYS5zcXVhcmUoKS5tdWwoMS1lLmRlY2F5KSk7Yz1zLm11bChlLm1vbWVudHVtKS5hZGQoYS5tdWwoZS5sZWFybmluZ1JhdGUpLmRpdihoLmFkZChlLmVwc2lsb24pLnNxcnQoKSkpO2kuYXNzaWduKGgpLHMuYXNzaWduKGMpO2w9by5zdWIoYyk7by5hc3NpZ24obCl9fSkpfX0pKSx0aGlzLmluY3JlbWVudEl0ZXJhdGlvbnMoKX0sby5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe251bGwhPXRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcyYmdG4odGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpLG51bGwhPXRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMmJnRoaXMuY2VudGVyZWQmJnRuKHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YXJpYWJsZX0pKSksbnVsbCE9dGhpcy5hY2N1bXVsYXRlZE1vbWVudHMmJnRuKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudmFyaWFibGV9KSkpfSxvLnByb3RvdHlwZS5nZXRXZWlnaHRzPWZ1bmN0aW9uKCl7cmV0dXJuIG4odGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciB0O3JldHVybiByKHRoaXMsKGZ1bmN0aW9uKGUpe3N3aXRjaChlLmxhYmVsKXtjYXNlIDA6cmV0dXJuIHQ9dGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzLmNvbmNhdCh0aGlzLmFjY3VtdWxhdGVkTW9tZW50cyksdGhpcy5jZW50ZXJlZCYmdC5wdXNoLmFwcGx5KHQsdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyksWzQsdGhpcy5zYXZlSXRlcmF0aW9ucygpXTtjYXNlIDE6cmV0dXJuWzIsW2Uuc2VudCgpXS5jb25jYXQodC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntuYW1lOnQub3JpZ2luYWxOYW1lLHRlbnNvcjp0LnZhcmlhYmxlfX0pKSldfX0pKX0pKX0sby5wcm90b3R5cGUuc2V0V2VpZ2h0cz1mdW5jdGlvbih0KXtyZXR1cm4gbih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24obil7c3dpdGNoKG4ubGFiZWwpe2Nhc2UgMDpyZXR1cm5bNCx0aGlzLmV4dHJhY3RJdGVyYXRpb25zKHQpXTtjYXNlIDE6cmV0dXJuIHQ9bi5zZW50KCksZT10aGlzLmNlbnRlcmVkP3QubGVuZ3RoLzM6dC5sZW5ndGgvMiwhMSx0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXM9dC5zbGljZSgwLGUpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue29yaWdpbmFsTmFtZTp0Lm5hbWUsdmFyaWFibGU6dC50ZW5zb3IudmFyaWFibGUoITEpfX0pKSx0aGlzLmFjY3VtdWxhdGVkTW9tZW50cz10LnNsaWNlKGUsMiplKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSksdGhpcy5jZW50ZXJlZCYmKHRoaXMuYWNjdW11bGF0ZWRNZWFuR3JhZHM9dC5zbGljZSgyKmUsMyplKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntvcmlnaW5hbE5hbWU6dC5uYW1lLHZhcmlhYmxlOnQudGVuc29yLnZhcmlhYmxlKCExKX19KSkpLFsyXX19KSl9KSl9LG8ucHJvdG90eXBlLmdldENvbmZpZz1mdW5jdGlvbigpe3JldHVybntsZWFybmluZ1JhdGU6dGhpcy5sZWFybmluZ1JhdGUsZGVjYXk6dGhpcy5kZWNheSxtb21lbnR1bTp0aGlzLm1vbWVudHVtLGVwc2lsb246dGhpcy5lcHNpbG9uLGNlbnRlcmVkOnRoaXMuY2VudGVyZWR9fSxvLmZyb21Db25maWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IHQoZS5sZWFybmluZ1JhdGUsZS5kZWNheSxlLm1vbWVudHVtLGUuZXBzaWxvbixlLmNlbnRlcmVkKX0sby5jbGFzc05hbWU9XCJSTVNQcm9wXCIsb30oWGQpO0hkKGVwKTt2YXIgbnA9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnNnZD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IFpkKHQpfSx0Lm1vbWVudHVtPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49ITEpLG5ldyB0cCh0LGUsbil9LHQucm1zcHJvcD1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB2b2lkIDA9PT1lJiYoZT0uOSksdm9pZCAwPT09biYmKG49MCksdm9pZCAwPT09ciYmKHI9bnVsbCksdm9pZCAwPT09byYmKG89ITEpLG5ldyBlcCh0LGUsbixyLG8pfSx0LmFkYW09ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHZvaWQgMD09PXQmJih0PS4wMDEpLHZvaWQgMD09PWUmJihlPS45KSx2b2lkIDA9PT1uJiYobj0uOTk5KSx2b2lkIDA9PT1yJiYocj1udWxsKSxuZXcgUWQodCxlLG4scil9LHQuYWRhZGVsdGE9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT10JiYodD0uMDAxKSx2b2lkIDA9PT1lJiYoZT0uOTUpLHZvaWQgMD09PW4mJihuPW51bGwpLG5ldyBZZCh0LGUsbil9LHQuYWRhbWF4PWZ1bmN0aW9uKHQsZSxuLHIsbyl7cmV0dXJuIHZvaWQgMD09PXQmJih0PS4wMDIpLHZvaWQgMD09PWUmJihlPS45KSx2b2lkIDA9PT1uJiYobj0uOTk5KSx2b2lkIDA9PT1yJiYocj1udWxsKSx2b2lkIDA9PT1vJiYobz0wKSxuZXcgSmQodCxlLG4scixvKX0sdC5hZGFncmFkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPS4xKSxuZXcgJGQodCxlKX0sdH0oKSxycD17c2dkOm5wLnNnZCxtb21lbnR1bTpucC5tb21lbnR1bSxhZGFkZWx0YTpucC5hZGFkZWx0YSxhZGFncmFkOm5wLmFkYWdyYWQscm1zcHJvcDpucC5ybXNwcm9wLGFkYW1heDpucC5hZGFtYXgsYWRhbTpucC5hZGFtfSxvcD1cInVuZGVmaW5lZFwiIT10eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lP3JlcXVlc3RBbmltYXRpb25GcmFtZTpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2V0SW1tZWRpYXRlP3NldEltbWVkaWF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdCgpfTtmdW5jdGlvbiBhcCgpe3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7cmV0dXJuIG9wKChmdW5jdGlvbigpe3JldHVybiB0KCl9KSl9KSl9d3QucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4gT3IodGhpcyx0KX0sd3QucHJvdG90eXBlLmJyb2FkY2FzdFRvPWZ1bmN0aW9uKHQpe3JldHVybiBmYyh0aGlzLHQpfSx3dC5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKHQpe3JldHVybiBCbyh0aGlzLHQpfSx3dC5wcm90b3R5cGUuZGl2Tm9OYW49ZnVuY3Rpb24odCl7cmV0dXJuIGJjKHRoaXMsdCl9LHd0LnByb3RvdHlwZS5zcXVhcmVkRGlmZmVyZW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gSGModGhpcyx0KX0sd3QucHJvdG90eXBlLnRpbGU9ZnVuY3Rpb24odCl7cmV0dXJuIHdjKHRoaXMsdCl9LHd0LnByb3RvdHlwZS5vbmVIb3Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB2b2lkIDA9PT1lJiYoZT0xKSx2b2lkIDA9PT1uJiYobj0wKSxSYyh0aGlzLHQsZSxuKX0sd3QucHJvdG90eXBlLnRyYW5zcG9zZT1mdW5jdGlvbih0KXtyZXR1cm4gdWEodGhpcyx0KX0sd3QucHJvdG90eXBlLnBhZD1mdW5jdGlvbih0LGUpe3JldHVybiBJYyh0aGlzLHQsZSl9LHd0LnByb3RvdHlwZS5iYXRjaE5vcm09ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gbmModGhpcyx0LGUsbixyLG8pfSx4dD1mZjtleHBvcnR7WWQgYXMgQWRhZGVsdGFPcHRpbWl6ZXIsJGQgYXMgQWRhZ3JhZE9wdGltaXplcixRZCBhcyBBZGFtT3B0aW1pemVyLEpkIGFzIEFkYW1heE9wdGltaXplcix4ciBhcyBBZGQsYnIgYXMgQWRkTixTciBhcyBCcm9hZGNhc3RUbyxjYSBhcyBEYXRhU3RvcmFnZSx3ciBhcyBEaXYscyBhcyBFTlYsbyBhcyBFbnZpcm9ubWVudCxGciBhcyBGcm9tUGl4ZWxzLENyIGFzIEZ1c2VkQmF0Y2hOb3JtLFRyIGFzIElkZW50aXR5LGxhIGFzIEtlcm5lbEJhY2tlbmQsX3IgYXMgTWF4UG9vbFdpdGhBcmdtYXgsdHAgYXMgTW9tZW50dW1PcHRpbWl6ZXIsa3IgYXMgTm9uTWF4U3VwcHJlc3Npb25WNSxBciBhcyBPbmVIb3QsWGQgYXMgT3B0aW1pemVyLE5yIGFzIFBhZFYyLGVwIGFzIFJNU1Byb3BPcHRpbWl6ZXIsQ3QgYXMgUmFuayxOaCBhcyBSZWR1Y3Rpb24sWmQgYXMgU0dET3B0aW1pemVyLFJyIGFzIFNxdWFyZSxFciBhcyBTcXVhcmVkRGlmZmVyZW5jZSx3dCBhcyBUZW5zb3IsbXQgYXMgVGVuc29yQnVmZmVyLERyIGFzIFRpbGUsSXIgYXMgVHJhbnNwb3NlLFN0IGFzIFZhcmlhYmxlLExyIGFzIGFicyxXciBhcyBhY29zLFVyIGFzIGFjb3NoLE9yIGFzIGFkZCwkdSBhcyBhZGROLHhvIGFzIGFkZFN0cmljdCxxbCBhcyBhbGwsS2wgYXMgYW55LGpsIGFzIGFyZ01heCxYbCBhcyBhcmdNaW4sVnIgYXMgYXNpbix6ciBhcyBhc2luaCxHciBhcyBhdGFuLGJvIGFzIGF0YW4yLEhyIGFzIGF0YW5oLE9sIGFzIGF2Z1Bvb2wsUGwgYXMgYXZnUG9vbDNkLGhuIGFzIGJhY2tlbmQsU2EgYXMgYmFja2VuZF91dGlsLGxoIGFzIGJhc2ljTFNUTUNlbGwsbmMgYXMgYmF0Y2hOb3JtLGFjIGFzIGJhdGNoTm9ybTJkLHVjIGFzIGJhdGNoTm9ybTNkLGhjIGFzIGJhdGNoTm9ybTRkLGVjIGFzIGJhdGNoTm9ybWFsaXphdGlvbixvYyBhcyBiYXRjaE5vcm1hbGl6YXRpb24yZCxzYyBhcyBiYXRjaE5vcm1hbGl6YXRpb24zZCxsYyBhcyBiYXRjaE5vcm1hbGl6YXRpb240ZCxyciBhcyBiYXRjaFRvU3BhY2VORCx1bCBhcyBib29sZWFuTWFza0FzeW5jLGZjIGFzIGJyb2FkY2FzdFRvLFZkIGFzIGJyb3dzZXIsZXIgYXMgYnVmZmVyLG9yIGFzIGNhc3QscXIgYXMgY2VpbCxLciBhcyBjbGlwQnlWYWx1ZSxkYyBhcyBjbG9uZSxUbiBhcyBjb21wbGV4LFluIGFzIGNvbmNhdCwkbiBhcyBjb25jYXQxZCxRbiBhcyBjb25jYXQyZCxKbiBhcyBjb25jYXQzZCxabiBhcyBjb25jYXQ0ZCxmbCBhcyBjb252MWQsZGwgYXMgY29udjJkLHdsIGFzIGNvbnYyZFRyYW5zcG9zZSxwbCBhcyBjb252M2QsQ2wgYXMgY29udjNkVHJhbnNwb3NlLGpyIGFzIGNvcyxYciBhcyBjb3NoLGFyIGFzIGN1bXN1bSxvYSBhcyBjdXN0b21HcmFkLFhlIGFzIGRlcHJlY2F0aW9uV2FybixpciBhcyBkZXB0aFRvU3BhY2UsbWwgYXMgZGVwdGh3aXNlQ29udjJkLEVoIGFzIGRpYWcsamUgYXMgZGlzYWJsZURlcHJlY2F0aW9uV2FybmluZ3MsdG4gYXMgZGlzcG9zZSxZZSBhcyBkaXNwb3NlVmFyaWFibGVzLEJvIGFzIGRpdixiYyBhcyBkaXZOb05hbix3byBhcyBkaXZTdHJpY3QsUmwgYXMgZG90LFJoIGFzIGRyb3BvdXQsbmggYXMgZWx1LEtlIGFzIGVuYWJsZURlYnVnTW9kZSxxZSBhcyBlbmFibGVQcm9kTW9kZSwkZSBhcyBlbmdpbmUsaSBhcyBlbnYsS2MgYXMgZXF1YWwsamMgYXMgZXF1YWxTdHJpY3QsWXIgYXMgZXJmLCRyIGFzIGV4cCxzciBhcyBleHBhbmREaW1zLFFyIGFzIGV4cG0xLENjIGFzIGV5ZSxnaCBhcyBmZnQsSG4gYXMgZmlsbCx1biBhcyBmaW5kQmFja2VuZCxjbiBhcyBmaW5kQmFja2VuZEZhY3RvcnksSnIgYXMgZmxvb3IsQ28gYXMgZmxvb3JEaXYsQWggYXMgZnJhbWUsaGYgYXMgZnVzZWQsaWwgYXMgZ2F0aGVyLENoIGFzIGdhdGhlck5ELExvIGFzIGdhdGhlcl91dGlsLGFuIGFzIGdldEJhY2tlbmQsaCBhcyBnZXRHcmFkaWVudCxsIGFzIGdldEtlcm5lbCxmIGFzIGdldEtlcm5lbHNGb3JCYWNrZW5kLFpvIGFzIGdyYWQsdGEgYXMgZ3JhZHMsWGMgYXMgZ3JlYXRlcixZYyBhcyBncmVhdGVyRXF1YWwsJGMgYXMgZ3JlYXRlckVxdWFsU3RyaWN0LFFjIGFzIGdyZWF0ZXJTdHJpY3QsU2ggYXMgaGFtbWluZ1dpbmRvdyxraCBhcyBoYW5uV2luZG93LG1oIGFzIGlmZnQsTm4gYXMgaW1hZyxuZiBhcyBpbWFnZSxGaCBhcyBpblRvcEtBc3luYyxCZCBhcyBpbyx4aCBhcyBpcmZmdCxsbyBhcyBpc0Zpbml0ZSxjbyBhcyBpc0luZix1byBhcyBpc05hTixlbiBhcyBrZWVwLHJoIGFzIGxlYWt5UmVsdSxKYyBhcyBsZXNzLFpjIGFzIGxlc3NFcXVhbCx0bCBhcyBsZXNzRXF1YWxTdHJpY3QsZWwgYXMgbGVzc1N0cmljdCxqaCBhcyBsaW5hbGcscW4gYXMgbGluc3BhY2UsdWggYXMgbG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24sWnIgYXMgbG9nLHRvIGFzIGxvZzFwLGVvIGFzIGxvZ1NpZ21vaWQsc2EgYXMgbG9nU29mdG1heCxZbCBhcyBsb2dTdW1FeHAscGMgYXMgbG9naWNhbEFuZCx2YyBhcyBsb2dpY2FsTm90LGdjIGFzIGxvZ2ljYWxPcixtYyBhcyBsb2dpY2FsWG9yLHpoIGFzIGxvc3NlcyxFbCBhcyBtYXRNdWwsV2QgYXMgbWF0aCwkbCBhcyBtYXgsX2wgYXMgbWF4UG9vbCxCbCBhcyBtYXhQb29sM2QsTGwgYXMgbWF4UG9vbFdpdGhBcmdtYXgsRW8gYXMgbWF4aW11bSxSbyBhcyBtYXhpbXVtU3RyaWN0LFFsIGFzIG1lYW4sUWUgYXMgbWVtb3J5LEpsIGFzIG1pbixJbyBhcyBtaW5pbXVtLGtvIGFzIG1pbmltdW1TdHJpY3QsU28gYXMgbW9kLEFvIGFzIG1vZFN0cmljdCxabCBhcyBtb21lbnRzLGZoIGFzIG1vdmluZ0F2ZXJhZ2UsVG8gYXMgbXVsLERvIGFzIG11bFN0cmljdCxoaCBhcyBtdWx0aVJOTkNlbGwsRWMgYXMgbXVsdGlub21pYWwsbm8gYXMgbmVnLGFwIGFzIG5leHRGcmFtZSxjaCBhcyBub3JtLG5sIGFzIG5vdEVxdWFsLHJsIGFzIG5vdEVxdWFsU3RyaWN0LFJjIGFzIG9uZUhvdCx6biBhcyBvbmVzLGpuIGFzIG9uZXNMaWtlLEFuIGFzIG9wLElsIGFzIG91dGVyUHJvZHVjdCxJYyBhcyBwYWQsa2MgYXMgcGFkMWQsU2MgYXMgcGFkMmQsQWMgYXMgcGFkM2QsVGMgYXMgcGFkNGQsTWwgYXMgcG9vbCxObyBhcyBwb3csRm8gYXMgcG93U3RyaWN0LG9oIGFzIHByZWx1LG5yIGFzIHByaW50LGVoIGFzIHByb2QsSmUgYXMgcHJvZmlsZSxEYyBhcyByYW5kLFVjIGFzIHJhbmRvbUdhbW1hLFZjIGFzIHJhbmRvbU5vcm1hbCx6YyBhcyByYW5kb21Vbmlmb3JtLEtuIGFzIHJhbmdlLG9uIGFzIHJlYWR5LERuIGFzIHJlYWwscm8gYXMgcmVjaXByb2NhbCxsbiBhcyByZWdpc3RlckJhY2tlbmQscCBhcyByZWdpc3RlckdyYWRpZW50LGQgYXMgcmVnaXN0ZXJLZXJuZWwsYWggYXMgcmVsdSxpaCBhcyByZWx1NixzbiBhcyByZW1vdmVCYWNrZW5kLHVyIGFzIHJlc2hhcGUsa2wgYXMgcmV2ZXJzZSxTbCBhcyByZXZlcnNlMWQsQWwgYXMgcmV2ZXJzZTJkLFRsIGFzIHJldmVyc2UzZCxEbCBhcyByZXZlcnNlNGQseWggYXMgcmZmdCxvbyBhcyByb3VuZCxhbyBhcyByc3FydCxPbiBhcyBzY2FsYXIsdmggYXMgc2NhdHRlck5ELEhvIGFzIHNjYXR0ZXJfdXRpbCxzaCBhcyBzZWx1LGJsIGFzIHNlcGFyYWJsZUNvbnYyZCxxZCBhcyBzZXJpYWxpemF0aW9uLHJuIGFzIHNldEJhY2tlbmQsZm4gYXMgc2V0UGxhdGZvcm0sZHIgYXMgc2V0ZGlmZjFkQXN5bmMsaW8gYXMgc2lnbW9pZCxzbyBhcyBzaWduLERoIGFzIHNpZ25hbCxobyBhcyBzaW4sZm8gYXMgc2luaCxXbCBhcyBzbGljZSxVbCBhcyBzbGljZTFkLFZsIGFzIHNsaWNlMmQsemwgYXMgc2xpY2UzZCxHbCBhcyBzbGljZTRkLEpvIGFzIHNsaWNlX3V0aWwsaWEgYXMgc29mdG1heCxwbyBhcyBzb2Z0cGx1cyxjciBhcyBzcGFjZVRvQmF0Y2hORCx3aCBhcyBzcGFyc2VUb0RlbnNlLGJoIGFzIHNwZWN0cmFsLHRyIGFzIHNwbGl0LHZvIGFzIHNxcnQsR2MgYXMgc3F1YXJlLEhjIGFzIHNxdWFyZWREaWZmZXJlbmNlLF9vIGFzIHNxdWFyZWREaWZmZXJlbmNlU3RyaWN0LGxyIGFzIHNxdWVlemUsaHIgYXMgc3RhY2ssZ28gYXMgc3RlcCxUaCBhcyBzdGZ0LGRoIGFzIHN0cmlkZWRTbGljZSxPbyBhcyBzdWIsTW8gYXMgc3ViU3RyaWN0LHRoIGFzIHN1bSxEdCBhcyBzdW1PdXRUeXBlLG1vIGFzIHRhbix5byBhcyB0YW5oLEZuIGFzIHRlbnNvcixNbiBhcyB0ZW5zb3IxZCxCbiBhcyB0ZW5zb3IyZCxQbiBhcyB0ZW5zb3IzZCxMbiBhcyB0ZW5zb3I0ZCxXbiBhcyB0ZW5zb3I1ZCxVbiBhcyB0ZW5zb3I2ZCxNdCBhcyB0ZW5zb3JfdXRpbCxCYyBhcyB0ZXN0X3V0aWwsWmUgYXMgdGlkeSx3YyBhcyB0aWxlLG5uIGFzIHRpbWUscGggYXMgdG9wayxycCBhcyB0cmFpbix1YSBhcyB0cmFuc3Bvc2UscWMgYXMgdHJ1bmNhdGVkTm9ybWFsLGcgYXMgdW5yZWdpc3RlckdyYWRpZW50LHYgYXMgdW5yZWdpc3Rlcktlcm5lbCxzbCBhcyB1bnNvcnRlZFNlZ21lbnRTdW0sZnIgYXMgdW5zdGFjayxzdCBhcyB1dGlsLGVhIGFzIHZhbHVlQW5kR3JhZCxuYSBhcyB2YWx1ZUFuZEdyYWRzLFZuIGFzIHZhcmlhYmxlLHJhIGFzIHZhcmlhYmxlR3JhZHMsS2QgYXMgdmVyc2lvbl9jb3JlLGpkIGFzIHdlYmdsLHljIGFzIHdoZXJlLHhjIGFzIHdoZXJlQXN5bmMsR24gYXMgemVyb3MsWG4gYXMgemVyb3NMaWtlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRmLWNvcmUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbInQiLCJlIiwibiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJoYXNPd25Qcm9wZXJ0eSIsInIiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImNyZWF0ZSIsIlByb21pc2UiLCJvIiwiYSIsImkiLCJ1IiwibmV4dCIsInMiLCJ0aHJvdyIsImRvbmUiLCJ2YWx1ZSIsInRoZW4iLCJhcHBseSIsImxhYmVsIiwic2VudCIsInRyeXMiLCJvcHMiLCJyZXR1cm4iLCJTeW1ib2wiLCJpdGVyYXRvciIsIlR5cGVFcnJvciIsImNhbGwiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiZ2xvYmFsIiwiZmxhZ3MiLCJmbGFnUmVnaXN0cnkiLCJ1cmxGbGFncyIsInBvcHVsYXRlVVJMRmxhZ3MiLCJzZXRQbGF0Zm9ybSIsInBsYXRmb3JtIiwiY29uc29sZSIsIndhcm4iLCJwbGF0Zm9ybU5hbWUiLCJyZWdpc3RlckZsYWciLCJldmFsdWF0aW9uRm4iLCJzZXRIb29rIiwic2V0IiwiZ2V0IiwiZXZhbHVhdGVGbGFnIiwiZ2V0TnVtYmVyIiwiZ2V0Qm9vbCIsImdldEZsYWdzIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiRXJyb3IiLCJzZXRGbGFncyIsImFzc2lnbiIsInJlc2V0IiwibG9jYXRpb24iLCJzZWFyY2giLCJyZXBsYWNlIiwiYXJndW1lbnRzIiwiam9pbiIsInRmanNmbGFncyIsInNwbGl0IiwiZm9yRWFjaCIsInRvTG93ZXJDYXNlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiTWFwIiwiYyIsImwiLCJtIiwiaCIsImYiLCJlbnRyaWVzIiwiZCIsImtlcm5lbE5hbWUiLCJiYWNrZW5kTmFtZSIsImhhcyIsInAiLCJ2IiwiZGVsZXRlIiwiZyIsInkiLCJNYXRoIiwicmFuZG9tIiwieCIsIm1heCIsIm1pbiIsImIiLCJ3IiwiQyIsIkUiLCJTIiwiUiIsIkkiLCJpc0FycmF5IiwiViIsImsiLCJBIiwiVCIsInRhbmgiLCJleHAiLCJEIiwiY2VpbCIsInNxcnQiLCJOIiwicmVwZWF0IiwiRiIsInNldFRpbWVvdXQiLCJfIiwic2xpY2UiLCJPIiwibWFwIiwiY29uY2F0IiwiZXZlcnkiLCJNIiwic29ydCIsIm5ld1NoYXBlIiwia2VwdERpbXMiLCJCIiwiRmxvYXQzMkFycmF5IiwiSW50MzJBcnJheSIsIlVpbnQ4QXJyYXkiLCJQIiwiTCIsImlzTmFOIiwiaXNGaW5pdGUiLCJXIiwiVSIsInoiLCJHIiwiSCIsIlN0cmluZyIsInEiLCJLIiwiaiIsIlgiLCJZIiwiJCIsIlEiLCJyb3VuZCIsIkoiLCJyZWR1Y2UiLCJaIiwidHQiLCJldCIsIm5vdyIsIm50IiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwicnQiLCJlbmNvZGUiLCJvdCIsImRlY29kZSIsImF0IiwiaXQiLCJmbG9vciIsInN0IiwiZnJlZXplIiwic2h1ZmZsZSIsImNsYW1wIiwibmVhcmVzdExhcmdlckV2ZW4iLCJzdW0iLCJyYW5kVW5pZm9ybSIsImRpc3RTcXVhcmVkIiwiYXNzZXJ0IiwiYXNzZXJ0U2hhcGVzTWF0Y2giLCJhc3NlcnROb25OdWxsIiwiZmxhdHRlbiIsInNpemVGcm9tU2hhcGUiLCJpc1NjYWxhclNoYXBlIiwiYXJyYXlzRXF1YWwiLCJpc0ludCIsInNpemVUb1NxdWFyaXNoU2hhcGUiLCJjcmVhdGVTaHVmZmxlZEluZGljZXMiLCJVaW50MzJBcnJheSIsInJpZ2h0UGFkIiwicmVwZWF0ZWRUcnkiLCJpbmZlckZyb21JbXBsaWNpdFNoYXBlIiwicGFyc2VBeGlzUGFyYW0iLCJzcXVlZXplU2hhcGUiLCJnZXRUeXBlZEFycmF5RnJvbURUeXBlIiwiZ2V0QXJyYXlGcm9tRFR5cGUiLCJjaGVja0NvbnZlcnNpb25Gb3JFcnJvcnMiLCJpc1ZhbGlkRHR5cGUiLCJoYXNFbmNvZGluZ0xvc3MiLCJpc1R5cGVkQXJyYXkiLCJieXRlc1BlckVsZW1lbnQiLCJieXRlc0Zyb21TdHJpbmdBcnJheSIsImlzU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNOdW1iZXIiLCJpbmZlckR0eXBlIiwiaXNGdW5jdGlvbiIsIm5lYXJlc3REaXZpc29yIiwiY29tcHV0ZVN0cmlkZXMiLCJ0b1R5cGVkQXJyYXkiLCJ0b05lc3RlZEFycmF5IiwibWFrZU9uZXNUeXBlZEFycmF5IiwibWFrZVplcm9zVHlwZWRBcnJheSIsImFzc2VydE5vbk5lZ2F0aXZlSW50ZWdlckRpbWVuc2lvbnMiLCJmZXRjaCIsImVuY29kZVN0cmluZyIsImRlY29kZVN0cmluZyIsImxvY1RvSW5kZXgiLCJpbmRleFRvTG9jIiwidXQiLCJiYWNrZW5kVGltZXIiLCJsb2dnZXIiLCJjdCIsInByb2ZpbGVLZXJuZWwiLCJ0aW1lIiwiZGF0YSIsImR0eXBlIiwiZ2V0RXh0cmFQcm9maWxlSW5mbyIsImxvZ0tlcm5lbFByb2ZpbGUiLCJrZXJuZWxNcyIsImVycm9yIiwicmFuayIsInNpemUiLCJzaGFwZSIsInRvU3RyaW5nIiwibG9nIiwibHQiLCJodCIsImZ0IiwiZHQiLCJmaWxsIiwiZ3QiLCJwdCIsInZ0IiwiZnJvbSIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwibXQiLCJ2YWx1ZXMiLCJzdHJpZGVzIiwidG9UZW5zb3IiLCJ5dCIsIm1ha2VUZW5zb3IiLCJ4dCIsImJ0Iiwid3QiLCJrZXB0IiwiaXNEaXNwb3NlZEludGVybmFsIiwiZGF0YUlkIiwiaWQiLCJyYW5rVHlwZSIsInRocm93SWZEaXNwb3NlZCIsImFzMUQiLCJhc1NjYWxhciIsInJlc2hhcGUiLCJhczJEIiwiYXMzRCIsImFzNEQiLCJhczVEIiwiYXNUeXBlIiwiY2FzdCIsImJ1ZmZlciIsImJ1ZmZlclN5bmMiLCJkYXRhU3luYyIsImFycmF5IiwiYXJyYXlTeW5jIiwicmVhZCIsInJlYWRTeW5jIiwiYnl0ZXMiLCJkaXNwb3NlIiwiaXNEaXNwb3NlZCIsImRpc3Bvc2VUZW5zb3IiLCJ0b0Zsb2F0IiwidG9JbnQiLCJ0b0Jvb2wiLCJwcmludCIsInJlc2hhcGVBcyIsImV4cGFuZERpbXMiLCJjdW1zdW0iLCJzcXVlZXplIiwiY2xvbmUiLCJnYXRoZXIiLCJtYXRNdWwiLCJkb3QiLCJub3JtIiwicmV2ZXJzZSIsInN0YWNrIiwidW5zdGFjayIsImJhdGNoTm9ybWFsaXphdGlvbiIsImJhdGNoTm9ybSIsImFsbCIsImFueSIsImxvZ1N1bUV4cCIsInByb2QiLCJtZWFuIiwiYXJnTWluIiwiYXJnTWF4IiwiYWRkU3RyaWN0IiwiYXRhbjIiLCJzdWIiLCJzdWJTdHJpY3QiLCJwb3ciLCJwb3dTdHJpY3QiLCJtdWwiLCJtdWxTdHJpY3QiLCJmbG9vckRpdiIsImRpdlN0cmljdCIsIm1pbmltdW0iLCJtaW5pbXVtU3RyaWN0IiwibWF4aW11bSIsIm1heGltdW1TdHJpY3QiLCJtb2QiLCJtb2RTdHJpY3QiLCJzcXVhcmVkRGlmZmVyZW5jZVN0cmljdCIsIm5vdEVxdWFsIiwibm90RXF1YWxTdHJpY3QiLCJsZXNzIiwibGVzc1N0cmljdCIsImVxdWFsIiwiZXF1YWxTdHJpY3QiLCJsZXNzRXF1YWwiLCJsZXNzRXF1YWxTdHJpY3QiLCJncmVhdGVyIiwiZ3JlYXRlclN0cmljdCIsImdyZWF0ZXJFcXVhbCIsImdyZWF0ZXJFcXVhbFN0cmljdCIsImxvZ2ljYWxBbmQiLCJsb2dpY2FsT3IiLCJsb2dpY2FsTm90IiwibG9naWNhbFhvciIsIndoZXJlIiwibmVnIiwic2lnbiIsImlzSW5mIiwiZXhwbTEiLCJsb2cxcCIsInJzcXJ0Iiwic3F1YXJlIiwicmVjaXByb2NhbCIsImFicyIsImNsaXBCeVZhbHVlIiwicmVsdSIsInJlbHU2IiwiZWx1Iiwic2VsdSIsImxlYWt5UmVsdSIsInByZWx1Iiwic2lnbW9pZCIsImxvZ1NpZ21vaWQiLCJzb2Z0cGx1cyIsInplcm9zTGlrZSIsIm9uZXNMaWtlIiwic2luIiwiY29zIiwidGFuIiwiYXNpbiIsImFjb3MiLCJhdGFuIiwic2luaCIsImNvc2giLCJhc2luaCIsImFjb3NoIiwiYXRhbmgiLCJlcmYiLCJzdGVwIiwic29mdG1heCIsImxvZ1NvZnRtYXgiLCJyZXNpemVCaWxpbmVhciIsImltYWdlIiwicmVzaXplTmVhcmVzdE5laWdoYm9yIiwiY29udjFkIiwiY29udjJkIiwiY29udjJkVHJhbnNwb3NlIiwiZGVwdGh3aXNlQ29udjJEIiwiZGVwdGh3aXNlQ29udjJkIiwic2VwYXJhYmxlQ29udjJkIiwiYXZnUG9vbCIsIm1heFBvb2wiLCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbiIsInBvb2wiLCJ2YXJpYWJsZSIsIm1ha2VWYXJpYWJsZSIsInVuc29ydGVkU2VnbWVudFN1bSIsImJhdGNoVG9TcGFjZU5EIiwic3BhY2VUb0JhdGNoTkQiLCJ0b3BrIiwic3RyaWRlZFNsaWNlIiwiZGVwdGhUb1NwYWNlIiwiZmZ0Iiwic3BlY3RyYWwiLCJpZmZ0IiwicmZmdCIsImlyZmZ0IiwiaGFzSW5zdGFuY2UiLCJDdCIsIkV0IiwiUnQiLCJJdCIsImt0IiwiU3QiLCJ0cmFpbmFibGUiLCJuYW1lIiwiaW5jUmVmIiwiZGlzcG9zZVZhcmlhYmxlIiwiRnVuY3Rpb24iLCJSMCIsIlIxIiwiUjIiLCJSMyIsIlI0IiwiUjUiLCJSNiIsImZsb2F0MzIiLCJpbnQzMiIsImJvb2wiLCJjb21wbGV4NjQiLCJBdCIsIlR0IiwiRHQiLCJOdCIsIkZ0IiwiX3QiLCJhZGQiLCJTZXQiLCJPdCIsIk10IiwibWFrZVR5cGVzTWF0Y2giLCJhc3NlcnRUeXBlc01hdGNoIiwiaXNUZW5zb3JJbkxpc3QiLCJzb21lIiwiZ2V0VGVuc29yc0luQ29udGFpbmVyIiwiQnQiLCJyZWdpc3RlcmVkVmFyaWFibGVzIiwibmV4dFRhcGVOb2RlSWQiLCJudW1CeXRlcyIsIm51bVRlbnNvcnMiLCJudW1TdHJpbmdUZW5zb3JzIiwibnVtRGF0YUJ1ZmZlcnMiLCJncmFkaWVudERlcHRoIiwia2VybmVsRGVwdGgiLCJzY29wZVN0YWNrIiwibnVtRGF0YU1vdmVzU3RhY2siLCJuZXh0U2NvcGVJZCIsInRlbnNvckluZm8iLCJXZWFrTWFwIiwicHJvZmlsaW5nIiwiYWN0aXZlUHJvZmlsZSIsIm5ld0J5dGVzIiwibmV3VGVuc29ycyIsInBlYWtCeXRlcyIsImtlcm5lbHMiLCJyZXN1bHQiLCJQdCIsIkVOViIsInJlZ2lzdHJ5IiwicmVnaXN0cnlGYWN0b3J5IiwicGVuZGluZ0JhY2tlbmRJbml0SWQiLCJzdGF0ZSIsInJlYWR5IiwicGVuZGluZ0JhY2tlbmRJbml0IiwiYmFja2VuZEluc3RhbmNlIiwiZ2V0U29ydGVkQmFja2VuZHMiLCJpbml0aWFsaXplQmFja2VuZCIsInN1Y2Nlc3MiLCJzZXRCYWNrZW5kIiwiaW5pdGlhbGl6ZUJhY2tlbmRzQW5kUmV0dXJuQmVzdCIsImFzeW5jSW5pdCIsImJhY2tlbmROYW1lcyIsImtleXMiLCJmaW5kQmFja2VuZCIsImZpbmRCYWNrZW5kRmFjdG9yeSIsImZhY3RvcnkiLCJyZWdpc3RlckJhY2tlbmQiLCJwcmlvcml0eSIsInNldHVwUmVnaXN0ZXJlZEtlcm5lbHMiLCJwcm9maWxlciIsInNldHVwRnVuYyIsImRpc3Bvc2VSZWdpc3RlcmVkS2VybmVscyIsImRpc3Bvc2VGdW5jIiwicmVzb2x2ZSIsImNhdGNoIiwibWVzc2FnZSIsInJlbW92ZUJhY2tlbmQiLCJtb3ZlRGF0YSIsImJhY2tlbmQiLCJkaXNwb3NlRGF0YSIsIm1vdmUiLCJzaG91bGRDaGVja0Zvck1lbUxlYWtzIiwidGlkeSIsInNjb3BlZFJ1biIsInN0YXJ0U2NvcGUiLCJlbmRTY29wZSIsIm5leHRUZW5zb3JJZCIsIm5leHRWYXJpYWJsZUlkIiwibWFrZVRlbnNvckZyb21EYXRhSWQiLCJhZGRUYXBlTm9kZSIsImFjdGl2ZVNjb3BlIiwicnVuS2VybmVsIiwicnVuS2VybmVsRnVuYyIsImNoZWNrS2VybmVsRm9yTWVtTGVhayIsIm51bURhdGFJZHMiLCJpc1RhcGVPbiIsImtlcm5lbEZ1bmMiLCJpbnB1dHMiLCJhdHRycyIsImdldFRlbnNvcnNGb3JHcmFkaWVudCIsImZpbHRlciIsInNhdmVUZW5zb3JzRm9yQmFja3dhcmRNb2RlIiwia2VlcCIsImJ5dGVzQWRkZWQiLCJ0b3RhbEJ5dGVzU25hcHNob3QiLCJ0ZW5zb3JzQWRkZWQiLCJ0b3RhbFRlbnNvcnNTbmFwc2hvdCIsImlucHV0U2hhcGVzIiwib3V0cHV0U2hhcGVzIiwiaW5wdXRzVG9TYXZlIiwib3V0cHV0c1RvU2F2ZSIsInNhdmVBbGxJbnB1dHMiLCJ3cml0ZSIsInJlZkNvdW50IiwidHJhY2siLCJkaXNwb3NlVmFyaWFibGVzIiwibWVtb3J5IiwidW5yZWxpYWJsZSIsInJlYXNvbnMiLCJwcm9maWxlIiwib3V0cHV0cyIsInNhdmVkIiwiZ3JhZEZ1bmMiLCJncmFkaWVudCIsImFjdGl2ZVRhcGUiLCJzdGFydFRhcGUiLCJlbmRUYXBlIiwic2NvcGVJZCIsImdyYWRpZW50cyIsIkx0IiwiZ3JhZHMiLCJjdXN0b21HcmFkIiwid2FsbE1zIiwid2luZG93IiwicHJvY2VzcyIsInNlbGYiLCJfdGZlbmdpbmUiLCJXdCIsImRvY3VtZW50IiwiV29ya2VyR2xvYmFsU2NvcGUiLCJVdCIsInZlcnNpb25zIiwibm9kZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRlc3QiLCJ2ZW5kb3IiLCJWdCIsInp0IiwiR3QiLCJIdCIsInF0IiwiYWxwaGEiLCJhbnRpYWxpYXMiLCJwcmVtdWx0aXBsaWVkQWxwaGEiLCJwcmVzZXJ2ZURyYXdpbmdCdWZmZXIiLCJkZXB0aCIsInN0ZW5jaWwiLCJmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0IiwiS3QiLCJqdCIsIk9mZnNjcmVlbkNhbnZhcyIsImNyZWF0ZUVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicHJldmVudERlZmF1bHQiLCJnZXRDb250ZXh0IiwiaXNDb250ZXh0TG9zdCIsImRpc2FibGUiLCJERVBUSF9URVNUIiwiU1RFTkNJTF9URVNUIiwiQkxFTkQiLCJESVRIRVIiLCJQT0xZR09OX09GRlNFVF9GSUxMIiwiU0FNUExFX0NPVkVSQUdFIiwiZW5hYmxlIiwiU0NJU1NPUl9URVNUIiwiQ1VMTF9GQUNFIiwiY3VsbEZhY2UiLCJCQUNLIiwiWHQiLCJZdCIsIiR0IiwiUXQiLCJSMzJGIiwiUjE2RiIsIlJHQkExNkYiLCJSR0JBMzJGIiwiUkVEIiwiSEFMRl9GTE9BVCIsIkZMT0FUIiwiUkdCQSIsIkhBTEZfRkxPQVRfT0VTIiwiaW50ZXJuYWxGb3JtYXRGbG9hdCIsImludGVybmFsRm9ybWF0SGFsZkZsb2F0IiwiaW50ZXJuYWxGb3JtYXRQYWNrZWRIYWxmRmxvYXQiLCJpbnRlcm5hbEZvcm1hdFBhY2tlZEZsb2F0IiwidGV4dHVyZUZvcm1hdEZsb2F0IiwiZG93bmxvYWRUZXh0dXJlRm9ybWF0IiwiZG93bmxvYWRVbnBhY2tOdW1DaGFubmVscyIsImRlZmF1bHROdW1DaGFubmVscyIsInRleHR1cmVUeXBlSGFsZkZsb2F0IiwidGV4dHVyZVR5cGVGbG9hdCIsIkp0IiwiZ2V0RXJyb3IiLCJOT19FUlJPUiIsIm5lIiwiREVOU0UiLCJTSEFSRURfQkFUQ0giLCJSRU5ERVIiLCJVUExPQUQiLCJQSVhFTFMiLCJET1dOTE9BRCIsIlVOUEFDS0VEX0ZMT0FUMTYiLCJVTlBBQ0tFRF9GTE9BVDMyIiwiUEFDS0VEXzRYMV9VTlNJR05FRF9CWVRFIiwiUEFDS0VEXzJYMl9GTE9BVDMyIiwiUEFDS0VEXzJYMl9GTE9BVDE2IiwiWnQiLCJ0ZSIsImVlIiwiSU5WQUxJRF9FTlVNIiwiSU5WQUxJRF9WQUxVRSIsIklOVkFMSURfT1BFUkFUSU9OIiwiSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04iLCJPVVRfT0ZfTUVNT1JZIiwiQ09OVEVYVF9MT1NUX1dFQkdMIiwicmUiLCJrZSIsImdldEV4dGVuc2lvbiIsIm9lIiwiY3JlYXRlU2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsInNoYWRlclNvdXJjZSIsImNvbXBpbGVTaGFkZXIiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImdldFNoYWRlckluZm9Mb2ciLCJhZSIsIkZSQUdNRU5UX1NIQURFUiIsInVlIiwiZXhlYyIsImllIiwic2UiLCJjZSIsImNyZWF0ZVByb2dyYW0iLCJsZSIsImxpbmtQcm9ncmFtIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwiZ2V0UHJvZ3JhbUluZm9Mb2ciLCJoZSIsInZhbGlkYXRlUHJvZ3JhbSIsIlZBTElEQVRFX1NUQVRVUyIsImZlIiwiY3JlYXRlQnVmZmVyIiwiYmluZEJ1ZmZlciIsIkFSUkFZX0JVRkZFUiIsImJ1ZmZlckRhdGEiLCJTVEFUSUNfRFJBVyIsImRlIiwiRUxFTUVOVF9BUlJBWV9CVUZGRVIiLCJwZSIsImNyZWF0ZVRleHR1cmUiLCJ2ZSIsImdlIiwiY3JlYXRlRnJhbWVidWZmZXIiLCJtZSIsImdldEF0dHJpYkxvY2F0aW9uIiwidmVydGV4QXR0cmliUG9pbnRlciIsImVuYWJsZVZlcnRleEF0dHJpYkFycmF5IiwieWUiLCJTZSIsImFjdGl2ZVRleHR1cmUiLCJURVhUVVJFMCIsImJpbmRUZXh0dXJlIiwiVEVYVFVSRV8yRCIsInhlIiwiZ2V0VW5pZm9ybUxvY2F0aW9uIiwiYmUiLCJ3ZSIsInVuaWZvcm0xaSIsIkNlIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsIkNPTE9SX0FUVEFDSE1FTlQwIiwiRWUiLCJSZSIsImNoZWNrRnJhbWVidWZmZXJTdGF0dXMiLCJGUkFNRUJVRkZFUl9DT01QTEVURSIsIkllIiwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UIiwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQiLCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlMiLCJGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRCIsIk1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTIiwiQWUiLCJUZSIsIkRlIiwiTmUiLCJGZSIsIl9lIiwiT2UiLCJnZXRQYXJhbWV0ZXIiLCJNQVhfVEVYVFVSRV9TSVpFIiwiTWUiLCJNQVhfVEVYVFVSRV9JTUFHRV9VTklUUyIsIkJlIiwiUGUiLCJMZSIsIldlIiwiVmUiLCJVZSIsInRleEltYWdlMkQiLCJkZWxldGVUZXh0dXJlIiwiZGVsZXRlRnJhbWVidWZmZXIiLCJ6ZSIsImZlbmNlU3luYyIsIkdlIiwiY2FsbEFuZENoZWNrIiwiY2FuQmVSZXByZXNlbnRlZCIsImdldFdlYkdMRXJyb3JNZXNzYWdlIiwiZ2V0RXh0ZW5zaW9uT3JUaHJvdyIsImNyZWF0ZVZlcnRleFNoYWRlciIsImNyZWF0ZUZyYWdtZW50U2hhZGVyIiwiY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyIiwiY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIiLCJnZXROdW1DaGFubmVscyIsInZhbGlkYXRlVGV4dHVyZVNpemUiLCJiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlIiwiYmluZFRleHR1cmVVbml0IiwidW5iaW5kVGV4dHVyZVVuaXQiLCJnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdyIsImdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb24iLCJiaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyIiwiYmluZENhbnZhc1RvRnJhbWVidWZmZXIiLCJ2aWV3cG9ydCIsImNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0Iiwic2Npc3NvciIsImJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyIiwidW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyIiwidmFsaWRhdGVGcmFtZWJ1ZmZlciIsImdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlIiwiZ2V0QmF0Y2hEaW0iLCJnZXRSb3dzQ29scyIsImdldFNoYXBlQXMzRCIsImdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUiLCJpc1Jlc2hhcGVGcmVlIiwiZ2V0V2ViR0xNYXhUZXh0dXJlU2l6ZSIsInJlc2V0TWF4VGV4dHVyZVNpemUiLCJyZXNldE1heFRleHR1cmVzSW5TaGFkZXIiLCJnZXRNYXhUZXh0dXJlc0luU2hhZGVyIiwiZ2V0V2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJWZXJzaW9uIiwiaGFzRXh0ZW5zaW9uIiwiaXNXZWJHTFZlcnNpb25FbmFibGVkIiwiaXNDYXBhYmxlT2ZSZW5kZXJpbmdUb0Zsb2F0VGV4dHVyZSIsImlzRG93bmxvYWRGbG9hdFRleHR1cmVFbmFibGVkIiwiaXNXZWJHTEZlbmNlRW5hYmxlZCIsIkhlIiwicWUiLCJLZSIsImplIiwiWGUiLCJZZSIsIiRlIiwiUWUiLCJKZSIsIlplIiwidG4iLCJlbiIsIm5uIiwicm4iLCJvbiIsImFuIiwic24iLCJ1biIsImNuIiwibG4iLCJobiIsImZuIiwiZG4iLCJwbiIsInZuIiwiZ24iLCJpbmRleE9mIiwibW4iLCJ5biIsInhuIiwiYm4iLCJ3biIsIkNuIiwiRW4iLCJSbiIsIkluIiwia24iLCJTbiIsIkFuIiwiZW5kc1dpdGgiLCJzdWJzdHJpbmciLCJvcGVyYSIsInN1YnN0ciIsIlRuIiwiY29tcGxleF8iLCJjb21wbGV4IiwiJHJlYWwiLCIkaW1hZyIsIkRuIiwicmVhbF8iLCJyZWFsIiwiJGlucHV0IiwiTm4iLCJpbWFnXyIsImltYWciLCJGbiIsIl9uIiwiT24iLCJNbiIsIkJuIiwiUG4iLCJMbiIsIlduIiwiVW4iLCJWbiIsInpuIiwiR24iLCJIbiIsInFuIiwibGluc3BhY2UiLCJLbiIsImpuIiwib25lc0xpa2VfIiwiWG4iLCJ6ZXJvc0xpa2VfIiwiWW4iLCJjb25jYXRfIiwiYXhpcyIsInRyIiwiJG4iLCJjb25jYXQxZF8iLCJRbiIsImNvbmNhdDJkXyIsIkpuIiwiY29uY2F0M2RfIiwiWm4iLCJjb25jYXQ0ZF8iLCJzcGxpdF8iLCIkeCIsImVyIiwibnIiLCJyciIsImJhdGNoVG9TcGFjZU5EXyIsIm9yIiwiY2FzdF8iLCJhciIsImN1bXN1bV8iLCJ0cmFuc3Bvc2UiLCJwZXJtdXRlZFgiLCJpciIsImRlcHRoVG9TcGFjZV8iLCJzciIsImV4cGFuZERpbXNfIiwic3BsaWNlIiwidXIiLCJyZXNoYXBlXyIsImNyIiwic3BhY2VUb0JhdGNoTkRfIiwibHIiLCJzcXVlZXplXyIsImhyIiwic3RhY2tfIiwiZnIiLCJ1bnN0YWNrXyIsImRyIiwicHIiLCJ2ciIsImdyIiwibXIiLCJ5ciIsInhyIiwiYnIiLCJ3ciIsIkNyIiwiRXIiLCJSciIsIklyIiwia3IiLCJTciIsIkFyIiwiVHIiLCJEciIsIk5yIiwiRnIiLCJfciIsIk9yIiwiYWRkXyIsIk1yIiwidW5zaGlmdCIsIkJyIiwiUHIiLCJMciIsImFic18iLCJjb21wbGV4QWJzIiwiV3IiLCJhY29zXyIsIlVyIiwiYWNvc2hfIiwiVnIiLCJhc2luXyIsInpyIiwiYXNpbmhfIiwiR3IiLCJhdGFuXyIsImRpdiIsIkhyIiwiYXRhbmhfIiwicXIiLCJjZWlsXyIsIktyIiwiY2xpcEJ5VmFsdWVfIiwiY2xpcCIsImpyIiwiY29zXyIsIlhyIiwiY29zaF8iLCJZciIsImVyZl8iLCJQSSIsIiRyIiwiZXhwXyIsIlFyIiwiZXhwbTFfIiwiSnIiLCJmbG9vcl8iLCJaciIsImxvZ18iLCJ0byIsImxvZzFwXyIsImVvIiwibG9nU2lnbW9pZF8iLCJubyIsIm5lZ18iLCJybyIsInJlY2lwcm9jYWxfIiwib28iLCJyb3VuZF8iLCJhbyIsInJzcXJ0XyIsImlvIiwic2lnbW9pZF8iLCJzbyIsInNpZ25fIiwidW8iLCJpc05hTl8iLCJjbyIsImlzSW5mXyIsImxvIiwiaXNGaW5pdGVfIiwiaG8iLCJzaW5fIiwiZm8iLCJzaW5oXyIsInBvIiwic29mdHBsdXNfIiwidm8iLCJzcXJ0XyIsImdvIiwic3RlcF8iLCJtbyIsInRhbl8iLCJ5byIsInRhbmhfIiwieG8iLCJhZGRTdHJpY3RfIiwiYm8iLCJhdGFuMl8iLCIkYSIsIiRiIiwid28iLCJkaXZTdHJpY3RfIiwiQ28iLCJmbG9vckRpdl8iLCJFbyIsIm1heGltdW1fIiwiUm8iLCJtYXhpbXVtU3RyaWN0XyIsIklvIiwibWluaW11bV8iLCJrbyIsIm1pbmltdW1TdHJpY3RfIiwiU28iLCJtb2RfIiwiQW8iLCJtb2RTdHJpY3RfIiwiVG8iLCJtdWxfIiwibXVsdGlwbHkiLCJEbyIsIm11bFN0cmljdF8iLCJObyIsInBvd18iLCJGbyIsInBvd1N0cmljdF8iLCJfbyIsInNxdWFyZWREaWZmZXJlbmNlU3RyaWN0XyIsInNxdWFyZWREaWZmZXJlbmNlIiwiT28iLCJzdWJfIiwic3VidHJhY3QiLCJNbyIsInN1YlN0cmljdF8iLCJCbyIsImRpdl8iLCJyZWFsRGl2aWRlIiwiUG8iLCJMbyIsInByZXBhcmVBbmRWYWxpZGF0ZSIsIldvIiwiVW8iLCJWbyIsInpvIiwiR28iLCJzbGljZVJhbmsiLCJudW1VcGRhdGVzIiwic2xpY2VTaXplIiwib3V0cHV0U2l6ZSIsIkhvIiwidmFsaWRhdGVVcGRhdGVTaGFwZSIsInZhbGlkYXRlSW5wdXQiLCJjYWxjdWxhdGVTaGFwZXMiLCJxbyIsIktvIiwiam8iLCJYbyIsIk1JTl9TQUZFX0lOVEVHRVIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiWW8iLCIkbyIsIlFvIiwiSm8iLCJhc3NlcnRQYXJhbXNWYWxpZCIsIm1hc2tUb0F4ZXMiLCJjb21wdXRlT3V0U2hhcGUiLCJzdGFydEZvckF4aXMiLCJzdG9wRm9yQXhpcyIsImlzU2xpY2VDb250aW5vdXMiLCJjb21wdXRlRmxhdE9mZnNldCIsIlpvIiwiYWEiLCJ0YSIsImVhIiwiZ3JhZCIsIm5hIiwicmEiLCJvYSIsImlhIiwic29mdG1heF8iLCJsb2dpdHMiLCJkaW0iLCJzYSIsImxvZ1NvZnRtYXhfIiwidWEiLCJ0cmFuc3Bvc2VfIiwicGVybSIsImNhIiwiZGF0YU1vdmVyIiwiZGF0YUlkc0NvdW50IiwibGEiLCJoYSIsImZsb2F0UHJlY2lzaW9uIiwiZXBzaWxvbiIsImJhdGNoTWF0TXVsIiwiZnVzZWRCYXRjaE1hdE11bCIsInRyYW5zcG9zZUEiLCJ0cmFuc3Bvc2VCIiwiYmlhcyIsImFjdGl2YXRpb24iLCJwcmVsdUFjdGl2YXRpb25XZWlnaHRzIiwiYWRkTiIsInNlbGVjdCIsImVsdURlciIsImludCIsImZ1c2VkQ29udjJkIiwiaW5wdXQiLCJjb252SW5mbyIsImNvbnYyZERlcklucHV0IiwiY29udjJkRGVyRmlsdGVyIiwiZnVzZWREZXB0aHdpc2VDb252MkQiLCJkZXB0aHdpc2VDb252MkREZXJJbnB1dCIsImRlcHRod2lzZUNvbnYyRERlckZpbHRlciIsImNvbnYzZCIsImNvbnYzZERlcklucHV0IiwiY29udjNkRGVyRmlsdGVyIiwibWF4UG9vbEJhY2twcm9wIiwiYXZnUG9vbEJhY2twcm9wIiwiYXZnUG9vbDNkIiwiYXZnUG9vbDNkQmFja3Byb3AiLCJtYXhQb29sM2QiLCJtYXhQb29sM2RCYWNrcHJvcCIsInRpbGUiLCJwYWQiLCJnYXRoZXJORCIsInNjYXR0ZXJORCIsInJlc2l6ZUJpbGluZWFyQmFja3Byb3AiLCJyZXNpemVOZWFyZXN0TmVpZ2hib3JCYWNrcHJvcCIsImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uNEQiLCJMUk5HcmFkIiwibXVsdGlub21pYWwiLCJvbmVIb3QiLCJub25NYXhTdXBwcmVzc2lvbiIsImNyb3BBbmRSZXNpemUiLCJzcGFyc2VUb0RlbnNlIiwiZGlhZyIsImZhIiwibWEiLCJwYSIsImRhIiwieWEiLCJ2YSIsInhhIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwidHlwZSIsImdhIiwiYmEiLCJwYWRJbmZvIiwib3V0SGVpZ2h0Iiwib3V0V2lkdGgiLCJiYXRjaFNpemUiLCJkYXRhRm9ybWF0IiwiaW5IZWlnaHQiLCJpbldpZHRoIiwiaW5DaGFubmVscyIsIm91dENoYW5uZWxzIiwic3RyaWRlSGVpZ2h0Iiwic3RyaWRlV2lkdGgiLCJmaWx0ZXJIZWlnaHQiLCJmaWx0ZXJXaWR0aCIsImVmZmVjdGl2ZUZpbHRlckhlaWdodCIsImVmZmVjdGl2ZUZpbHRlcldpZHRoIiwiZGlsYXRpb25IZWlnaHQiLCJkaWxhdGlvbldpZHRoIiwiaW5TaGFwZSIsIm91dFNoYXBlIiwiZmlsdGVyU2hhcGUiLCJmcm9udCIsImJhY2siLCJvdXREZXB0aCIsImluRGVwdGgiLCJzdHJpZGVEZXB0aCIsImZpbHRlckRlcHRoIiwiZWZmZWN0aXZlRmlsdGVyRGVwdGgiLCJkaWxhdGlvbkRlcHRoIiwid2EiLCJDYSIsIkVhIiwiUmEiLCJJYSIsImthIiwiU2EiLCJjYXN0VGVuc29yIiwicmVzaGFwZVRlbnNvciIsImxpbnNwYWNlSW1wbCIsInVwY2FzdFR5cGUiLCJheGVzQXJlSW5uZXJNb3N0RGltcyIsImNvbWJpbmVMb2NhdGlvbnMiLCJjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzIiwiZXhwYW5kU2hhcGVUb0tlZXBEaW0iLCJhc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyIsImdldEF4ZXNQZXJtdXRhdGlvbiIsImdldFVuZG9BeGVzUGVybXV0YXRpb24iLCJnZXRJbm5lck1vc3RBeGVzIiwiZ2V0QnJvYWRjYXN0RGltcyIsImdldFJlZHVjdGlvbkF4ZXMiLCJhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZSIsImFzc2VydFBhcmFtc0NvbnNpc3RlbnQiLCJjb21wdXRlUG9vbDJESW5mbyIsImNvbXB1dGVQb29sM0RJbmZvIiwiY29tcHV0ZUNvbnYyREluZm8iLCJjb21wdXRlQ29udjNESW5mbyIsImNvbXB1dGVEZWZhdWx0UGFkIiwidHVwbGVWYWx1ZXNBcmVPbmUiLCJlaXRoZXJTdHJpZGVzT3JEaWxhdGlvbnNBcmVPbmUiLCJjb252ZXJ0Q29udjJERGF0YUZvcm1hdCIsIlBBUkFMTEVMSVpFX1RIUkVTSE9MRCIsImNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZSIsIkFhIiwiVGEiLCJEYSIsIk5hIiwiRmEiLCJfYSIsIk9hIiwiQmEiLCJzZWxlY3RlZEluZGljZXMiLCJNYSIsIm51bVZhbGlkT3V0cHV0cyIsInNlbGVjdGVkU2NvcmVzIiwic2NvcmUiLCJib3hJbmRleCIsInN1cHByZXNzQmVnaW5JbmRleCIsIldhIiwiUGEiLCJMYSIsInN1YmFycmF5IiwiVWEiLCJWYSIsInphIiwiaW5kZXgiLCJHYSIsIkhhIiwib3V0cHV0U2hhcGUiLCJ2YXJpYWJsZU5hbWVzIiwidXNlckNvZGUiLCJxYSIsInBhY2tlZElucHV0cyIsInBhY2tlZE91dHB1dCIsIkthIiwid2luZG93U2l6ZSIsImluU2l6ZSIsImphIiwiWGEiLCJZYSIsInZlcnNpb24iLCJhdHRyaWJ1dGUiLCJ2YXJ5aW5nVnMiLCJ2YXJ5aW5nRnMiLCJ0ZXh0dXJlMkQiLCJvdXRwdXQiLCJkZWZpbmVPdXRwdXQiLCJkZWZpbmVTcGVjaWFsTmFOIiwiZGVmaW5lU3BlY2lhbEluZiIsImRlZmluZVJvdW5kIiwiUWEiLCJKYSIsIlphIiwic2hhcGVJbmZvIiwibG9naWNhbFNoYXBlIiwiaXNVbmlmb3JtIiwiZWkiLCJ0aSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwidWkiLCJ0ZXhTaGFwZSIsImZsYXRPZmZzZXQiLCJuaSIsInJpIiwib2kiLCJpc1BhY2tlZCIsImFpIiwiaWkiLCJzaSIsImNpIiwibGkiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJoaSIsImZpIiwiZGkiLCJwaSIsInZpIiwiZ2kiLCJtaSIsInlpIiwieGkiLCJiaSIsIndpIiwiQ2kiLCJFaSIsIlJpIiwiSWkiLCJraSIsIlNpIiwic3VwcG9ydHNCcm9hZGNhc3RpbmciLCJBaSIsImdldEN1c3RvbVNldHVwRnVuYyIsIm1pbkxvYyIsImdldFVuaWZvcm1Mb2NhdGlvbk5vVGhyb3ciLCJtYXhMb2MiLCJnbCIsInVuaWZvcm0xZiIsIlRpIiwiRGkiLCJOaSIsIkZpIiwiX2kiLCJPaSIsIk1pIiwiQmkiLCJQaSIsIkxpIiwiV2kiLCJVaSIsIlZpIiwiemkiLCJHaSIsIkhpIiwicWkiLCJLaSIsImppIiwib3V0UGFja2luZ1NjaGVtZSIsIlhpIiwiWWkiLCJibG9ja1NpemUiLCJnZXRIZWlnaHRDb29yZFN0cmluZyIsImdldFdpZHRoQ29vcmRTdHJpbmciLCJnZXREZXB0aENvb3JkU3RyaW5nIiwiZ2V0T3V0cHV0RGVwdGhTaXplIiwiZ2V0SW5wdXRTYW1wbGluZ1N0cmluZyIsIiRpIiwiUWkiLCJvdXRUZXhVc2FnZSIsIkppIiwiWmkiLCJ0cyIsImVzIiwibnMiLCJycyIsIm9zIiwidmFsdWVMb2MiLCJhcyIsImlzIiwic2xpY2VEaW0iLCJzcyIsInVzIiwiY3MiLCJVaW50MTZBcnJheSIsImxzIiwidGV4UGFyYW1ldGVyaSIsIlRFWFRVUkVfV1JBUF9TIiwiQ0xBTVBfVE9fRURHRSIsIlRFWFRVUkVfV1JBUF9UIiwiVEVYVFVSRV9NSU5fRklMVEVSIiwiTkVBUkVTVCIsIlRFWFRVUkVfTUFHX0ZJTFRFUiIsImhzIiwiZnMiLCJkcyIsIlVOU0lHTkVEX0JZVEUiLCJwcyIsInZzIiwiZ3MiLCJtcyIsInlzIiwieHMiLCJQSVhFTF9QQUNLX0JVRkZFUiIsIlNUUkVBTV9SRUFEIiwicmVhZFBpeGVscyIsImJzIiwiZ2V0QnVmZmVyU3ViRGF0YSIsIndzIiwiQ3MiLCJFcyIsIlJzIiwiY3JlYXRlVmVydGV4QnVmZmVyIiwiY3JlYXRlSW5kZXhCdWZmZXIiLCJjcmVhdGVGbG9hdDMyTWF0cml4VGV4dHVyZSIsImNyZWF0ZUZsb2F0MTZNYXRyaXhUZXh0dXJlIiwiY3JlYXRlVW5zaWduZWRCeXRlc01hdHJpeFRleHR1cmUiLCJjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlIiwiY3JlYXRlRmxvYXQxNlBhY2tlZE1hdHJpeFRleHR1cmUiLCJiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMiLCJ1cGxvYWREZW5zZU1hdHJpeFRvVGV4dHVyZSIsInVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSIsImNyZWF0ZUJ1ZmZlckZyb21PdXRwdXRUZXh0dXJlIiwiZG93bmxvYWRGbG9hdDMyTWF0cml4RnJvbUJ1ZmZlciIsImRvd25sb2FkQnl0ZUVuY29kZWRGbG9hdE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlIiwiZG93bmxvYWRQYWNrZWRNYXRyaXhGcm9tQnVmZmVyIiwiZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZSIsIklzIiwib3V0cHV0VGV4dHVyZSIsInByb2dyYW0iLCJkaXNwb3NlZCIsInZlcnRleEF0dHJzQXJlQm91bmQiLCJpdGVtc1RvUG9sbCIsInRleHR1cmVGbG9hdEV4dGVuc2lvbiIsImRlYnVnIiwidGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiIsImNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24iLCJjb2xvckJ1ZmZlckhhbGZGbG9hdEV4dGVuc2lvbiIsInZlcnRleEJ1ZmZlciIsImluZGV4QnVmZmVyIiwiZnJhbWVidWZmZXIiLCJ0ZXh0dXJlQ29uZmlnIiwiZmluaXNoIiwiZGVsZXRlQnVmZmVyIiwiZGVsZXRlTWF0cml4VGV4dHVyZSIsImRvd25sb2FkTWF0cml4RHJpdmVyIiwiY3JlYXRlQnVmZmVyRnJvbVRleHR1cmUiLCJiaW5kVGV4dHVyZVRvRnJhbWVCdWZmZXIiLCJ1bmJpbmRUZXh0dXJlVG9GcmFtZUJ1ZmZlciIsImNyZWF0ZUFuZFdhaXRGb3JGZW5jZSIsImNyZWF0ZUZlbmNlIiwicG9sbEZlbmNlIiwiU1lOQ19HUFVfQ09NTUFORFNfQ09NUExFVEUiLCJmbHVzaCIsImNsaWVudFdhaXRTeW5jIiwiQUxSRUFEWV9TSUdOQUxFRCIsIkNPTkRJVElPTl9TQVRJU0ZJRUQiLCJiZWdpblF1ZXJ5IiwiZW5kUXVlcnkiLCJpc1F1ZXJ5QXZhaWxhYmxlIiwicXVlcnkiLCJpc0ZlbmNlUGFzc2VkIiwiZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZSIsImF0dGFjaFNoYWRlciIsInNldFByb2dyYW0iLCJkZWxldGVQcm9ncmFtIiwidXNlUHJvZ3JhbSIsImdldEF0dHJpYnV0ZUxvY2F0aW9uIiwic2V0SW5wdXRNYXRyaXhUZXh0dXJlIiwidGhyb3dJZk5vUHJvZ3JhbSIsInNldE91dHB1dE1hdHJpeFRleHR1cmUiLCJzZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyIiwic2V0T3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSIsInNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uIiwic2V0T3V0cHV0TWF0cml4V3JpdGVSZWdpb25Ecml2ZXIiLCJzZXRPdXRwdXRQYWNrZWRNYXRyaXhXcml0ZVJlZ2lvbiIsImRlYnVnVmFsaWRhdGUiLCJleGVjdXRlUHJvZ3JhbSIsImRyYXdFbGVtZW50cyIsIlRSSUFOR0xFUyIsIlVOU0lHTkVEX1NIT1JUIiwiYmxvY2tVbnRpbEFsbFByb2dyYW1zQ29tcGxldGVkIiwiZ2V0UXVlcnlUaW1lckV4dGVuc2lvbiIsImRpc2pvaW50UXVlcnlUaW1lckV4dGVuc2lvbiIsImdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIiLCJnZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxIiwiY3JlYXRlUXVlcnkiLCJUSU1FX0VMQVBTRURfRVhUIiwiY3JlYXRlUXVlcnlFWFQiLCJiZWdpblF1ZXJ5RVhUIiwiZW5kUXVlcnlFWFQiLCJ3YWl0Rm9yUXVlcnlBbmRHZXRUaW1lIiwiZ2V0UXVlcnlUaW1lIiwiZ2V0UXVlcnlQYXJhbWV0ZXIiLCJRVUVSWV9SRVNVTFQiLCJnZXRRdWVyeU9iamVjdEVYVCIsIlFVRVJZX1JFU1VMVF9FWFQiLCJRVUVSWV9SRVNVTFRfQVZBSUxBQkxFIiwiZGlzam9pbnQiLCJHUFVfRElTSk9JTlRfRVhUIiwiUVVFUllfUkVTVUxUX0FWQUlMQUJMRV9FWFQiLCJhZGRJdGVtVG9Qb2xsIiwicG9sbEl0ZW1zIiwiaXNEb25lRm4iLCJyZXNvbHZlRm4iLCJrcyIsInRleERhdGEiLCJTcyIsIkFzIiwiVHMiLCJkZXB0aFJhZGl1cyIsImJldGEiLCJEcyIsIk5zIiwiRnMiLCJfcyIsIk9zIiwic2VlZExvYyIsIk1zIiwiQnMiLCJQcyIsIkxzIiwiV3MiLCJVcyIsIlZzIiwienMiLCJHcyIsIkhzIiwicXMiLCJLcyIsImpzIiwiWHMiLCJZcyIsIiRzIiwiUXMiLCJudW1TZWdtZW50cyIsIkpzIiwiWnMiLCJ0dSIsInN0YXJ0TG9jIiwidW5pZm9ybTFpdiIsImV1IiwibnUiLCJydSIsImdwZ3B1IiwibnVtVXNlZFRleHR1cmVzIiwibnVtRnJlZVRleHR1cmVzIiwiZnJlZVRleHR1cmVzIiwibG9nRW5hYmxlZCIsInVzZWRUZXh0dXJlcyIsImFjcXVpcmVUZXh0dXJlIiwib3UiLCJhdSIsInNoaWZ0IiwicmVsZWFzZVRleHR1cmUiLCJnZXROdW1Vc2VkVGV4dHVyZXMiLCJnZXROdW1GcmVlVGV4dHVyZXMiLCJpdSIsInN1IiwidXUiLCJjdSIsImx1IiwiaHUiLCJmdSIsImR1IiwicHUiLCJ2dSIsImd1IiwibXUiLCJ5dSIsInh1IiwiYnUiLCJ3dSIsIkN1IiwiRXUiLCJSdSIsIkl1Iiwia3UiLCJTdSIsIkF1IiwiVHUiLCJEdSIsIk51IiwiRnUiLCJfdSIsIk91IiwiTXUiLCJCdSIsIlB1IiwiTHUiLCJXdSIsIlV1IiwicGVuZGluZ1JlYWQiLCJwZW5kaW5nRGlzcG9zYWwiLCJXZWFrU2V0IiwiZGF0YVJlZkNvdW50IiwibnVtQnl0ZXNJbkdQVSIsInVwbG9hZFdhaXRNcyIsImRvd25sb2FkV2FpdE1zIiwid2FybmVkQWJvdXRNZW1vcnkiLCJwZW5kaW5nRGVsZXRlcyIsImJpbmFyeUNhY2hlIiwiZ3BncHVDcmVhdGVkTG9jYWxseSIsInRleHR1cmVNYW5hZ2VyIiwibnVtTUJCZWZvcmVXYXJuaW5nIiwic2NyZWVuIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNwdUJhY2tlbmQiLCJjaGVja051bWVyaWNhbFByb2JsZW1zIiwidXNhZ2UiLCJjb21wbGV4VGVuc29ycyIsInJ1bldlYkdMUHJvZ3JhbSIsImNvbnZlcnRBbmRDYWNoZU9uQ1BVIiwiYWN0aXZlVGltZXJzIiwiZ2V0VmFsdWVzRnJvbVRleHR1cmUiLCJ0ZXh0dXJlIiwicHJvZ3JhbVRpbWVyc1N0YWNrIiwic3RhcnRUaW1lciIsInN0YXJ0TXMiLCJlbmRNcyIsImVuZFRpbWVyIiwicmVsZWFzZUdQVURhdGEiLCJvcmlnRGF0YUlkIiwiY29tcHV0ZUJ5dGVzIiwiZ2V0VGV4dHVyZSIsInVwbG9hZFRvR1BVIiwiZ2V0RGF0YUluZm8iLCJnZXRDUFVCYWNrZW5kIiwic2hvdWxkRXhlY3V0ZU9uQ1BVIiwiZ2V0R1BHUFVDb250ZXh0IiwibWFrZU91dHB1dCIsImNvbXBpbGVBbmRSdW4iLCJzaGFsbG93U2xpY2UiLCJwYWNrZWRVbmFyeU9wIiwibWFrZUNvbXBsZXhDb21wb25lbnRUZW5zb3JJbmZvIiwicGFja2VkQmluYXJ5T3AiLCJhcmdSZWR1Y2UiLCJhcmdSZWR1Y2VQYWNrZWQiLCJzZWdPcENvbXB1dGUiLCJhcmdNaW5NYXhSZWR1Y2UiLCJjb21wbGV4U2VwYXJhYmxlQmluYXJ5T3AiLCJjb252MmRCeU1hdE11bCIsImNvbnYyZFdpdGhJbTJSb3ciLCJwYWNrZWRSZXNoYXBlIiwiZmZ0SW1wbCIsIm1ha2VUZW5zb3JJbmZvIiwidW5wYWNrVGVuc29yIiwicGFja1RlbnNvciIsInVuaWZvcm1WYWx1ZXMiLCJnZXRBbmRTYXZlQmluYXJ5Iiwic291cmNlIiwid2ViR0xQcm9ncmFtIiwidW5pZm9ybUxvY2F0aW9ucyIsImluU2hhcGVJbmZvcyIsIm91dFNoYXBlSW5mbyIsImluZkxvYyIsIm5hbkxvYyIsIk5hTiIsInVuaWZvcm0xZnYiLCJnZXRUZXh0dXJlTWFuYWdlciIsIkhUTUxDYW52YXNFbGVtZW50IiwicmVtb3ZlIiwiZmxvYXRQcmVjaXNpb25WYWx1ZSIsImdsb2JhbFRoaXMiLCJWdSIsImV4cG9ydHMiLCJ6dSIsImNoYXJDb2RlQXQiLCJzMCIsInMxIiwiczIiLCJkb3VibGUiLCJxdWljayIsImFtZCIsImFsZWEiLCJHdSIsInhvcjEyOCIsIkh1IiwieG9yd293IiwicXUiLCJEYXRlIiwieG9yc2hpZnQ3IiwiS3UiLCJ4b3I0MDk2IiwianUiLCJ0eWNoZWkiLCJYdSIsImVudHJvcHkiLCJyYW5kb21CeXRlcyIsImNyeXB0byIsIm1zQ3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwicGx1Z2lucyIsInBhc3MiLCJmcm9tQ2hhckNvZGUiLCJyZXF1aXJlIiwiWXUiLCIkdSIsImFkZE5fIiwiUXUiLCJKdSIsIlp1Iiwic2NhbGUiLCJvZmZzZXQiLCJ2YXJpYW5jZSIsInZhcmlhbmNlRXBzaWxvbiIsInRjIiwiZWMiLCJiYXRjaE5vcm1hbGl6YXRpb25fIiwibmMiLCJiYXRjaE5vcm1fIiwicmMiLCJvYyIsImJhdGNoTm9ybWFsaXphdGlvbjJkXyIsImFjIiwiYmF0Y2hOb3JtMmRfIiwiaWMiLCJzYyIsImJhdGNoTm9ybWFsaXphdGlvbjNkXyIsInVjIiwiYmF0Y2hOb3JtM2RfIiwiY2MiLCJsYyIsImJhdGNoTm9ybWFsaXphdGlvbjRkXyIsImhjIiwiYmF0Y2hOb3JtNGRfIiwiZmMiLCJicm9hZGNhc3RUb18iLCJpbnB1dFNoYXBlIiwiZGMiLCJjbG9uZV8iLCJwYyIsImxvZ2ljYWxBbmRfIiwidmMiLCJsb2dpY2FsTm90XyIsImdjIiwibG9naWNhbE9yXyIsIm1jIiwibG9naWNhbFhvcl8iLCJ5YyIsIndoZXJlXyIsIiRjb25kaXRpb24iLCJ4YyIsImJjIiwiZGl2Tm9OYW5fIiwid2MiLCJ0aWxlXyIsInJlcHMiLCJDYyIsImV5ZV8iLCJFYyIsIm11bHRpbm9taWFsXyIsImxvZ2l0czJEIiwiUmMiLCJvbmVIb3RfIiwiaW5kaWNlcyIsIm9uVmFsdWUiLCJvZmZWYWx1ZSIsIkljIiwicGFkXyIsInBhZGRpbmdzIiwiY29uc3RhbnRWYWx1ZSIsImtjIiwicGFkMWRfIiwiU2MiLCJwYWQyZF8iLCJBYyIsInBhZDNkXyIsIlRjIiwicGFkNGRfIiwiRGMiLCJyYW5kXyIsIk5jIiwiRmMiLCJfYyIsIk9jIiwiTWMiLCJCYyIsIlRFU1RfRVBTSUxPTl9GTE9BVDE2IiwiZXhwZWN0QXJyYXlzQ2xvc2UiLCJ0ZXN0RXBzaWxvbiIsImV4cGVjdFByb21pc2VUb0ZhaWwiLCJmYWlsIiwiZXhwZWN0QXJyYXlzRXF1YWwiLCJleHBlY3ROdW1iZXJzQ2xvc2UiLCJleHBlY3RWYWx1ZXNJblJhbmdlIiwiZXhwZWN0QXJyYXlCdWZmZXJzRXF1YWwiLCJleHBlY3QiLCJ0b0VxdWFsIiwiUGMiLCJzdGREZXYiLCJuZXh0VmFsIiwidHJ1bmNhdGVkIiwidXBwZXIiLCJsb3dlciIsIm5leHRWYWx1ZSIsImlzVmFsaWRUcnVuY2F0ZWQiLCJjb252ZXJ0VmFsdWUiLCJMYyIsInJhbmR1IiwicmFuZG4iLCJXYyIsImNhblJldHVybkZsb2F0IiwicmFuZ2UiLCJVYyIsInJhbmRvbUdhbW1hXyIsIlZjIiwicmFuZG9tTm9ybWFsXyIsInpjIiwicmFuZG9tVW5pZm9ybV8iLCJHYyIsInNxdWFyZV8iLCJIYyIsInNxdWFyZWREaWZmZXJlbmNlXyIsInFjIiwidHJ1bmNhdGVkTm9ybWFsXyIsIktjIiwiZXF1YWxfIiwiamMiLCJlcXVhbFN0cmljdF8iLCJYYyIsImdyZWF0ZXJfIiwiWWMiLCJncmVhdGVyRXF1YWxfIiwiJGMiLCJncmVhdGVyRXF1YWxTdHJpY3RfIiwiUWMiLCJncmVhdGVyU3RyaWN0XyIsIkpjIiwibGVzc18iLCJaYyIsImxlc3NFcXVhbF8iLCJ0bCIsImxlc3NFcXVhbFN0cmljdF8iLCJlbCIsImxlc3NTdHJpY3RfIiwibmwiLCJub3RFcXVhbF8iLCJybCIsIm5vdEVxdWFsU3RyaWN0XyIsIm9sIiwiYWwiLCJpbCIsImdhdGhlcl8iLCJkaW1TaXplIiwic2wiLCJ1bnNvcnRlZFNlZ21lbnRTdW1fIiwidWwiLCJjbCIsImR5NEQiLCJkbCIsInZsIiwibGwiLCJobCIsImR5NUQiLCJmbCIsImNvbnYxZF8iLCJjb252MmRfIiwicGwiLCJjb252M2RfIiwiJGZpbHRlciIsIng1RCIsImNvbnYyZERlckZpbHRlcl8iLCJ4NEQiLCJjb252MmREZXJJbnB1dF8iLCJtbCIsImRlcHRod2lzZUNvbnYyZF8iLCJ5bCIsInhsIiwiZGVwdGh3aXNlQ29udjJkRGVySW5wdXRfIiwiZGVwdGh3aXNlQ29udjJkRGVyRmlsdGVyXyIsImJsIiwic2VwYXJhYmxlQ29udjJkXyIsIndsIiwiY29udjJkVHJhbnNwb3NlXyIsIkNsIiwiY29udjNkVHJhbnNwb3NlXyIsIkVsIiwibWF0TXVsXyIsIlJsIiwiZG90XyIsIklsIiwib3V0ZXJQcm9kdWN0XyIsImtsIiwicmV2ZXJzZV8iLCJTbCIsInJldmVyc2UxZF8iLCJBbCIsInJldmVyc2UyZF8iLCJUbCIsInJldmVyc2UzZF8iLCJEbCIsInJldmVyc2U0ZF8iLCJObCIsIiRkeSIsIkZsIiwiaW5wdXQ0RCIsIl9sIiwibWF4UG9vbF8iLCJPbCIsImF2Z1Bvb2xfIiwiTWwiLCJwb29sXyIsIkJsIiwibWF4UG9vbDNkXyIsImlucHV0NUQiLCJQbCIsImF2Z1Bvb2wzZF8iLCJMbCIsIm1heFBvb2xXaXRoQXJnbWF4XyIsImZpbHRlclNpemUiLCJpbmNsdWRlQmF0Y2hJbkluZGV4IiwiaW5kZXhlcyIsIldsIiwic2xpY2VfIiwiYmVnaW4iLCJVbCIsInNsaWNlMWRfIiwiVmwiLCJzbGljZTJkXyIsInpsIiwic2xpY2UzZF8iLCJHbCIsInNsaWNlNGRfIiwiSGwiLCJxbCIsImFsbF8iLCJLbCIsImFueV8iLCJqbCIsImFyZ01heF8iLCJYbCIsImFyZ01pbl8iLCJZbCIsImxvZ1N1bUV4cF8iLCIkbCIsIm1heF8iLCJheGVzIiwiUWwiLCJtZWFuXyIsIkpsIiwibWluXyIsIlpsIiwibW9tZW50c18iLCJ0aCIsInN1bV8iLCJlaCIsInByb2RfIiwibmgiLCJlbHVfIiwiZHkiLCJyaCIsImxlYWt5UmVsdV8iLCJvaCIsInByZWx1XyIsImFoIiwicmVsdV8iLCJpaCIsInJlbHU2XyIsInNoIiwic2VsdV8iLCJ1aCIsImxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uXyIsImNoIiwibm9ybV8iLCJsaCIsImJhc2ljTFNUTUNlbGxfIiwiaGgiLCJtdWx0aVJOTkNlbGxfIiwiZmgiLCJtb3ZpbmdBdmVyYWdlXyIsImRoIiwic3RyaWRlZFNsaWNlXyIsInBoIiwidG9wa18iLCJ2aCIsInNjYXR0ZXJORF8iLCJ1cGRhdGVzIiwiZ2giLCJmZnRfIiwibWgiLCJpZmZ0XyIsInloIiwicmZmdF8iLCJ4aCIsImlyZmZ0XyIsImJoIiwid2giLCJzcGFyc2VUb0RlbnNlXyIsIiRzcGFyc2VJbmRpY2VzIiwiJHNwYXJzZVZhbHVlcyIsIiRkZWZhdWx0VmFsdWUiLCJDaCIsImdhdGhlck5EXyIsIkVoIiwiZGlhZ18iLCJSaCIsImRyb3BvdXRfIiwiSWgiLCJraCIsImhhbm5XaW5kb3dfIiwiU2giLCJoYW1taW5nV2luZG93XyIsIkFoIiwiZnJhbWVfIiwiVGgiLCJzdGZ0XyIsIkRoIiwiaGFubldpbmRvdyIsImhhbW1pbmdXaW5kb3ciLCJmcmFtZSIsInN0ZnQiLCJOaCIsIkZoIiwiTk9ORSIsIk1FQU4iLCJTVU0iLCJTVU1fQllfTk9OWkVST19XRUlHSFRTIiwiX2giLCJhYnNvbHV0ZURpZmZlcmVuY2VfIiwiT2giLCJjb21wdXRlV2VpZ2h0ZWRMb3NzXyIsIk1oIiwiY29zaW5lRGlzdGFuY2VfIiwiQmgiLCJoaW5nZUxvc3NfIiwiUGgiLCJodWJlckxvc3NfIiwiTGgiLCJsb2dMb3NzXyIsIldoIiwibWVhblNxdWFyZWRFcnJvcl8iLCJVaCIsInNpZ21vaWRDcm9zc0VudHJvcHlfIiwiVmgiLCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XyIsInpoIiwiUmVkdWN0aW9uIiwiYWJzb2x1dGVEaWZmZXJlbmNlIiwiY29tcHV0ZVdlaWdodGVkTG9zcyIsImNvc2luZURpc3RhbmNlIiwiaGluZ2VMb3NzIiwiaHViZXJMb3NzIiwibG9nTG9zcyIsIm1lYW5TcXVhcmVkRXJyb3IiLCJzaWdtb2lkQ3Jvc3NFbnRyb3B5Iiwic29mdG1heENyb3NzRW50cm9weSIsIkdoIiwiSGgiLCJiYW5kUGFydF8iLCJxaCIsImdyYW1TY2htaWR0XyIsIktoIiwicXJfIiwiamgiLCJiYW5kUGFydCIsImdyYW1TY2htaWR0IiwiWGgiLCJORUdBVElWRV9JTkZJTklUWSIsIm1heE91dHB1dFNpemUiLCJpb3VUaHJlc2hvbGQiLCJzY29yZVRocmVzaG9sZCIsInNvZnRObXNTaWdtYSIsIlloIiwicmVzaXplQmlsaW5lYXJfIiwiYWxpZ25Db3JuZXJzIiwibmV3SGVpZ2h0IiwibmV3V2lkdGgiLCIkaCIsInJlc2l6ZU5lYXJlc3ROZWlnaGJvcl8iLCJiYXRjaEltYWdlcyIsIlFoIiwibm9uTWF4U3VwcHJlc3Npb25fIiwiYm94ZXMiLCJzY29yZXMiLCJKaCIsIlpoIiwibm9uTWF4U3VwcHJlc3Npb25XaXRoU2NvcmVfIiwidGYiLCJlZiIsImNyb3BBbmRSZXNpemVfIiwiaW1hZ2VzIiwiYm94SW5kIiwibWV0aG9kIiwiZXh0cmFwb2xhdGlvblZhbHVlIiwiY3JvcFNpemUiLCJuZiIsIm5vbk1heFN1cHByZXNzaW9uQXN5bmMiLCJub25NYXhTdXBwcmVzc2lvbldpdGhTY29yZSIsIm5vbk1heFN1cHByZXNzaW9uV2l0aFNjb3JlQXN5bmMiLCJyZiIsIm9mIiwiYWYiLCJzZiIsInVmIiwiZnVzZWRNYXRNdWxfIiwiY2YiLCJmdXNlZENvbnYyZF8iLCJkaWxhdGlvbnMiLCJkaW1Sb3VuZGluZ01vZGUiLCJsZiIsImZ1c2VkRGVwdGh3aXNlQ29udjJkXyIsImhmIiwiZmYiLCJsaW5hbGciLCJsb3NzZXMiLCJmdXNlZCIsInNpZ25hbCIsImJhdGNoTm9ybTJkIiwiYmF0Y2hOb3JtYWxpemF0aW9uMmQiLCJiYXRjaE5vcm0zZCIsImJhdGNoTm9ybWFsaXphdGlvbjNkIiwiYmF0Y2hOb3JtNGQiLCJiYXRjaE5vcm1hbGl6YXRpb240ZCIsImJyb2FkY2FzdFRvIiwiZGl2Tm9OYW4iLCJleWUiLCJwYWQxZCIsInBhZDJkIiwicGFkM2QiLCJwYWQ0ZCIsInJhbmQiLCJyYW5kb21HYW1tYSIsInJhbmRvbU5vcm1hbCIsInJhbmRvbVVuaWZvcm0iLCJ0cnVuY2F0ZWROb3JtYWwiLCJjb252M2RUcmFuc3Bvc2UiLCJvcCIsImJvb2xlYW5NYXNrQXN5bmMiLCJjb25jYXQxZCIsImNvbmNhdDJkIiwiY29uY2F0M2QiLCJjb25jYXQ0ZCIsIm91dGVyUHJvZHVjdCIsInJldmVyc2UxZCIsInJldmVyc2UyZCIsInJldmVyc2UzZCIsInJldmVyc2U0ZCIsIm1heFBvb2xXaXRoQXJnbWF4Iiwic2xpY2UxZCIsInNsaWNlMmQiLCJzbGljZTNkIiwic2xpY2U0ZCIsIm1vbWVudHMiLCJ3aGVyZUFzeW5jIiwic2V0ZGlmZjFkQXN5bmMiLCJvbmVzIiwic2NhbGFyIiwidGVuc29yIiwidGVuc29yMWQiLCJ0ZW5zb3IyZCIsInRlbnNvcjNkIiwidGVuc29yNGQiLCJ0ZW5zb3I1ZCIsInRlbnNvcjZkIiwiemVyb3MiLCJiYXNpY0xTVE1DZWxsIiwibXVsdGlSTk5DZWxsIiwibW92aW5nQXZlcmFnZSIsImRyb3BvdXQiLCJpblRvcEtBc3luYyIsImRmIiwicGYiLCJQT1NJVElWRV9JTkZJTklUWSIsInZmIiwiZ2YiLCJsaW5lYXIiLCJtZiIsImZpcnN0VXNlIiwiYnJvYWRjYXN0ZWRCaW5hcnlDb21wbGV4T3AiLCJicm9hZGNhc3RlZEJpbmFyeU9wIiwiaHlwb3QiLCJ0cnVuYyIsInBvb2wzZCIsIm1heFBvb2wzZFBvc2l0aW9ucyIsImZmdEJhdGNoIiwiaXNFeHBvbmVudE9mMiIsImZmdFJhZGl4MiIsImZvdXJpZXJUcmFuc2Zvcm1CeU1hdG11bCIsInNjYXR0ZXIiLCJ5ZiIsInhmIiwiYmYiLCJ3ZiIsIkNmIiwiRWYiLCJSZiIsIklmIiwia2YiLCJTZiIsIkFmIiwiVGYiLCJEZiIsIk5mIiwiRmYiLCJfZiIsIk9mIiwiTWYiLCJwaXhlbHMiLCJudW1DaGFubmVscyIsIkhUTUxWaWRlb0VsZW1lbnQiLCJIVE1MSW1hZ2VFbGVtZW50IiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiZHJhd0ltYWdlIiwiQmYiLCJQZiIsIkxmIiwicGVyZm9ybWFuY2UiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwiVGV4dERlY29kZXIiLCJXZiIsIlVmIiwiVmYiLCJ1dGlsIiwiaHJ0aW1lIiwiemYiLCJ1aW50MTYiLCJ1aW50OCIsIkdmIiwiSGYiLCJxdWFudGl6YXRpb24iLCJxZiIsImJ5dGVMZW5ndGgiLCJLZiIsIkJ1ZmZlciIsIkJsb2IiLCJhdG9iIiwiYnRvYSIsImpmIiwiWGYiLCJZZiIsInRyaW0iLCIkZiIsIm1vZGVsVG9wb2xvZ3kiLCJBcnJheUJ1ZmZlciIsImRhdGVTYXZlZCIsIm1vZGVsVG9wb2xvZ3lUeXBlIiwibW9kZWxUb3BvbG9neUJ5dGVzIiwid2VpZ2h0U3BlY3NCeXRlcyIsIndlaWdodFNwZWNzIiwid2VpZ2h0RGF0YUJ5dGVzIiwid2VpZ2h0RGF0YSIsIlFmIiwic2F2ZVJvdXRlcnMiLCJsb2FkUm91dGVycyIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJyZWdpc3RlclNhdmVSb3V0ZXIiLCJyZWdpc3RlckxvYWRSb3V0ZXIiLCJnZXRTYXZlSGFuZGxlcnMiLCJnZXRIYW5kbGVycyIsImdldExvYWRIYW5kbGVycyIsIkpmIiwiWmYiLCJtYW5hZ2VycyIsInJlZ2lzdGVyTWFuYWdlciIsImdldE1hbmFnZXIiLCJnZXRTY2hlbWVzIiwidGQiLCJzY2hlbWUiLCJwYXRoIiwiZWQiLCJsb2FkIiwicmVtb3ZlTW9kZWwiLCJzYXZlIiwibW9kZWxBcnRpZmFjdHNJbmZvIiwibmQiLCJyZCIsIm9kIiwiaW5kZXhlZERCIiwibW96SW5kZXhlZERCIiwid2Via2l0SW5kZXhlZERCIiwibXNJbmRleGVkREIiLCJzaGltSW5kZXhlZERCIiwiYWQiLCJjcmVhdGVPYmplY3RTdG9yZSIsImtleVBhdGgiLCJtb2RlbFBhdGgiLCJkYXRhYmFzZUFjdGlvbiIsIm9wZW4iLCJvbnVwZ3JhZGVuZWVkZWQiLCJvbnN1Y2Nlc3MiLCJ0cmFuc2FjdGlvbiIsIm9iamVjdFN0b3JlIiwiY2xvc2UiLCJtb2RlbEFydGlmYWN0cyIsIm9uZXJyb3IiLCJvbmNvbXBsZXRlIiwicHV0IiwiVVJMX1NDSEVNRSIsInNkIiwic3RhcnRzV2l0aCIsInVkIiwibGlzdE1vZGVscyIsImdldEFsbCIsImNkIiwibGQiLCJoZCIsImZkIiwiZGQiLCJwZCIsInZkIiwiZ2QiLCJpbmZvIiwidG9wb2xvZ3kiLCJtb2RlbE1ldGFkYXRhIiwibWQiLCJ5ZCIsImxvY2FsU3RvcmFnZSIsIkxTIiwic2V0SXRlbSIsImZvcm1hdCIsImdlbmVyYXRlZEJ5IiwiY29udmVydGVkQnkiLCJ1c2VyRGVmaW5lZE1ldGFkYXRhIiwicmVtb3ZlSXRlbSIsImdldEl0ZW0iLCJieXRlT2Zmc2V0IiwieGQiLCJiZCIsImtleSIsIndkIiwiQ2QiLCJFZCIsIlJkIiwiSWQiLCJtb2RlbFRvcG9sb2d5RmlsZU5hbWUiLCJ3ZWlnaHREYXRhRmlsZU5hbWUiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJwYXRocyIsIndlaWdodHMiLCJ3ZWlnaHRzTWFuaWZlc3QiLCJqc29uQW5jaG9yIiwiZG93bmxvYWQiLCJocmVmIiwiZGlzcGF0Y2hFdmVudCIsIk1vdXNlRXZlbnQiLCJ3ZWlnaHREYXRhQW5jaG9yIiwia2QiLCJmaWxlcyIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJ0YXJnZXQiLCJjaGVja01hbmlmZXN0QW5kV2VpZ2h0RmlsZXMiLCJyZWFkQXNBcnJheUJ1ZmZlciIsInJlYWRBc1RleHQiLCJTZCIsIkFkIiwiZmV0Y2hGdW5jIiwicmVxdWVzdEluaXQiLCJpc0JpbmFyeSIsIm9uUHJvZ3Jlc3MiLCJhcnJheUJ1ZmZlciIsIlRkIiwibWFuaWZlc3RFbnRyeSIsImdyb3VwT2Zmc2V0Iiwic2l6ZUJ5dGVzIiwiRGQiLCJERUZBVUxUX01FVEhPRCIsIndlaWdodFBhdGhQcmVmaXgiLCJib2R5IiwiRm9ybURhdGEiLCJhcHBlbmQiLCJvayIsInJlc3BvbnNlcyIsInN0YXR1cyIsImpzb24iLCJsb2FkV2VpZ2h0cyIsImxhc3RJbmRleE9mIiwiVVJMX1NDSEVNRV9SRUdFWCIsIk5kIiwibWF0Y2giLCJGZCIsIl9kIiwiT2QiLCJNZCIsInNhdmVIYW5kbGVyIiwiQmQiLCJicm93c2VyRmlsZXMiLCJicm93c2VySFRUUFJlcXVlc3QiLCJjb25jYXRlbmF0ZUFycmF5QnVmZmVycyIsImRlY29kZVdlaWdodHMiLCJlbmNvZGVXZWlnaHRzIiwiZ3JvdXAiLCJzcGVjcyIsImZyb21NZW1vcnkiLCJ0cmFpbmluZ0NvbmZpZyIsImdldE1vZGVsQXJ0aWZhY3RzSW5mb0ZvckpTT04iLCJodHRwIiwiaXNIVFRQU2NoZW1lIiwid2VpZ2h0c0xvYWRlckZhY3RvcnkiLCJ3aXRoU2F2ZUhhbmRsZXIiLCJjb3B5TW9kZWwiLCJtb3ZlTW9kZWwiLCJQZCIsIkxkIiwiY29uZnVzaW9uTWF0cml4XyIsIldkIiwiY29uZnVzaW9uTWF0cml4IiwiVWQiLCJmcm9tUGl4ZWxzXyIsIkltYWdlRGF0YSIsInJlYWR5U3RhdGUiLCJnZXRJbWFnZURhdGEiLCJWZCIsInRvUGl4ZWxzIiwiVWludDhDbGFtcGVkQXJyYXkiLCJwdXRJbWFnZURhdGEiLCJmcm9tUGl4ZWxzIiwiemQiLCJnZXRDbGFzc05hbWUiLCJjbGFzc05hbWUiLCJmcm9tQ29uZmlnIiwiR2QiLCJjbGFzc05hbWVNYXAiLCJnZXRNYXAiLCJyZWdpc3RlciIsIkhkIiwicWQiLCJTZXJpYWxpemFibGUiLCJTZXJpYWxpemF0aW9uTWFwIiwicmVnaXN0ZXJDbGFzcyIsIktkIiwiamQiLCJncGdwdV91dGlsIiwid2ViZ2xfdXRpbCIsImZvcmNlSGFsZkZsb2F0IiwiTWF0aEJhY2tlbmRXZWJHTCIsInNldFdlYkdMQ29udGV4dCIsIkdQR1BVQ29udGV4dCIsIlhkIiwibWluaW1pemUiLCJjb21wdXRlR3JhZGllbnRzIiwiYXBwbHlHcmFkaWVudHMiLCJpdGVyYXRpb25zXyIsImluY3JlbWVudEl0ZXJhdGlvbnMiLCJpdGVyYXRpb25zIiwic2F2ZUl0ZXJhdGlvbnMiLCJnZXRXZWlnaHRzIiwic2V0V2VpZ2h0cyIsImV4dHJhY3RJdGVyYXRpb25zIiwiWWQiLCJsZWFybmluZ1JhdGUiLCJyaG8iLCJhY2N1bXVsYXRlZEdyYWRzIiwiYWNjdW11bGF0ZWRVcGRhdGVzIiwib3JpZ2luYWxOYW1lIiwiZ2V0Q29uZmlnIiwiJGQiLCJpbml0aWFsQWNjdW11bGF0b3JWYWx1ZSIsIlFkIiwiYmV0YTEiLCJiZXRhMiIsImFjY3VtdWxhdGVkRmlyc3RNb21lbnQiLCJhY2N1bXVsYXRlZFNlY29uZE1vbWVudCIsImFjY0JldGExIiwiYWNjQmV0YTIiLCJKZCIsImRlY2F5IiwiYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm0iLCJpdGVyYXRpb24iLCJaZCIsInNldExlYXJuaW5nUmF0ZSIsInRwIiwibW9tZW50dW0iLCJ1c2VOZXN0ZXJvdiIsImFjY3VtdWxhdGlvbnMiLCJzZXRNb21lbnR1bSIsImVwIiwiYWNjdW11bGF0ZWRNZWFuU3F1YXJlcyIsImFjY3VtdWxhdGVkTW9tZW50cyIsImFjY3VtdWxhdGVkTWVhbkdyYWRzIiwiY2VudGVyZWQiLCJucCIsInNnZCIsInJtc3Byb3AiLCJhZGFtIiwiYWRhZGVsdGEiLCJhZGFtYXgiLCJhZGFncmFkIiwicnAiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZXRJbW1lZGlhdGUiLCJhcCIsIkFkYWRlbHRhT3B0aW1pemVyIiwiQWRhZ3JhZE9wdGltaXplciIsIkFkYW1PcHRpbWl6ZXIiLCJBZGFtYXhPcHRpbWl6ZXIiLCJBZGQiLCJBZGROIiwiQnJvYWRjYXN0VG8iLCJEYXRhU3RvcmFnZSIsIkRpdiIsIkVudmlyb25tZW50IiwiRnJvbVBpeGVscyIsIkZ1c2VkQmF0Y2hOb3JtIiwiSWRlbnRpdHkiLCJLZXJuZWxCYWNrZW5kIiwiTWF4UG9vbFdpdGhBcmdtYXgiLCJNb21lbnR1bU9wdGltaXplciIsIk5vbk1heFN1cHByZXNzaW9uVjUiLCJPbmVIb3QiLCJPcHRpbWl6ZXIiLCJQYWRWMiIsIlJNU1Byb3BPcHRpbWl6ZXIiLCJSYW5rIiwiU0dET3B0aW1pemVyIiwiU3F1YXJlIiwiU3F1YXJlZERpZmZlcmVuY2UiLCJUZW5zb3IiLCJUZW5zb3JCdWZmZXIiLCJUaWxlIiwiVHJhbnNwb3NlIiwiVmFyaWFibGUiLCJiYWNrZW5kX3V0aWwiLCJicm93c2VyIiwiZGVwcmVjYXRpb25XYXJuIiwiZGlzYWJsZURlcHJlY2F0aW9uV2FybmluZ3MiLCJlbmFibGVEZWJ1Z01vZGUiLCJlbmFibGVQcm9kTW9kZSIsImVuZ2luZSIsImVudiIsImdhdGhlcl91dGlsIiwiZ2V0QmFja2VuZCIsImdldEdyYWRpZW50IiwiZ2V0S2VybmVsIiwiZ2V0S2VybmVsc0ZvckJhY2tlbmQiLCJtYXRoIiwibmV4dEZyYW1lIiwicmVnaXN0ZXJHcmFkaWVudCIsInJlZ2lzdGVyS2VybmVsIiwic2NhdHRlcl91dGlsIiwic2VyaWFsaXphdGlvbiIsInNsaWNlX3V0aWwiLCJzdW1PdXRUeXBlIiwidGVuc29yX3V0aWwiLCJ0ZXN0X3V0aWwiLCJ0cmFpbiIsInVucmVnaXN0ZXJHcmFkaWVudCIsInVucmVnaXN0ZXJLZXJuZWwiLCJ2YWx1ZUFuZEdyYWQiLCJ2YWx1ZUFuZEdyYWRzIiwidmFyaWFibGVHcmFkcyIsInZlcnNpb25fY29yZSIsIndlYmdsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow/tfjs-core/dist/tf-core.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tensorflow/tfjs-core/node_modules/node-fetch/lib/index.es.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@tensorflow/tfjs-core/node_modules/node-fetch/lib/index.es.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchError: () => (/* binding */ FetchError),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   Response: () => (/* binding */ Response),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n// (MIT licensed)\nconst BUFFER = Symbol(\"buffer\");\nconst TYPE = Symbol(\"type\");\nclass Blob {\n    constructor(){\n        this[TYPE] = \"\";\n        const blobParts = arguments[0];\n        const options = arguments[1];\n        const buffers = [];\n        if (blobParts) {\n            const a = blobParts;\n            const length = Number(a.length);\n            for(let i = 0; i < length; i++){\n                const element = a[i];\n                let buffer;\n                if (element instanceof Buffer) {\n                    buffer = element;\n                } else if (ArrayBuffer.isView(element)) {\n                    buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n                } else if (element instanceof ArrayBuffer) {\n                    buffer = Buffer.from(element);\n                } else if (element instanceof Blob) {\n                    buffer = element[BUFFER];\n                } else {\n                    buffer = Buffer.from(typeof element === \"string\" ? element : String(element));\n                }\n                buffers.push(buffer);\n            }\n        }\n        this[BUFFER] = Buffer.concat(buffers);\n        let type = options && options.type !== undefined && String(options.type).toLowerCase();\n        if (type && !/[^\\u0020-\\u007E]/.test(type)) {\n            this[TYPE] = type;\n        }\n    }\n    get size() {\n        return this[BUFFER].length;\n    }\n    get type() {\n        return this[TYPE];\n    }\n    slice() {\n        const size = this.size;\n        const start = arguments[0];\n        const end = arguments[1];\n        let relativeStart, relativeEnd;\n        if (start === undefined) {\n            relativeStart = 0;\n        } else if (start < 0) {\n            relativeStart = Math.max(size + start, 0);\n        } else {\n            relativeStart = Math.min(start, size);\n        }\n        if (end === undefined) {\n            relativeEnd = size;\n        } else if (end < 0) {\n            relativeEnd = Math.max(size + end, 0);\n        } else {\n            relativeEnd = Math.min(end, size);\n        }\n        const span = Math.max(relativeEnd - relativeStart, 0);\n        const buffer = this[BUFFER];\n        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n        const blob = new Blob([], {\n            type: arguments[2]\n        });\n        blob[BUFFER] = slicedBuffer;\n        return blob;\n    }\n}\nObject.defineProperties(Blob.prototype, {\n    size: {\n        enumerable: true\n    },\n    type: {\n        enumerable: true\n    },\n    slice: {\n        enumerable: true\n    }\n});\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n    value: \"Blob\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */ /**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */ function FetchError(message, type, systemError) {\n    Error.call(this, message);\n    this.message = message;\n    this.type = type;\n    // when err.type is `system`, err.code contains system error code\n    if (systemError) {\n        this.code = this.errno = systemError.code;\n    }\n    // hide custom error implementation details from end-users\n    Error.captureStackTrace(this, this.constructor);\n}\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = \"FetchError\";\n/**\n * body.js\n *\n * Body interface provides common methods for Request and Response\n */ const Stream = __webpack_require__(/*! stream */ \"stream\");\nvar _require = __webpack_require__(/*! stream */ \"stream\");\nconst PassThrough = _require.PassThrough;\nlet convert;\ntry {\n    convert = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'encoding'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n} catch (e) {}\nconst INTERNALS = Symbol(\"Body internals\");\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ function Body(body) {\n    var _this = this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;\n    let size = _ref$size === undefined ? 0 : _ref$size;\n    var _ref$timeout = _ref.timeout;\n    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n    if (body == null) {\n        // body is undefined or null\n        body = null;\n    } else if (typeof body === \"string\") {\n    // body is string\n    } else if (isURLSearchParams(body)) {\n    // body is a URLSearchParams\n    } else if (body instanceof Blob) {\n    // body is blob\n    } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    } else if (Object.prototype.toString.call(body) === \"[object ArrayBuffer]\") {\n    // body is array buffer\n    } else if (body instanceof Stream) {\n    // body is stream\n    } else {\n        // none of the above\n        // coerce to string\n        body = String(body);\n    }\n    this[INTERNALS] = {\n        body,\n        disturbed: false,\n        error: null\n    };\n    this.size = size;\n    this.timeout = timeout;\n    if (body instanceof Stream) {\n        body.on(\"error\", function(err) {\n            _this[INTERNALS].error = new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, \"system\", err);\n        });\n    }\n}\nBody.prototype = {\n    get body () {\n        return this[INTERNALS].body;\n    },\n    get bodyUsed () {\n        return this[INTERNALS].disturbed;\n    },\n    /**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */ arrayBuffer () {\n        return consumeBody.call(this).then(function(buf) {\n            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n        });\n    },\n    /**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */ blob () {\n        let ct = this.headers && this.headers.get(\"content-type\") || \"\";\n        return consumeBody.call(this).then(function(buf) {\n            return Object.assign(// Prevent copying\n            new Blob([], {\n                type: ct.toLowerCase()\n            }), {\n                [BUFFER]: buf\n            });\n        });\n    },\n    /**\n  * Decode response as json\n  *\n  * @return  Promise\n  */ json () {\n        var _this2 = this;\n        return consumeBody.call(this).then(function(buffer) {\n            try {\n                return JSON.parse(buffer.toString());\n            } catch (err) {\n                return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, \"invalid-json\"));\n            }\n        });\n    },\n    /**\n  * Decode response as text\n  *\n  * @return  Promise\n  */ text () {\n        return consumeBody.call(this).then(function(buffer) {\n            return buffer.toString();\n        });\n    },\n    /**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */ buffer () {\n        return consumeBody.call(this);\n    },\n    /**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */ textConverted () {\n        var _this3 = this;\n        return consumeBody.call(this).then(function(buffer) {\n            return convertBody(buffer, _this3.headers);\n        });\n    }\n};\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n    body: {\n        enumerable: true\n    },\n    bodyUsed: {\n        enumerable: true\n    },\n    arrayBuffer: {\n        enumerable: true\n    },\n    blob: {\n        enumerable: true\n    },\n    json: {\n        enumerable: true\n    },\n    text: {\n        enumerable: true\n    }\n});\nBody.mixIn = function(proto) {\n    for (const name of Object.getOwnPropertyNames(Body.prototype)){\n        // istanbul ignore else: future proof\n        if (!(name in proto)) {\n            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n            Object.defineProperty(proto, name, desc);\n        }\n    }\n};\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */ function consumeBody() {\n    var _this4 = this;\n    if (this[INTERNALS].disturbed) {\n        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n    }\n    this[INTERNALS].disturbed = true;\n    if (this[INTERNALS].error) {\n        return Body.Promise.reject(this[INTERNALS].error);\n    }\n    // body is null\n    if (this.body === null) {\n        return Body.Promise.resolve(Buffer.alloc(0));\n    }\n    // body is string\n    if (typeof this.body === \"string\") {\n        return Body.Promise.resolve(Buffer.from(this.body));\n    }\n    // body is blob\n    if (this.body instanceof Blob) {\n        return Body.Promise.resolve(this.body[BUFFER]);\n    }\n    // body is buffer\n    if (Buffer.isBuffer(this.body)) {\n        return Body.Promise.resolve(this.body);\n    }\n    // body is buffer\n    if (Object.prototype.toString.call(this.body) === \"[object ArrayBuffer]\") {\n        return Body.Promise.resolve(Buffer.from(this.body));\n    }\n    // istanbul ignore if: should never happen\n    if (!(this.body instanceof Stream)) {\n        return Body.Promise.resolve(Buffer.alloc(0));\n    }\n    // body is stream\n    // get ready to actually consume the body\n    let accum = [];\n    let accumBytes = 0;\n    let abort = false;\n    return new Body.Promise(function(resolve, reject) {\n        let resTimeout;\n        // allow timeout on slow response body\n        if (_this4.timeout) {\n            resTimeout = setTimeout(function() {\n                abort = true;\n                reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, \"body-timeout\"));\n            }, _this4.timeout);\n        }\n        // handle stream error, such as incorrect content-encoding\n        _this4.body.on(\"error\", function(err) {\n            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, \"system\", err));\n        });\n        _this4.body.on(\"data\", function(chunk) {\n            if (abort || chunk === null) {\n                return;\n            }\n            if (_this4.size && accumBytes + chunk.length > _this4.size) {\n                abort = true;\n                reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, \"max-size\"));\n                return;\n            }\n            accumBytes += chunk.length;\n            accum.push(chunk);\n        });\n        _this4.body.on(\"end\", function() {\n            if (abort) {\n                return;\n            }\n            clearTimeout(resTimeout);\n            try {\n                resolve(Buffer.concat(accum));\n            } catch (err) {\n                // handle streams that have accumulated too much data (issue #414)\n                reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, \"system\", err));\n            }\n        });\n    });\n}\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */ function convertBody(buffer, headers) {\n    if (typeof convert !== \"function\") {\n        throw new Error(\"The package `encoding` must be installed to use the textConverted() function\");\n    }\n    const ct = headers.get(\"content-type\");\n    let charset = \"utf-8\";\n    let res, str;\n    // header\n    if (ct) {\n        res = /charset=([^;]*)/i.exec(ct);\n    }\n    // no charset in content type, peek at response body for at most 1024 bytes\n    str = buffer.slice(0, 1024).toString();\n    // html5\n    if (!res && str) {\n        res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n    }\n    // html4\n    if (!res && str) {\n        res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n        if (res) {\n            res = /charset=(.*)/i.exec(res.pop());\n        }\n    }\n    // xml\n    if (!res && str) {\n        res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n    }\n    // found charset\n    if (res) {\n        charset = res.pop();\n        // prevent decode issues when sites use incorrect encoding\n        // ref: https://hsivonen.fi/encoding-menu/\n        if (charset === \"gb2312\" || charset === \"gbk\") {\n            charset = \"gb18030\";\n        }\n    }\n    // turn raw buffers into a single utf-8 buffer\n    return convert(buffer, \"UTF-8\", charset).toString();\n}\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */ function isURLSearchParams(obj) {\n    // Duck-typing as a necessary condition.\n    if (typeof obj !== \"object\" || typeof obj.append !== \"function\" || typeof obj.delete !== \"function\" || typeof obj.get !== \"function\" || typeof obj.getAll !== \"function\" || typeof obj.has !== \"function\" || typeof obj.set !== \"function\") {\n        return false;\n    }\n    // Brand-checking and more duck-typing as optional condition.\n    return obj.constructor.name === \"URLSearchParams\" || Object.prototype.toString.call(obj) === \"[object URLSearchParams]\" || typeof obj.sort === \"function\";\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */ function clone(instance) {\n    let p1, p2;\n    let body = instance.body;\n    // don't allow cloning a used body\n    if (instance.bodyUsed) {\n        throw new Error(\"cannot clone body after it is used\");\n    }\n    // check that body is a stream and not form-data object\n    // note: we can't clone the form-data object without having it as a dependency\n    if (body instanceof Stream && typeof body.getBoundary !== \"function\") {\n        // tee instance body\n        p1 = new PassThrough();\n        p2 = new PassThrough();\n        body.pipe(p1);\n        body.pipe(p2);\n        // set instance body to teed body and return the other teed body\n        instance[INTERNALS].body = p1;\n        body = p2;\n    }\n    return body;\n}\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Response or Request instance\n */ function extractContentType(instance) {\n    const body = instance.body;\n    // istanbul ignore if: Currently, because of a guard in Request, body\n    // can never be null. Included here for completeness.\n    if (body === null) {\n        // body is null\n        return null;\n    } else if (typeof body === \"string\") {\n        // body is string\n        return \"text/plain;charset=UTF-8\";\n    } else if (isURLSearchParams(body)) {\n        // body is a URLSearchParams\n        return \"application/x-www-form-urlencoded;charset=UTF-8\";\n    } else if (body instanceof Blob) {\n        // body is blob\n        return body.type || null;\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        return null;\n    } else if (Object.prototype.toString.call(body) === \"[object ArrayBuffer]\") {\n        // body is array buffer\n        return null;\n    } else if (typeof body.getBoundary === \"function\") {\n        // detect form data input from form-data module\n        return `multipart/form-data;boundary=${body.getBoundary()}`;\n    } else {\n        // body is stream\n        // can't really do much about this\n        return null;\n    }\n}\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */ function getTotalBytes(instance) {\n    const body = instance.body;\n    // istanbul ignore if: included for completion\n    if (body === null) {\n        // body is null\n        return 0;\n    } else if (typeof body === \"string\") {\n        // body is string\n        return Buffer.byteLength(body);\n    } else if (isURLSearchParams(body)) {\n        // body is URLSearchParams\n        return Buffer.byteLength(String(body));\n    } else if (body instanceof Blob) {\n        // body is blob\n        return body.size;\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        return body.length;\n    } else if (Object.prototype.toString.call(body) === \"[object ArrayBuffer]\") {\n        // body is array buffer\n        return body.byteLength;\n    } else if (body && typeof body.getLengthSync === \"function\") {\n        // detect form data input from form-data module\n        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n        body.hasKnownLength && body.hasKnownLength()) {\n            // 2.x\n            return body.getLengthSync();\n        }\n        return null;\n    } else {\n        // body is stream\n        // can't really do much about this\n        return null;\n    }\n}\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */ function writeToStream(dest, instance) {\n    const body = instance.body;\n    if (body === null) {\n        // body is null\n        dest.end();\n    } else if (typeof body === \"string\") {\n        // body is string\n        dest.write(body);\n        dest.end();\n    } else if (isURLSearchParams(body)) {\n        // body is URLSearchParams\n        dest.write(Buffer.from(String(body)));\n        dest.end();\n    } else if (body instanceof Blob) {\n        // body is blob\n        dest.write(body[BUFFER]);\n        dest.end();\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        dest.write(body);\n        dest.end();\n    } else if (Object.prototype.toString.call(body) === \"[object ArrayBuffer]\") {\n        // body is array buffer\n        dest.write(Buffer.from(body));\n        dest.end();\n    } else {\n        // body is stream\n        body.pipe(dest);\n    }\n}\n// expose Promise\nBody.Promise = global.Promise;\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */ const invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\nfunction validateName(name) {\n    name = `${name}`;\n    if (invalidTokenRegex.test(name)) {\n        throw new TypeError(`${name} is not a legal HTTP header name`);\n    }\n}\nfunction validateValue(value) {\n    value = `${value}`;\n    if (invalidHeaderCharRegex.test(value)) {\n        throw new TypeError(`${value} is not a legal HTTP header value`);\n    }\n}\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */ function find(map, name) {\n    name = name.toLowerCase();\n    for(const key in map){\n        if (key.toLowerCase() === name) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst MAP = Symbol(\"map\");\nclass Headers {\n    /**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */ constructor(){\n        let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n        this[MAP] = Object.create(null);\n        if (init instanceof Headers) {\n            const rawHeaders = init.raw();\n            const headerNames = Object.keys(rawHeaders);\n            for (const headerName of headerNames){\n                for (const value of rawHeaders[headerName]){\n                    this.append(headerName, value);\n                }\n            }\n            return;\n        }\n        // We don't worry about converting prop to ByteString here as append()\n        // will handle it.\n        if (init == null) {\n        // no op\n        } else if (typeof init === \"object\") {\n            const method = init[Symbol.iterator];\n            if (method != null) {\n                if (typeof method !== \"function\") {\n                    throw new TypeError(\"Header pairs must be iterable\");\n                }\n                // sequence<sequence<ByteString>>\n                // Note: per spec we have to first exhaust the lists then process them\n                const pairs = [];\n                for (const pair of init){\n                    if (typeof pair !== \"object\" || typeof pair[Symbol.iterator] !== \"function\") {\n                        throw new TypeError(\"Each header pair must be iterable\");\n                    }\n                    pairs.push(Array.from(pair));\n                }\n                for (const pair of pairs){\n                    if (pair.length !== 2) {\n                        throw new TypeError(\"Each header pair must be a name/value tuple\");\n                    }\n                    this.append(pair[0], pair[1]);\n                }\n            } else {\n                // record<ByteString, ByteString>\n                for (const key of Object.keys(init)){\n                    const value = init[key];\n                    this.append(key, value);\n                }\n            }\n        } else {\n            throw new TypeError(\"Provided initializer must be an object\");\n        }\n    }\n    /**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */ get(name) {\n        name = `${name}`;\n        validateName(name);\n        const key = find(this[MAP], name);\n        if (key === undefined) {\n            return null;\n        }\n        return this[MAP][key].join(\", \");\n    }\n    /**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */ forEach(callback) {\n        let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n        let pairs = getHeaders(this);\n        let i = 0;\n        while(i < pairs.length){\n            var _pairs$i = pairs[i];\n            const name = _pairs$i[0], value = _pairs$i[1];\n            callback.call(thisArg, value, name, this);\n            pairs = getHeaders(this);\n            i++;\n        }\n    }\n    /**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */ set(name, value) {\n        name = `${name}`;\n        value = `${value}`;\n        validateName(name);\n        validateValue(value);\n        const key = find(this[MAP], name);\n        this[MAP][key !== undefined ? key : name] = [\n            value\n        ];\n    }\n    /**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */ append(name, value) {\n        name = `${name}`;\n        value = `${value}`;\n        validateName(name);\n        validateValue(value);\n        const key = find(this[MAP], name);\n        if (key !== undefined) {\n            this[MAP][key].push(value);\n        } else {\n            this[MAP][name] = [\n                value\n            ];\n        }\n    }\n    /**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */ has(name) {\n        name = `${name}`;\n        validateName(name);\n        return find(this[MAP], name) !== undefined;\n    }\n    /**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */ delete(name) {\n        name = `${name}`;\n        validateName(name);\n        const key = find(this[MAP], name);\n        if (key !== undefined) {\n            delete this[MAP][key];\n        }\n    }\n    /**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */ raw() {\n        return this[MAP];\n    }\n    /**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */ keys() {\n        return createHeadersIterator(this, \"key\");\n    }\n    /**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */ values() {\n        return createHeadersIterator(this, \"value\");\n    }\n    /**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */ [Symbol.iterator]() {\n        return createHeadersIterator(this, \"key+value\");\n    }\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n    value: \"Headers\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nObject.defineProperties(Headers.prototype, {\n    get: {\n        enumerable: true\n    },\n    forEach: {\n        enumerable: true\n    },\n    set: {\n        enumerable: true\n    },\n    append: {\n        enumerable: true\n    },\n    has: {\n        enumerable: true\n    },\n    delete: {\n        enumerable: true\n    },\n    keys: {\n        enumerable: true\n    },\n    values: {\n        enumerable: true\n    },\n    entries: {\n        enumerable: true\n    }\n});\nfunction getHeaders(headers) {\n    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"key+value\";\n    const keys = Object.keys(headers[MAP]).sort();\n    return keys.map(kind === \"key\" ? function(k) {\n        return k.toLowerCase();\n    } : kind === \"value\" ? function(k) {\n        return headers[MAP][k].join(\", \");\n    } : function(k) {\n        return [\n            k.toLowerCase(),\n            headers[MAP][k].join(\", \")\n        ];\n    });\n}\nconst INTERNAL = Symbol(\"internal\");\nfunction createHeadersIterator(target, kind) {\n    const iterator = Object.create(HeadersIteratorPrototype);\n    iterator[INTERNAL] = {\n        target,\n        kind,\n        index: 0\n    };\n    return iterator;\n}\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n    next () {\n        // istanbul ignore if\n        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n            throw new TypeError(\"Value of `this` is not a HeadersIterator\");\n        }\n        var _INTERNAL = this[INTERNAL];\n        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;\n        const values = getHeaders(target, kind);\n        const len = values.length;\n        if (index >= len) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        this[INTERNAL].index = index + 1;\n        return {\n            value: values[index],\n            done: false\n        };\n    }\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n    value: \"HeadersIterator\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */ function exportNodeCompatibleHeaders(headers) {\n    const obj = Object.assign({\n        __proto__: null\n    }, headers[MAP]);\n    // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n    const hostHeaderKey = find(headers[MAP], \"Host\");\n    if (hostHeaderKey !== undefined) {\n        obj[hostHeaderKey] = obj[hostHeaderKey][0];\n    }\n    return obj;\n}\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */ function createHeadersLenient(obj) {\n    const headers = new Headers();\n    for (const name of Object.keys(obj)){\n        if (invalidTokenRegex.test(name)) {\n            continue;\n        }\n        if (Array.isArray(obj[name])) {\n            for (const val of obj[name]){\n                if (invalidHeaderCharRegex.test(val)) {\n                    continue;\n                }\n                if (headers[MAP][name] === undefined) {\n                    headers[MAP][name] = [\n                        val\n                    ];\n                } else {\n                    headers[MAP][name].push(val);\n                }\n            }\n        } else if (!invalidHeaderCharRegex.test(obj[name])) {\n            headers[MAP][name] = [\n                obj[name]\n            ];\n        }\n    }\n    return headers;\n}\n/**\n * response.js\n *\n * Response class provides content decoding\n */ var _require$1 = __webpack_require__(/*! http */ \"http\");\nconst STATUS_CODES = _require$1.STATUS_CODES;\nconst INTERNALS$1 = Symbol(\"Response internals\");\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ class Response {\n    constructor(){\n        let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Body.call(this, body, opts);\n        const status = opts.status || 200;\n        this[INTERNALS$1] = {\n            url: opts.url,\n            status,\n            statusText: opts.statusText || STATUS_CODES[status],\n            headers: new Headers(opts.headers)\n        };\n    }\n    get url() {\n        return this[INTERNALS$1].url;\n    }\n    get status() {\n        return this[INTERNALS$1].status;\n    }\n    /**\n  * Convenience property representing if the request ended normally\n  */ get ok() {\n        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n    }\n    get statusText() {\n        return this[INTERNALS$1].statusText;\n    }\n    get headers() {\n        return this[INTERNALS$1].headers;\n    }\n    /**\n  * Clone this response\n  *\n  * @return  Response\n  */ clone() {\n        return new Response(clone(this), {\n            url: this.url,\n            status: this.status,\n            statusText: this.statusText,\n            headers: this.headers,\n            ok: this.ok\n        });\n    }\n}\nBody.mixIn(Response.prototype);\nObject.defineProperties(Response.prototype, {\n    url: {\n        enumerable: true\n    },\n    status: {\n        enumerable: true\n    },\n    ok: {\n        enumerable: true\n    },\n    statusText: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    }\n});\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n    value: \"Response\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n/**\n * request.js\n *\n * Request class contains server only options\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */ var _require$2 = __webpack_require__(/*! url */ \"url\");\nconst format_url = _require$2.format;\nconst parse_url = _require$2.parse;\nconst INTERNALS$2 = Symbol(\"Request internals\");\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */ function isRequest(input) {\n    return typeof input === \"object\" && typeof input[INTERNALS$2] === \"object\";\n}\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */ class Request {\n    constructor(input){\n        let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let parsedURL;\n        // normalize input\n        if (!isRequest(input)) {\n            if (input && input.href) {\n                // in order to support Node.js' Url objects; though WHATWG's URL objects\n                // will fall into this branch also (since their `toString()` will return\n                // `href` property anyway)\n                parsedURL = parse_url(input.href);\n            } else {\n                // coerce input to a string before attempting to parse\n                parsedURL = parse_url(`${input}`);\n            }\n            input = {};\n        } else {\n            parsedURL = parse_url(input.url);\n        }\n        let method = init.method || input.method || \"GET\";\n        method = method.toUpperCase();\n        if ((init.body != null || isRequest(input) && input.body !== null) && (method === \"GET\" || method === \"HEAD\")) {\n            throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n        }\n        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n        Body.call(this, inputBody, {\n            timeout: init.timeout || input.timeout || 0,\n            size: init.size || input.size || 0\n        });\n        const headers = new Headers(init.headers || input.headers || {});\n        if (init.body != null) {\n            const contentType = extractContentType(this);\n            if (contentType !== null && !headers.has(\"Content-Type\")) {\n                headers.append(\"Content-Type\", contentType);\n            }\n        }\n        this[INTERNALS$2] = {\n            method,\n            redirect: init.redirect || input.redirect || \"follow\",\n            headers,\n            parsedURL\n        };\n        // node-fetch-only options\n        this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n        this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n        this.counter = init.counter || input.counter || 0;\n        this.agent = init.agent || input.agent;\n    }\n    get method() {\n        return this[INTERNALS$2].method;\n    }\n    get url() {\n        return format_url(this[INTERNALS$2].parsedURL);\n    }\n    get headers() {\n        return this[INTERNALS$2].headers;\n    }\n    get redirect() {\n        return this[INTERNALS$2].redirect;\n    }\n    /**\n  * Clone this request\n  *\n  * @return  Request\n  */ clone() {\n        return new Request(this);\n    }\n}\nBody.mixIn(Request.prototype);\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n    value: \"Request\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nObject.defineProperties(Request.prototype, {\n    method: {\n        enumerable: true\n    },\n    url: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    redirect: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    }\n});\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */ function getNodeRequestOptions(request) {\n    const parsedURL = request[INTERNALS$2].parsedURL;\n    const headers = new Headers(request[INTERNALS$2].headers);\n    // fetch step 1.3\n    if (!headers.has(\"Accept\")) {\n        headers.set(\"Accept\", \"*/*\");\n    }\n    // Basic fetch\n    if (!parsedURL.protocol || !parsedURL.hostname) {\n        throw new TypeError(\"Only absolute URLs are supported\");\n    }\n    if (!/^https?:$/.test(parsedURL.protocol)) {\n        throw new TypeError(\"Only HTTP(S) protocols are supported\");\n    }\n    // HTTP-network-or-cache fetch steps 2.4-2.7\n    let contentLengthValue = null;\n    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n        contentLengthValue = \"0\";\n    }\n    if (request.body != null) {\n        const totalBytes = getTotalBytes(request);\n        if (typeof totalBytes === \"number\") {\n            contentLengthValue = String(totalBytes);\n        }\n    }\n    if (contentLengthValue) {\n        headers.set(\"Content-Length\", contentLengthValue);\n    }\n    // HTTP-network-or-cache fetch step 2.11\n    if (!headers.has(\"User-Agent\")) {\n        headers.set(\"User-Agent\", \"node-fetch/1.0 (+https://github.com/bitinn/node-fetch)\");\n    }\n    // HTTP-network-or-cache fetch step 2.15\n    if (request.compress) {\n        headers.set(\"Accept-Encoding\", \"gzip,deflate\");\n    }\n    if (!headers.has(\"Connection\") && !request.agent) {\n        headers.set(\"Connection\", \"close\");\n    }\n    // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n    return Object.assign({}, parsedURL, {\n        method: request.method,\n        headers: exportNodeCompatibleHeaders(headers),\n        agent: request.agent\n    });\n}\n/**\n * index.js\n *\n * a request API compatible with window.fetch\n *\n * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.\n */ const http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nvar _require$3 = __webpack_require__(/*! stream */ \"stream\");\nconst PassThrough$1 = _require$3.PassThrough;\nvar _require2 = __webpack_require__(/*! url */ \"url\");\nconst resolve_url = _require2.resolve;\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */ function fetch(url, opts) {\n    // allow custom promise\n    if (!fetch.Promise) {\n        throw new Error(\"native promise missing, set fetch.Promise to your favorite alternative\");\n    }\n    Body.Promise = fetch.Promise;\n    // wrap http.request into fetch\n    return new fetch.Promise(function(resolve, reject) {\n        // build request object\n        const request = new Request(url, opts);\n        const options = getNodeRequestOptions(request);\n        const send = (options.protocol === \"https:\" ? https : http).request;\n        // send request\n        const req = send(options);\n        let reqTimeout;\n        function finalize() {\n            req.abort();\n            clearTimeout(reqTimeout);\n        }\n        if (request.timeout) {\n            req.once(\"socket\", function(socket) {\n                reqTimeout = setTimeout(function() {\n                    reject(new FetchError(`network timeout at: ${request.url}`, \"request-timeout\"));\n                    finalize();\n                }, request.timeout);\n            });\n        }\n        req.on(\"error\", function(err) {\n            reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, \"system\", err));\n            finalize();\n        });\n        req.on(\"response\", function(res) {\n            clearTimeout(reqTimeout);\n            const headers = createHeadersLenient(res.headers);\n            // HTTP fetch step 5\n            if (fetch.isRedirect(res.statusCode)) {\n                // HTTP fetch step 5.2\n                const location = headers.get(\"Location\");\n                // HTTP fetch step 5.3\n                const locationURL = location === null ? null : resolve_url(request.url, location);\n                // HTTP fetch step 5.5\n                switch(request.redirect){\n                    case \"error\":\n                        reject(new FetchError(`redirect mode is set to error: ${request.url}`, \"no-redirect\"));\n                        finalize();\n                        return;\n                    case \"manual\":\n                        // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n                        if (locationURL !== null) {\n                            headers.set(\"Location\", locationURL);\n                        }\n                        break;\n                    case \"follow\":\n                        // HTTP-redirect fetch step 2\n                        if (locationURL === null) {\n                            break;\n                        }\n                        // HTTP-redirect fetch step 5\n                        if (request.counter >= request.follow) {\n                            reject(new FetchError(`maximum redirect reached at: ${request.url}`, \"max-redirect\"));\n                            finalize();\n                            return;\n                        }\n                        // HTTP-redirect fetch step 6 (counter increment)\n                        // Create a new Request object.\n                        const requestOpts = {\n                            headers: new Headers(request.headers),\n                            follow: request.follow,\n                            counter: request.counter + 1,\n                            agent: request.agent,\n                            compress: request.compress,\n                            method: request.method,\n                            body: request.body\n                        };\n                        // HTTP-redirect fetch step 9\n                        if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n                            reject(new FetchError(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\"));\n                            finalize();\n                            return;\n                        }\n                        // HTTP-redirect fetch step 11\n                        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === \"POST\") {\n                            requestOpts.method = \"GET\";\n                            requestOpts.body = undefined;\n                            requestOpts.headers.delete(\"content-length\");\n                        }\n                        // HTTP-redirect fetch step 15\n                        resolve(fetch(new Request(locationURL, requestOpts)));\n                        finalize();\n                        return;\n                }\n            }\n            // prepare response\n            let body = res.pipe(new PassThrough$1());\n            const response_options = {\n                url: request.url,\n                status: res.statusCode,\n                statusText: res.statusMessage,\n                headers: headers,\n                size: request.size,\n                timeout: request.timeout\n            };\n            // HTTP-network fetch step 12.1.1.3\n            const codings = headers.get(\"Content-Encoding\");\n            // HTTP-network fetch step 12.1.1.4: handle content codings\n            // in following scenarios we ignore compression support\n            // 1. compression support is disabled\n            // 2. HEAD request\n            // 3. no Content-Encoding header\n            // 4. no content response (204)\n            // 5. content not modified response (304)\n            if (!request.compress || request.method === \"HEAD\" || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n                resolve(new Response(body, response_options));\n                return;\n            }\n            // For Node v6+\n            // Be less strict when decoding compressed responses, since sometimes\n            // servers send slightly invalid responses that are still accepted\n            // by common browsers.\n            // Always using Z_SYNC_FLUSH is what cURL does.\n            const zlibOptions = {\n                flush: zlib.Z_SYNC_FLUSH,\n                finishFlush: zlib.Z_SYNC_FLUSH\n            };\n            // for gzip\n            if (codings == \"gzip\" || codings == \"x-gzip\") {\n                body = body.pipe(zlib.createGunzip(zlibOptions));\n                resolve(new Response(body, response_options));\n                return;\n            }\n            // for deflate\n            if (codings == \"deflate\" || codings == \"x-deflate\") {\n                // handle the infamous raw deflate response from old servers\n                // a hack for old IIS and Apache servers\n                const raw = res.pipe(new PassThrough$1());\n                raw.once(\"data\", function(chunk) {\n                    // see http://stackoverflow.com/questions/37519828\n                    if ((chunk[0] & 0x0F) === 0x08) {\n                        body = body.pipe(zlib.createInflate());\n                    } else {\n                        body = body.pipe(zlib.createInflateRaw());\n                    }\n                    resolve(new Response(body, response_options));\n                });\n                return;\n            }\n            // otherwise, use response as-is\n            resolve(new Response(body, response_options));\n        });\n        writeToStream(req, request);\n    });\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */ fetch.isRedirect = function(code) {\n    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n// Needed for TypeScript.\nfetch.default = fetch;\n// expose Promise\nfetch.Promise = global.Promise;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fetch);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRlbnNvcmZsb3cvdGZqcy1jb3JlL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoL2xpYi9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGtIQUFrSDtBQUNsSCxpQkFBaUI7QUFFakIsTUFBTUEsU0FBU0MsT0FBTztBQUN0QixNQUFNQyxPQUFPRCxPQUFPO0FBRXBCLE1BQU1FO0lBQ0xDLGFBQWM7UUFDYixJQUFJLENBQUNGLEtBQUssR0FBRztRQUViLE1BQU1HLFlBQVlDLFNBQVMsQ0FBQyxFQUFFO1FBQzlCLE1BQU1DLFVBQVVELFNBQVMsQ0FBQyxFQUFFO1FBRTVCLE1BQU1FLFVBQVUsRUFBRTtRQUVsQixJQUFJSCxXQUFXO1lBQ2QsTUFBTUksSUFBSUo7WUFDVixNQUFNSyxTQUFTQyxPQUFPRixFQUFFQyxNQUFNO1lBQzlCLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJRixRQUFRRSxJQUFLO2dCQUNoQyxNQUFNQyxVQUFVSixDQUFDLENBQUNHLEVBQUU7Z0JBQ3BCLElBQUlFO2dCQUNKLElBQUlELG1CQUFtQkUsUUFBUTtvQkFDOUJELFNBQVNEO2dCQUNWLE9BQU8sSUFBSUcsWUFBWUMsTUFBTSxDQUFDSixVQUFVO29CQUN2Q0MsU0FBU0MsT0FBT0csSUFBSSxDQUFDTCxRQUFRQyxNQUFNLEVBQUVELFFBQVFNLFVBQVUsRUFBRU4sUUFBUU8sVUFBVTtnQkFDNUUsT0FBTyxJQUFJUCxtQkFBbUJHLGFBQWE7b0JBQzFDRixTQUFTQyxPQUFPRyxJQUFJLENBQUNMO2dCQUN0QixPQUFPLElBQUlBLG1CQUFtQlYsTUFBTTtvQkFDbkNXLFNBQVNELE9BQU8sQ0FBQ2IsT0FBTztnQkFDekIsT0FBTztvQkFDTmMsU0FBU0MsT0FBT0csSUFBSSxDQUFDLE9BQU9MLFlBQVksV0FBV0EsVUFBVVEsT0FBT1I7Z0JBQ3JFO2dCQUNBTCxRQUFRYyxJQUFJLENBQUNSO1lBQ2Q7UUFDRDtRQUVBLElBQUksQ0FBQ2QsT0FB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LElBQUksQ0FBQytGLEtBQUtxQixhQUFhO29CQUNwQyxPQUFPO3dCQUNOdEwsT0FBT0EsS0FBS2tFLElBQUksQ0FBQytGLEtBQUtzQixnQkFBZ0I7b0JBQ3ZDO29CQUNBL0ksUUFBUSxJQUFJc0YsU0FBUzlILE1BQU04SztnQkFDNUI7Z0JBQ0E7WUFDRDtZQUVBLGdDQUFnQztZQUNoQ3RJLFFBQVEsSUFBSXNGLFNBQVM5SCxNQUFNOEs7UUFDNUI7UUFFQXRHLGNBQWM0RixLQUFLZDtJQUNwQjtBQUNEO0FBRUE7Ozs7O0NBS0MsR0FDRFksTUFBTU8sVUFBVSxHQUFHLFNBQVV0TCxJQUFJO0lBQ2hDLE9BQU9BLFNBQVMsT0FBT0EsU0FBUyxPQUFPQSxTQUFTLE9BQU9BLFNBQVMsT0FBT0EsU0FBUztBQUNqRjtBQUVBLHlCQUF5QjtBQUN6QitLLE1BQU1zQixPQUFPLEdBQUd0QjtBQUVoQixpQkFBaUI7QUFDakJBLE1BQU12SSxPQUFPLEdBQUdnRCxPQUFPaEQsT0FBTztBQUU5QixpRUFBZXVJLEtBQUtBLEVBQUM7QUFDNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWNvbW1lbnRlci8uL25vZGVfbW9kdWxlcy9AdGVuc29yZmxvdy90ZmpzLWNvcmUvbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvbGliL2luZGV4LmVzLmpzP2JlMDciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RtcHZhci9qc2RvbS9ibG9iL2FhODViMmFiZjA3NzY2ZmY3YmY1YzFmNmRhYWZiMzcyNmYyZjJkYjUvbGliL2pzZG9tL2xpdmluZy9ibG9iLmpzXG4vLyAoTUlUIGxpY2Vuc2VkKVxuXG5jb25zdCBCVUZGRVIgPSBTeW1ib2woJ2J1ZmZlcicpO1xuY29uc3QgVFlQRSA9IFN5bWJvbCgndHlwZScpO1xuXG5jbGFzcyBCbG9iIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0dGhpc1tUWVBFXSA9ICcnO1xuXG5cdFx0Y29uc3QgYmxvYlBhcnRzID0gYXJndW1lbnRzWzBdO1xuXHRcdGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG5cblx0XHRjb25zdCBidWZmZXJzID0gW107XG5cblx0XHRpZiAoYmxvYlBhcnRzKSB7XG5cdFx0XHRjb25zdCBhID0gYmxvYlBhcnRzO1xuXHRcdFx0Y29uc3QgbGVuZ3RoID0gTnVtYmVyKGEubGVuZ3RoKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IGFbaV07XG5cdFx0XHRcdGxldCBidWZmZXI7XG5cdFx0XHRcdGlmIChlbGVtZW50IGluc3RhbmNlb2YgQnVmZmVyKSB7XG5cdFx0XHRcdFx0YnVmZmVyID0gZWxlbWVudDtcblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZWxlbWVudCkpIHtcblx0XHRcdFx0XHRidWZmZXIgPSBCdWZmZXIuZnJvbShlbGVtZW50LmJ1ZmZlciwgZWxlbWVudC5ieXRlT2Zmc2V0LCBlbGVtZW50LmJ5dGVMZW5ndGgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHRcdFx0XHRcdGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGVsZW1lbnQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0XHRcdFx0YnVmZmVyID0gZWxlbWVudFtCVUZGRVJdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGVsZW1lbnQgOiBTdHJpbmcoZWxlbWVudCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJ1ZmZlcnMucHVzaChidWZmZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXNbQlVGRkVSXSA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycyk7XG5cblx0XHRsZXQgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlICE9PSB1bmRlZmluZWQgJiYgU3RyaW5nKG9wdGlvbnMudHlwZSkudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodHlwZSAmJiAhL1teXFx1MDAyMC1cXHUwMDdFXS8udGVzdCh0eXBlKSkge1xuXHRcdFx0dGhpc1tUWVBFXSA9IHR5cGU7XG5cdFx0fVxuXHR9XG5cdGdldCBzaXplKCkge1xuXHRcdHJldHVybiB0aGlzW0JVRkZFUl0ubGVuZ3RoO1xuXHR9XG5cdGdldCB0eXBlKCkge1xuXHRcdHJldHVybiB0aGlzW1RZUEVdO1xuXHR9XG5cdHNsaWNlKCkge1xuXHRcdGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG5cblx0XHRjb25zdCBzdGFydCA9IGFyZ3VtZW50c1swXTtcblx0XHRjb25zdCBlbmQgPSBhcmd1bWVudHNbMV07XG5cdFx0bGV0IHJlbGF0aXZlU3RhcnQsIHJlbGF0aXZlRW5kO1xuXHRcdGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZWxhdGl2ZVN0YXJ0ID0gMDtcblx0XHR9IGVsc2UgaWYgKHN0YXJ0IDwgMCkge1xuXHRcdFx0cmVsYXRpdmVTdGFydCA9IE1hdGgubWF4KHNpemUgKyBzdGFydCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbGF0aXZlU3RhcnQgPSBNYXRoLm1pbihzdGFydCwgc2l6ZSk7XG5cdFx0fVxuXHRcdGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVsYXRpdmVFbmQgPSBzaXplO1xuXHRcdH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuXHRcdFx0cmVsYXRpdmVFbmQgPSBNYXRoLm1heChzaXplICsgZW5kLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVsYXRpdmVFbmQgPSBNYXRoLm1pbihlbmQsIHNpemUpO1xuXHRcdH1cblx0XHRjb25zdCBzcGFuID0gTWF0aC5tYXgocmVsYXRpdmVFbmQgLSByZWxhdGl2ZVN0YXJ0LCAwKTtcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXNbQlVGRkVSXTtcblx0XHRjb25zdCBzbGljZWRCdWZmZXIgPSBidWZmZXIuc2xpY2UocmVsYXRpdmVTdGFydCwgcmVsYXRpdmVTdGFydCArIHNwYW4pO1xuXHRcdGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbXSwgeyB0eXBlOiBhcmd1bWVudHNbMl0gfSk7XG5cdFx0YmxvYltCVUZGRVJdID0gc2xpY2VkQnVmZmVyO1xuXHRcdHJldHVybiBibG9iO1xuXHR9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJsb2IucHJvdG90eXBlLCB7XG5cdHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHR0eXBlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0c2xpY2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0dmFsdWU6ICdCbG9iJyxcblx0d3JpdGFibGU6IGZhbHNlLFxuXHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0Y29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBmZXRjaC1lcnJvci5qc1xuICpcbiAqIEZldGNoRXJyb3IgaW50ZXJmYWNlIGZvciBvcGVyYXRpb25hbCBlcnJvcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBGZXRjaEVycm9yIGluc3RhbmNlXG4gKlxuICogQHBhcmFtICAgU3RyaW5nICAgICAgbWVzc2FnZSAgICAgIEVycm9yIG1lc3NhZ2UgZm9yIGh1bWFuXG4gKiBAcGFyYW0gICBTdHJpbmcgICAgICB0eXBlICAgICAgICAgRXJyb3IgdHlwZSBmb3IgbWFjaGluZVxuICogQHBhcmFtICAgU3RyaW5nICAgICAgc3lzdGVtRXJyb3IgIEZvciBOb2RlLmpzIHN5c3RlbSBlcnJvclxuICogQHJldHVybiAgRmV0Y2hFcnJvclxuICovXG5mdW5jdGlvbiBGZXRjaEVycm9yKG1lc3NhZ2UsIHR5cGUsIHN5c3RlbUVycm9yKSB7XG4gIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcblxuICAvLyB3aGVuIGVyci50eXBlIGlzIGBzeXN0ZW1gLCBlcnIuY29kZSBjb250YWlucyBzeXN0ZW0gZXJyb3IgY29kZVxuICBpZiAoc3lzdGVtRXJyb3IpIHtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLmVycm5vID0gc3lzdGVtRXJyb3IuY29kZTtcbiAgfVxuXG4gIC8vIGhpZGUgY3VzdG9tIGVycm9yIGltcGxlbWVudGF0aW9uIGRldGFpbHMgZnJvbSBlbmQtdXNlcnNcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG59XG5cbkZldGNoRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuRmV0Y2hFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGZXRjaEVycm9yO1xuRmV0Y2hFcnJvci5wcm90b3R5cGUubmFtZSA9ICdGZXRjaEVycm9yJztcblxuLyoqXG4gKiBib2R5LmpzXG4gKlxuICogQm9keSBpbnRlcmZhY2UgcHJvdmlkZXMgY29tbW9uIG1ldGhvZHMgZm9yIFJlcXVlc3QgYW5kIFJlc3BvbnNlXG4gKi9cblxuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBQYXNzVGhyb3VnaCA9IF9yZXF1aXJlLlBhc3NUaHJvdWdoO1xuXG5cbmxldCBjb252ZXJ0O1xudHJ5IHtcblx0Y29udmVydCA9IHJlcXVpcmUoJ2VuY29kaW5nJykuY29udmVydDtcbn0gY2F0Y2ggKGUpIHt9XG5cbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnQm9keSBpbnRlcm5hbHMnKTtcblxuLyoqXG4gKiBCb2R5IG1peGluXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keVxuICpcbiAqIEBwYXJhbSAgIFN0cmVhbSAgYm9keSAgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gICBPYmplY3QgIG9wdHMgIFJlc3BvbnNlIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuZnVuY3Rpb24gQm9keShib2R5KSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0dmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuXHQgICAgX3JlZiRzaXplID0gX3JlZi5zaXplO1xuXG5cdGxldCBzaXplID0gX3JlZiRzaXplID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRzaXplO1xuXHR2YXIgX3JlZiR0aW1lb3V0ID0gX3JlZi50aW1lb3V0O1xuXHRsZXQgdGltZW91dCA9IF9yZWYkdGltZW91dCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdGltZW91dDtcblxuXHRpZiAoYm9keSA9PSBudWxsKSB7XG5cdFx0Ly8gYm9keSBpcyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdGJvZHkgPSBudWxsO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuXHRcdC8vIGJvZHkgaXMgc3RyaW5nXG5cdH0gZWxzZSBpZiAoaXNVUkxTZWFyY2hQYXJhbXMoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIGEgVVJMU2VhcmNoUGFyYW1zXG5cdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHQvLyBib2R5IGlzIGJsb2Jcblx0fSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIGJ1ZmZlclxuXHR9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuXHRcdC8vIGJvZHkgaXMgYXJyYXkgYnVmZmVyXG5cdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuXHRcdC8vIGJvZHkgaXMgc3RyZWFtXG5cdH0gZWxzZSB7XG5cdFx0Ly8gbm9uZSBvZiB0aGUgYWJvdmVcblx0XHQvLyBjb2VyY2UgdG8gc3RyaW5nXG5cdFx0Ym9keSA9IFN0cmluZyhib2R5KTtcblx0fVxuXHR0aGlzW0lOVEVSTkFMU10gPSB7XG5cdFx0Ym9keSxcblx0XHRkaXN0dXJiZWQ6IGZhbHNlLFxuXHRcdGVycm9yOiBudWxsXG5cdH07XG5cdHRoaXMuc2l6ZSA9IHNpemU7XG5cdHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG5cblx0aWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcblx0XHRib2R5Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdF90aGlzW0lOVEVSTkFMU10uZXJyb3IgPSBuZXcgRmV0Y2hFcnJvcihgSW52YWxpZCByZXNwb25zZSBib2R5IHdoaWxlIHRyeWluZyB0byBmZXRjaCAke190aGlzLnVybH06ICR7ZXJyLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycik7XG5cdFx0fSk7XG5cdH1cbn1cblxuQm9keS5wcm90b3R5cGUgPSB7XG5cdGdldCBib2R5KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uYm9keTtcblx0fSxcblxuXHRnZXQgYm9keVVzZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5kaXN0dXJiZWQ7XG5cdH0sXG5cblx0LyoqXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIEFycmF5QnVmZmVyXG4gICpcbiAgKiBAcmV0dXJuICBQcm9taXNlXG4gICovXG5cdGFycmF5QnVmZmVyKCkge1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1Zikge1xuXHRcdFx0cmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIFJldHVybiByYXcgcmVzcG9uc2UgYXMgQmxvYlxuICAqXG4gICogQHJldHVybiBQcm9taXNlXG4gICovXG5cdGJsb2IoKSB7XG5cdFx0bGV0IGN0ID0gdGhpcy5oZWFkZXJzICYmIHRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnO1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1Zikge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oXG5cdFx0XHQvLyBQcmV2ZW50IGNvcHlpbmdcblx0XHRcdG5ldyBCbG9iKFtdLCB7XG5cdFx0XHRcdHR5cGU6IGN0LnRvTG93ZXJDYXNlKClcblx0XHRcdH0pLCB7XG5cdFx0XHRcdFtCVUZGRVJdOiBidWZcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIERlY29kZSByZXNwb25zZSBhcyBqc29uXG4gICpcbiAgKiBAcmV0dXJuICBQcm9taXNlXG4gICovXG5cdGpzb24oKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRyZXR1cm4gY29uc3VtZUJvZHkuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGJ1ZmZlci50b1N0cmluZygpKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlamVjdChuZXcgRmV0Y2hFcnJvcihgaW52YWxpZCBqc29uIHJlc3BvbnNlIGJvZHkgYXQgJHtfdGhpczIudXJsfSByZWFzb246ICR7ZXJyLm1lc3NhZ2V9YCwgJ2ludmFsaWQtanNvbicpKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvKipcbiAgKiBEZWNvZGUgcmVzcG9uc2UgYXMgdGV4dFxuICAqXG4gICogQHJldHVybiAgUHJvbWlzZVxuICAqL1xuXHR0ZXh0KCkge1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0cmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIERlY29kZSByZXNwb25zZSBhcyBidWZmZXIgKG5vbi1zcGVjIGFwaSlcbiAgKlxuICAqIEByZXR1cm4gIFByb21pc2VcbiAgKi9cblx0YnVmZmVyKCkge1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdC8qKlxuICAqIERlY29kZSByZXNwb25zZSBhcyB0ZXh0LCB3aGlsZSBhdXRvbWF0aWNhbGx5IGRldGVjdGluZyB0aGUgZW5jb2RpbmcgYW5kXG4gICogdHJ5aW5nIHRvIGRlY29kZSB0byBVVEYtOCAobm9uLXNwZWMgYXBpKVxuICAqXG4gICogQHJldHVybiAgUHJvbWlzZVxuICAqL1xuXHR0ZXh0Q29udmVydGVkKCkge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdFx0XHRyZXR1cm4gY29udmVydEJvZHkoYnVmZmVyLCBfdGhpczMuaGVhZGVycyk7XG5cdFx0fSk7XG5cdH1cblxufTtcblxuLy8gSW4gYnJvd3NlcnMsIGFsbCBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQm9keS5wcm90b3R5cGUsIHtcblx0Ym9keTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGJvZHlVc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0YXJyYXlCdWZmZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRibG9iOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0anNvbjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHRleHQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuQm9keS5taXhJbiA9IGZ1bmN0aW9uIChwcm90bykge1xuXHRmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoQm9keS5wcm90b3R5cGUpKSB7XG5cdFx0Ly8gaXN0YW5idWwgaWdub3JlIGVsc2U6IGZ1dHVyZSBwcm9vZlxuXHRcdGlmICghKG5hbWUgaW4gcHJvdG8pKSB7XG5cdFx0XHRjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihCb2R5LnByb3RvdHlwZSwgbmFtZSk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIGRlc2MpO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBDb25zdW1lIGFuZCBjb252ZXJ0IGFuIGVudGlyZSBCb2R5IHRvIGEgQnVmZmVyLlxuICpcbiAqIFJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jb25zdW1lLWJvZHlcbiAqXG4gKiBAcmV0dXJuICBQcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVCb2R5KCkge1xuXHR2YXIgX3RoaXM0ID0gdGhpcztcblxuXHRpZiAodGhpc1tJTlRFUk5BTFNdLmRpc3R1cmJlZCkge1xuXHRcdHJldHVybiBCb2R5LlByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoYGJvZHkgdXNlZCBhbHJlYWR5IGZvcjogJHt0aGlzLnVybH1gKSk7XG5cdH1cblxuXHR0aGlzW0lOVEVSTkFMU10uZGlzdHVyYmVkID0gdHJ1ZTtcblxuXHRpZiAodGhpc1tJTlRFUk5BTFNdLmVycm9yKSB7XG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZWplY3QodGhpc1tJTlRFUk5BTFNdLmVycm9yKTtcblx0fVxuXG5cdC8vIGJvZHkgaXMgbnVsbFxuXHRpZiAodGhpcy5ib2R5ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZXNvbHZlKEJ1ZmZlci5hbGxvYygwKSk7XG5cdH1cblxuXHQvLyBib2R5IGlzIHN0cmluZ1xuXHRpZiAodHlwZW9mIHRoaXMuYm9keSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlc29sdmUoQnVmZmVyLmZyb20odGhpcy5ib2R5KSk7XG5cdH1cblxuXHQvLyBib2R5IGlzIGJsb2Jcblx0aWYgKHRoaXMuYm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlc29sdmUodGhpcy5ib2R5W0JVRkZFUl0pO1xuXHR9XG5cblx0Ly8gYm9keSBpcyBidWZmZXJcblx0aWYgKEJ1ZmZlci5pc0J1ZmZlcih0aGlzLmJvZHkpKSB7XG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZXNvbHZlKHRoaXMuYm9keSk7XG5cdH1cblxuXHQvLyBib2R5IGlzIGJ1ZmZlclxuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuYm9keSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcblx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlc29sdmUoQnVmZmVyLmZyb20odGhpcy5ib2R5KSk7XG5cdH1cblxuXHQvLyBpc3RhbmJ1bCBpZ25vcmUgaWY6IHNob3VsZCBuZXZlciBoYXBwZW5cblx0aWYgKCEodGhpcy5ib2R5IGluc3RhbmNlb2YgU3RyZWFtKSkge1xuXHRcdHJldHVybiBCb2R5LlByb21pc2UucmVzb2x2ZShCdWZmZXIuYWxsb2MoMCkpO1xuXHR9XG5cblx0Ly8gYm9keSBpcyBzdHJlYW1cblx0Ly8gZ2V0IHJlYWR5IHRvIGFjdHVhbGx5IGNvbnN1bWUgdGhlIGJvZHlcblx0bGV0IGFjY3VtID0gW107XG5cdGxldCBhY2N1bUJ5dGVzID0gMDtcblx0bGV0IGFib3J0ID0gZmFsc2U7XG5cblx0cmV0dXJuIG5ldyBCb2R5LlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdGxldCByZXNUaW1lb3V0O1xuXG5cdFx0Ly8gYWxsb3cgdGltZW91dCBvbiBzbG93IHJlc3BvbnNlIGJvZHlcblx0XHRpZiAoX3RoaXM0LnRpbWVvdXQpIHtcblx0XHRcdHJlc1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0YWJvcnQgPSB0cnVlO1xuXHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYFJlc3BvbnNlIHRpbWVvdXQgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7X3RoaXM0LnVybH0gKG92ZXIgJHtfdGhpczQudGltZW91dH1tcylgLCAnYm9keS10aW1lb3V0JykpO1xuXHRcdFx0fSwgX3RoaXM0LnRpbWVvdXQpO1xuXHRcdH1cblxuXHRcdC8vIGhhbmRsZSBzdHJlYW0gZXJyb3IsIHN1Y2ggYXMgaW5jb3JyZWN0IGNvbnRlbnQtZW5jb2Rpbmdcblx0XHRfdGhpczQuYm9keS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtfdGhpczQudXJsfTogJHtlcnIubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyKSk7XG5cdFx0fSk7XG5cblx0XHRfdGhpczQuYm9keS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuXHRcdFx0aWYgKGFib3J0IHx8IGNodW5rID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKF90aGlzNC5zaXplICYmIGFjY3VtQnl0ZXMgKyBjaHVuay5sZW5ndGggPiBfdGhpczQuc2l6ZSkge1xuXHRcdFx0XHRhYm9ydCA9IHRydWU7XG5cdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgY29udGVudCBzaXplIGF0ICR7X3RoaXM0LnVybH0gb3ZlciBsaW1pdDogJHtfdGhpczQuc2l6ZX1gLCAnbWF4LXNpemUnKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0YWNjdW1CeXRlcyArPSBjaHVuay5sZW5ndGg7XG5cdFx0XHRhY2N1bS5wdXNoKGNodW5rKTtcblx0XHR9KTtcblxuXHRcdF90aGlzNC5ib2R5Lm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoYWJvcnQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjbGVhclRpbWVvdXQocmVzVGltZW91dCk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJlc29sdmUoQnVmZmVyLmNvbmNhdChhY2N1bSkpO1xuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdC8vIGhhbmRsZSBzdHJlYW1zIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0b28gbXVjaCBkYXRhIChpc3N1ZSAjNDE0KVxuXHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYENvdWxkIG5vdCBjcmVhdGUgQnVmZmVyIGZyb20gcmVzcG9uc2UgYm9keSBmb3IgJHtfdGhpczQudXJsfTogJHtlcnIubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIERldGVjdCBidWZmZXIgZW5jb2RpbmcgYW5kIGNvbnZlcnQgdG8gdGFyZ2V0IGVuY29kaW5nXG4gKiByZWY6IGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTAxMTMvcGFyc2luZy5odG1sI2RldGVybWluaW5nLXRoZS1jaGFyYWN0ZXItZW5jb2RpbmdcbiAqXG4gKiBAcGFyYW0gICBCdWZmZXIgIGJ1ZmZlciAgICBJbmNvbWluZyBidWZmZXJcbiAqIEBwYXJhbSAgIFN0cmluZyAgZW5jb2RpbmcgIFRhcmdldCBlbmNvZGluZ1xuICogQHJldHVybiAgU3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRCb2R5KGJ1ZmZlciwgaGVhZGVycykge1xuXHRpZiAodHlwZW9mIGNvbnZlcnQgIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYWNrYWdlIGBlbmNvZGluZ2AgbXVzdCBiZSBpbnN0YWxsZWQgdG8gdXNlIHRoZSB0ZXh0Q29udmVydGVkKCkgZnVuY3Rpb24nKTtcblx0fVxuXG5cdGNvbnN0IGN0ID0gaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuXHRsZXQgY2hhcnNldCA9ICd1dGYtOCc7XG5cdGxldCByZXMsIHN0cjtcblxuXHQvLyBoZWFkZXJcblx0aWYgKGN0KSB7XG5cdFx0cmVzID0gL2NoYXJzZXQ9KFteO10qKS9pLmV4ZWMoY3QpO1xuXHR9XG5cblx0Ly8gbm8gY2hhcnNldCBpbiBjb250ZW50IHR5cGUsIHBlZWsgYXQgcmVzcG9uc2UgYm9keSBmb3IgYXQgbW9zdCAxMDI0IGJ5dGVzXG5cdHN0ciA9IGJ1ZmZlci5zbGljZSgwLCAxMDI0KS50b1N0cmluZygpO1xuXG5cdC8vIGh0bWw1XG5cdGlmICghcmVzICYmIHN0cikge1xuXHRcdHJlcyA9IC88bWV0YS4rP2NoYXJzZXQ9KFsnXCJdKSguKz8pXFwxL2kuZXhlYyhzdHIpO1xuXHR9XG5cblx0Ly8gaHRtbDRcblx0aWYgKCFyZXMgJiYgc3RyKSB7XG5cdFx0cmVzID0gLzxtZXRhW1xcc10rP2h0dHAtZXF1aXY9KFsnXCJdKWNvbnRlbnQtdHlwZVxcMVtcXHNdKz9jb250ZW50PShbJ1wiXSkoLis/KVxcMi9pLmV4ZWMoc3RyKTtcblxuXHRcdGlmIChyZXMpIHtcblx0XHRcdHJlcyA9IC9jaGFyc2V0PSguKikvaS5leGVjKHJlcy5wb3AoKSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8geG1sXG5cdGlmICghcmVzICYmIHN0cikge1xuXHRcdHJlcyA9IC88XFw/eG1sLis/ZW5jb2Rpbmc9KFsnXCJdKSguKz8pXFwxL2kuZXhlYyhzdHIpO1xuXHR9XG5cblx0Ly8gZm91bmQgY2hhcnNldFxuXHRpZiAocmVzKSB7XG5cdFx0Y2hhcnNldCA9IHJlcy5wb3AoKTtcblxuXHRcdC8vIHByZXZlbnQgZGVjb2RlIGlzc3VlcyB3aGVuIHNpdGVzIHVzZSBpbmNvcnJlY3QgZW5jb2Rpbmdcblx0XHQvLyByZWY6IGh0dHBzOi8vaHNpdm9uZW4uZmkvZW5jb2RpbmctbWVudS9cblx0XHRpZiAoY2hhcnNldCA9PT0gJ2diMjMxMicgfHwgY2hhcnNldCA9PT0gJ2diaycpIHtcblx0XHRcdGNoYXJzZXQgPSAnZ2IxODAzMCc7XG5cdFx0fVxuXHR9XG5cblx0Ly8gdHVybiByYXcgYnVmZmVycyBpbnRvIGEgc2luZ2xlIHV0Zi04IGJ1ZmZlclxuXHRyZXR1cm4gY29udmVydChidWZmZXIsICdVVEYtOCcsIGNoYXJzZXQpLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogRGV0ZWN0IGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICogcmVmOiBodHRwczovL2dpdGh1Yi5jb20vYml0aW5uL25vZGUtZmV0Y2gvaXNzdWVzLzI5NiNpc3N1ZWNvbW1lbnQtMzA3NTk4MTQzXG4gKlxuICogQHBhcmFtICAgT2JqZWN0ICBvYmogICAgIE9iamVjdCB0byBkZXRlY3QgYnkgdHlwZSBvciBicmFuZFxuICogQHJldHVybiAgU3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKG9iaikge1xuXHQvLyBEdWNrLXR5cGluZyBhcyBhIG5lY2Vzc2FyeSBjb25kaXRpb24uXG5cdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqLmFwcGVuZCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmRlbGV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmdldEFsbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmhhcyAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIEJyYW5kLWNoZWNraW5nIGFuZCBtb3JlIGR1Y2stdHlwaW5nIGFzIG9wdGlvbmFsIGNvbmRpdGlvbi5cblx0cmV0dXJuIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVVJMU2VhcmNoUGFyYW1zJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgVVJMU2VhcmNoUGFyYW1zXScgfHwgdHlwZW9mIG9iai5zb3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIENsb25lIGJvZHkgZ2l2ZW4gUmVzL1JlcSBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAgIE1peGVkICBpbnN0YW5jZSAgUmVzcG9uc2Ugb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHJldHVybiAgTWl4ZWRcbiAqL1xuZnVuY3Rpb24gY2xvbmUoaW5zdGFuY2UpIHtcblx0bGV0IHAxLCBwMjtcblx0bGV0IGJvZHkgPSBpbnN0YW5jZS5ib2R5O1xuXG5cdC8vIGRvbid0IGFsbG93IGNsb25pbmcgYSB1c2VkIGJvZHlcblx0aWYgKGluc3RhbmNlLmJvZHlVc2VkKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2xvbmUgYm9keSBhZnRlciBpdCBpcyB1c2VkJyk7XG5cdH1cblxuXHQvLyBjaGVjayB0aGF0IGJvZHkgaXMgYSBzdHJlYW0gYW5kIG5vdCBmb3JtLWRhdGEgb2JqZWN0XG5cdC8vIG5vdGU6IHdlIGNhbid0IGNsb25lIHRoZSBmb3JtLWRhdGEgb2JqZWN0IHdpdGhvdXQgaGF2aW5nIGl0IGFzIGEgZGVwZW5kZW5jeVxuXHRpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSAmJiB0eXBlb2YgYm9keS5nZXRCb3VuZGFyeSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIHRlZSBpbnN0YW5jZSBib2R5XG5cdFx0cDEgPSBuZXcgUGFzc1Rocm91Z2goKTtcblx0XHRwMiA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuXHRcdGJvZHkucGlwZShwMSk7XG5cdFx0Ym9keS5waXBlKHAyKTtcblx0XHQvLyBzZXQgaW5zdGFuY2UgYm9keSB0byB0ZWVkIGJvZHkgYW5kIHJldHVybiB0aGUgb3RoZXIgdGVlZCBib2R5XG5cdFx0aW5zdGFuY2VbSU5URVJOQUxTXS5ib2R5ID0gcDE7XG5cdFx0Ym9keSA9IHAyO1xuXHR9XG5cblx0cmV0dXJuIGJvZHk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgdGhlIG9wZXJhdGlvbiBcImV4dHJhY3QgYSBgQ29udGVudC1UeXBlYCB2YWx1ZSBmcm9tIHxvYmplY3R8XCIgYXNcbiAqIHNwZWNpZmllZCBpbiB0aGUgc3BlY2lmaWNhdGlvbjpcbiAqIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHlpbml0LWV4dHJhY3RcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBpbnN0YW5jZS5ib2R5IGlzIHByZXNlbnQuXG4gKlxuICogQHBhcmFtICAgTWl4ZWQgIGluc3RhbmNlICBSZXNwb25zZSBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb250ZW50VHlwZShpbnN0YW5jZSkge1xuXHRjb25zdCBib2R5ID0gaW5zdGFuY2UuYm9keTtcblxuXHQvLyBpc3RhbmJ1bCBpZ25vcmUgaWY6IEN1cnJlbnRseSwgYmVjYXVzZSBvZiBhIGd1YXJkIGluIFJlcXVlc3QsIGJvZHlcblx0Ly8gY2FuIG5ldmVyIGJlIG51bGwuIEluY2x1ZGVkIGhlcmUgZm9yIGNvbXBsZXRlbmVzcy5cblxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdC8vIGJvZHkgaXMgbnVsbFxuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuXHRcdC8vIGJvZHkgaXMgc3RyaW5nXG5cdFx0cmV0dXJuICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnO1xuXHR9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBhIFVSTFNlYXJjaFBhcmFtc1xuXHRcdHJldHVybiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnO1xuXHR9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0Ly8gYm9keSBpcyBibG9iXG5cdFx0cmV0dXJuIGJvZHkudHlwZSB8fCBudWxsO1xuXHR9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkge1xuXHRcdC8vIGJvZHkgaXMgYnVmZmVyXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG5cdFx0Ly8gYm9keSBpcyBhcnJheSBidWZmZXJcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIGlmICh0eXBlb2YgYm9keS5nZXRCb3VuZGFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIGRldGVjdCBmb3JtIGRhdGEgaW5wdXQgZnJvbSBmb3JtLWRhdGEgbW9kdWxlXG5cdFx0cmV0dXJuIGBtdWx0aXBhcnQvZm9ybS1kYXRhO2JvdW5kYXJ5PSR7Ym9keS5nZXRCb3VuZGFyeSgpfWA7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gYm9keSBpcyBzdHJlYW1cblx0XHQvLyBjYW4ndCByZWFsbHkgZG8gbXVjaCBhYm91dCB0aGlzXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgRmV0Y2ggU3RhbmRhcmQgdHJlYXRzIHRoaXMgYXMgaWYgXCJ0b3RhbCBieXRlc1wiIGlzIGEgcHJvcGVydHkgb24gdGhlIGJvZHkuXG4gKiBGb3IgdXMsIHdlIGhhdmUgdG8gZXhwbGljaXRseSBnZXQgaXQgd2l0aCBhIGZ1bmN0aW9uLlxuICpcbiAqIHJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS10b3RhbC1ieXRlc1xuICpcbiAqIEBwYXJhbSAgIEJvZHkgICAgaW5zdGFuY2UgICBJbnN0YW5jZSBvZiBCb2R5XG4gKiBAcmV0dXJuICBOdW1iZXI/ICAgICAgICAgICAgTnVtYmVyIG9mIGJ5dGVzLCBvciBudWxsIGlmIG5vdCBwb3NzaWJsZVxuICovXG5mdW5jdGlvbiBnZXRUb3RhbEJ5dGVzKGluc3RhbmNlKSB7XG5cdGNvbnN0IGJvZHkgPSBpbnN0YW5jZS5ib2R5O1xuXG5cdC8vIGlzdGFuYnVsIGlnbm9yZSBpZjogaW5jbHVkZWQgZm9yIGNvbXBsZXRpb25cblxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdC8vIGJvZHkgaXMgbnVsbFxuXHRcdHJldHVybiAwO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuXHRcdC8vIGJvZHkgaXMgc3RyaW5nXG5cdFx0cmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKGJvZHkpO1xuXHR9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBVUkxTZWFyY2hQYXJhbXNcblx0XHRyZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoU3RyaW5nKGJvZHkpKTtcblx0fSBlbHNlIGlmIChib2R5IGluc3RhbmNlb2YgQmxvYikge1xuXHRcdC8vIGJvZHkgaXMgYmxvYlxuXHRcdHJldHVybiBib2R5LnNpemU7XG5cdH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBidWZmZXJcblx0XHRyZXR1cm4gYm9keS5sZW5ndGg7XG5cdH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG5cdFx0Ly8gYm9keSBpcyBhcnJheSBidWZmZXJcblx0XHRyZXR1cm4gYm9keS5ieXRlTGVuZ3RoO1xuXHR9IGVsc2UgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkuZ2V0TGVuZ3RoU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIGRldGVjdCBmb3JtIGRhdGEgaW5wdXQgZnJvbSBmb3JtLWRhdGEgbW9kdWxlXG5cdFx0aWYgKGJvZHkuX2xlbmd0aFJldHJpZXZlcnMgJiYgYm9keS5fbGVuZ3RoUmV0cmlldmVycy5sZW5ndGggPT0gMCB8fCAvLyAxLnhcblx0XHRib2R5Lmhhc0tub3duTGVuZ3RoICYmIGJvZHkuaGFzS25vd25MZW5ndGgoKSkge1xuXHRcdFx0Ly8gMi54XG5cdFx0XHRyZXR1cm4gYm9keS5nZXRMZW5ndGhTeW5jKCk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdC8vIGJvZHkgaXMgc3RyZWFtXG5cdFx0Ly8gY2FuJ3QgcmVhbGx5IGRvIG11Y2ggYWJvdXQgdGhpc1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogV3JpdGUgYSBCb2R5IHRvIGEgTm9kZS5qcyBXcml0YWJsZVN0cmVhbSAoZS5nLiBodHRwLlJlcXVlc3QpIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gICBCb2R5ICAgIGluc3RhbmNlICAgSW5zdGFuY2Ugb2YgQm9keVxuICogQHJldHVybiAgVm9pZFxuICovXG5mdW5jdGlvbiB3cml0ZVRvU3RyZWFtKGRlc3QsIGluc3RhbmNlKSB7XG5cdGNvbnN0IGJvZHkgPSBpbnN0YW5jZS5ib2R5O1xuXG5cblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHQvLyBib2R5IGlzIG51bGxcblx0XHRkZXN0LmVuZCgpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuXHRcdC8vIGJvZHkgaXMgc3RyaW5nXG5cdFx0ZGVzdC53cml0ZShib2R5KTtcblx0XHRkZXN0LmVuZCgpO1xuXHR9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBVUkxTZWFyY2hQYXJhbXNcblx0XHRkZXN0LndyaXRlKEJ1ZmZlci5mcm9tKFN0cmluZyhib2R5KSkpO1xuXHRcdGRlc3QuZW5kKCk7XG5cdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHQvLyBib2R5IGlzIGJsb2Jcblx0XHRkZXN0LndyaXRlKGJvZHlbQlVGRkVSXSk7XG5cdFx0ZGVzdC5lbmQoKTtcblx0fSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIGJ1ZmZlclxuXHRcdGRlc3Qud3JpdGUoYm9keSk7XG5cdFx0ZGVzdC5lbmQoKTtcblx0fSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcblx0XHQvLyBib2R5IGlzIGFycmF5IGJ1ZmZlclxuXHRcdGRlc3Qud3JpdGUoQnVmZmVyLmZyb20oYm9keSkpO1xuXHRcdGRlc3QuZW5kKCk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gYm9keSBpcyBzdHJlYW1cblx0XHRib2R5LnBpcGUoZGVzdCk7XG5cdH1cbn1cblxuLy8gZXhwb3NlIFByb21pc2VcbkJvZHkuUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xuXG4vKipcbiAqIGhlYWRlcnMuanNcbiAqXG4gKiBIZWFkZXJzIGNsYXNzIG9mZmVycyBjb252ZW5pZW50IGhlbHBlcnNcbiAqL1xuXG5jb25zdCBpbnZhbGlkVG9rZW5SZWdleCA9IC9bXlxcXl9gYS16QS1aXFwtMC05ISMkJSYnKisufH5dLztcbmNvbnN0IGludmFsaWRIZWFkZXJDaGFyUmVnZXggPSAvW15cXHRcXHgyMC1cXHg3ZVxceDgwLVxceGZmXS87XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZShuYW1lKSB7XG5cdG5hbWUgPSBgJHtuYW1lfWA7XG5cdGlmIChpbnZhbGlkVG9rZW5SZWdleC50ZXN0KG5hbWUpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgJHtuYW1lfSBpcyBub3QgYSBsZWdhbCBIVFRQIGhlYWRlciBuYW1lYCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWx1ZSkge1xuXHR2YWx1ZSA9IGAke3ZhbHVlfWA7XG5cdGlmIChpbnZhbGlkSGVhZGVyQ2hhclJlZ2V4LnRlc3QodmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgbGVnYWwgSFRUUCBoZWFkZXIgdmFsdWVgKTtcblx0fVxufVxuXG4vKipcbiAqIEZpbmQgdGhlIGtleSBpbiB0aGUgbWFwIG9iamVjdCBnaXZlbiBhIGhlYWRlciBuYW1lLlxuICpcbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAqXG4gKiBAcGFyYW0gICBTdHJpbmcgIG5hbWUgIEhlYWRlciBuYW1lXG4gKiBAcmV0dXJuICBTdHJpbmd8VW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGZpbmQobWFwLCBuYW1lKSB7XG5cdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuXHRcdGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSkge1xuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3QgTUFQID0gU3ltYm9sKCdtYXAnKTtcbmNsYXNzIEhlYWRlcnMge1xuXHQvKipcbiAgKiBIZWFkZXJzIGNsYXNzXG4gICpcbiAgKiBAcGFyYW0gICBPYmplY3QgIGhlYWRlcnMgIFJlc3BvbnNlIGhlYWRlcnNcbiAgKiBAcmV0dXJuICBWb2lkXG4gICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGxldCBpbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG5cblx0XHR0aGlzW01BUF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdFx0aWYgKGluaXQgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG5cdFx0XHRjb25zdCByYXdIZWFkZXJzID0gaW5pdC5yYXcoKTtcblx0XHRcdGNvbnN0IGhlYWRlck5hbWVzID0gT2JqZWN0LmtleXMocmF3SGVhZGVycyk7XG5cblx0XHRcdGZvciAoY29uc3QgaGVhZGVyTmFtZSBvZiBoZWFkZXJOYW1lcykge1xuXHRcdFx0XHRmb3IgKGNvbnN0IHZhbHVlIG9mIHJhd0hlYWRlcnNbaGVhZGVyTmFtZV0pIHtcblx0XHRcdFx0XHR0aGlzLmFwcGVuZChoZWFkZXJOYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFdlIGRvbid0IHdvcnJ5IGFib3V0IGNvbnZlcnRpbmcgcHJvcCB0byBCeXRlU3RyaW5nIGhlcmUgYXMgYXBwZW5kKClcblx0XHQvLyB3aWxsIGhhbmRsZSBpdC5cblx0XHRpZiAoaW5pdCA9PSBudWxsKSB7XG5cdFx0XHQvLyBubyBvcFxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGluaXQgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRjb25zdCBtZXRob2QgPSBpbml0W1N5bWJvbC5pdGVyYXRvcl07XG5cdFx0XHRpZiAobWV0aG9kICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdIZWFkZXIgcGFpcnMgbXVzdCBiZSBpdGVyYWJsZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+XG5cdFx0XHRcdC8vIE5vdGU6IHBlciBzcGVjIHdlIGhhdmUgdG8gZmlyc3QgZXhoYXVzdCB0aGUgbGlzdHMgdGhlbiBwcm9jZXNzIHRoZW1cblx0XHRcdFx0Y29uc3QgcGFpcnMgPSBbXTtcblx0XHRcdFx0Zm9yIChjb25zdCBwYWlyIG9mIGluaXQpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIHBhaXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYWlyW1N5bWJvbC5pdGVyYXRvcl0gIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0VhY2ggaGVhZGVyIHBhaXIgbXVzdCBiZSBpdGVyYWJsZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYWlycy5wdXNoKEFycmF5LmZyb20ocGFpcikpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG5cdFx0XHRcdFx0aWYgKHBhaXIubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYSBuYW1lL3ZhbHVlIHR1cGxlJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuYXBwZW5kKHBhaXJbMF0sIHBhaXJbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyByZWNvcmQ8Qnl0ZVN0cmluZywgQnl0ZVN0cmluZz5cblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5pdCkpIHtcblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IGluaXRba2V5XTtcblx0XHRcdFx0XHR0aGlzLmFwcGVuZChrZXksIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm92aWRlZCBpbml0aWFsaXplciBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuICAqIFJldHVybiBjb21iaW5lZCBoZWFkZXIgdmFsdWUgZ2l2ZW4gbmFtZVxuICAqXG4gICogQHBhcmFtICAgU3RyaW5nICBuYW1lICBIZWFkZXIgbmFtZVxuICAqIEByZXR1cm4gIE1peGVkXG4gICovXG5cdGdldChuYW1lKSB7XG5cdFx0bmFtZSA9IGAke25hbWV9YDtcblx0XHR2YWxpZGF0ZU5hbWUobmFtZSk7XG5cdFx0Y29uc3Qga2V5ID0gZmluZCh0aGlzW01BUF0sIG5hbWUpO1xuXHRcdGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXNbTUFQXVtrZXldLmpvaW4oJywgJyk7XG5cdH1cblxuXHQvKipcbiAgKiBJdGVyYXRlIG92ZXIgYWxsIGhlYWRlcnNcbiAgKlxuICAqIEBwYXJhbSAgIEZ1bmN0aW9uICBjYWxsYmFjayAgRXhlY3V0ZWQgZm9yIGVhY2ggaXRlbSB3aXRoIHBhcmFtZXRlcnMgKHZhbHVlLCBuYW1lLCB0aGlzQXJnKVxuICAqIEBwYXJhbSAgIEJvb2xlYW4gICB0aGlzQXJnICAgYHRoaXNgIGNvbnRleHQgZm9yIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICogQHJldHVybiAgVm9pZFxuICAqL1xuXHRmb3JFYWNoKGNhbGxiYWNrKSB7XG5cdFx0bGV0IHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcblxuXHRcdGxldCBwYWlycyA9IGdldEhlYWRlcnModGhpcyk7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdHdoaWxlIChpIDwgcGFpcnMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgX3BhaXJzJGkgPSBwYWlyc1tpXTtcblx0XHRcdGNvbnN0IG5hbWUgPSBfcGFpcnMkaVswXSxcblx0XHRcdCAgICAgIHZhbHVlID0gX3BhaXJzJGlbMV07XG5cblx0XHRcdGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdmFsdWUsIG5hbWUsIHRoaXMpO1xuXHRcdFx0cGFpcnMgPSBnZXRIZWFkZXJzKHRoaXMpO1xuXHRcdFx0aSsrO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuICAqIE92ZXJ3cml0ZSBoZWFkZXIgdmFsdWVzIGdpdmVuIG5hbWVcbiAgKlxuICAqIEBwYXJhbSAgIFN0cmluZyAgbmFtZSAgIEhlYWRlciBuYW1lXG4gICogQHBhcmFtICAgU3RyaW5nICB2YWx1ZSAgSGVhZGVyIHZhbHVlXG4gICogQHJldHVybiAgVm9pZFxuICAqL1xuXHRzZXQobmFtZSwgdmFsdWUpIHtcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xuXHRcdHZhbHVlID0gYCR7dmFsdWV9YDtcblx0XHR2YWxpZGF0ZU5hbWUobmFtZSk7XG5cdFx0dmFsaWRhdGVWYWx1ZSh2YWx1ZSk7XG5cdFx0Y29uc3Qga2V5ID0gZmluZCh0aGlzW01BUF0sIG5hbWUpO1xuXHRcdHRoaXNbTUFQXVtrZXkgIT09IHVuZGVmaW5lZCA/IGtleSA6IG5hbWVdID0gW3ZhbHVlXTtcblx0fVxuXG5cdC8qKlxuICAqIEFwcGVuZCBhIHZhbHVlIG9udG8gZXhpc3RpbmcgaGVhZGVyXG4gICpcbiAgKiBAcGFyYW0gICBTdHJpbmcgIG5hbWUgICBIZWFkZXIgbmFtZVxuICAqIEBwYXJhbSAgIFN0cmluZyAgdmFsdWUgIEhlYWRlciB2YWx1ZVxuICAqIEByZXR1cm4gIFZvaWRcbiAgKi9cblx0YXBwZW5kKG5hbWUsIHZhbHVlKSB7XG5cdFx0bmFtZSA9IGAke25hbWV9YDtcblx0XHR2YWx1ZSA9IGAke3ZhbHVlfWA7XG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xuXHRcdHZhbGlkYXRlVmFsdWUodmFsdWUpO1xuXHRcdGNvbnN0IGtleSA9IGZpbmQodGhpc1tNQVBdLCBuYW1lKTtcblx0XHRpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXNbTUFQXVtrZXldLnB1c2godmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzW01BUF1bbmFtZV0gPSBbdmFsdWVdO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuICAqIENoZWNrIGZvciBoZWFkZXIgbmFtZSBleGlzdGVuY2VcbiAgKlxuICAqIEBwYXJhbSAgIFN0cmluZyAgIG5hbWUgIEhlYWRlciBuYW1lXG4gICogQHJldHVybiAgQm9vbGVhblxuICAqL1xuXHRoYXMobmFtZSkge1xuXHRcdG5hbWUgPSBgJHtuYW1lfWA7XG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xuXHRcdHJldHVybiBmaW5kKHRoaXNbTUFQXSwgbmFtZSkgIT09IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuICAqIERlbGV0ZSBhbGwgaGVhZGVyIHZhbHVlcyBnaXZlbiBuYW1lXG4gICpcbiAgKiBAcGFyYW0gICBTdHJpbmcgIG5hbWUgIEhlYWRlciBuYW1lXG4gICogQHJldHVybiAgVm9pZFxuICAqL1xuXHRkZWxldGUobmFtZSkge1xuXHRcdG5hbWUgPSBgJHtuYW1lfWA7XG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xuXHRcdGNvbnN0IGtleSA9IGZpbmQodGhpc1tNQVBdLCBuYW1lKTtcblx0XHRpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGRlbGV0ZSB0aGlzW01BUF1ba2V5XTtcblx0XHR9XG5cdH1cblxuXHQvKipcbiAgKiBSZXR1cm4gcmF3IGhlYWRlcnMgKG5vbi1zcGVjIGFwaSlcbiAgKlxuICAqIEByZXR1cm4gIE9iamVjdFxuICAqL1xuXHRyYXcoKSB7XG5cdFx0cmV0dXJuIHRoaXNbTUFQXTtcblx0fVxuXG5cdC8qKlxuICAqIEdldCBhbiBpdGVyYXRvciBvbiBrZXlzLlxuICAqXG4gICogQHJldHVybiAgSXRlcmF0b3JcbiAgKi9cblx0a2V5cygpIHtcblx0XHRyZXR1cm4gY3JlYXRlSGVhZGVyc0l0ZXJhdG9yKHRoaXMsICdrZXknKTtcblx0fVxuXG5cdC8qKlxuICAqIEdldCBhbiBpdGVyYXRvciBvbiB2YWx1ZXMuXG4gICpcbiAgKiBAcmV0dXJuICBJdGVyYXRvclxuICAqL1xuXHR2YWx1ZXMoKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZUhlYWRlcnNJdGVyYXRvcih0aGlzLCAndmFsdWUnKTtcblx0fVxuXG5cdC8qKlxuICAqIEdldCBhbiBpdGVyYXRvciBvbiBlbnRyaWVzLlxuICAqXG4gICogVGhpcyBpcyB0aGUgZGVmYXVsdCBpdGVyYXRvciBvZiB0aGUgSGVhZGVycyBvYmplY3QuXG4gICpcbiAgKiBAcmV0dXJuICBJdGVyYXRvclxuICAqL1xuXHRbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblx0XHRyZXR1cm4gY3JlYXRlSGVhZGVyc0l0ZXJhdG9yKHRoaXMsICdrZXkrdmFsdWUnKTtcblx0fVxufVxuSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWFkZXJzLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG5cdHZhbHVlOiAnSGVhZGVycycsXG5cdHdyaXRhYmxlOiBmYWxzZSxcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEhlYWRlcnMucHJvdG90eXBlLCB7XG5cdGdldDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGZvckVhY2g6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRzZXQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRhcHBlbmQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRoYXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRkZWxldGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRrZXlzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0dmFsdWVzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0ZW50cmllczogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRIZWFkZXJzKGhlYWRlcnMpIHtcblx0bGV0IGtpbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdrZXkrdmFsdWUnO1xuXG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzW01BUF0pLnNvcnQoKTtcblx0cmV0dXJuIGtleXMubWFwKGtpbmQgPT09ICdrZXknID8gZnVuY3Rpb24gKGspIHtcblx0XHRyZXR1cm4gay50b0xvd2VyQ2FzZSgpO1xuXHR9IDoga2luZCA9PT0gJ3ZhbHVlJyA/IGZ1bmN0aW9uIChrKSB7XG5cdFx0cmV0dXJuIGhlYWRlcnNbTUFQXVtrXS5qb2luKCcsICcpO1xuXHR9IDogZnVuY3Rpb24gKGspIHtcblx0XHRyZXR1cm4gW2sudG9Mb3dlckNhc2UoKSwgaGVhZGVyc1tNQVBdW2tdLmpvaW4oJywgJyldO1xuXHR9KTtcbn1cblxuY29uc3QgSU5URVJOQUwgPSBTeW1ib2woJ2ludGVybmFsJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnNJdGVyYXRvcih0YXJnZXQsIGtpbmQpIHtcblx0Y29uc3QgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKEhlYWRlcnNJdGVyYXRvclByb3RvdHlwZSk7XG5cdGl0ZXJhdG9yW0lOVEVSTkFMXSA9IHtcblx0XHR0YXJnZXQsXG5cdFx0a2luZCxcblx0XHRpbmRleDogMFxuXHR9O1xuXHRyZXR1cm4gaXRlcmF0b3I7XG59XG5cbmNvbnN0IEhlYWRlcnNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZih7XG5cdG5leHQoKSB7XG5cdFx0Ly8gaXN0YW5idWwgaWdub3JlIGlmXG5cdFx0aWYgKCF0aGlzIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSAhPT0gSGVhZGVyc0l0ZXJhdG9yUHJvdG90eXBlKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBvZiBgdGhpc2AgaXMgbm90IGEgSGVhZGVyc0l0ZXJhdG9yJyk7XG5cdFx0fVxuXG5cdFx0dmFyIF9JTlRFUk5BTCA9IHRoaXNbSU5URVJOQUxdO1xuXHRcdGNvbnN0IHRhcmdldCA9IF9JTlRFUk5BTC50YXJnZXQsXG5cdFx0ICAgICAga2luZCA9IF9JTlRFUk5BTC5raW5kLFxuXHRcdCAgICAgIGluZGV4ID0gX0lOVEVSTkFMLmluZGV4O1xuXG5cdFx0Y29uc3QgdmFsdWVzID0gZ2V0SGVhZGVycyh0YXJnZXQsIGtpbmQpO1xuXHRcdGNvbnN0IGxlbiA9IHZhbHVlcy5sZW5ndGg7XG5cdFx0aWYgKGluZGV4ID49IGxlbikge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dmFsdWU6IHVuZGVmaW5lZCxcblx0XHRcdFx0ZG9uZTogdHJ1ZVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR0aGlzW0lOVEVSTkFMXS5pbmRleCA9IGluZGV4ICsgMTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR2YWx1ZTogdmFsdWVzW2luZGV4XSxcblx0XHRcdGRvbmU6IGZhbHNlXG5cdFx0fTtcblx0fVxufSwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIZWFkZXJzSXRlcmF0b3JQcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuXHR2YWx1ZTogJ0hlYWRlcnNJdGVyYXRvcicsXG5cdHdyaXRhYmxlOiBmYWxzZSxcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogRXhwb3J0IHRoZSBIZWFkZXJzIG9iamVjdCBpbiBhIGZvcm0gdGhhdCBOb2RlLmpzIGNhbiBjb25zdW1lLlxuICpcbiAqIEBwYXJhbSAgIEhlYWRlcnMgIGhlYWRlcnNcbiAqIEByZXR1cm4gIE9iamVjdFxuICovXG5mdW5jdGlvbiBleHBvcnROb2RlQ29tcGF0aWJsZUhlYWRlcnMoaGVhZGVycykge1xuXHRjb25zdCBvYmogPSBPYmplY3QuYXNzaWduKHsgX19wcm90b19fOiBudWxsIH0sIGhlYWRlcnNbTUFQXSk7XG5cblx0Ly8gaHR0cC5yZXF1ZXN0KCkgb25seSBzdXBwb3J0cyBzdHJpbmcgYXMgSG9zdCBoZWFkZXIuIFRoaXMgaGFjayBtYWtlc1xuXHQvLyBzcGVjaWZ5aW5nIGN1c3RvbSBIb3N0IGhlYWRlciBwb3NzaWJsZS5cblx0Y29uc3QgaG9zdEhlYWRlcktleSA9IGZpbmQoaGVhZGVyc1tNQVBdLCAnSG9zdCcpO1xuXHRpZiAoaG9zdEhlYWRlcktleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0b2JqW2hvc3RIZWFkZXJLZXldID0gb2JqW2hvc3RIZWFkZXJLZXldWzBdO1xuXHR9XG5cblx0cmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBIZWFkZXJzIG9iamVjdCBmcm9tIGFuIG9iamVjdCBvZiBoZWFkZXJzLCBpZ25vcmluZyB0aG9zZSB0aGF0IGRvXG4gKiBub3QgY29uZm9ybSB0byBIVFRQIGdyYW1tYXIgcHJvZHVjdGlvbnMuXG4gKlxuICogQHBhcmFtICAgT2JqZWN0ICBvYmogIE9iamVjdCBvZiBoZWFkZXJzXG4gKiBAcmV0dXJuICBIZWFkZXJzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnNMZW5pZW50KG9iaikge1xuXHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcblx0Zm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKG9iaikpIHtcblx0XHRpZiAoaW52YWxpZFRva2VuUmVnZXgudGVzdChuYW1lKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmIChBcnJheS5pc0FycmF5KG9ialtuYW1lXSkpIHtcblx0XHRcdGZvciAoY29uc3QgdmFsIG9mIG9ialtuYW1lXSkge1xuXHRcdFx0XHRpZiAoaW52YWxpZEhlYWRlckNoYXJSZWdleC50ZXN0KHZhbCkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaGVhZGVyc1tNQVBdW25hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRoZWFkZXJzW01BUF1bbmFtZV0gPSBbdmFsXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoZWFkZXJzW01BUF1bbmFtZV0ucHVzaCh2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghaW52YWxpZEhlYWRlckNoYXJSZWdleC50ZXN0KG9ialtuYW1lXSkpIHtcblx0XHRcdGhlYWRlcnNbTUFQXVtuYW1lXSA9IFtvYmpbbmFtZV1dO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gaGVhZGVycztcbn1cblxuLyoqXG4gKiByZXNwb25zZS5qc1xuICpcbiAqIFJlc3BvbnNlIGNsYXNzIHByb3ZpZGVzIGNvbnRlbnQgZGVjb2RpbmdcbiAqL1xuXG52YXIgX3JlcXVpcmUkMSA9IHJlcXVpcmUoJ2h0dHAnKTtcblxuY29uc3QgU1RBVFVTX0NPREVTID0gX3JlcXVpcmUkMS5TVEFUVVNfQ09ERVM7XG5cblxuY29uc3QgSU5URVJOQUxTJDEgPSBTeW1ib2woJ1Jlc3BvbnNlIGludGVybmFscycpO1xuXG4vKipcbiAqIFJlc3BvbnNlIGNsYXNzXG4gKlxuICogQHBhcmFtICAgU3RyZWFtICBib2R5ICBSZWFkYWJsZSBzdHJlYW1cbiAqIEBwYXJhbSAgIE9iamVjdCAgb3B0cyAgUmVzcG9uc2Ugb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5jbGFzcyBSZXNwb25zZSB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGxldCBib2R5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXHRcdGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuXHRcdEJvZHkuY2FsbCh0aGlzLCBib2R5LCBvcHRzKTtcblxuXHRcdGNvbnN0IHN0YXR1cyA9IG9wdHMuc3RhdHVzIHx8IDIwMDtcblxuXHRcdHRoaXNbSU5URVJOQUxTJDFdID0ge1xuXHRcdFx0dXJsOiBvcHRzLnVybCxcblx0XHRcdHN0YXR1cyxcblx0XHRcdHN0YXR1c1RleHQ6IG9wdHMuc3RhdHVzVGV4dCB8fCBTVEFUVVNfQ09ERVNbc3RhdHVzXSxcblx0XHRcdGhlYWRlcnM6IG5ldyBIZWFkZXJzKG9wdHMuaGVhZGVycylcblx0XHR9O1xuXHR9XG5cblx0Z2V0IHVybCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0udXJsO1xuXHR9XG5cblx0Z2V0IHN0YXR1cygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzO1xuXHR9XG5cblx0LyoqXG4gICogQ29udmVuaWVuY2UgcHJvcGVydHkgcmVwcmVzZW50aW5nIGlmIHRoZSByZXF1ZXN0IGVuZGVkIG5vcm1hbGx5XG4gICovXG5cdGdldCBvaygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzID49IDIwMCAmJiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXMgPCAzMDA7XG5cdH1cblxuXHRnZXQgc3RhdHVzVGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzVGV4dDtcblx0fVxuXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5oZWFkZXJzO1xuXHR9XG5cblx0LyoqXG4gICogQ2xvbmUgdGhpcyByZXNwb25zZVxuICAqXG4gICogQHJldHVybiAgUmVzcG9uc2VcbiAgKi9cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShjbG9uZSh0aGlzKSwge1xuXHRcdFx0dXJsOiB0aGlzLnVybCxcblx0XHRcdHN0YXR1czogdGhpcy5zdGF0dXMsXG5cdFx0XHRzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRvazogdGhpcy5va1xuXHRcdH0pO1xuXHR9XG59XG5cbkJvZHkubWl4SW4oUmVzcG9uc2UucHJvdG90eXBlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLCB7XG5cdHVybDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHN0YXR1czogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdG9rOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0c3RhdHVzVGV4dDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGhlYWRlcnM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRjbG9uZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVzcG9uc2UucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0dmFsdWU6ICdSZXNwb25zZScsXG5cdHdyaXRhYmxlOiBmYWxzZSxcblx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogcmVxdWVzdC5qc1xuICpcbiAqIFJlcXVlc3QgY2xhc3MgY29udGFpbnMgc2VydmVyIG9ubHkgb3B0aW9uc1xuICpcbiAqIEFsbCBzcGVjIGFsZ29yaXRobSBzdGVwIG51bWJlcnMgYXJlIGJhc2VkIG9uIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnL2NvbW1pdC1zbmFwc2hvdHMvYWU3MTY4MjJjYjNhNjE4NDMyMjZjZDA5MGVlZmM2NTg5NDQ2YzFkMi8uXG4gKi9cblxudmFyIF9yZXF1aXJlJDIgPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgZm9ybWF0X3VybCA9IF9yZXF1aXJlJDIuZm9ybWF0O1xuY29uc3QgcGFyc2VfdXJsID0gX3JlcXVpcmUkMi5wYXJzZTtcblxuXG5jb25zdCBJTlRFUk5BTFMkMiA9IFN5bWJvbCgnUmVxdWVzdCBpbnRlcm5hbHMnKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIFJlcXVlc3QuXG4gKlxuICogQHBhcmFtICAgTWl4ZWQgICBpbnB1dFxuICogQHJldHVybiAgQm9vbGVhblxuICovXG5mdW5jdGlvbiBpc1JlcXVlc3QoaW5wdXQpIHtcblx0cmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0W0lOVEVSTkFMUyQyXSA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogUmVxdWVzdCBjbGFzc1xuICpcbiAqIEBwYXJhbSAgIE1peGVkICAgaW5wdXQgIFVybCBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcGFyYW0gICBPYmplY3QgIGluaXQgICBDdXN0b20gb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5jbGFzcyBSZXF1ZXN0IHtcblx0Y29uc3RydWN0b3IoaW5wdXQpIHtcblx0XHRsZXQgaW5pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cblx0XHRsZXQgcGFyc2VkVVJMO1xuXG5cdFx0Ly8gbm9ybWFsaXplIGlucHV0XG5cdFx0aWYgKCFpc1JlcXVlc3QoaW5wdXQpKSB7XG5cdFx0XHRpZiAoaW5wdXQgJiYgaW5wdXQuaHJlZikge1xuXHRcdFx0XHQvLyBpbiBvcmRlciB0byBzdXBwb3J0IE5vZGUuanMnIFVybCBvYmplY3RzOyB0aG91Z2ggV0hBVFdHJ3MgVVJMIG9iamVjdHNcblx0XHRcdFx0Ly8gd2lsbCBmYWxsIGludG8gdGhpcyBicmFuY2ggYWxzbyAoc2luY2UgdGhlaXIgYHRvU3RyaW5nKClgIHdpbGwgcmV0dXJuXG5cdFx0XHRcdC8vIGBocmVmYCBwcm9wZXJ0eSBhbnl3YXkpXG5cdFx0XHRcdHBhcnNlZFVSTCA9IHBhcnNlX3VybChpbnB1dC5ocmVmKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGNvZXJjZSBpbnB1dCB0byBhIHN0cmluZyBiZWZvcmUgYXR0ZW1wdGluZyB0byBwYXJzZVxuXHRcdFx0XHRwYXJzZWRVUkwgPSBwYXJzZV91cmwoYCR7aW5wdXR9YCk7XG5cdFx0XHR9XG5cdFx0XHRpbnB1dCA9IHt9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXJzZWRVUkwgPSBwYXJzZV91cmwoaW5wdXQudXJsKTtcblx0XHR9XG5cblx0XHRsZXQgbWV0aG9kID0gaW5pdC5tZXRob2QgfHwgaW5wdXQubWV0aG9kIHx8ICdHRVQnO1xuXHRcdG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0aWYgKChpbml0LmJvZHkgIT0gbnVsbCB8fCBpc1JlcXVlc3QoaW5wdXQpICYmIGlucHV0LmJvZHkgIT09IG51bGwpICYmIChtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnKSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdCB3aXRoIEdFVC9IRUFEIG1ldGhvZCBjYW5ub3QgaGF2ZSBib2R5Jyk7XG5cdFx0fVxuXG5cdFx0bGV0IGlucHV0Qm9keSA9IGluaXQuYm9keSAhPSBudWxsID8gaW5pdC5ib2R5IDogaXNSZXF1ZXN0KGlucHV0KSAmJiBpbnB1dC5ib2R5ICE9PSBudWxsID8gY2xvbmUoaW5wdXQpIDogbnVsbDtcblxuXHRcdEJvZHkuY2FsbCh0aGlzLCBpbnB1dEJvZHksIHtcblx0XHRcdHRpbWVvdXQ6IGluaXQudGltZW91dCB8fCBpbnB1dC50aW1lb3V0IHx8IDAsXG5cdFx0XHRzaXplOiBpbml0LnNpemUgfHwgaW5wdXQuc2l6ZSB8fCAwXG5cdFx0fSk7XG5cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzIHx8IGlucHV0LmhlYWRlcnMgfHwge30pO1xuXG5cdFx0aWYgKGluaXQuYm9keSAhPSBudWxsKSB7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IGV4dHJhY3RDb250ZW50VHlwZSh0aGlzKTtcblx0XHRcdGlmIChjb250ZW50VHlwZSAhPT0gbnVsbCAmJiAhaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTFMkMl0gPSB7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHRyZWRpcmVjdDogaW5pdC5yZWRpcmVjdCB8fCBpbnB1dC5yZWRpcmVjdCB8fCAnZm9sbG93Jyxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRwYXJzZWRVUkxcblx0XHR9O1xuXG5cdFx0Ly8gbm9kZS1mZXRjaC1vbmx5IG9wdGlvbnNcblx0XHR0aGlzLmZvbGxvdyA9IGluaXQuZm9sbG93ICE9PSB1bmRlZmluZWQgPyBpbml0LmZvbGxvdyA6IGlucHV0LmZvbGxvdyAhPT0gdW5kZWZpbmVkID8gaW5wdXQuZm9sbG93IDogMjA7XG5cdFx0dGhpcy5jb21wcmVzcyA9IGluaXQuY29tcHJlc3MgIT09IHVuZGVmaW5lZCA/IGluaXQuY29tcHJlc3MgOiBpbnB1dC5jb21wcmVzcyAhPT0gdW5kZWZpbmVkID8gaW5wdXQuY29tcHJlc3MgOiB0cnVlO1xuXHRcdHRoaXMuY291bnRlciA9IGluaXQuY291bnRlciB8fCBpbnB1dC5jb3VudGVyIHx8IDA7XG5cdFx0dGhpcy5hZ2VudCA9IGluaXQuYWdlbnQgfHwgaW5wdXQuYWdlbnQ7XG5cdH1cblxuXHRnZXQgbWV0aG9kKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQyXS5tZXRob2Q7XG5cdH1cblxuXHRnZXQgdXJsKCkge1xuXHRcdHJldHVybiBmb3JtYXRfdXJsKHRoaXNbSU5URVJOQUxTJDJdLnBhcnNlZFVSTCk7XG5cdH1cblxuXHRnZXQgaGVhZGVycygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0uaGVhZGVycztcblx0fVxuXG5cdGdldCByZWRpcmVjdCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0ucmVkaXJlY3Q7XG5cdH1cblxuXHQvKipcbiAgKiBDbG9uZSB0aGlzIHJlcXVlc3RcbiAgKlxuICAqIEByZXR1cm4gIFJlcXVlc3RcbiAgKi9cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMpO1xuXHR9XG59XG5cbkJvZHkubWl4SW4oUmVxdWVzdC5wcm90b3R5cGUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVxdWVzdC5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuXHR2YWx1ZTogJ1JlcXVlc3QnLFxuXHR3cml0YWJsZTogZmFsc2UsXG5cdGVudW1lcmFibGU6IGZhbHNlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXF1ZXN0LnByb3RvdHlwZSwge1xuXHRtZXRob2Q6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHR1cmw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRoZWFkZXJzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0cmVkaXJlY3Q6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRjbG9uZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSBSZXF1ZXN0IHRvIE5vZGUuanMgaHR0cCByZXF1ZXN0IG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICAgUmVxdWVzdCAgQSBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcmV0dXJuICBPYmplY3QgICBUaGUgb3B0aW9ucyBvYmplY3QgdG8gYmUgcGFzc2VkIHRvIGh0dHAucmVxdWVzdFxuICovXG5mdW5jdGlvbiBnZXROb2RlUmVxdWVzdE9wdGlvbnMocmVxdWVzdCkge1xuXHRjb25zdCBwYXJzZWRVUkwgPSByZXF1ZXN0W0lOVEVSTkFMUyQyXS5wYXJzZWRVUkw7XG5cdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXF1ZXN0W0lOVEVSTkFMUyQyXS5oZWFkZXJzKTtcblxuXHQvLyBmZXRjaCBzdGVwIDEuM1xuXHRpZiAoIWhlYWRlcnMuaGFzKCdBY2NlcHQnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnKi8qJyk7XG5cdH1cblxuXHQvLyBCYXNpYyBmZXRjaFxuXHRpZiAoIXBhcnNlZFVSTC5wcm90b2NvbCB8fCAhcGFyc2VkVVJMLmhvc3RuYW1lKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT25seSBhYnNvbHV0ZSBVUkxzIGFyZSBzdXBwb3J0ZWQnKTtcblx0fVxuXG5cdGlmICghL15odHRwcz86JC8udGVzdChwYXJzZWRVUkwucHJvdG9jb2wpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT25seSBIVFRQKFMpIHByb3RvY29scyBhcmUgc3VwcG9ydGVkJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcHMgMi40LTIuN1xuXHRsZXQgY29udGVudExlbmd0aFZhbHVlID0gbnVsbDtcblx0aWYgKHJlcXVlc3QuYm9keSA9PSBudWxsICYmIC9eKFBPU1R8UFVUKSQvaS50ZXN0KHJlcXVlc3QubWV0aG9kKSkge1xuXHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9ICcwJztcblx0fVxuXHRpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwpIHtcblx0XHRjb25zdCB0b3RhbEJ5dGVzID0gZ2V0VG90YWxCeXRlcyhyZXF1ZXN0KTtcblx0XHRpZiAodHlwZW9mIHRvdGFsQnl0ZXMgPT09ICdudW1iZXInKSB7XG5cdFx0XHRjb250ZW50TGVuZ3RoVmFsdWUgPSBTdHJpbmcodG90YWxCeXRlcyk7XG5cdFx0fVxuXHR9XG5cdGlmIChjb250ZW50TGVuZ3RoVmFsdWUpIHtcblx0XHRoZWFkZXJzLnNldCgnQ29udGVudC1MZW5ndGgnLCBjb250ZW50TGVuZ3RoVmFsdWUpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXAgMi4xMVxuXHRpZiAoIWhlYWRlcnMuaGFzKCdVc2VyLUFnZW50JykpIHtcblx0XHRoZWFkZXJzLnNldCgnVXNlci1BZ2VudCcsICdub2RlLWZldGNoLzEuMCAoK2h0dHBzOi8vZ2l0aHViLmNvbS9iaXRpbm4vbm9kZS1mZXRjaCknKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwIDIuMTVcblx0aWYgKHJlcXVlc3QuY29tcHJlc3MpIHtcblx0XHRoZWFkZXJzLnNldCgnQWNjZXB0LUVuY29kaW5nJywgJ2d6aXAsZGVmbGF0ZScpO1xuXHR9XG5cdGlmICghaGVhZGVycy5oYXMoJ0Nvbm5lY3Rpb24nKSAmJiAhcmVxdWVzdC5hZ2VudCkge1xuXHRcdGhlYWRlcnMuc2V0KCdDb25uZWN0aW9uJywgJ2Nsb3NlJyk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCA0LjJcblx0Ly8gY2h1bmtlZCBlbmNvZGluZyBpcyBoYW5kbGVkIGJ5IE5vZGUuanNcblxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkVVJMLCB7XG5cdFx0bWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcblx0XHRoZWFkZXJzOiBleHBvcnROb2RlQ29tcGF0aWJsZUhlYWRlcnMoaGVhZGVycyksXG5cdFx0YWdlbnQ6IHJlcXVlc3QuYWdlbnRcblx0fSk7XG59XG5cbi8qKlxuICogaW5kZXguanNcbiAqXG4gKiBhIHJlcXVlc3QgQVBJIGNvbXBhdGlibGUgd2l0aCB3aW5kb3cuZmV0Y2hcbiAqXG4gKiBBbGwgc3BlYyBhbGdvcml0aG0gc3RlcCBudW1iZXJzIGFyZSBiYXNlZCBvbiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy9jb21taXQtc25hcHNob3RzL2FlNzE2ODIyY2IzYTYxODQzMjI2Y2QwOTBlZWZjNjU4OTQ0NmMxZDIvLlxuICovXG5cbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5cbnZhciBfcmVxdWlyZSQzID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFBhc3NUaHJvdWdoJDEgPSBfcmVxdWlyZSQzLlBhc3NUaHJvdWdoO1xuXG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IHJlc29sdmVfdXJsID0gX3JlcXVpcmUyLnJlc29sdmU7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbi8qKlxuICogRmV0Y2ggZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgICB1cmwgICBBYnNvbHV0ZSB1cmwgb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAgT2JqZWN0ICAgb3B0cyAgRmV0Y2ggb3B0aW9uc1xuICogQHJldHVybiAgUHJvbWlzZVxuICovXG5mdW5jdGlvbiBmZXRjaCh1cmwsIG9wdHMpIHtcblxuXHQvLyBhbGxvdyBjdXN0b20gcHJvbWlzZVxuXHRpZiAoIWZldGNoLlByb21pc2UpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ25hdGl2ZSBwcm9taXNlIG1pc3NpbmcsIHNldCBmZXRjaC5Qcm9taXNlIHRvIHlvdXIgZmF2b3JpdGUgYWx0ZXJuYXRpdmUnKTtcblx0fVxuXG5cdEJvZHkuUHJvbWlzZSA9IGZldGNoLlByb21pc2U7XG5cblx0Ly8gd3JhcCBodHRwLnJlcXVlc3QgaW50byBmZXRjaFxuXHRyZXR1cm4gbmV3IGZldGNoLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdC8vIGJ1aWxkIHJlcXVlc3Qgb2JqZWN0XG5cdFx0Y29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgb3B0cyk7XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IGdldE5vZGVSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0KTtcblxuXHRcdGNvbnN0IHNlbmQgPSAob3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBodHRwcyA6IGh0dHApLnJlcXVlc3Q7XG5cblx0XHQvLyBzZW5kIHJlcXVlc3Rcblx0XHRjb25zdCByZXEgPSBzZW5kKG9wdGlvbnMpO1xuXHRcdGxldCByZXFUaW1lb3V0O1xuXG5cdFx0ZnVuY3Rpb24gZmluYWxpemUoKSB7XG5cdFx0XHRyZXEuYWJvcnQoKTtcblx0XHRcdGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcblx0XHR9XG5cblx0XHRpZiAocmVxdWVzdC50aW1lb3V0KSB7XG5cdFx0XHRyZXEub25jZSgnc29ja2V0JywgZnVuY3Rpb24gKHNvY2tldCkge1xuXHRcdFx0XHRyZXFUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBuZXR3b3JrIHRpbWVvdXQgYXQ6ICR7cmVxdWVzdC51cmx9YCwgJ3JlcXVlc3QtdGltZW91dCcpKTtcblx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHR9LCByZXF1ZXN0LnRpbWVvdXQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgcmVxdWVzdCB0byAke3JlcXVlc3QudXJsfSBmYWlsZWQsIHJlYXNvbjogJHtlcnIubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyKSk7XG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH0pO1xuXG5cdFx0cmVxLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uIChyZXMpIHtcblx0XHRcdGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcblxuXHRcdFx0Y29uc3QgaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnNMZW5pZW50KHJlcy5oZWFkZXJzKTtcblxuXHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDVcblx0XHRcdGlmIChmZXRjaC5pc1JlZGlyZWN0KHJlcy5zdGF0dXNDb2RlKSkge1xuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS4yXG5cdFx0XHRcdGNvbnN0IGxvY2F0aW9uID0gaGVhZGVycy5nZXQoJ0xvY2F0aW9uJyk7XG5cblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuM1xuXHRcdFx0XHRjb25zdCBsb2NhdGlvblVSTCA9IGxvY2F0aW9uID09PSBudWxsID8gbnVsbCA6IHJlc29sdmVfdXJsKHJlcXVlc3QudXJsLCBsb2NhdGlvbik7XG5cblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuNVxuXHRcdFx0XHRzd2l0Y2ggKHJlcXVlc3QucmVkaXJlY3QpIHtcblx0XHRcdFx0XHRjYXNlICdlcnJvcic6XG5cdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHJlZGlyZWN0IG1vZGUgaXMgc2V0IHRvIGVycm9yOiAke3JlcXVlc3QudXJsfWAsICduby1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Y2FzZSAnbWFudWFsJzpcblx0XHRcdFx0XHRcdC8vIG5vZGUtZmV0Y2gtc3BlY2lmaWMgc3RlcDogbWFrZSBtYW51YWwgcmVkaXJlY3QgYSBiaXQgZWFzaWVyIHRvIHVzZSBieSBzZXR0aW5nIHRoZSBMb2NhdGlvbiBoZWFkZXIgdmFsdWUgdG8gdGhlIHJlc29sdmVkIFVSTC5cblx0XHRcdFx0XHRcdGlmIChsb2NhdGlvblVSTCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRoZWFkZXJzLnNldCgnTG9jYXRpb24nLCBsb2NhdGlvblVSTCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdmb2xsb3cnOlxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDJcblx0XHRcdFx0XHRcdGlmIChsb2NhdGlvblVSTCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDVcblx0XHRcdFx0XHRcdGlmIChyZXF1ZXN0LmNvdW50ZXIgPj0gcmVxdWVzdC5mb2xsb3cpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBtYXhpbXVtIHJlZGlyZWN0IHJlYWNoZWQgYXQ6ICR7cmVxdWVzdC51cmx9YCwgJ21heC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgNiAoY291bnRlciBpbmNyZW1lbnQpXG5cdFx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgUmVxdWVzdCBvYmplY3QuXG5cdFx0XHRcdFx0XHRjb25zdCByZXF1ZXN0T3B0cyA9IHtcblx0XHRcdFx0XHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKSxcblx0XHRcdFx0XHRcdFx0Zm9sbG93OiByZXF1ZXN0LmZvbGxvdyxcblx0XHRcdFx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyICsgMSxcblx0XHRcdFx0XHRcdFx0YWdlbnQ6IHJlcXVlc3QuYWdlbnQsXG5cdFx0XHRcdFx0XHRcdGNvbXByZXNzOiByZXF1ZXN0LmNvbXByZXNzLFxuXHRcdFx0XHRcdFx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuXHRcdFx0XHRcdFx0XHRib2R5OiByZXF1ZXN0LmJvZHlcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA5XG5cdFx0XHRcdFx0XHRpZiAocmVzLnN0YXR1c0NvZGUgIT09IDMwMyAmJiByZXF1ZXN0LmJvZHkgJiYgZ2V0VG90YWxCeXRlcyhyZXF1ZXN0KSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoJ0Nhbm5vdCBmb2xsb3cgcmVkaXJlY3Qgd2l0aCBib2R5IGJlaW5nIGEgcmVhZGFibGUgc3RyZWFtJywgJ3Vuc3VwcG9ydGVkLXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxMVxuXHRcdFx0XHRcdFx0aWYgKHJlcy5zdGF0dXNDb2RlID09PSAzMDMgfHwgKHJlcy5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDMwMikgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdQT1NUJykge1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0cy5tZXRob2QgPSAnR0VUJztcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdHMuYm9keSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdHMuaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxNVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShmZXRjaChuZXcgUmVxdWVzdChsb2NhdGlvblVSTCwgcmVxdWVzdE9wdHMpKSk7XG5cdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByZXBhcmUgcmVzcG9uc2Vcblx0XHRcdGxldCBib2R5ID0gcmVzLnBpcGUobmV3IFBhc3NUaHJvdWdoJDEoKSk7XG5cdFx0XHRjb25zdCByZXNwb25zZV9vcHRpb25zID0ge1xuXHRcdFx0XHR1cmw6IHJlcXVlc3QudXJsLFxuXHRcdFx0XHRzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLFxuXHRcdFx0XHRzdGF0dXNUZXh0OiByZXMuc3RhdHVzTWVzc2FnZSxcblx0XHRcdFx0aGVhZGVyczogaGVhZGVycyxcblx0XHRcdFx0c2l6ZTogcmVxdWVzdC5zaXplLFxuXHRcdFx0XHR0aW1lb3V0OiByZXF1ZXN0LnRpbWVvdXRcblx0XHRcdH07XG5cblx0XHRcdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDEyLjEuMS4zXG5cdFx0XHRjb25zdCBjb2RpbmdzID0gaGVhZGVycy5nZXQoJ0NvbnRlbnQtRW5jb2RpbmcnKTtcblxuXHRcdFx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgMTIuMS4xLjQ6IGhhbmRsZSBjb250ZW50IGNvZGluZ3NcblxuXHRcdFx0Ly8gaW4gZm9sbG93aW5nIHNjZW5hcmlvcyB3ZSBpZ25vcmUgY29tcHJlc3Npb24gc3VwcG9ydFxuXHRcdFx0Ly8gMS4gY29tcHJlc3Npb24gc3VwcG9ydCBpcyBkaXNhYmxlZFxuXHRcdFx0Ly8gMi4gSEVBRCByZXF1ZXN0XG5cdFx0XHQvLyAzLiBubyBDb250ZW50LUVuY29kaW5nIGhlYWRlclxuXHRcdFx0Ly8gNC4gbm8gY29udGVudCByZXNwb25zZSAoMjA0KVxuXHRcdFx0Ly8gNS4gY29udGVudCBub3QgbW9kaWZpZWQgcmVzcG9uc2UgKDMwNClcblx0XHRcdGlmICghcmVxdWVzdC5jb21wcmVzcyB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnIHx8IGNvZGluZ3MgPT09IG51bGwgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDIwNCB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMzA0KSB7XG5cdFx0XHRcdHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlX29wdGlvbnMpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3IgTm9kZSB2Nitcblx0XHRcdC8vIEJlIGxlc3Mgc3RyaWN0IHdoZW4gZGVjb2RpbmcgY29tcHJlc3NlZCByZXNwb25zZXMsIHNpbmNlIHNvbWV0aW1lc1xuXHRcdFx0Ly8gc2VydmVycyBzZW5kIHNsaWdodGx5IGludmFsaWQgcmVzcG9uc2VzIHRoYXQgYXJlIHN0aWxsIGFjY2VwdGVkXG5cdFx0XHQvLyBieSBjb21tb24gYnJvd3NlcnMuXG5cdFx0XHQvLyBBbHdheXMgdXNpbmcgWl9TWU5DX0ZMVVNIIGlzIHdoYXQgY1VSTCBkb2VzLlxuXHRcdFx0Y29uc3QgemxpYk9wdGlvbnMgPSB7XG5cdFx0XHRcdGZsdXNoOiB6bGliLlpfU1lOQ19GTFVTSCxcblx0XHRcdFx0ZmluaXNoRmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNIXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBmb3IgZ3ppcFxuXHRcdFx0aWYgKGNvZGluZ3MgPT0gJ2d6aXAnIHx8IGNvZGluZ3MgPT0gJ3gtZ3ppcCcpIHtcblx0XHRcdFx0Ym9keSA9IGJvZHkucGlwZSh6bGliLmNyZWF0ZUd1bnppcCh6bGliT3B0aW9ucykpO1xuXHRcdFx0XHRyZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZV9vcHRpb25zKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZm9yIGRlZmxhdGVcblx0XHRcdGlmIChjb2RpbmdzID09ICdkZWZsYXRlJyB8fCBjb2RpbmdzID09ICd4LWRlZmxhdGUnKSB7XG5cdFx0XHRcdC8vIGhhbmRsZSB0aGUgaW5mYW1vdXMgcmF3IGRlZmxhdGUgcmVzcG9uc2UgZnJvbSBvbGQgc2VydmVyc1xuXHRcdFx0XHQvLyBhIGhhY2sgZm9yIG9sZCBJSVMgYW5kIEFwYWNoZSBzZXJ2ZXJzXG5cdFx0XHRcdGNvbnN0IHJhdyA9IHJlcy5waXBlKG5ldyBQYXNzVGhyb3VnaCQxKCkpO1xuXHRcdFx0XHRyYXcub25jZSgnZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuXHRcdFx0XHRcdC8vIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM3NTE5ODI4XG5cdFx0XHRcdFx0aWYgKChjaHVua1swXSAmIDB4MEYpID09PSAweDA4KSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gYm9keS5waXBlKHpsaWIuY3JlYXRlSW5mbGF0ZSgpKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ym9keSA9IGJvZHkucGlwZSh6bGliLmNyZWF0ZUluZmxhdGVSYXcoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlX29wdGlvbnMpKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gb3RoZXJ3aXNlLCB1c2UgcmVzcG9uc2UgYXMtaXNcblx0XHRcdHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlX29wdGlvbnMpKTtcblx0XHR9KTtcblxuXHRcdHdyaXRlVG9TdHJlYW0ocmVxLCByZXF1ZXN0KTtcblx0fSk7XG59XG5cbi8qKlxuICogUmVkaXJlY3QgY29kZSBtYXRjaGluZ1xuICpcbiAqIEBwYXJhbSAgIE51bWJlciAgIGNvZGUgIFN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuICBCb29sZWFuXG4gKi9cbmZldGNoLmlzUmVkaXJlY3QgPSBmdW5jdGlvbiAoY29kZSkge1xuXHRyZXR1cm4gY29kZSA9PT0gMzAxIHx8IGNvZGUgPT09IDMwMiB8fCBjb2RlID09PSAzMDMgfHwgY29kZSA9PT0gMzA3IHx8IGNvZGUgPT09IDMwODtcbn07XG5cbi8vIE5lZWRlZCBmb3IgVHlwZVNjcmlwdC5cbmZldGNoLmRlZmF1bHQgPSBmZXRjaDtcblxuLy8gZXhwb3NlIFByb21pc2VcbmZldGNoLlByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcblxuZXhwb3J0IGRlZmF1bHQgZmV0Y2g7XG5leHBvcnQgeyBIZWFkZXJzLCBSZXF1ZXN0LCBSZXNwb25zZSwgRmV0Y2hFcnJvciB9O1xuIl0sIm5hbWVzIjpbIkJVRkZFUiIsIlN5bWJvbCIsIlRZUEUiLCJCbG9iIiwiY29uc3RydWN0b3IiLCJibG9iUGFydHMiLCJhcmd1bWVudHMiLCJvcHRpb25zIiwiYnVmZmVycyIsImEiLCJsZW5ndGgiLCJOdW1iZXIiLCJpIiwiZWxlbWVudCIsImJ1ZmZlciIsIkJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiZnJvbSIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiU3RyaW5nIiwicHVzaCIsImNvbmNhdCIsInR5cGUiLCJ1bmRlZmluZWQiLCJ0b0xvd2VyQ2FzZSIsInRlc3QiLCJzaXplIiwic2xpY2UiLCJzdGFydCIsImVuZCIsInJlbGF0aXZlU3RhcnQiLCJyZWxhdGl2ZUVuZCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJzcGFuIiwic2xpY2VkQnVmZmVyIiwiYmxvYiIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJ0b1N0cmluZ1RhZyIsInZhbHVlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJGZXRjaEVycm9yIiwibWVzc2FnZSIsInN5c3RlbUVycm9yIiwiRXJyb3IiLCJjYWxsIiwiY29kZSIsImVycm5vIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJjcmVhdGUiLCJuYW1lIiwiU3RyZWFtIiwicmVxdWlyZSIsIl9yZXF1aXJlIiwiUGFzc1Rocm91Z2giLCJjb252ZXJ0IiwiZSIsIklOVEVSTkFMUyIsIkJvZHkiLCJib2R5IiwiX3RoaXMiLCJfcmVmIiwiX3JlZiRzaXplIiwiX3JlZiR0aW1lb3V0IiwidGltZW91dCIsImlzVVJMU2VhcmNoUGFyYW1zIiwiaXNCdWZmZXIiLCJ0b1N0cmluZyIsImRpc3R1cmJlZCIsImVycm9yIiwib24iLCJlcnIiLCJ1cmwiLCJib2R5VXNlZCIsImFycmF5QnVmZmVyIiwiY29uc3VtZUJvZHkiLCJ0aGVuIiwiYnVmIiwiY3QiLCJoZWFkZXJzIiwiZ2V0IiwiYXNzaWduIiwianNvbiIsIl90aGlzMiIsIkpTT04iLCJwYXJzZSIsIlByb21pc2UiLCJyZWplY3QiLCJ0ZXh0IiwidGV4dENvbnZlcnRlZCIsIl90aGlzMyIsImNvbnZlcnRCb2R5IiwibWl4SW4iLCJwcm90byIsImdldE93blByb3BlcnR5TmFtZXMiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX3RoaXM0IiwiVHlwZUVycm9yIiwicmVzb2x2ZSIsImFsbG9jIiwiYWNjdW0iLCJhY2N1bUJ5dGVzIiwiYWJvcnQiLCJyZXNUaW1lb3V0Iiwic2V0VGltZW91dCIsImNodW5rIiwiY2xlYXJUaW1lb3V0IiwiY2hhcnNldCIsInJlcyIsInN0ciIsImV4ZWMiLCJwb3AiLCJvYmoiLCJhcHBlbmQiLCJkZWxldGUiLCJnZXRBbGwiLCJoYXMiLCJzZXQiLCJzb3J0IiwiY2xvbmUiLCJpbnN0YW5jZSIsInAxIiwicDIiLCJnZXRCb3VuZGFyeSIsInBpcGUiLCJleHRyYWN0Q29udGVudFR5cGUiLCJnZXRUb3RhbEJ5dGVzIiwiZ2V0TGVuZ3RoU3luYyIsIl9sZW5ndGhSZXRyaWV2ZXJzIiwiaGFzS25vd25MZW5ndGgiLCJ3cml0ZVRvU3RyZWFtIiwiZGVzdCIsIndyaXRlIiwiZ2xvYmFsIiwiaW52YWxpZFRva2VuUmVnZXgiLCJpbnZhbGlkSGVhZGVyQ2hhclJlZ2V4IiwidmFsaWRhdGVOYW1lIiwidmFsaWRhdGVWYWx1ZSIsImZpbmQiLCJtYXAiLCJrZXkiLCJNQVAiLCJIZWFkZXJzIiwiaW5pdCIsInJhd0hlYWRlcnMiLCJyYXciLCJoZWFkZXJOYW1lcyIsImtleXMiLCJoZWFkZXJOYW1lIiwibWV0aG9kIiwiaXRlcmF0b3IiLCJwYWlycyIsInBhaXIiLCJBcnJheSIsImpvaW4iLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwiZ2V0SGVhZGVycyIsIl9wYWlycyRpIiwiY3JlYXRlSGVhZGVyc0l0ZXJhdG9yIiwidmFsdWVzIiwiZW50cmllcyIsImtpbmQiLCJrIiwiSU5URVJOQUwiLCJ0YXJnZXQiLCJIZWFkZXJzSXRlcmF0b3JQcm90b3R5cGUiLCJpbmRleCIsInNldFByb3RvdHlwZU9mIiwibmV4dCIsImdldFByb3RvdHlwZU9mIiwiX0lOVEVSTkFMIiwibGVuIiwiZG9uZSIsImV4cG9ydE5vZGVDb21wYXRpYmxlSGVhZGVycyIsIl9fcHJvdG9fXyIsImhvc3RIZWFkZXJLZXkiLCJjcmVhdGVIZWFkZXJzTGVuaWVudCIsImlzQXJyYXkiLCJ2YWwiLCJfcmVxdWlyZSQxIiwiU1RBVFVTX0NPREVTIiwiSU5URVJOQUxTJDEiLCJSZXNwb25zZSIsIm9wdHMiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwib2siLCJfcmVxdWlyZSQyIiwiZm9ybWF0X3VybCIsImZvcm1hdCIsInBhcnNlX3VybCIsIklOVEVSTkFMUyQyIiwiaXNSZXF1ZXN0IiwiaW5wdXQiLCJSZXF1ZXN0IiwicGFyc2VkVVJMIiwiaHJlZiIsInRvVXBwZXJDYXNlIiwiaW5wdXRCb2R5IiwiY29udGVudFR5cGUiLCJyZWRpcmVjdCIsImZvbGxvdyIsImNvbXByZXNzIiwiY291bnRlciIsImFnZW50IiwiZ2V0Tm9kZVJlcXVlc3RPcHRpb25zIiwicmVxdWVzdCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJjb250ZW50TGVuZ3RoVmFsdWUiLCJ0b3RhbEJ5dGVzIiwiaHR0cCIsImh0dHBzIiwiX3JlcXVpcmUkMyIsIlBhc3NUaHJvdWdoJDEiLCJfcmVxdWlyZTIiLCJyZXNvbHZlX3VybCIsInpsaWIiLCJmZXRjaCIsInNlbmQiLCJyZXEiLCJyZXFUaW1lb3V0IiwiZmluYWxpemUiLCJvbmNlIiwic29ja2V0IiwiaXNSZWRpcmVjdCIsInN0YXR1c0NvZGUiLCJsb2NhdGlvbiIsImxvY2F0aW9uVVJMIiwicmVxdWVzdE9wdHMiLCJyZXNwb25zZV9vcHRpb25zIiwic3RhdHVzTWVzc2FnZSIsImNvZGluZ3MiLCJ6bGliT3B0aW9ucyIsImZsdXNoIiwiWl9TWU5DX0ZMVVNIIiwiZmluaXNoRmx1c2giLCJjcmVhdGVHdW56aXAiLCJjcmVhdGVJbmZsYXRlIiwiY3JlYXRlSW5mbGF0ZVJhdyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tensorflow/tfjs-core/node_modules/node-fetch/lib/index.es.js\n");

/***/ })

};
;